<chapter id="python-language-ref">
<title>Sprog reference</title>
<sect1 id="python-gui-idle">
<title>GUI og IDLE - hvad er det?</title>
<para>
GUI er en forkortelse af Graphic User Interface og er de programmer,
som dels opretter de virtuelle vinduer, knapper, menuer m.v. Dette giver
brugeren mulighed for ved klik m.v. at kalde de med nævnte elementer
forbundne funktioner, hvis formål kan være at sende en tekst til en
tekstboks, hente en fil ind eller sende en ud på et eksternt lager som
f.eks. en harddisk, tegne grafik  og meget andet. Koden til GUI
komponenterne findes bl.a. i Pythons Tk bibliotek. At koden til
vinduerne kommer fra Tk biblioteket kan ses af ordet Tk øverst i
grundvinduet.
</para>

<para>
<screen>
>>> from Tkinter import Label
>>> barnAfLabel = Label()
</screen>
</para>

<para>
Da der som nævnt findes en grundmodel af GUI komponenterne i Tk, kan
værkføreren Tkinter sende bud ud i Tk, om at koden til opførelsen af
grundvinduet skal gøres tilgængelig til opførelse af en kopi af Label(),
som jeg i dette tilfælde har valgt at kalde barnAfLabel, fordi det som
andre børn har sit ophav, hvorfra det arver i moderen, en betegnelse,
der også ses brugt i andre danske bøger om computersprog. På engelsk
kaldes moderen for the parent (forælderen). I Python bruges også
betegnelsen the main class eller the basic class.
</para>
</sect1>

<sect1 id="python-interaktiv">
<title>Immediate (interaktiv) mode</title>
<para>
Fra gamle DOS kender du muligvis dosprompten c:\> klarmeldingen, til at
computerne kan modtage dine kommandoer. I Python anvendes \>>> som en
tilsvarende klarmelding. En melding om at Python er i Immediate eller
som den også kaldes interaktiv mode. Det er herfra, du begynder din
Python programmering, men bestemt også moden den erfarne Python
programmør vender tilbage til og anvender f.eks. ved test af nye
programstumper.
 </para>
</sect1>

<sect1 id="python-kommentar">
<title>Kommentarer</title>
<para>
Når du programmerer har du fra tid til anden brug for at indsætte
kommentarer - dele af programmet, som du og andre kan læse, men som
computersproget springer over. I Python markerer \# (hashtegnet - på
dansk kaldet havelåge eller bøftegn). En kommentar begynder ved
havelågen og fortsætter programlinjen ud. Eks. 1:
</para>
<screen>
>>># Python springer over kommentarer
>>> print "Kommentarer er til dig og ikke til computeren."
Kommentarer er til dig og ikke til computeren.
</screen>
<para>
Det er også muligt at udskrive hash-tegnet, hvis det er en del af en
tekst-streng. Eks. 2:
<screen>
>>> print "Her udskriver vi et hash-tegn #"
Her udskriver vi et hash-tegn #
</screen>
I dette eksempel var der INGEN kommentarer. Bøftegnet er her
en del af en teksstreng. En sådan skal Python meget gerne reagere på og
ikke forbigå. Læg mærke til at bøftegnet udskrives her, hvad det ikke
gjorde i eksemplet, hvor det tjente sit rette formål.
</para>

<sect2 id="python-kommentar1">
<title>Kommentarer i anførselstegns par</title>
<para>
Strenge kan også være indesluttet i 3 anførselstegn (enkelte eller dobbelte).
Eks. 1:
<screen>
>>> print """
... Navn:       Klippeøen Bornholm
... Befolkning: 44.500
... """

Navn:   	Klippeøen Bornholm
Befolkning:     44.500
</screen>

Eks. 2:

<screen>
>>> def Funktion():
...     """Indskudt tekst"""
...     return "Normalt bruges 1 tegnsæt"
...
>>> Funktion()
'Normalt bruges 1 tegns\xe6t'
</screen>

Eks. 3:

<screen>
>>> class Klasse:
...     """ Bruges ofte, hvor teksten ikke skal udskrives. """
...     print "Normal tekst til normal udskrift."
...
Normal tekst til normal udskrift.
</screen>

Eks. 4:

<screen>
>>> def inaktiv():
...     """Vær passiv, men dokumemter det.
... Nej, der sker virkelig intet."""
...     pass
...
>>> inaktiv()
</screen>
</para>
<para>
Bemærk at tre anførselstegn (enkelte eller dobbelte efter dit ønske)
lader Python springe over alt mellem de første (indledende)
anførselstegn og de sidste, hvad du også kan se, af at Nej ... ikke
behøver den ellers krævede blokindrykning.
</para>
</sect2>
</sect1>

<sect1 id="python-aritop">
<title>Aritmetiske operatorer</title>

<itemizedlist mark="opencircle">
<listitem>
<para>
Addition    +   eks:  3 + 4 = 12
</para>
</listitem>

<listitem>
<para>
Subtraktion  -    eks: 3 - 4 = -1
</para>
</listitem>

<listitem>
<para>
Multiplikation   *    eks:  3 * 4 = 12
</para>
</listitem>

<listitem>
<para>
Eksponent notation   **   eks:  3 ** 4 = 81
</para>
</listitem>

<listitem>
<para>
Division     /   eks: 3 / 4 = 0 (afrunder nedad til nærmeste hele tal)
</para>
</listitem>

<listitem>
<para>
Division     //    eks: 3 // 4 = 0 (afrunder nedad til nærmeste hele tal)
</para>
</listitem>

<listitem>
<para>
Modulus    %   eks: 3.0 % 4.0 = 0.75
</para>
</listitem>
</itemizedlist>

<para>
FARE:  Pas på ved heltalsdivisioner
</para>

<screen>
>>> 25 / 24
>>>
 1
</screen>

<para>
25 divideret med 24 burde give 1.0416666666666667, men Python runder
automatisk af nedad til nærmeste heltal, som i dette tilfælde er 1.
</para>

<para>
<screen>
>>> 25 / 24.0
1.0416666666666667
</screen>

For at få decimaldelen returneret (udskrevet) er det nødvendigt, at
mindst det ene af tallene er et decimaltal (et tal med flydende komma).
</para>

<para>
I Python er der fuld støtte for flydende tal (floating point numbers).
Operatorer med operanter af blandet type konverterer heltals (integer)
operanten til tal med flydende komma (på engelsk punktum):
<screen>
>>> 3 * 3.75 / 1.5
7.5
>>> 7.0 / 2
3.5
</screen>
</para>

<para>
<screen>
>>> print "simpelt eksempel " * 3
 simpelt eksempel simpelt eksempel simpelt eksempel
</screen>
I de traditionelle computersprog kan det ikke gøres så enkelt. Der kræves noget som:

<screen>
print "simpelt eksempel " + "simpelt eksempel " + "simpelt eksempel "
</screen>
</para>
</sect1>

<sect1 id="python-variabler">
<title>Variabler</title>
<para>
En variabel er en pegepind, der peger på et antal adresser i computerens
arbejdslager (RAM), hvor data, der kan være flere ting f.eks. tal og
tekststrenge, placeres. Variablen skal tildeles et navn, der ikke må
indeholde de dansk/norske specialtegn ÆØÅ og æøå. Det skal lige
bemærkes, at der i visse underversioner af version 2.3 har været
muligheder for at bruge de nævte tegn.
</para>

<sect2 id="python-variabler1">
<title>Erklæring af variabler</title>
<para>
Når programmørerne skulle foretage beregninger på Dask, Danmarks første
computer, måtte de tænke i nuller og et taller. Det er meget ubekvemt
for mennesker så tallene blev erstattet med ord - i første omgang ord på
3 bogstaver. Det var en stor lettelse for programmørerne. Nu kan
variabel- og andre navne normalt have op til 256 bogstaver eller tal
blot bør første tegn i et variabelnavn være et bogstav, der ikke må være
et dansk/norsk specialtegn æøå og ÆØÅ. I Python er der for så vidt ikke
noget i vejen, for at første tegn kan være et understreg tegn, men det
kan være en rigtig dårlig løsning, da fordefinerede navne m.v. herved
let vil kunne overskrives.  I Python skal variabler ikke erklæres.
Erklæringen sker automatisk. MEN BEMÆRK Python gør forskel på store og små bogstaver,
d.v.s. at variablerne a og A er to  forskellige variabler og vil blive
fortolket som sådanne. Det samme gælder naturligvis også alle andre
navne (på lister, tuples m.v.)
</para>
<para>
<screen>
>>> # Først tildeles x værdien nul, så tildeles y værdien i x og z værdien i y.
>>> x = y = z = 0
>>> x
0
>>> y
0
>>> z
0
</screen>

BEMÆRK: I Python anvendes  == for lig med  og = for tildel. Der er
således markant forskel på  x == y og x = y
</para>
</sect2>

<sect2 id="python-variabler2">
<title>Variabler kan overskrives</title>
<para>
Globale variabler kan overskrives:
<screen>
>>> e = 1000 # definering af global variabel
>>> def nix():
...     global e
...     e = 25
...
>>> e
1000
>>> nix()
>>> e
25
</screen>

Globale navne er flere ting, så pas på:

<screen>
>>> liste = [1,2,3,4,5]
>>> def funktion(l):
...     global liste
...     liste.append(12345)
...
>>> liste
[1, 2, 3, 4, 5]
>>> funktion(liste)
>>> liste
[1, 2, 3, 4, 5, 12345]
>>>
</screen>
</para>

<para>
Indledningsvis oprettes listen [1,2,3,4,5]. Det første kald viser, at
såfremt listen kaldes, inden den i funktionen funktion erklærede globale
liste overtager 1: den udenfor funktionen definerede liste og 2: tildeler
den et element (12345) yderligere. Her markeres det, at en
global variabel erklæret i en funktion overstyrer en global variabel
erklæret udenfor funktionen.
</para>
</sect2>

<sect2 id="python-variabler3">
<title>Variablers adresse</title>

<para>
Variablers type kan findes med type:

<screen>
>>> a = 25
>>> type(a)
&lt;type 'int'>
>>> a = 12.4
>>> type(a)
&lt;type 'float'>
>>> a = "Rønne"
>>> type(a)
&lt;type 'str'>
</screen>
</para>
</sect2>

<sect2 id="python-variabler4">
<title>Variablers adresse</title>

<para>
Variablers adresse i RAM kan findes med id
<screen>
>>> a = 12.4
>>> id(a)
136095956
>>> a = 23
>>> id(a)
135591272
>>> a = "Rønne"
>>> id(a)
1078892096
</screen>
</para>

<para>
Af  følgende udskrift fremgår det, at samme bogstav giver samme adresse:

<screen>
>>> s = "Dette er en streng."
>>> for i in range(0,18):
...     print s[i], id(s[i])
...
D 1078892160
e 1076630176
t 1076645984
t 1076645984
e 1076630176
  1078892192
e 1076630176
r 1076518048
  1078892192
e 1076630176
n 1076614816
  1078892192
s 1076613536
t 1076645984
r 1076518048
e 1076630176
n 1076614816
g 1076690208
</screen>
</para>

<para>
<screen>
>>> s = "AABBCCaabbcc"
>>> for i in range(0,len(s)):
...     print s[i], id(s[i])
...
A 1078892448
A 1078892448
B 1078892384
B 1078892384
C 1078892608
C 1078892608
a 1076679360
a 1076679360
b 1076679584
b 1076679584
c 1076690176
c 1076690176
</screen>
</para>
</sect2>

<sect2 id="python-variabler5">
<title>Variabler i Python</title>
<para>
At Python er et ret nyt computsprog, det markerer sig bl.a. m.h.t.
variablers egenskaber og anvendelsesmåde. I de traditionelle
computersprog som C, C++, Pascal, Delphi, Visual Basic, Java og andre
skal variable være det man kalder strongly typed dvs. de skal defineres
til at indeholde ganske bestemte værdityper f.eks. heltal eller
tekststrenge, og kun de således definerede typer må gemmes i de aktuelle
variabler. Sådan er det ikke i Python. Her flyttes variablers indhold
automatisk til andre adresser i lageret, hvis omdefinering er nødvendig,
bl.a. fordi alle former for variabler ikke fylder lige meget i lageret.
</para>
<para>
Eks. 1:
<screen>
>>> # Her sker der 2 ting: 1: variablen a erklæres (is declared) og
>>> # 2: tildeles samtidig værdien "Tekststreng" d.v.s. den sættes til
>>> # at pege på de adresser i computerens lager, hvor "Tekststreng"
>>> # opbevares.
>>> a = "Tekststreng"
>>> a
Tekststreng
>>> # Nu tildeles samme variabel uden videre et heltal (integer) som værdi.
>>> a = 25
>>> print a
25
</screen>
</para>

<para>

<screen>
Eks. 2:
>>> a = "Tekststreng " + str(25)
>>>
>>> a
'Tekststreng 25'
</screen>
</para>

<para>
Python er ikke strongly typed som C, Pascal og mon ikke de fleste andre
computersprogs variabler skal være det. At et sprog er strong typed
betyder, at en variabel ene og alene kan indeholde den type af værdi,
den er oprettet (defineret) til at indeholde. C, Pascal og de andre
sprog holder kort sagt styr på de adresser i computerens RAM lager,
variablerne er sat til at pege på.
</para>
</sect2>
</sect1>

<sect1 id="python-bool">
<title>Boolske udtryk/variabler </title>
<para>
Boolske udtryk/variabler kan indtage/tildeles 2 værdier og kun 2. De 2
værdier er sand (true) og falsk (false). De 2 værdier burde i alle
computersprog repræsenteres med 0 for falsk og 1 for sand, men sådan er
det desværre ikke altid. Til alt held benytter Python også her det
logiske altså: 0 for falsk og 1 for sand, hvad følgende eksempel kan
påvise:
</para>
<para>
Eks. 1:

<screen>
>>> 2 == 3
0
>>> 2 == 2
1
</screen>
</para>
<para>
<command>Udtryk & Resultat</command>
</para>

<itemizedlist mark="openring">
<listitem>
<para>
true and true & true
</para>
</listitem>

<listitem>
<para>
true and false & false
</para>
</listitem>

<listitem>
<para>
false and true &  false
</para>
</listitem>

<listitem>
<para>
false and false & false
</para>
</listitem>

<listitem>
<para>
not true & false
</para>
</listitem>

<listitem>
<para>
not false & true
</para>
</listitem>

<listitem>
<para>
true or true & true
</para>
</listitem>

<listitem>
<para>
true or false & true
</para>
</listitem>

<listitem>
<para>
false or true & true
</para>
</listitem>

<listitem>
<para>
false or false & false
</para>
</listitem>
</itemizedlist>

<para>
Eks. 2
Vi begynder med at lade en variabel, pege på en adresse i lageret, hvor
værdien 5 lagres. Af nemhedsgrunde vælger vi at give variablen det
absolut intetsigende navn a. Det var en ordentlig smøre for at beskrive,
hvad der reelt sker. Når man ved, hvad det, der sker og, for at det hele
ikke skal blive absurd og mekanisk, kan vi tillade os at sige, at vi
tildeler variablen a værdien 5, værdien b værdien 7 og variablen c
værdien 9. De samme forhold bør altid gælde for den seriøse programmør.
Man kan tildele en variabel en værdi f.eks. a = 25 og b = 15 + 10 med
tildelingstegnet = og eksempelvis betinge, at såfremt den værdi en
variabel peger på opfylder de samme betingelser som f.eks. indeholder
samme talsum, som i dette tilfælde så er \ a == b.
</para>
<para>
Nu kan vi gå videre og teste de tildelte værdiers sandhedsværdier i
matematiske udtryk:

<screen>
>>> a == 5
1
>>> a == 7
0
>>> b == 7
1
>>> b == 5
0
>>> a == 6 and b == 7
0
>>> a == 7 and b == 7
0
>>> not a == 7 and b == 7
1
>>> a == 7 or b == 7
1
>>> a == 7 or b == 6
0
>>> a == 6 or b == 7
1
>>> not ( a == 7 and b == 6)
1
</screen>
</para>
</sect1>

<sect1 id="python-rai">
<title>Indskriv interaktivt </title>
<para>
I interaktiv mode kan tal indskrives med 2 forskellige funktioner:
raw_input, hvor tal modtages som var det tekst, og input der modtager
tal som tal. I førstnævnte vil den modtagne værdi ofte skulle
konverteres til tal, ellers kan det give uheldige resultater eks:
<screen>
>>> tal = raw_input("Skriv et tal: " )
Skriv et tal: 730
>>> tal * 4
'730730730730'
>>>
Det går langt bedre med:
>>> tal = input("Skriv et tal: " )
Skriv et tal: 730
>>> tal
730
</screen>
</para>

<para>
<screen>
integer = raw_input( "Skriv et helt tal:\n" )
integer = int( integer )
if integer < 0:
	print "%d er mindre end nul" % integer
else:
	print "%d er større end nul" % integer

>>> # Fra tekst til tal
>>> heltal = raw_input("Skriv et helt tal: ")
Skriv et helt tal: 25
>>> "Det indtastede tal var " + heltal
'Det indtastede tal var 25'


>>> # Fra tal til tekst
>>> heltal = input("Skriv et helt tal: ")
Skriv et helt tal: 25
>>> # og konverteres til streng
>>> "Det indtastede tal var " + str(heltal)
'Det indtastede tal var 25'
</screen>
</para>
</sect1>

<sect1 id="python-scripts">
<title>Scripts</title>
<para>
Hvis og når du kommer ud for at skulle udvikle større projekter i Python,
bliver du nødt til at gemme din Python-kode som individuelle filer du
kan bruge igen og igen. Hertil findes der adskillige tekst editorer til
Linux at vælge imellem. (Indsæt her et link til beskrivelse af tekst
editorer i FTAV).
Brugen af editoren er slet ikke så svært, som det kan virke i første
omgang, hvad du let kan konstatere, hvis du har skrevet et eksempel i
immediate mode, så marker hele teksten og kopier det hele til den
editor, du vil bruge. Når du har koden inde i editoren, så lad editoren
foretage en find og erstat og fjern alle
<screen>
>>>
</screen>
meldingerne. Hvis du har bevaret koden med de tilhørende blokkoloner
m.v., så er det, du nu har tilbage et script (Pythons benævnelse af et
program). Scriptet kan du gemme under et lovligt navn og med
typebetegnelsen py som eksempelvis mitScript.py. Herefter kan du afvikle
(køre) programmet lige så tit du lyster. Desuden er det meget let at
udvide og ændre. Det sker ved at hente det ind i editoren igen og skrive
videre på det. Det er naturligvis ikke meningen, at du hver gang skal
begynde dine projekter i interaktiv mode for derfra at flytte dem ud i
editoren og fortsætte der. De større projekter er som antydet bøvlede at
behandle i interaktiv mode. Der skriver du det hele i editoren og gemmer
det på nævnte måde. Når du har skrevet et program (et script) og ønsker
at afvikle det, sker det ved fra det bibliotek, hvori skriptet findes at
taste python programmetsNavn.py
</para>
<para>
I Linux kan Python scripts gøres direkte eksekverbare ved at indsætte

<screen>
#! /usr/bin/env python
</screen>

som første linje i programmet. "#!" (havelåge og udråbstegn) SKAL være
de to første karakterer i scriptet. Scriptet kan tildeles en eksekverbar
mode eller tilladelse ved anvendelse af kommandoen:

<screen>
$ chmod +x myscript.py
</screen>
</para>

<para>
Det er muligt at anvende andre styrekoder end ASCII i Python
kildetekster. Den bedste fremgangsmåde til udførelse af dette er at
indsætte endnu en speciel kommando linje umiddelbart efter den allerede
viste, således:

<screen>
#! /usr/bin/env python
# -*- coding: iso-8859-1 -*-
</screen>
</para>

<para>
Hvis du ønsker at afvikle en opstartsfil mere fra det aktuelle
bibliotek, kan du skrive en global opstartsfil ved at bruge koden:
<screen>
if os.path.isfile('.pythonrc.py'): execfile('.pythonrc.py')
</screen>
</para>

<para>
Hvis du ønsker at anvende opstartsfilen i et program, må programmet
yderligere indeholde følgende kode (aktuelt tilpasset til dit program):
<screen>
import os
filnavn = os.environ.get('PYTHONSTARTUP')
if filnavn and os.path.isfile(filnavn):
    execfile(filnavn)
</screen>
</para>
</sect1>

<sect1 id="python-ifelse">
<title>If, elif og else</title>
<para>
Her er et eksempel på hvorledes man kan teste for forskellige
betingelser, og få ens funktioner til at gøre nogle forskellige ting.
<screen>
>>> def findMax(a,b,c):
...     max = a
...     if b > a:
...             max = b
...     if c > b:
...             max = c
...     return max
...
>>> findMax(37, 2 * 19 ,43)
43
</screen>
</para>
<para>
<screen>
>>> tal = 17 ** 4
>>> if tal < 50000:
...     	print "Tallet er mindre end 50000"
	else:
...     	print "Tallet er",tal
...
Tallet er 83521
If sætningen er måske den bedst kendte sætning (statement)
>>> x = int(raw_input("Skriv et helt tal: "))
>>> if x < 0:
...      x = 0
...      print 'Negativt tal ændret til nul'
... elif x == 0:
...      print 'Nul'
... elif x == 1:
...      print 'Et'
... else:
...      print 'Større end 1'
...
</screen>
</para>
<para>
Der kan være nul eller flere elif blokke, else kan vælges/udelades efter
ønske. Nøgleordet "elif" er en forkortelse af "else if" og er praktisk,
da der derved er muligt at undgå alt for mange blokindrykninger (de
fylder enormt i bredden).
</para>
<para>
<screen>
>>> streng = "wqexmjupiolåærdtce45rft6g8ijuplbkilmæø3we45rft6g8ijupl"
>>> if len(streng) > 50:
...     print "Længden af strengen er større end 50"
... elif len(streng) > 45:
...     print "Længden af strengen er større end 45"
... elif len(streng) > 40:
...     print "Længden af strengen er større end 40"
... else:
...     print "Længden af strengen er:", len(streng)
...
Længden af strengen er større end 50
</screen>
</para>
<para>
Simulering af terningekast: ALLE variabler i Python SKAL være erklærede,
inden de bruges første gang, I det følgende eksempel skal der bruges 6
fordefinerede variabler. Her har Python en speciel og særdeles
konstruktiv måde at gøre det på:
<screen>
f6 = f5 = f4 = f3 = f2 = f1 = 0
I andre om ikke alle andre computersprog skulle det gøres nogenlunde således:
f1 = 0
f2 = 0
f3 = 0
f4 = 0
f5 = 0
f6 = 0
Simulering af terningekast:
>>> import random
>>> f6 = f5 =f4 = f3 = f2 = f1 = 0
>>> for kast in range( 1, 10001 ):       # 10.000 terningekast
...     udfald = random.randrange( 1, 7 )
...     if udfald == 1:
...             f1 += 1
...     elif udfald == 2:
...             f2 += 1
...     elif udfald == 3:
...             f3 += 1
...     elif udfald == 4:
...             f4 += 1
...     elif udfald == 5:
...             f5 += 1
...     else:
...             f6 += 1
print "Udfald:"
print "Antal enere:  ", f1
print "Antal toere:  ", f2
print "Antal treere:  ", f3
print "Antal firere:  ", f4
print "Antal femmere: " ,f5
print "Antal seksere: ", f6
import random
def kastMed2():
   terning1 = random.randrange( 1, 7 )
   terning2 = random.randrange( 1, 7 )
   sumTotal = terning1 + terning2
   print "Spiller slog%d + %d = %d" % ( terning1, terning2, sumTotal )
   return sumTotal
sum = kastMed2()       # første omgang kast
if sum == 7 or sum == 11:
   gameStatus = "VANDT"
elif sum == 2 or sum == 3 or sum == 12:
   gameStatus = "TABTE"
else:                                     # husker points
   gameStatus = "FORTSÆT"
   minePoints = sum
   print "Spillers points er ", minePoints
while gameStatus == "FORTSÆT":   # fortsæt spillet
   sum = kastMed2()
   if sum == minePoints:             # vandt med følgende resultat
      gameStatus = "VANDT"
   elif sum == 7:                  # vandt ved at slå/kaste summen 7
      gameStatus = "TABTE"
if gameStatus == "VANDT":
   print "Spilleren vandt"
else:
   print "Spilleren tabte"
</screen>
</para>
</sect1>

<sect1 id="python-afbryd">
<title>Break og continue</title>
<para>
<screen>
>>> for i in range(1,101):
...     print i,
...     if i == 6:
...             break
...
1 2 3 4 5 6
</screen>
</para>
</sect1>

<sect1 id="python-rundgang">
<title>Løkker</title>
<para>
En computer er god til at huske (hvis ikke strømmen afbrydes) og god til
at gentage. Når en kommando ønskes gentaget, kan det ske i en eller
anden form for løkke, der køres i ring sådan at fortolkningen begynder
umiddelbart efter blokkolon, fortsætter blokken ud og gentager samme
proces til kommandoen i løkkens øverste linje er opfyldt. Her vil vi se på
løkkestrukturer.
</para>
</sect1>

<sect1 id="python-mens">
<title>While</title>
<para>
<screen>
>>> i = 0  # i skal være defineret inden løkken gennemløbes
>>> while i < 11:
...     print i,
...     i += 1
...
0 1 2 3 4 5 6 7 8 9 10
</screen>
</para>
<para>
Fibonacci tal
Fibonaccis tal er en uendelig talrække, hvor det enkelte tal
fremkommer som summen af de to foregående eks: 1, 1, 2,3,5,8,13...
</para>
<para>
<screen>
>>> def fib(n):
	a, b = 0, 1
...     while b < n:
...             print b,
...             a, b = b, a + b
>>> fib(100)
1 1 2 3 5 8 13 21 34 55 89
>>> def fib2(n):
...     resultat = []
...     a, b = 0, 1
...     while b < n:
...             resultat.append(b)
...             a,b = b, a + b
...     return resultat
...
>>> fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
</screen>
</para>
</sect1>

<sect1 id="python-omIgen">
<title>For løkker</title>
<para>
Se også under range. Alle range løkker med 2 eller flere parametre kan
anvendes i forbindelse med for løkker.
</para>
<para>
<screen>
>>> for i in range(1,11):
...     print i,
...
1 2 3 4 5i 6 7 8 9 10
</screen>
</para>
<para>
Kartotek = []     # liste af Pythonbøger
</para>
<para>
print "Indskriv bogtitel.\n"
</para>
<para>
for i in range( 5 ):
   titel = raw_input( "Indskriv bog %d: " % ( i + 1 ) )
   Kartotek.append( titel )
</para>
<para>
print "\nVis indhold"
</para>
<para>
for i in range( len( Kartotek ) ):
   Indskriv bogtitel.
</para>
<para>
Indskriv bog 1: "Programming Python"
Indskriv bog 2: "Python Cookbook"
Indskriv bog 3: "Python How To Program"
Indskriv bog 4: "Jython Essentials"
Indskriv bog 5: "Learn to Program"
</para>
<para>
Vis indhold
        1     "Programming Python"
        2     "Python Cookbook"
        3     "Python How To Program"
        4     "Jython Essentials"
        5     "Learn to Program"
</para>
<para>
print "%9d     %-25s" % ( i + 1, Kartotek[ i ] )
</para>
<para>
Kvadrattal:
>>> def Kvadrat(k):
...     return k * k
...
>>> for i in range(1,11):
...     print Kvadrat(i),
...
1 4 9 16 25 36 49 64 81 100
</para>
<para>
Tilfældige tal:
>>> import random
>>> for i in range( 1, 21 ):
...     print random.randrange( 1, 7 ),
...
5 2 2 3 1 5 4 5 3 4 2 1 2 5 6 6 1 3 4 6
</para>
<para>
Histogram:
print "Danner histogram ud fra listeindhold:"
print "%s %6s %6s" % ( "Indeks", "Element", "Histogram" )
</para>
<para>
for i in range( len( liste ) ):
	print "%3d %6d  %-12s" % ( i, liste[ i ], "*" * liste[ i ] )
</para>
<para>
Skriv 10 heltal:
Skriv helt tal: 1: 12
Skriv helt tal: 2: 5
Skriv helt tal: 3: 3
Skriv helt tal: 4: 6
Skriv helt tal: 5: 5
Skriv helt tal: 6: 8
Skriv helt tal: 7: 6
Skriv helt tal: 8: 1
Skriv helt tal: 9: 4
Skriv helt tal: 10: 9
</para>
<para>
Danner histogram ud fra listeindhold:
Indeks Element Histogram
  0     12  ************
  1      5         *****
  2      3           ***
  3      6        ******
  4      5         *****
  5      8      ********
  6      6        ******
  7      1             *
  8      4          ****
  9      9     *********
</para>
<para>
</para>
<para>
<screen>
Mål længden af nogle tekststrenge:
>>> a = ['Ugleenge', 'Murergade', 'Galløkken']
for l in a:
        print l, len(l)
>>>
Ugleenge 8
Murergade 9
Galløkken 9
>>>
</screen>
</para>
<para>
<screen>
For løkker og slicing:
for x in a[:]: # opret en slice copy af den aktuelle liste:
>>> if len(l) > 6: a.insert(0, l)
>>> a
['Galløkken', 'Ugleenge', 'Murergade', 'Galløkken']
>>>
>>> for i in range(len(a)):
        print i, a[i]...
...
0 Galløkken
1 Ugleenge
2 Murergade
3 Galløkken
>>>
</screen>
</para>
</sect1>

<sect1 id="python-pass">
<title>Pass sætningen</title>
<para>
pass sætningen bruges til at gøre ingen ting. Kan bruges når en sætning
syntaktisk er nødvendig, mens programmet ikke kræver nogen aktion. For
eksempel:
</para>
<para>
<screen>
Eks. 1
>>> class Klasse:
        pass...
...
>>>
</screen>
</para>
<para>
<screen>
Eks. 2
while True:
	pass # vent på tastaturklik
</screen>
</para>
</sect1>

<sect1 id="python-funkdef">
<title>Funktionsdefinering og -kald</title>
<para>
Under udviklingen af et program kan der være brug for en hensigtsmæssig
måde at opdele programmet på, så vi kan nøjes med at beskæftige os med
en del af programmet ad gangen. Vi kan ønske at putte mere trivielle
rutiner hen i et hjørne af programmet, så de ikke forstyrrer os i den
øvrige programskrivning. Her er funktioner (functions) eller som de
samme også ofte kaldes metoder (methods) en velkendt hjælp i de fleste
computersprog om ikke alle de nuværende. I det oprindelige BASIC kendtes
begrebet ikke, hvorfor vi brugte "GOTO" i massevis. I Pascal og Delphi
er der ud over funktionerne nogle til funktioner forholdsvis svarende
"pakkesamlere", der kaldes procedurer. Procedurer kan returnere en
værdi, men behøver det ikke. Alt efter computersprog kan en funktion
ubetinget skulle returnere en værdi (gælder i C++), i andre
computersprog som Pascal, Delphi, Visual Basic og Python kan en funktion
returnere en værdi, men behøver det ikke nødvendigvis. Python funktioner
bliver derfor, hvad C++ programmører nok vil kalde en procedure. Men
lad os nu skrive en Python funktion af hver slags - først en funktion,
der returnerer en værdi (altså den "rigtige" funktion).
</para>
<para>
Når du er færdig med defineringen skal du trykker 2 gange på
Enter-tasten dels for at fortælle Python, at defineringen er færdig og
dels for at komme tilbage til interaktiv mode markeringen
</para>
<para>
<screen>
>>>
Funktionsdefinering:
>>> def funktion():-
...     a = 4 * 5
...     return a
...
Funktionskald:
>>> funktion()
20
</screen>
</para>
<para>
Som du kan se ovenfor, skal nøgleordet def bruges for at fortælle
Python, at det kommende er en funktionsdefinering. Efter nøgleordet
følger funktionsnavnet, der kan være alle lovlige navne som i variabler.
Efter funktionsnavnet følger en parameterliste, der som her kan være
tom. Den omgives af runde parenteser og efterfølges af det kolon, som du
med garanti vil glemme mange gange, inden du er inde i rutinen med at
fortælle Python, at det kommende er en sammenhørende blok (her
funktionskroppen). Python reagerer ved at rykke de efterfølgende
programlinjer en tabulatorbredde til højre. Hvis du kopierer kode fra
eksempelvis en editor til Python, er det nødvendigt, at få nævnte
indrykninger med evt. ved selv at indsætte dem ved at trykke på
tastaturets tabulatortast. Der er ofte flere blokke i en funktion. Er
der det, skal de programlinjer, der hører til den pågældende blok rykkes
endnu et tabulatorstop til højre.
</para>
<para>
Returværdien kan også indgå i eksempelvis en anden regneoperation:
</para>
<para>
<screen>
>>> print funktion() * 7
140
</screen>
</para>
<para>
Funktion med et parameter (kaldes undertiden et argument):
</para>
<para>
>>> def f(a):
...     return a * 1.25
...
>>> f(75)
93.75
</para>
<para>
Funktion med mere end et parameter:
</para>
<para>
>>> def funktionsnavn(s1,s2):
...     return s1 + s2
</para>
<para>
Funktionskald:
</para>
<para>
>>> funktionsnavn("Streng1 ", "streng2.")
'Streng1 streng2.
</para>
<para>
Samme funktion, men ved tildeling af numeriske værdier:
</para>
<para>
>>> funktionsnavn(10,20.50)
30.5
</para>
<para>
Brugerdefineret funktion kalder anden brugerdefineret funktion:
</para>
<para>
>>> def f1():
...     print f2()
...
>>> def f2():
...     print "Funktion f2 er blevet kaldt."
...
>>> f1()
Funktion f2 er blevet kaldt.
None
</para>
<para>
Brugerdefineret funktion kalder fordefineret funktion:
</para>
<para>
>>> from sys import exit
>>> def afslut():
...     sys.exit()
...
>>> afslut()
ajbo@linux:~>
</para>
<para>
>>> m = input("Skriv denne maaneds nummer: ")
Skriv nummeret (pladsen i kalenderen) for denne maaned: 12
>>> maanedsnavne = ["januar","februar","marts","april","maj","juni","juli",\
... "august","september","oktober","november","december"]
>>> if 1 <= m <= 12:
... print "Denne maaneds navn er",maanedsnavne[m - 1]
</para>
<para>
Denne maaneds navn er december
</para>
<para>
Liste kan modtages som argument i funktion:
>>> liste [] #opretter tom global liste
>>> def ul(l): # argumentet l erklæres her som lokalt navn
...     liste.append(l)  # udvider den globale liste
...
>>> ul(1)
>>> ul("Hasle")
>>> ul(2)
>>> ul("Nyker")
Kørselsresultat:
>>> liste
[1, 'Hasle', 2, 'Nyker']
</para>
<para>
>>> liste = [1,2,3,4]
>>> def udvL(l = []): # argumentet l erklæres her som lokalt navn
...     for i in range(5,11):
...             l.append(i)
...             print l
...
Kørselsresultat:
>>> udvL(liste)
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6, 7]
[1, 2, 3, 4, 5, 6, 7, 8]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>>
</para>
<para>
def kR( lengde = 1, bredde = 1, hojde= 1 ):
   return lengde * bredde * hojde
</para>
<para>
print "Forvalgte kasserumfang:", kR()
print "Rumfang af kasse med længden 10 er: ", kR( 10 )
print "Rumfang af kasse med højden 10 er: ", kR(1 ,10 )
print "Rumfang af kasse med længde og  højde 10 er: ", kR(10 ,10 )
print "Rumfang af kasse med længde 12, bredde 4  og  højde 10 er: ", kR(12,4 ,10 )
</para>
<para>
</para>
<para>
Find primtal:
>>> for i in range(2, 10):
...      for j in range(2, i):
...             if i % j == 0:
...                     print i, 'er lig med', j, '*', i/j
...                     break
...             else:
...                     print i, 'er et primtal'
...
3 er et primtal
4 er lig med 2 * 2
5 er et primtal
5 er et primtal
5 er et primtal
6 er lig med 2 * 3
7 er et primtal
7 er et primtal
7 er et primtal
7 er et primtal
7 er et primtal
8 er lig med 2 * 4
9 er et primtal
9 er lig med 3 * 3
>>>
</para>
<para>
Beregn fakultet ved rekursion:
def fakultet( tal ):
	if tal <= 1:
 		return 1
	else:
		return tal * fakultet( tal - 1 )  # rekursivt kald
</para>
<para>
for i in range( 1,11 ):
		print "%2d! = %d" % ( i, fakultet( i ) )
</para>
<para>
ajbo@linux:~> python fakultet.py
 1! = 1
 2! = 2
 3! = 6
 4! = 24
 5! = 120
 6! = 720
 7! = 5040
 8! = 40320
 9! = 362880
10! = 3628800
</para>
<para>
<screen>
>>> def F():
>>> 	F()
...
>>> F.ekstra
23
>>>
</screen>
</para>
<para>
<screen>
def OK(prompt, rundgang=4, svar='Svar ja eller nej!'):
    while True:
        ok = raw_input(prompt)
        if ok in ('JA', 'Ja', 'ja'): return 1
        if ok in ('NEJ', 'Nej', 'nej'): return 0
        rundgang = rundgang - 1
        if rundgang < 0: raise IOError, 'vanskelig bruger'
        print svar
Kan kaldes med eksempelvis:
OK('Ønsker du at afslutte?')
og:
OK('Ønskes filen lukket?', 2)
</screen>
</para>
<para>
<screen>
>>> i = 5
>>> def f(arg = i):
...     print i
...
>>> f()
5
>>>
</screen>
</para>
<para>
<screen>
>>> def f(a, L=[]):
    L.append(a)
    return L... ...
...
Et kørselsresultat:
>>> for i in range(10):
...     print f(i)
...
[0]
[0, 1]
[0, 1, 2]
[0, 1, 2, 3]
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4, 5]
[0, 1, 2, 3, 4, 5, 6]
[0, 1, 2, 3, 4, 5, 6, 7]
[0, 1, 2, 3, 4, 5, 6, 7, 8]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>>
</screen>
</para>
<para>
<screen>
def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
</screen>
</para>
<para>
<screen>
>>> for i in range(10):
...     print f(i),
...
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
>>>
</screen>
</para>
<para>
<screen>
Returner variablen None:
>>> def f():
...     return
...
</screen>
</para>
<para>
<screen>
>>> print f(56)
None
>>>
</screen>
</para>
<para>
Nøgleords argumenter (keyword arguments). Du kan vælge at lade din
funktion have et antal fordefinerede og forud værditildelte nøgleord.
Sådanne nøgleord må ikke forveksles med de i Python forud definerede
variabler. Vi skal se et eksempel:
</para>
<para>
<screen>
>>> def funktion(computer,kvalitet, styresystem = "Linux", computersprog = "Python"):
...      print "En",kvalitet,computer, "anvender", styresystem
...
>>> funktion("PC","veludstyret")
En veludstyret PC anvender Linux
>>>
</screen>
Argumenterne computer og kvalitet er tomme, hvorfor de skal tildeles
værdi ved funktionskald. Det skal nøgleordsargumenterne ikke, da de
allerede er tildelt en sådan. Det samme gælder nøgleordet computersprog.
</para>
<para>
Som andre variabler, kan variablen kvalitet modtage en tom værdi,
ellers kan du få et lidt ulogisk resultat som:
<screen>
>>> funktion(0,0)
En 0 0 anvender naturligvis Linux
>>>
>>> funktion("PC","")
En  PC anvender Linux
>>>
>>> funktion("","veludstyret")
En veludstyret  anvender Linux
>>>
>>> funktion("PC","nogenlunde",styresystem = "Windows")
En nogenlunde PC anvender Windows
>>>
</screen>
</para>
<para>
Når en funktions sidste parameter er af formen **navn (med 2
foranstillede stjerner), kan den modtage en ordliste, hvis nøgleord ikke
findes i parameterlisten. Det kan kombineres med en formel parameter af
formen *navn (med 1 foranstillet stjerne).*navn skal komme før **navn:
<screen>
>>> def f(vareart, *argumenter, **noegleord):
...     pass
...
>>>
</screen>
Funktionskald af den type bruges meget i Python, så det er vigtigt at
forstå virkning m.v, hvorfor jeg viste første eksempel med danske navne,
ellers er det mest praktist at holde sig til de engelske, da det er dem,
du normalt vil se:
</para>
<para>
<screen>
>>> def f(programnavn, *arguments, **keywords):
...     return programnavn, arguments, keywords
...
>>> f("mitProgram.py")
('mitProgram.py', (), {})
>>>
</screen>
</para>
<para>
Som du ser, returneres der en tuple indeholdende 1: argumentet 2: en
tuple og 3: en ordliste. Hvis du ønsker at læse den eksterne fil
mitProgram.py, kan du anvende følgende indledning:
</para>
<para>
<screen>
>>> f("mitProgram.py","r")
('mitProgram.py', ('r',), {})
>>>
</screen>
</para>
<para>
>>> f("mitProgram.py","r","r2","r3")
('mitProgram.py', ('r', 'r2', 'r3'), {})
>>>
</para>
<para>
>>> f("mitProgram.py","r","r2","r3", regnskabsaar = 2003)
('mitProgram.py', ('r', 'r2', 'r3'), {'regnskabsaar': 2003})
>>>
</para>
<para>
>>> f("mitProgram.py","r","r2","r3",regnskabsmaaned = "januar")
('mitProgram.py', ('r', 'r2', 'r3'), {'maaned': 'januar'})
>>>
>>> f("mitProgram.py","r","r2","r3",maaned = "februar")
('mitProgram.py', ('r', 'r2', 'r3'), {'maaned': 'februar'})
>>>
>>> f("mitProgram.py","r","r2","r3",maaned = "januar",md2 = "februar")
('mitProgram.py', ('r', 'r2', 'r3'), {'md2': 'februar', 'md': 'januar'})
>>>
</para>
<para>
Argumentlisten behøver ikke nødvendigvis at være af et omfang som en dansk stil:
</para>
<para>
>>> def f(v,*a, **k):
...     return v,a,k
...
>>> f("Vareart","cykel",navn = "Christiania")
('Vareart', ('cykel',), {'navn': 'Christiania'})
>>>
>>> f("Vareart","cykel",navn2 = "Christiania")
('Vareart', ('cykel',), {'navn2': 'Christiania'})
>>>
</para>
<para>
>>> def f(v,*a, **k):
...     print a, k
...
>>> f("Vareart","cykel",navn = "Christiania")
('cykel',) {'navn': 'Christiania'}
</para>
<para>
>>> def f(a,*b,**c):
...     c = {1:"en",2:"to",3:"tre"}
...     return a,b,c
...
>>> f(1,2)
(1, (2,), {1: 'en', 2: 'to', 3: 'tre'})
>>>
</para>
<para>
Bemærk: boglisten kræver de krøllede parenteser:
>>> def f(a,*b,**c):
...     return a,b,c
...
...
</para>
<para>
>>> f(1,"fire","fem","seks",7:"syv",8:"otte",9:"ni")
  File "&lt;stdin&gt;", line 1
    f(1,"fire","fem","seks",7:"syv",8:"otte",9:"ni")
                             ^
SyntaxError: invalid syntax
>>> f(1,"fire","fem","seks",{7:"syv",8:"otte",9:"ni"})
(1, ('fire', 'fem', 'seks', {8: 'otte', 9: 'ni', 7: 'syv'}), {})
>>>
</para>
<para>
>>> def f(a,*b,**c):
...     for arg in b : print arg
...
>>> f(1,"to","tre","fire")
to
tre
fire
>>>
</para>
<para>
>>> args = [1,10]
>>> range(*args)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>>
</para>
<para>
>>> args = [3, 6]
>>> range(*args)
[3, 4, 5]
</para>
<para>
<screen>
Lamda arbejder i baggrunden:
>>> def svindel(n):
...     return lambda x: x + n
...
>>> f = svindel(1.25)
>>> f(100)
101.25
>>>
</screen>
</para>
</sect1>

<sect1 id="python-lister">
<title>Lister</title>
<para>
Lister er variabler med nul til flere sammenhørende rum. Listen kendes
på dens firkantede parenteser. Tænker du dig dem taget væk, har du en
tuple. Den kendes på dens kommaer.
</para>
<para>
<screen>
Listens og dens muligheder:
>>> # Opret tom liste
>>> listen = []
>>> # udvid listen med et ekstra element
>>> listen.append("Ypnasted")
>>> # udvidelsen kan også ske således:
>>> listen[len(listen):] = "Teglkaas"
>>> listen[len(listen):] = ["Hellig Peder"]
>>> listen
['Ypnasted', 'T', 'e', 'g', 'l', 'k', 'a', 'a', 's', 'Hellig Peder']
>>> # udvidelsen kan også ske således:
>>> listen.extend(["Vang","Hammeren"])
>>> listen
['Ypnasted', 'T', 'e', 'g', 'l', 'k', 'a', 'a', 's', 'Hellig Peder', 'Vang', 'Hammeren']
>>> # Listen kan vendes om:
>>> listen.reverse()
>>> listen
['Hammeren', 'Vang', 'Hellig Peder', 's', 'a', 'a', 'k', 'l', 'g', 'e', 'T', 'Ypnasted']
>>> # fjerner sidste element i listen:
>>> listen.pop()
'Ypnasted'
>>> listen
['Hammeren', 'Vang', 'Hellig Peder', 's', 'a', 'a', 'k', 'l', 'g', 'e', 'T']
>>> for i in range(0,8):
...     listen.pop()
...
'T'
'e'
'g'
'l'
'k'
'a'
'a'
's'
>>> listen
['Hammeren', 'Vang', 'Hellig Peder']
>>> # sorterer listen
>>> listen.sort()
>>> listen
['Hammeren', 'Hellig Peder', 'Vang']
>>> # fjerner angivne element fra listen:
>>> listen.remove("Hellig Peder")
>>> listen
['Hammeren', 'Vang']
>>> # returnerer givne indeks (plads) i listen
>>> listen.index("Hammeren")
0
>>> listen.index("Vang")
1
>>> # finder listens største element:
>>> max(listen)
'Vang'
>>> # finder listens mindste element:
>>> min(listen)
'Hammeren'
>>> # opdeler listen i enkeltelementer
>>> zip(listen,[1,2])
[('Hammeren', 1), ('Vang', 2)]
>>> zip(listen,[8,7])
[('Hammeren', 8), ('Vang', 7)]
>>> # multiplicerer listen:
>>> lister = listen * 2
>>> lister
['Hammeren', 'Vang', 'Hammeren', 'Vang']
>>> # multiplicerer listen:
>>> lister = zip(listen,[1,2]) * 2
>>> lister
[('Hammeren', 1), ('Vang', 2), ('Hammeren', 1), ('Vang', 2)]
>>>
</screen>
</para>
<para>
Returnering af større eller mindre dele af en liste kaldes slicing.
Slicing af en given del af en liste sker ved at indsætte start- og
slutindeks i de fra listen velkendte firkantede parenteser:
</para>
<para>
>>> l = [1,2,3,3,4,5,6,7,8,9]
>>> print l[0] # returner listens første element
1
>>> print l[0:4] # returner listens 4 første elementer
[1, 2, 3, 3]
>>> print l[3:6] # returner  listens  4. til 6. element
[3, 4, 5]
>>> print l[-4] # returner listens 4. sidste element
6
>>> print l[-1] # returner listens sidste element
9
>>>
</para>
<para>
# Opret liste med lige tal <= 20
# Søg i liste efter integer (heltal)
liste = range( 0, 21, 2 )
#listeindhold: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
print liste
skalFindes = int( raw_input( "Indtast heltal <= 20: " ) )
if skalFindes in liste:
	print "Fundet på indeks:", liste.index( skalFindes )
else:
	print "Elementet blev ikke fundet"
</para>
<para>
Indtast heltal <= 20: 12
Fundet på indeks: 6
Indtast heltal <= 20: 13
Elementet blev ikke fundet
</para>
<para>
Listen og tuplen har flere lighedspunkter:
>>> l = []
>>> t = {}
>>> t = 1,2,3,5
>>> t
(1, 2, 3, 5)
>>> l = t
>>> l
(1, 2, 3, 5)
>>> l[1]
2
>>> t[1]
2
>>> l = [6,7,8,9]
>>> l
[6, 7, 8, 9]
>>> t = l
>>> t
[6, 7, 8, 9]
</para>
<para>
</para>
<para>
liste = []    # opret tom liste
# indsæt elementer i listen
for indeks in range( 1, 11 ):
   liste += [ indeks ]
</para>
<para>
print "Listens indhold:", liste
</para>
<para>
print # indsætter tom linje
</para>
<para>
for element in liste:
   print element,
</para>
<para>
print
</para>
<para>
# listetilgang via indeks (rumnummer)
print "\nVælg elementer efter deres indeks:"
print "Listens indhold:"
</para>
<para>
for i in range( len( liste ) ):
   print "%6d %3d" % ( i, liste[ i ] )
</para>
<para>
print "\nOpdatering af listeelementer..."
print "Listens indhold før opdateringen:", liste
liste[ 0 ] = -100
liste[ -3 ] = "bornholmere"
print "Listens indhold efter opdateringen:", liste
</para>
<para>
ajbo@linux:~> python anvendt_liste.py
Listens indhold: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</para>
<para>
1 2 3 4 5 6 7 8 9 10
</para>
<para>
Vælg elementer efter deres indeks:
Listens indhold:
     0   1
     1   2
     2   3
     3   4
     4   5
     5   6
     6   7
     7   8
     8   9
     9  10
</para>
<para>
Opdatering af listeelementer...
Listens indhold før opdateringen: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Listens indhold efter opdateringen: [-100, 2, 3, 4, 5, 6, 7, 'bornholmere', 9, 10]
</para>
<para>
liste = []   # opretter tom liste
</para>
<para>
# indsæt 10 heltal via brugerindtastninger
print "Skriv 10 heltal:"
</para>
<para>
for i in range( 10 ):
   nytElement = int( raw_input( "Skriv helt tal: %d: " % ( i + 1 ) ) )
   liste += [ nytElement ]
</para>
<para>
</para>
<para>
Udskrift af lister i liste:
liste = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]
</para>
<para>
print "Elementerne i listen:"
for i in liste:
	for element in i:
		print element,
		print
</para>
<para>
Kørselsresultat:
python row.py
Elementerne i listen:
1
2
3
4
5
6
7
8
9
</para>
<para>
>>> liste = range(11)
>>> liste
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</para>
<para>
Lister kan flettes (indeholde andre lister) f.eks:
>>> liste = [[]]
>>> liste
[[]]
>>> liste * 3
[[], [], []]
</para>
<para>
>>> liste_1 = [2, 3]
>>> liste_2 = [1,liste_1, 4]
>>> len(liste_2)
3
>>> liste_2[1]
[2, 3]
>>> liste_2[1][0]
2
>>> liste_2[1].append('ekstrapost')
>>> liste_2
[1, [2, 3, 'ekstrapost'], 4]
>>> liste_1
[2, 3, 'ekstrapost']
>>>
</para>
<para>
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]
</para>
<para>
</para>
<para>
>>> liste = ["Ugleenge","Sæne","Bækkely","Stampen"]
>>> for i, v in enumerate(liste):
...     print i,v
...
0 Ugleenge
1 Sæne
2 Bækkely
3 Stampen
>>>
</para>
<para>
Der kan også dannes løkke over to eller flere samtidige sekvenser:
>>> person = ['Ole', '120', 'naturen']
>>> svar = ['navn:', 'alder:', 'hobby:']
>>> for i, j in zip(person,svar):
...     print j,i
...
navn: Ole
alder: 120
hobby: naturen
>>>
</para>
<para>
<screen>
Lister kan sammenlignes:
>>> [1, 2, 3] < [1, 2, 4]
True
>>>
>>> [1, 2, 3, 4] < [1, 2, 4]
True
>>>
>>> [2,3,4] <> [2.0,3.0,4.0]
True
>>>
>>> [1, 2] < [1, 2, -1]
True
>>>
>>> [1, 2, 3] == [1.0, 2.0, 3.0]
True
>>>
>>> [1, 2, 3,4] <>[1, 2, 3,"p"]
True
>>>
>>> [1, 2, ['aa', 'ab']] < [1, 2, ['abc', 'a'], 4]
</screen>
</para>
<para>
Lister anvendt som stakke
</para>
<para>
I computersproget FORTH benyttes begrebet stakke meget. Der sammenligner
man normalt en stak med en stabel tallerkener. I en sådan stabel
tallerkener, vil den nederste under normale forhold blive placeret i
bunden at stakken eller stabelen. I FORTH arbejder man normalt med
begreberne LIFO (last in first out eller på dansk først ind (altså
øverst i tallerkenstabelen) first out eller først ud betyder, som ordet
siger først ud - altså at man tager den øverste tallerken (det øverste
eller sidst placerede element først. Modsvarende LIFO bruger man også
FIFO i FORTH. Forkortelsen FIFO står for first in first out eller på
dansk først ind først ud. Overført til tallerkenstablen betyder det, at
den nederste tallerken i stakken, er den tjeneren benytter først. Jeg
har vagt at forklare princippet ud fra FORTH, fordi det derved også
bliver lettere at forstå, hvordan man i Python kan lave noget
tilsvarende. I Python kalder man en stak for en queue ligesom normalt
må nøjes med at udskrive selve FIFO og LIFO elementerne. Det kan gøres
således:
</para>
<para>
<screen>
>>> queue = ["Arnager","Dueodde","Nexø","Svaneke"]
>>> queue.pop(0)
'Arnager'
>>> queue.pop(2)
'Svaneke'
>>> queue.append("Gudhjem")
>>> queue.pop(2)
'Gudhjem'
>>> queue.append("Tejn")
>>> queue.pop(2)
'Tejn'
>>>
</screen>
</para>

<sect2 id="python-tabeller-tol">
<title>Funktionelle programmeringsværktøjer</title>
<para>
I Python er der tre fordefinerede funktioner, der er meget nyttige i
forbindelse med lister:
<screen>
filter(), map(), and reduce().
</screen>
Eksempel:
Syntaks: filter(funktion,sekvens) returnerer om muligt en sekvens af
samme type som den i filters parameterliste. Den returnerede sekvens
består af de værdier, der gør, at funktion(argument) er sand (true).
</para>
<para>
Eksempel:
<screen>
Beregn Primtal:
Syntaks: filter(funktion, blok)
>>> def f(x): return x % 2 != 0 and x % 3 != 0
...
>>> filter(f, range(2, 25))
[5, 7, 11, 13, 17, 19, 23]
</screen>
</para>
<para>
</para>
<para>
Syntaks: map(funktion, blok)
</para>
<para>
kalder funktion(parameter) for hver enkelt af sekvensens elementer
og returnerer en liste indeholdende returværdierne.
</para>
<para>
Eksempel:
Beregn kubiktal:
>>> def kubik(x): return x*x*x
...
>>> map(kubik, range(1, 11))
[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
>>>
</para>
<para>
map kan også tage flere sekvenser.
>>> def kvadrat(x): return x*x
...
>>> map(None, sekvens, map(kvadrat, sekvens))
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49)]
>>>
</para>
<para>
Eksempel:
Syntaks: reduce(funktion, sekvens)
>>> 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
55
>>>
</para>
<para>
>>> def sumTotal(x,y): return x + y
...
>>> reduce(sumTotal, range(1, 11))
55
>>>
</para>
<para>
>>> reduce(sumTotal, range(11)
... )
55
>>>
</para>
<para>
Nyhed i Python version 2.3:
>>> navne = ['London','Paris','New Yorkbyer','Gudhjem']
>>> [byer.strip() for byer in navne]
['London', 'Paris', 'New Yorkbyer', 'Gudhjem']
>>>
</para>
<para>
>>> drenge = ["Ole","Per","Sofus","Nikolai"]
>>> [navne.strip() for navne in drenge]
['Ole', 'Per', 'Sofus', 'Nikolai']
>>>
</para>
<para>
<screen>
>>> lige =  [2, 4, 6]
>>> [3*x for x in lige]
[6, 12, 18]
>>>
>>> [3*x for x in lige if x > 3]
[12, 18]
>>>
>>> [3*x for x in lige if x < 2]
[]
>>>
>>> [[x,x**2] for x in lige]
[[2, 4], [4, 16], [6, 36]]
>>>
>>> lige = [2, 4, 6]
>>> blandede = [4, 3, -9]
>>> [x*y for x in lige for y in blandede]
[8, 6, -18, 16, 12, -36, 24, 18, -54]
>>>
>>> [x+y for x in lige for y in blandede]
[6, 5, -7, 8, 7, -5, 10, 9, -3]
>>>
>>> [lige[i] * blandede[i] for i in range(len(lige))]
[8, 12, -54]
>>>
>>> [str(round(355/113.0, i)) for i in range(1,6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
>>>
>>> [x**3 for x in range(5)]
[0, 1, 8, 27, 64]
>>>
</screen>
</para>
<para>
Tuples består af et anatal værdier adskille med kommaer. Man siger, at
tuples kendes på deres kommaer, mens listen kendes på dens firkantede
parenteser. Eks:
<screen>
>>> t = 1,2,3,4,5
>>> t
(1, 2, 3, 4, 5)
>>>
At de adskillende kommaer virkelig betyder noget ses her:
>>> varsel = "Fare forude!"
>>> len(varsel)
12
>>> varsel = "Fare forude!",
>>> len(varsel)
1
>>>
</screen>
I det første lilfælde er "Fare forude!" en tekststreng, mens det i det
sidste tilfælde er en tuple. Forskellen er ene og alene kommaet.
</para>
<para>
<screen>
Tuplen og dens anvendelse oprettet ud fra brugerdata:
t = int( raw_input( "Skriv aktuelt timetal: " ) )
m = int( raw_input( "Skriv aktuelt minuttal: " ) )
s = int( raw_input( "Skriv aktuelt sekundtal: " ) )
</screen>
</para>
<para>
ligeNu = t, m, s   # opret  tuple
</para>
<para>
print "Tuplens indhold er:", ligeNu
</para>
<para>
print "Antal sekunder siden midnat", \
   ( ligeNu[ 0 ] * 3600 + ligeNu[ 1 ] * 60 +
     ligeNu[ 2 ] )
</para>
<para>
Kørselsresultat:
ajbo@linux:~> python anvendt_tuple.py
Skriv aktuelt timetal: 11
Skriv aktuelt minuttal: 17
Skriv aktuelt sekundtal: 13
Tuplens indhold er: (11, 17, 13)
Antal sekunder siden midnat 40633
</para>
<para>
Strengs, listes og tuples anvendelse:
strengen = "abcdefghij"
tuplen = ( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 )
listen = [ "I", "II", "III", "IV", "V",
              "VI", "VII", "VIII", "IX", "X" ]
</para>
<para>
print "strengen: ", strengen
print "tuplen: ", tuplen
print "listen: ", listen
</para>
<para>
start = int( raw_input( "Vælg startpunkt: " ) )
sidste = int( raw_input( "Vælg slutpunkt: " ) )
</para>
<para>
print "\nstrengen[", start, ":", sidste, "] = ", \
   strengen[ start:sidste ]
</para>
<para>
print "tuplen[", start, ":", sidste, "] = ", \
   tuplen[ start:sidste ]
</para>
<para>
print "listen[", start, ":", sidste, "] = ", \
   listen[ start:sidste ]
</para>
<para>
Kørselsresultat:
strengen:  abcdefghij
tuplen:  (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
listen:  ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X']
Vælg startpunkt: 0
Vælg slutpunkt: 6
</para>
<para>
strengen[ 0 : 6 ] =  abcdef
tuplen[ 0 : 6 ] =  (1, 2, 3, 4, 5, 6)
listen[ 0 : 6 ] =  ['I', 'II', 'III', 'IV', 'V', 'VI']
ajbo@linux:~>
</para>
<para>
Tuples kan flettes (be nested):
>>> t = 12345, 54321, 'hej!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hej!')
</para>
<para>
>>> # Tuples kan flettes:
>>> u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hej!'), (1, 2, 3, 4, 5))
</para>
<para>
Tuples kan sammenlignes:
>>> (1, 2, 3) < (1, 2, 4)
True
>>>
>>> (1, 2, 3, 4) < (1, 2, 4)
True
>>>
>>> (2,3,4) <> (2.0,3.0,4.0)
False
>>>
>>> (1, 2) < (1, 2, -1)
True
>>>
>>> (1, 2, 3) == (1.0, 2.0, 3.0)
True
>>>
>>> (1, 2, 3,4) <>(1, 2, 3,"p")
True
>>>
>>> (1, 2, ('aa', 'ab')) < (1, 2, ('abc', 'a'), 4)
True
>>>
</para>
<para>
<screen>
Sammenligning af Lister og tuples
>>> [1, 2, 3] < (1, 2, 4)
True
>>>
>>> [1, 2, 3, 4] < (1, 2, 4)
True
>>>
>>> [2,3,4] <> (2.0,3.0,4.0)
True
>>>
>>> [1, 2] < (1, 2, -1)
>>> True
>>>
[1, 2, 3] == (1.0, 2.0, 3.0)
True
>>>
>>> [1, 2, 3,4] <> (1, 2, 3,"p")
True
>>>
>>> [1, 2, ['aa', 'ab']] < (1, 2, ('abc', 'a'), 4)
True
>>>
</screen>
</para>
<para>
<screen>
ordliste = {} # opretter tom dictionary
print "Ordlisten indhold:", ordliste
</screen>
</para>
<para>
postnumre = { "Rønne": 3700, "Allinge": 3770, "Gudhjem": 3780, "Nexø": 3730}
print "\nAlle indsatte postnumre:", postnumre
</para>
<para>
# access  og ret eksistenende ordliste
print "\nRønne postnummer:", postnumre[ "Rønne" ]
postnumre[ "Gudhjem" ] = 3760
print "Gudhjems rigtige postnummer:", postnumre[ "Gudhjem" ]
</para>
<para>
# tilføj postnummer
postnumre[ "Aakirkeby" ] = 3720
print "\nOrdlistens postnumre efter rettelsen:"
print postnumre
</para>
<para>
# slet indgang fra ordlisten
del postnumre[ "Allinge" ]
print "\nOrdlistens nuværende indhold:"
print postnumre
</para>
<para>
Ordlisten indhold: {}
</para>
<para>
Alle indsatte postnumre: {'Nexø': 3730, 'Gudhjem': 3780, 'Rønne': 3700, 'Allinge': 3770}
</para>
<para>
Rønne postnummer: 3700
Gudhjems rigtige postnummer: 3760
</para>
<para>
Ordlistens postnumre efter rettelsen:
{'Nexø': 3730, 'Aakirkeby': 3720, 'Gudhjem': 3760, 'Rønne': 3700, 'Allinge': 3770}
</para>
<para>
Ordlistens nuværende indhold:
{'Nexø': 3730, 'Aakirkeby': 3720, 'Gudhjem': 3760, 'Rønne': 3700}
</para>
<para>
</para>
<para>
Her er et eksempel på anvendelse af en ordliste:
>>> postnr = {'Nyker': 3700, 'Hasle': 3790}
>>> postnr['Gudhjem'] = 3760
>>> postnr
{'Hasle': 3790, 'Nyker': 3700, 'Gudhjem': 3760}
>>>
>>> del postnr["Hasle"]
>>> postnr
{'Nyker': 3700, 'Gudhjem': 3760}
>>>
>>> postnr
{'Muleby': 3700, 'Nyker': 3700, 'Gudhjem': 3760}
>>>
>>> postnr.keys()
['Muleby', 'Nyker', 'Gudhjem']
>>>
>>> postnr.has_key("Hasle")
0
>>>
>>> postnr.has_key("Gudhjem")
1
>>>
</para>
<para>
Konstruktøren dict() opretter ordlister direkte fra en liste hvis elementer er tuples:
>>> liste = [('Muleby', 3700), ('Nyker', 3700), ('Gudhjem', 3760)]
>>> dict(liste)
{'Nyker': 3700, 'Muleby': 3700, 'Gudhjem': 3760}
>>>
eller:
>>> dict([('Muleby', 3700), ('Nyker', 3700), ('Gudhjem', 3760)])
{'Nyker': 3700, 'Muleby': 3700, 'Gudhjem': 3760}
>>>
</para>
<para>
>>> liste = []
>>> for i in range(6):
...     liste.append((str(i), i* i))
...
>>>
</para>
<para>
>>> liste = [('0', 0), ('1', 1), ('2', 4), ('3', 9), ('4', 16), ('5', 25)]
>>> dict(liste)
{'1': 1, '0': 0, '3': 9, '2': 4, '5': 25, '4': 16}
>>>
</para>
<para>
Løkke teknikker:
>>> t = "Ugleenge","Sæne","Bækkely","Stampen"
>>> t
('Ugleenge', 'S\xe6ne', 'B\xe6kkely', 'Stampen')
>>>
</para>
<para>
ordliste = {"Ugleenge" : 1,"Sæne" : 2,"Bækkely" :3,"Stampen" : 4}
>>> for i in ordliste.items(): print i
...
('S\xe6ne', 2)
('B\xe6kkely', 3)
('Ugleenge', 1)
('Stampen', 4)
>>>
</para>
<para>
</para>
<para>
kalender = { 1 : "Januar", 2 : "Februar", 3 : "Marts",
                4 : "April", 5 : "Maj", 6 : "Juni", 7 : "Juli",
                8 : "August", 9 : "September", 10 : "Oktober",
                11 : "November", 12 : "December" }
</para>
<para>
print "Ordlistens indhold:"
print kalender.items()
</para>
<para>
print "\nOrdlistens indgange er:"
print kalender.keys()
</para>
<para>
print "\nOrdlistens elementer er:"
print kalender.values()
</para>
<para>
print "\nFor løkke henter ordliste elementer:"
for indgang in kalender.keys():
	print "kalender[", indgang, "] =", kalender[ indgang ]
</para>
<para>
Kørselsresultat:
ajbo@linux:~> python kalender.py
Ordlistens indhold:
[(1, 'Januar'), (2, 'Februar'), (3, 'Marts'), (4, 'April'),
(5, 'Maj'), (6, 'Juni'), (7, 'Juli'), (8, 'August'), (9, 'September'),
(10, 'Oktober'), (11, 'November'), (12, 'December')]
</para>
<para>
Ordlistens  indeks (indgange) er:
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
</para>
<para>
Ordlistens elementer er:
['Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni',
'Juli', 'August', 'September', 'Oktober', 'November', 'December']
</para>
<para>
For løkke henter ordliste elementer:
kalender[ 1 ] = Januar
kalender[ 2 ] = Februar
kalender[ 3 ] = Marts
kalender[ 4 ] = April
kalender[ 5 ] = Maj
kalender[ 6 ] = Juni
kalender[ 7 ] = Juli
kalender[ 8 ] = August
kalender[ 9 ] = September
kalender[ 10 ] = Oktober
kalender[ 11 ] = November
kalender[ 12 ] = December
ajbo@linux:~>
</para>
</sect2>
</sect1>

<sect1 id="python-undslip">
 <title>Escape sekvenser</title>
<para>
<screen>
\n  Ny linje
\t  Vandret tabulator. Flytter markøren til næste tabulatorstop
\r  Vognretur. Flytter markøren til linjens begyndelse
\b  Backspace. Flytter markøren 1 plads tilbage
\a  Systemklokke
\\  Backspace. Indsætter \
\"  Indsætter anførselstegn
\'  Indsætter enkelt anførselstegn
</screen>
</para>
</sect1>

<sect1 id="python-tallene">
<title>Talsystemer</title>
<para>
I computersproget Forth, kan man benytte omkring 70 forskellige
talsystemer afhængig af sprogversionen. Det talsystem vi bruger i vore
dage et 10-talsystemet eller det decimale talsystem. Sådan har det ikke
været altid verden over. For omkring 4000 år siden brugtes
60-talsystemet i områ det lige nordvest for Persiske Hav. Lad os lige se
på tallet 4320. Det består af 4 tusinder, 3 hundreder, 2 tiere og 0
enere, hvilket de fleste sikkert tager som en selvfølgelighed, men er
det nu også så selvfølgelig? Nej, det allerede nævnte har sikkert
allerede røbet, at det slet ikke er så enkelt 10-talsystemet er nonsens
for enhver computer. Den kan alene arbejde i 2-talsystemet. Det skyldes,
at computeren, som det elektriske apparat den er, reelt kun kan reagere
på, om der går en strøm i en ledning eller ikke. Hvis der går en strøm,
har man vedtaget at registrere tilstanden med tallet 1. Hvis der ikke
går nogen strøm, registreres det med tallet 0.
</para>
<para>
2 er grundtal i totalsystemet, som 10 er det i 10-talsystemet og n i
n-talsystemet. Cifrene i et talsystem udgør altid det antal,
talsystemets grundtal angiver. Grundtallet er normalt det, der giver
talsystemet dets navn. I totalsystemet er der to cifre (nul og et). I
titalsystemet er der ti cifre (fra og med 0 til og med 9) osv.
</para>
<para>
Fordi alle talsystemer har 0 som laveste ciffer, bliver højeste ciffer
en mindre end talsystemets grundtal. I 2-talsystemet bliver det størst
ciffer således 2 - 1 = 1 og i 10-talsystemet 10 - 1 = 9 og sådan
fremdeles. Det bageste ciffer (det længst til højre) vil repræsentere
ciffer gange grundtal i første. Et ciffer i et tal vil altid udgøre
ciffer gange grundtal i n - 1. Men lad os lade Python gøre det lidt
klarere:
</para>

<sect2 id="python-tallene-1">
<title>Hexadeximale og oktale tal</title>
<para>
I Python specificeres et hexadecimalt tal ved et foranstillet nul
efterfulgt af et x og afsluttet med det hexadecimale tal som f.eks. 0x49
svarende til 9 + 4 * 16 = 73 i vores normale 10-talsystem. Jeg kommer
ikke nærmere ind på det oktale talsystem (det med grundtallet 8), men
skal nøjes med kort at nævne, at i det er 7 største ciffer x udelades.
Det betyder, at 0x49 svarer til 0111 (1 ener 1 8-er og 1 64-er eller 8
** 2) altså 1 + 8 + 64 = 73 i det decimale talsystem. Det kan være
svært for en begynder at forstå, så lad os se på et par eksempler:
</para>
<para>
Først et eksempel fra 10-talsystemet (decimaltal systemet)
<screen>
>>> for i in range(0,9):
...     print "10 i",i,". er:", 10 ** i
...
10 i 0 . er: 1
10 i 1 . er: 10
10 i 2 . er: 100
10 i 3 . er: 1000
10 i 4 . er: 10000
10 i 5 . er: 100000
10 i 6 . er: 1000000
10 i 7 . er: 10000000
10 i 8 . er: 100000000
>>>

Det binære talsystem:
>>> for i in range(0,9):
...     print "2 i ",i,". er:", 2 ** i
...
2 i  0 . er: 1
2 i  1 . er: 2
2 i  2 . er: 4
2 i  3 . er: 8
2 i  4 . er: 16
2 i  5 . er: 32
2 i  6 . er: 64
2 i  7 . er: 128
2 i  8 . er: 256
>>>

Det oktale talsystem:
>>> for i in range(0,9):
...     print "8 i",i,". er:",8 ** i
...
8 i 0 . er: 1
8 i 1 . er: 8
8 i 2 . er: 64
8 i 3 . er: 512
8 i 4 . er: 4096
8 i 5 . er: 32768
8 i 6 . er: 262144
8 i 7 . er: 2097152
8 i 8 . er: 16777216
>>>

Det hexadecimale talsystem:
>>> for i in range(0,9):
...     print "16 i",i,". er:",16 ** i
...
16 i 0 . er: 1
16 i 1 . er: 16
16 i 2 . er: 256
16 i 3 . er: 4096
16 i 4 . er: 65536
16 i 5 . er: 1048576
16 i 6 . er: 16777216
16 i 7 . er: 268435456
16 i 8 . er: 4294967296
>>>

Udskriv hexadecimale tal:
>>> for i in range(0,17):
...     print hex(i)
...
0x0
0x1
0x2
0x3
0x4
0x5
0x6
0x7
0x8
0x9
0xa
0xb
0xc
0xd
0xe
0xf
0x10

Udskriv oktale tal
>>> for i in range(0,17):
...     print oct(i)
...
0
01
02
03
04
05
06
07
010
011
012
013
014
015
016
017
020
</screen>
</para>
</sect2>

<sect2 id="python-tallene-2">
<title>Fra oktale og hexadecimale tal til decimale</title>

<screen>
>>> a = 0x49
>>> a
73
>>> a = 0111
>>> a
73

>>> # om der benyttes "store" eller "små"
>>> # bogstaver er uden betydning
>>> a = 0xa5
>>> a
165
>>> b = 0XB2
>>> b
178
</screen>
</sect2>

<sect2 id="python-tallene-3">
 <title>Fra decimale til oktale og hexadecimale tal</title>

<para>
<screen>
>>> oct(73)
'0111'
>>> hex(73)
'0x49'
</screen>
</para>
</sect2>

<sect2 id="python-tallene-4">
<title>Hexadecimale tal i tekststrenge</title>
<para>
I tekststrenge erstattes nul af backslach.
</para>
<para>
<screen>
>>> "\x41", chr(65) # 1 + 4 * 16 = 65
('A', 'A')
>>> "\x61", chr(97) # 1 + 6 * 16 = 97
('a', 'a')
</screen>
</para>
<para>
Det lettest sagte er at funktion chr er gammeldags, vil fra Python 2.4
være helt out, så det er ene og alene unichr funktionen, der bør
bruges. Men går vi i dybden, så er det ikke helt så let. Forklaringen
er, at chr funktionen i dens oprindelige udformning ene og alene var
beregnet til karakterer (tal, bogstaver m.m.), hvis numeriske værdi var
under 129. Til og med Python 2.2 returneredes der en fejlmelding, hvis
karakterens numeriske værdi var større end 128. Fra og med karakter
nummer 129 og tegntabellen ud skulle funktionen unichr bruges. Kort sagt
er det en større tegntabel, hvor stor ligger sådan lidt hen i det
uvisse, for Pythons vedkommende bliver den fra version 2.4 enorm stor,
da man går over til at bruge 64 bits (et ettal efterfulgt af 64 nuller)
kode. Der må have været en del overvejelser i Python samfundet, om
hvordan chr funktionen skal fungere fremover, for selv i den samme
version af sproget er der og har der været afvigelser. I den version jeg
bruger lige nu (en Python 2.3) returnerer chr og unichr funktionerne
tegnnummer 156 således:
<screen>
>>> chr(156)
'\x9c'
>>> unichr(156)
u'\x9c'
</screen>
I begge tilfælde er returneringen helt i orden. At der står et u foran
anførselstegnet i unichr returneringen fortæller, at strengen er en
unicode streng, hvad chr returneringen naturligvis ikke er. FORDI
returneringen her var i orden, kan der være god grund til at antage, at
Python har "snydt" lidt, så der i den version jeg bruger lige nu,
benyttes samme kode i chr som i unichr funktionerne, men som antydet er
det ikke altid tilfældet, hvad du vil kunne konstere ved at bruge en
Python version lavere end 2.3
</para>
<para>
<screen>
l = []  # her oprettes tom liste
for i in range(65,91):
if i / 78 == 0: print "\n"
l.append(chr(i)) # chr konverteret tal til karakter (character)
...
>>> l
['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
>>> l = []
>>> for i in range(65 + 32,91 + 32):
...     l.append(chr(i))
...
>>> l
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
>>>
</screen>
</para>
<para>
Tallet 32 er lig med afstanden mellem et "store" bogstavs numeriske
værdi og det tilsvarende "lille" bogstavs numeriske værdi.
</para>
<para>
<screen>
>>> def  uni():
...     tal = input("Skriv et helt tal mellem -1 og 256: ")
...     print tal, unichr(tal)
...
>>> uni()
Skriv et helt tal mellem -1 og 256: 255
255 ÿ
</screen>
</para>
</sect2>
</sect1>

<sect1 id="python-kompleks">
<title>Komplekse tal</title>
<para>
I Python er der naturligvis også støtte for komplekse tal (komplekse tal
er sammensat af reelle tal (normale tal) og irrationale tal som f.eks.
kvadrat- og kubikrod, Pii og uendelige uperiodiske decimalbrøker). De
immaginære tal skrives med et efterstillet j eller J.
</para>
<para>
Komplekse tal med et reelt tal, de ikke er nul, skrives som (reelle tal
+ immaginære tal med efterstillet j) eller kan dannes ved anvendelse af
complex(reelt tal, immaginært tal) funktionen.
</para>
<para>
<screen>
>>> 5 * 4j
20j
>>> 5.0 * 5j
25j
>>> 1j * 1J
(-1+0j)
>>> 1j * complex(0,1)
(-1+0j)
>>> 3+1j*3
(3+3j)
>>> (3+1j)*3
(9+3j)
>>> (1+2j)/(1+1j)
(1.5+0.5j)
</screen>
</para>
<para>
Komplekse tal repræsenteres ved en reel og en immaginær del. De to dele
kan adskilles ved brug af kompleksTal.real og kompleksTal.imag:
<screen>
>>> a=1.5+0.5j
>>> a.real
1.5
>>> a.imag
0.5
</screen>
</para>
<para>
Konverterings funktionerne for flydende tal og heltal (float(), int()
and long()) fungerer ikke på komplekse tal. Her skal du anvende
abs(immaginære del af tal) og komplekseTal.real:
<screen>
>>> a.real
3.0
>>> a.imag
4.0
>>> abs(a)  # sqrt(a.real**2 + a.imag**2)
5.0
>>>
</screen>
</para>
</sect1>

<sect1 id="python-klasser">
<title>Klasser</title>

<para>
Objekter osm flyvemaskiner, rugbrød og knapper i et Python GUI program
har egenskaber som eksempelvis, der kan være fælles. Eksempler på
egenskaber er farve og størrelse. Jo flere egenskaber, de har fælles,
jo nærmere er de beslægtede. De kan have så mange fælles egenskaber, at
det bliver naturligt at samle dem i fælles grupper eller klasser. I OOP
(objektorienteret programmering - se først i bogen) går ud på at udnytte
(genbruge) fælles egenskaber.
</para>
<para>
Klasser repræsenterer grupper af objekter med fælles egenskaber. At
egenskaberne er fælles kan i høj grad bruges til noget, når det gælder
Python og andre objektorienterede computersprog. Programmøren skal ikke
genopfinde de fælles egenskaber, men kan lade sine klasser arve de
egenskaber andre klasser allerede er i besiddelse af. Han eller hun
fortæller Python, at der skal oprettes en klasse ved at indsætte
nøgleordet class først på en programlinje eks:
</para>
<para>
<screen>
class Klasse:
	pass
</screen>
</para>
<para>
Det viste eksempel arver ikke direkte nogen som helst egenskaber, men
der skal selvfølgelig en masse kode til for at danne de nødvendige
forbindelser (interface mellem eksemplet og fortolkeren). Det kan
følgende antyde:
</para>
<para>
<screen>
>>> dir(Klasse)
['__doc__', '__module__']
>>>

Her ser du endnu et eksempel, på hvor beskeden en fuldgyldig Python klasse kan være:

>>> class Klasse:
	""" Dette er en fuldgyldig Python klasse."""


>>> class Klasse:
	pass

</screen>
</para>
<para>
Defineringen skal indledes med class, der skal efterfølges af et
lovligt navn og et kolon, hvor sidstnævnte er indledningen til
klassens krop. Denne indledning er samtidig indledningen af en blok. I
denne blok skal der være mindst en fejlfri programlinje. De er der i
begge de viste eksempler, hvorfor de er helt OK. Det vil jeg godt se et
bevis på lige nu og her:
</para>
<para>
<screen>
Det kan vi få en kontrol på lige her og nu:

>>> class Klasse:
	""" Dette er en fuldgyldig Python klasse."""

>>> Klasse
&lt;class __main__.Klasse at 0x8291e24>
>>>


>>> class Klasse:
	pass

>>> Klasse
&lt;class __main__.Klasse at 0x827038c>
>>>
</screen>
</para>
<para>
Klasse opfylder alle betingelser for at være en fuldgyldig Python
klasse. Den begynder med nøgleordet class, har et navn, der er fuldt
lovligt og dermed brugbart, og den omfatter en krop, der begynder med
kolon og den i Python obligatoriske indrykning. Nøgleordet pass gør
ingen ting, og det er netop formålet med pass.
</para>
<para>
Som vist kan det konstateres, at Klasse virkelig er en fuld færdig og
lovlig Python klasse ved fra interaktiv mode at skrive klassenavnet
(Klasse) og trykke på Enter-tasten.
</para>
<para>
<screen>
x = Klasse()

Test:
>>> x
&lt;__main__.Klasse instance at 0x826ca94>
>>>
</screen>
</para>
<para>
I Python er der en række muligheder for at få uddybende informationer om
en klasse. Dem vil vi se på her i indledningen til afsnittet om klasser:
</para>
<para>
<screen>
>>> dir
&lt;built-in function dir>

Den fordefinerede eller i Python indbyggede (built-in) funktion dir kan med
sin parameterliste fortælle, om Klasse nu også er en klasse.

>>> dir()
['Klasse', 'PyShell', '__builtins__', '__doc__', '__name__']
>>>
</screen>
</para>
<para>
Der oprettes en liste, hvis første element er klassenavnet selv. Ved
konstruktionen af Klasse er PyShell anvendt, hvad PyShell er, kan vi
også få oplyst:
</para>
<para>
<screen>
>>> PyShell
&lt;module 'PyShell' from '/usr/lib/python2.2/site-packages/idle/PyShell.py'>
>>>
</screen>
</para>
<para>
Det kan vel næppe komme som en overraskelse, at der er anvendt et modul
til konstruktionen af vores Klasse, men prøv lige selv at lave følgende
test, og du vil overraskes over, hvor mange stumper, der er anvendt til
konstruktionen:
</para>
<para>
<screen>
>>> import PyShell
>>> dir(PyShell)
['ACTIVE', 'ALL', 'ANCHOR', 'ARC', 'At', 'AtEnd', 'AtInsert', ...

Nederst i den lange udskrift, hvorfra jeg kun har medtaget starten, genfinder du

'__builtins__', '__doc__' og '__name__',

</screen>
</para>
<para>
Helt tilsvarende kan man få oplysning, om hvilke programstumper (OOP
dele), der indgår i Klasse:
</para>
<para>
<screen>
>>> dir(Klasse)
['__doc__', '__module__']
>>>
</screen>
</para>
<para>
Dem vil vi se nærmere på i forbindelse med Klasse, men Klasse er
defineret tom, så vi behøver en udvidelse af erklæringen:
<screen>
>>> class Klasse:
	def _init_(self):
		pass
</screen>
</para>
<para>
"def _init_(Klasse)" er på sin vis 3 ting: 1: definering af funktionen
_init_ og 2: initialisering (grundlæggende værditildeling til Klasse)
og 3: Klasses konstruktør. Argumentet self fortæller, at Klassen bruger
sine egne egenskaber, hvad det vil sige, skal vi snart se, men lad os
først lave endnu en kontrol:
</para>
<para>
</para>
<para>
>>> dir(Klasse)
['__doc__', '__module__', '_init_']
</para>
<para>
Vi ser, at _init_ er indsat som element i listen.
</para>
<para>
</para>
<para>
>>> Klasse._init_
&lt;unbound method Klasse._init_>
</para>
<para>
</para>
<para>
Vi har endnu ikke importeret et modul. Det vil vi gøre:
</para>
<para>
</para>
<para>
>>> import math
>>> class Klasse(math):
	print math.pi
</para>
<para>
</para>
<para>
3.14159265359
>>>
</para>
<para>
Test:
>>> import math
>>> math
&lt;module 'math' from '/usr/lib/python2.2/lib-dynload/math.so'>
>>>
</para>
<para>
Når Python fortolkeren indleder eksekveringen af et program, er værdien
af _name_ lig med _main_ (læg godt mærke til det, for programlinjen
indgår i en lang række af bogens eksempler, hvor det er svært at
kommentere og samtidig bevare læsbarheden, og den derfor udelades
programlinjen er if _name_ == "_main_": eks. if __name__ == '__main__':
Dialog().mainloop() det skal læses som: Hvis det er klassen Dialog, der
startes op, så skal løkken mainloop startes op - den kontrollerer, om
der indtræder nye hændelser (events) fra program og/eller bruger.)
</para>
<para>
Namespace og scope er to navne for det samme - at angive et navns
virkningsområde eller sagt på en anden måde det område, hvori navnet
kan bruges. Det kan følgende eksempel belyse:
</para>
<para>
<screen>
>>> x = 256
>>> class Klasse:
	print x
	
256
>>>
</screen>
</para>
<para>
Klasse har ene og alene mulighed for at kende navnet x og dermed for at
kunne returnere variablens værdi, fordi v er defineret som global
variabel (globalt navn). Det fører videre til:
</para>
<para>
<screen>
x = 1 # global variabel
</screen>
</para>
<para>
# ændrer den lokale variabel x (shadows (skygger for) den globale variabel
def a():
	x = 25
</para>
<para>
	print "\nVærdien i den lokale x er", x, "efter defineringen og kaldet af a"
	x += 1
	print "Den lokale x (den i a) er",x, #før a forlades"
</para>
<para>
# ænder den globale variabel x
def b():
	global x
	print "\nDen globale x er nu",x,"Ved kald fra b"
	x *= 10
	print "Globale x er",x,"når b er forladt"
</para>
<para>
print "Globale x er",x
x = 7
print "Globale x er", x
</para>
<para>
a()
b()
a()
b()
</para>
<para>
print "\nGlobale x er" ,x
</para>
<para>
</para>
<para>
Kørselsresultat:
</para>
<para>
</para>
<para>
Globale x er 1
</para>
<para>
Globale x er 7
</para>
<para>
Værdien i den lokale x er 25 efter defineringen og kaldet af a
</para>
<para>
Den lokale x (den i a) er 26
Den globale x er nu 7 Ved kald fra b
</para>
<para>
Globale x er 70 når b er forladt
</para>
<para>
Værdien i den lokale x er 25 efter defineringen og kaldet af a
</para>
<para>
Den lokale x (den i a) er 26
Den globale x er nu 70 Ved kald fra b
</para>
<para>
Globale x er 700 når b er forladt
</para>
<para>
Globale x er 700
</para>
<para>
</para>
<para>
<screen>
>>> class Klasse:
...     i = 123
...     def f(self):
...             return "Python klasser er i en klasse for sig."
...
</screen>
</para>
<para>
Klasse.i og Klasse.f er begge lovlige attribut referencer, der
henholdsvis returnerer et heltal og brugt på rette måde resultatet af
en metodeafvikling. Læg mærke til, at for at få nævnte resultat
returneret, så skal både klasse og metode have parameterliste.
</para>
<para>
<screen>
>>> Klasse.i
123
>>> print Klasse().f()
Python klasser er i en klasse for sig.
</screen>
Har du gemt nogle af dine definitioner i py filer, har du for så vidt
allerede lavet Python moduler, der principielt fuldstændig svarer til de
fordefinerede moduler i Python. Men skriv de to følgende funktioner i en
editor og gem dem med navnet fibonacci.py
<screen>
def fib(n):
	a, b = 0, 1
	while b < n:
		print b,
		a, b = b, a + b
def fib2(n):
	resultat = []
	a, b = 0, 1
	while b < n:
		resultat.append(b)
		a,b = b, a + b
	return resultat
</screen>
</para>
<para>
fibonacci.py er et ganske normalt python modul og skal derfor også
importeres på den helt normale måde. Start Python op i interaktiv mode
og skriv følgende kode:
</para>
<para>
>>> import fibonacci
>>> fibonacci.fib(100)
>>> fibonacci.fib2(100)
</para>
<para>
Gør du det vil programafviklingen se således ud:
>>> import fibonacci
>>> fibonacci.fib(100)
1 1 2 3 5 8 13 21 34 55 89
>>> fibonacci.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>>
</para>
<para>
Hvis du har til hensigt at bruge en funktion ofte, kan du tildele den et lokalt navn:
>>> import fibonacci
>>> f = fibonacci.fib
</para>
<para>
Et kørselsresultat:
>>> f(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
>>>
</para>
<para>
<screen>
Naturligvis kan du også bruge  type og dir  funktionerne på fibonacci.py:
>>> type(fibonacci)
&lt;type 'module'&gt;
fibonacci.py er altså et modul, hvad vi  vel nok kunne ane.
>>> dir(fibonacci)
['__builtins__', '__doc__', '__file__', '__name__', 'fib', 'fib2']
Her returneres liste indeholdende alle navne, variabler, moduler,
funktioner m.v., der er defineret i øjeblikket.
>>> dir()
['__builtins__', '__doc__', '__name__', 'fibonacci']
>>>
</screen>
</para>
<para>
Uden argumenter returnerer \dir() de navne, du har defineret i
øjeblikket. Det drejer sig alene om fibonacci modulet. dir() lister ikke
den indbyggede (fordefinerede) funktioners og variablers navne, hvis du
ønsker at se dem, så kan det ske ved at udskrive en liste af
standardmodulet  \__bultin__ 's indhold:
</para>
<para>
<screen>
>>> dir(__builtin__)
['ArithmeticError', 'AssertionError', 'AttributeError', 'DeprecationWarning', ....
>>> import sys
>>> sys.path = ".:/usr/local/lib/python"
</screen>
</para>
<para>
Kørselsresultat:
>>> sys.path
['', '/usr/local/lib/python23.zip', '/usr/local/lib/python2.3', '/usr/local/lib/
python2.3/plat-linux2','/usr/local/lib/python2.3/lib-tk', '/usr/local/lib/
python2.3/lib-dynload', '/usr/local/lib/python2.3/site-packages']
>>>
</para>
<para>
>>> PYTHONPATH = sys.path   # PYTHONPATH skal defineres for at kunne bruges
</para>
<para>
<screen>
Et kørselsresultat:
>>> PYTHONPATH
['', '/usr/local/lib/python23.zip', '/usr/local/lib/python2.3', '/usr/local/lib/
python2.3/plat-linux2', '/usr/local/lib/python2.3/lib-tk', '/usr/local/lib/
python2.3/lib-dynload', '/usr/local/lib/python2.3/site-packages']
>>>
</screen>
</para>
<para>
Som du ser, returnerer PYTHONPATH en liste. I den er de aktuelle stier,
de stier hvori fortolkeren vil søge for at finde moduler m.v. Det kan du
udnytte ved at tilføje det eller de biblioteker, hvori du gemmer dine
selvkomponerede klasser, som element eller elementer. I det store og
hele er det underordnet, hvor du placerer dine moduler. Jeg oprettede
biblioteket mineModuler i mit brugerområdes rod. Nu kan jeg flytte mine
moduler dertil og indsætte biblioteket som element i listen:
</para>
<para>
<screen>
PYTHONPATH.append("/home/ajbo/mineModuler")
</screen>
</para>
<para>
Kørselsresultat:
>>> PYTHONPATH
['', '/usr/local/lib/python23.zip', '/usr/local/lib/python2.3',
'/usr/local/lib/python2.3/plat-linux2',
'/usr/local/lib/python2.3/lib-tk', '/usr/local/lib/python2.3/lib-dynload',
'/usr/local/lib/python2.3/site-packages', '/home/ajbo/mineModuler']
>>>
</para>
<para>
<screen>
Det er også muligt at adskille sys.path og PYTHONPATH,
så de hver især kan bruges efter behov:
>>> PYTHONPATH = "/home/ajbo/mineModuler"
>>> PYTHONPATH
'/home/ajbo/mineModuler'
>>> sys.path
['', '/usr/local/lib/python23.zip', '/usr/local/lib/python2.3',
'/usr/local/lib/python2.3/plat-linux2',
'/usr/local/lib/python2.3/lib-tk', '/usr/local/lib/python2.3/lib-dynload',
'/usr/local/lib/python2.3/site-packages']
>>>
</screen>
</para>
<para>
</para>
<para>
Del sætningen kan bruges på 2 forskellige måder. Der er en måde, hvorpå
et element kan fjernes fra en liste ud fra elementets indeks-nummer i
stedet for selve elementet. Den kan bruges til at fjerne slices fra en
liste. Og som eks. 2 viser kan del også fjerne selve listen.
<screen>
Eksempel 1:
>>> liste = [-1, 1, 66.6, 333, 333, 1234.5]
>>> del liste[0]
>>> liste
[1, 66.6, 333, 333, 1234.5]
</screen>
</para>
<para>
Eksempel 2:
>>> del liste[2:4]
>>> liste
[1, 66.6, 1234.5]
</para>
<para>
<screen>
Eksempel 3:
>>> del liste
</screen>
</para>
</sect1>

<sect1 id="python-sort">
<title>Sortering</title>

<sect2 id="python-sort-1">
<title>Sortering af basale typer</title>
<para>
I mange computersprog bruges nogenlunde følgende rutine, når værdierne
i to variabler skal bytte plads f.eks. i en sorteringsrutine:
<screen>
>>> a = 50; b = 25
>>> temp = a
>>> a = b
>>> b = temp
>>> print a,b
25 50
>>>

I Python er samme proces kortere og mere logisk:
>>> a = 50; b = 25
>>> a, b = b, a
>>> print a,b
25 50
>>>

Sortering af elementerne i en liste foretages let med sort() funktionen:

>>> l = [2,34,5,4,78,6,12]
>>> l.sort()
>>> print l
[2, 4, 5, 6, 12, 34, 78]
>>>
</screen>
</para>
<para>
Ud fra det, jeg har været inde på et eller flere andre steder i bogen,
kan du passende forsøge at forklare, hvorfor også den følgende sortering
er korrekt, for det er den.
</para>
<para>
<screen>
>>> l = ["A","d","B","g","s","a","w","I","k","a","p","P"]
>>> l.sort()
>>> print l
['A', 'B', 'I', 'P', 'a', 'a', 'd', 'g', 'k', 'p', 's', 'w']
>>>
</screen>
</para>
<para>
Sort funktionen kan anvendes uden parameter eller med en funktion som
parameter. Anvendelsen uden parameter, som vist ovenfor, svarer helt til
sort(cmp), hvor cmp() er en fordefineret funktion der sammenligner to
værdier, x og y, og returnerer -1,0 og 1 afhængig af om\ x < y, x == y
eller \ x > y.
</para>
<para>
<screen>
>>> l = [2,34,5,4,78,6,12]
>>> l.sort()
>>> print l
[2, 4, 5, 6, 12, 34, 78]

Eller:
>>> l.sort(cmp)
>>> print l
[2, 4, 5, 6, 12, 34, 78]
>>>

Hvis du ønsker det, kan du let lave din egen sammenligningsfunktion:

>>> def Sam(a,b):
...     return a - b
...
>>> l = [2,34,5,4,78,6,1]
>>> l.sort(Sam)
>>> print l
[1, 2, 4, 5, 6, 34, 78]
>>>
</screen>
</para>
<para>
Lambda kan være svær at forstå virkningen af. Som jeg er inde på
andetsteds, så opererer lambda i baggrunden. Lad os se på Sam() ovenfor
igen. Sam er en funktion med sit eget navn. Sam() trækker b fra a. Ved
brug af lambda kan denne operation flyttes op i sort's parameterliste:
<screen>
>>> l = [2,34,5,4,78,6,1]
>>> l.sort(lambda a, b : a- b)
>>> print l
[1, 2, 4, 5, 6, 34, 78]
>>>
</screen>
</para>
<para>
Nu kunne jeg imidlertid godt tænke mig at anvende samme lambda på en
sortering i faldende orden. Det eneste, jeg da skal gøre er at bytte om,
så
<screen>
>>> l = [2,34,5,4,78,6,1]
>>> l.sort(lambda a, b : b - a)
>>> print l
[78, 34, 6, 5, 4, 2, 1]
>>>

Tilsvarende kunne Sam() ganske let ændres til at fortage sortering med
faldende orden:
>>> def Sam(a,b):
...     return b - a
...
>>> l = [2,34,5,4,78,6,1]
>>> l.sort(Sam)
>>> print l
[78, 34, 6, 5, 4, 2, 1]
>>>
</screen>
</para>
<para>
I sorteringrutiner er hastighed ofte et vigtigt parameter, så i
sorteringer i stigende orden er det bedst at bruge sort uden parametre.
Ønsker du sortering i faldende orden bliver ekspeditionstiden kortest
ved at udføre operationen i to omgange. Først foretages en sortering i
stigende orden med sort() og derefter anvendes funktionen reverse():
<screen>
>>> l = [2,34,5,4,78,6,1]
>>> l.sort()
>>> l.reverse()
>>> print l
[78, 34, 6, 5, 4, 2, 1]
>>>
</screen>
Med strengfunktionen split(), er det enkelt at konvertere en tekststreng
til en liste. Når det er gjort, kan strengen sorteres helt tilsvarende
den numeriske sortering, vi har set på ovenfor:
<screen>
>>> import string
>>> streng = "Lad os dele opgaven op i enkeltelementer."
>>> s = streng.split()
>>> s
['Lad', 'os', 'dele', 'opgaven', 'op', 'i', 'enkeltelementer.']
>>> s.sort()
>>> s
['Lad', 'dele', 'enkeltelementer.', 'i', 'op', 'opgaven', 'os']
>>> s.reverse()
>>> s
['os', 'opgaven', 'op', 'i', 'enkeltelementer.', 'dele', 'Lad']
>>>

Her de samme rutiner med brug af Lambda funktionen:
>>> import string
>>> l = "Lad os dele opgaven op i enkeltelementer.".split()
>>> l.sort(lambda a,b:cmp(a,b))
>>> print l
['Lad', 'dele', 'enkeltelementer.', 'i', 'op', 'opgaven', 'os']
>>>

>>> import string
>>> l = "Lad os dele opgaven op i enkeltelementer.".split()
>>> l.sort(lambda a,b: - cmp(a,b))
>>>
>>> print l
['os', 'opgaven', 'op', 'i', 'enkeltelementer.', 'dele', 'Lad']
>>>

Her er en kasusafhængig strengsortering med stigende orden,
der anvender Lambda funktionen:
>>> import string
>>> l = "Lad os dele opgaven op i enkeltelementer.".split()
>>> l.sort(lambda a,b: cmp(string.lower(a), string.lower(b)))
>>> print l
['dele', 'enkeltelementer.', 'i', 'Lad', 'op', 'opgaven', 'os']

Og her den samme sortering i faldende orden:
>>> l.sort(lambda a,b: cmp(string.lower(b), string.lower(a)))
>>> print l
['os', 'opgaven', 'op', 'Lad', 'i', 'enkeltelementer.', 'dele']
>>>

Sorter strengen, indsæt elementerne i en tuple og sæt den
ind i en liste for senerer sortering:

>>> import string
>>> l = "Lad os dele opgaven op i enkeltelementer.".split()
>>> listen = []
>>> for i in range(len(l)):
...     listen.append((string.lower(l[i]),i))
...
>>> listen.sort()
>>> print listen
[('dele', 2), ('enkeltelementer.', 6), ('i', 5), ('lad', 0), ('op', 4),
('opgaven', 3), ('os', 1)]
>>>

Nu kan listen renses for tuplens indvirkning ved
(vi har ingen brug for indeksværdierne (tallene)) :

>>> nyListe = []
>>> for springOver, i in listen:
...     nyListe.append(l[i])
...
>>> print nyListe
['dele', 'enkeltelementer.', 'i', 'Lad', 'op', 'opgaven', 'os']
>>>

En anden vej til målet er at lagre de oprindelige data (elementer) som
listens andet led:

>>> import string
>>> l = string.split("Lad os dele opgaven op i enkeltelementer.")
>>> listen = []
>>> for element in l:
...     listen.append((string.lower(element), element))
...
>>>
>>> print listen
[('lad', 'Lad'), ('os', 'os'), ('dele', 'dele'), ('opgaven', 'opgaven'), ('op', 'op'),
 ('i', 'i'), ('enkeltelementer.', 'enkeltelementer.')]
</screen>
</para>
</sect2>
</sect1>

<sect1 id="python-exceptions">
<title>Exceptions (undtagelser)</title>
<para>
<screen>
eks. 1
>>> x
Traceback (most recent call last):
  File "&lt;pyshell\# 0&gt;", line 1, in ?
    x
NameError: name 'x' is not defined
</screen>
</para>

<para>
Ved at fortolke koden bagfra finder Python en fejl i linje 1. Det viser
sig at være en navnefejl - variablen x er ikke defineret.
</para>

<para>
Der findes ofte rester af forskellig slags i arbejdslageret, er den
krævede definering en meget stor fordel, for den betyder, at en
nyerklæret variabel samtidig tildeles en værdi.En variabel i Python
altid pege på den værdi, som du eller en anden programmør har sat den
til ved seneste anvendelse. Den kan ganske enkelt ikke pege på en af de
nævnte datarester.
</para>

<para>
eks. 2
Vi kunne undgå fejlmeldingen ovenfor ved at tildele variablen en værdi.
Så er alt for så vidt i orden, i hvert fald i det aktuelle tilfælde:
</para>

<para>
<screen>
>>> # Her er variablen defineret
>>> x = 1
>>> try: print x
except Navnefejl: x = 0
1
</screen>
</para>

<para>
Fordi variablen er erklæret og tildelt værdi, så kan try løkken
gennemføres tilfredsstillende, så afviklingen når aldrig frem til
except løkken.
</para>

<para>
<screen>
>>> # Tilsvarende uden defineret variabel
>>> try: print y
except Navnefejl: y = 0
Traceback (most recent call last):
  File "&lt;pyshell\#51&gt;", line 3, in -toplevel-
    except Navnefejl: y = 0
NameError: name 'Navnefejl' is not defined
</screen>
</para>

<para>
Fordi variablen ikke er erklæret og tildelt værdi, så kan try løkken ikke
gennemføres tilfredsstillende, så afviklingen når frem til except løkken.
Her gives fejlmelding, da Navnefejl er ukendt, det samme gælder y, men
afviklingen afbrydes inden y behandles.
</para>
</sect1>

<sect1 id="python-unicode">
<title>Unicode</title>
<para>
Python 2.0 kunne anvende grundtypen Unicode strenge. Unicode bruger
16-bit tal til at repræsentere karakterer i stedet for de 8-bits tal,
der bruges af ASCII. Det betyder, at der i stedet for 256 tegn i en
tegntabel nu er plads til 65.536 forskellige tegn.
</para>

<para>
I Python kildekode, det du skriver, når du programmerer i Python,
skrives Unicode strenge som u"tekststreng". Unicode karakterer ved
hjælp af escape sekvensen  \\uHHHH, hvor HHHH er et 4-cifret
hexadecimalt tal fra 0000 til FFFF. Den
eksisterende \\xHHHH escape sekvens kan også anvendes. Det samme gælder
oktale escape sekvenser for karakterer op til U+01FF, der repræsenteres
af  \\777. Jeg har ikke fundet det nødvendigt at tage eksempler med her,
men skal gøre opmærksom på at Python 2.4 også skulle kunne håndtere 32
og 64 bits unicoder.
</para>

<para>
En konvertering til Unicode streng returnerer en 8-bit streng i det
ønskede kodeformat, der eksempelvis kan være   'ascii', 'utf-8' eller
den vi vel nok oftest benytter i Danmark  'iso-8859-1'.
</para>

<para>
Sammenføjning af  8-bit og Unicode strenge vil altid returnere en
Unicode streng.
</para>

<para>
eks:
>>> 'a' + u'bc'
u'abc'
</para>

<para>
2 metoder til målet:
</para>

<para>
>>> "Nexø"
'Nex\xf8'
>>> print "Nexø"
Nexø
</para>
<para>
2 andre metoder til 2 ANDRE mål:
>>> print "Rønne"
Rønne
</para>
<para>
>>> print str("Rønne")
Rønne
</para>
<para>
Sådan skulle ord funktionen anvendes i Python med lavere versionsnummer end 2.3:
</para>
<para>
>>> ord(u'\xc6')
198
</para>
<para>
Fordi:
>>> ord("Æ")
</para>
<para>
UnicodeError: ASCII encoding error: ordinal not in range(128)
</para>
<para>
Og sådan nu (med Python version 2.3):
>>> ord("Æ")
198
</para>
<para>
Talværdien 198 er bogstavets korrekte nummer i Unicode tabellen.
</para>
<para>
>>> u"Computersproget\u0020Python\u0020er\u0020fra\u00201991"
u'Computersproget Python er fra 1991'
>>>
</para>
<para>
Konverter unicode streng til gammeldags 8-bit streng
>>> u"æøåÆØÅ".encode('utf-8')
'\xc3\xa6\xc3\xb8\xc3\xa5\xc3\x86\xc3\x98\xc3\x85'
>>>
</para>
</sect1>

<sect1 id="python-try-except">
<title>Prøv ... Ellers</title>
<para>
BEMÆRK Pythons indrykninger SKAL bevares, ellers KAN eksemplet ikke afvikles:
</para>
<para>
<screen>
>>> while 1:
	try:
		indkomst = int(raw_input("Skriv et helt tal: "))
		break
	except ValueError:
		print "Tallet var ikke et heltal (an integer). Prøv igen..."
</screen>
</para>
<para>
</para>
<para>
Skriv et helt tal: 23.6
Tallet var ikke et heltal (an integer). Prøv igen...
Skriv et helt tal: 24
>>>
</para>
<para>
Af hensyn til overskueligheden og til den absolut nødvendige bevarelse
af indrykningerne,  kommenterer jeg først eksemplet her:
while 1: læses som lige så længe påstanden er sand, så skal blokken
indkomst = int(raw_input("Skriv et helt tal: ")) og
break udføres.
<screen>
raw_input("Skriv et helt tal: ")
</screen>
modtager en værdi, der lagres et eller
andet sted i computerens arbejdslager, men inden det sker, konverteres
den til et heltal (an integer) v.h.a. funktionen int().Kan det ske,
sættes en variabel med navnet indkomst til at pege på stedet i lageret,
hvor det hele tal findes i form af et antal "ledninger" med og uden strøm 
på (svarende helt til 1-taller  og 0-er) i vores binære talsystem. Såfremt
og kun såfremt den indtastede værdi kan tildeles indkomst, så fortsættes
til næste programlinje break - afbryd while løkken. Er den indtastede
værdi et heltal, kommer blokken except ValueError: aldrig i brug, så det
næste Python skal gøre er at melde klar til mere aktiv kommunikation med
brugeren, hvilket som bekendt meldes med  \>>>
</para>
<para>
Men en gang mere PAS PÅ INDRYKNINGERNE. De SKAL ubetinget være korrekte,
ellers kan Python fortolkeren jo ikke afgøre, hvor en blok begynder og
slutter.
</para>
</sect1>

<sect1 id="python-dictionary">
<title>Ordbog (dictionary)</title>
<para>
Lad os starte gennemgangen af ordbøger (dictionaries)
et helt andet sted, ved et tilbageblik til lister og tuples.
</para>
<para>
<screen>
Liste:
>>> ordliste = ['Arnager', 1, 'Hasle', 2, 'Vang', 3]
>>> ordliste
('Arnager', 1, 'Hasle', 2, 'Vang', 3)
>>> ordliste[0]
'Arnager'
</screen>
</para>
<para>
tuple:
>>> ordliste = 'Arnager', 1, 'Hasle', 2, 'Vang', 3
>>> ordliste
('Arnager', 1, 'Hasle', 2, 'Vang', 3)
>>> ordliste[0]
'Arnager'
</para>
<para>
<screen>
Ordbogen:
>>> ordliste = {'Arnager': 1, 'Hasle': 2, 'Vang' : 3}
>>> ordliste
{'Arnager': 1, 'Hasle': 2, 'Vang': 3}
ordliste[0]
KeyError: 0
</screen>
</para>
<para>
Sammenlign nu de ovenstående bevidst ukommenterede eksempler,
så er vi ligesom klar til at gå videre til det egentlige.
En ordbog/ordliste adskiller sig fra listen på den måde at
listen er omgivet af firkaltede parenteser, mens ordbogen er omgivet
af krøllede parenteser. tuples kan, men ikke nødvendigvis, være omgivet
af almindelige runde parenteser. Mens liste og tuple kan returnere
element v.h.a. navn og firkantede parenteser indeholdende elementnummer,
kræver returnering fra en ordbog en lidt mere kompliceret operation. Den vil
vi tage lidt i etaper:
</para>
<para>
<screen>
>>> if "Hasle" in ordliste:
  print ordliste['Hasle']
else:
  print 'ikke fundet'
2
</screen>
</para>
<para>
Hvis vi nu i stedet for at tænke på den direkte oversættelse af ordet dictionary (ordbog)
og i stedet for tænker på den som en ordliste - en indholdsfortegnelse i en bog, så kan det returberede
2-tal ovenfor fint henvise til den side i bogen, hvor Hasle er omtalt og sådan fremdeles.
</para>
<para>
Hvis vi i stedet for at tænke på the dictionary som indholdslisten tænker på den som en lænke (a link)
på en hjemmeside, så vil det ofte være således, at en hotlink i form af en virtuel knap med en eller anden påskrift
ved et klik med musen fører til ankerpladsen - en beskrivelse eller omtale af påskriften, så kunne en ordliste komme
til at se ud som denne:
</para>
<para>
<screen>
ordliste = {"Arnager": "Lille fiskerby syd for Bornholms flyveplads." ,
"Hasle": "Lille vestbornholmsk by.", 'Vang' : 'Lille by, havde tidligere 
en del stenindustri.' }
>>> if "Vang" in ordliste:
  print ordliste['Vang']
else:
  print 'ikke fundet'
Lille by, der tidligere havde en del stenindustri.
</screen>
</para>
<para>
Nu er vi vist allerede kommet dertil, hvor Pythons ordbøger kan bruges til noget konstruktivt. Men der er meget mere endnu,
vi skal se på i den forbindelse.
</para>
<para>
<screen>
>>> indeks = {}
>>> def indskriv(indgangsord, sidenummer):
        if indeks.has_key(indgangsord):
            indeks[indgangsord].append(sidenummer)
        else:
            indeks[indgangsord] = [sidenummer]
>>> indskriv("Gudhjem",0)
>>> indeks
{'Gudhjem': [0]}
indeks = {}
def nyIndgang(noegle, sidenummer):
    if indeks.has_key(noegle):
        indeks[noegle].append(sidenummer)
    else:
        indeks[noegle] = [sidenummer]
>>> nyIndgang("Arnager",0)
>>> nyIndgang("Bodilsker",1)
>>> nyIndgang("Pedersker",2)
>>>
>>> indeks
{'Arnager': [0], 'Bodilsker': [1], 'Pedersker': [2]}
# Pas på med sidenumrene ellers:
>>> nyIndgang("Arnager",0)
>>> nyIndgang("Bolsker",0)
>>> indeks
{'Arnager': [0], 'Bolsker': [0]}
</screen>
</para>
<para>
Mange har anskaffet et eller flere af de efterhånden prisbillige digitale kameraer. De lagrer oftest billederne i jpg eller tif format. Førstnævnte er det mest velegnede til hjemmesider m.v. Samme filtype kan desværre ikke uden videre anvendes af Python - der skal
et ekstra modul til. Derfor kan det være en fordel at konvertere billeder til gif formater, der har en række fordele frem for jpg formatet, med generelt fylder en smule mere. Tif formatet fylder temmelig mere end de to andre formater. Det skyldes primært at tif kan gemme
flere farver - farver der ofte er usynlige for det menneskelige øje. Her vil jeg ene og alene vise, hvordan gif og jpg formaterne hentes inde i Python programmer.
</para>
<para>
<screen>
from Tkinter import *
root = Tk()
foto = PhotoImage(file = "AKTIV/h.gif")
Button(root, image = foto).pack()
root.mainloop()
</screen>
</para>
<para>
eller f.eks.
</para>
<para>
<screen>
from Tkinter import *
root = Tk()
fotobibliotek = "AKTIV"
foto = PhotoImage(file = "fotobibliotek + "h.gif")
Button(root, image = foto).pack()
root.mainloop()
</screen>
</para>
<para>
Det følgende eksempel  kræver PIL installeret - PIL håndterer over
30 formater PIL kan hentes fra www.pythonware.com til såvel Windows
som Linux. Pas på at få den rette (nyeste) version af det gratis eller
evt. det kommercielle modul.
</para>
<para>
<screen>
from Tkinter import *
import ImageTk, Image
root = Tk()
fotobibliotek = "AKTIV"
foto = ImageTk.PhotoImage(file = fotobibliotek + "h.jpg")
Button(image = foto).pack()
root.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{16.5cm}
\includegraphics{skyer.jpg}
\end{minipage}
</figure>
</para -->
<para>
<screen>
from Tkinter import *
from glob import glob
from tkMessageBox import askyesno
from tkFileDialog import askopenfilename
import random
def opretArvinger(root):
    global arbejdsplads, tilslutAfbryd
    arbejdsplads = Canvas(root, bg='white')
    arbejdsplads.pack(side=LEFT, expand=YES, fill=BOTH)
    tilslutAfbryd = Button(root, text='Start', command=onStart)
    tilslutAfbryd.pack(fill=BOTH)
    Button(root, text='Åbn',  command=onOpen).pack(fill=BOTH)
    Button(root, text='Klokke',  command=onBeep).pack(fill=BOTH)
    Button(root, text='Afbryd',  command=onQuit).pack(fill=BOTH)
def onStart():
    global rundgang
    rundgang = 1
    tilslutAfbryd.config(text='Stop', command=onStop)
    onTimer()
def onStop():
    global rundgang
    rundgang = 0
    tilslutAfbryd.config(text='Start', command=onStart)
def onOpen():
    global foto
    onStop()
    pick = askopenfilename(initialdir=bibliotek)
    if pick:
        foto = PhotoImage(file=pick)
        arbejdsplads.config(height=foto.height(), width=foto.width())
        arbejdsplads.create_image(2, 2, image=foto, anchor=NW)
def onQuit():
    if askyesno('Verify', 'Vil du slutte?'):
        root.quit()
def onBeep():
    global hyl
    hyl = hyl ^ 1
def onTimer():
    global foto
    if rundgang:
        pick = random.choice(fotos)
        foto = PhotoImage(file=pick)
        arbejdsplads.create_image(2, 2, image=foto, anchor=NW)
        if hyl: root.bell()
        root.after(milSekunder, onTimer)
import sys
if len(sys.argv) == 2:
    bibliotek = sys.argv[1]
else:
    bibliotek = '../gifs' # Forvalgt bibliotek
fotos = glob(bibliotek + '/*.gif')
root = Tk()
opretArvinger(root)
milSekunder = 2000
hyl  = 1
root.mainloop()
</screen>
</para>
<para>
<screen>
from Tkinter import *
from glob import glob
from tkMessageBox import askyesno
from tkFileDialog import askopenfilename
import random
def opretArvinger(root):
    global arbejdsplads, tilslutAfbryd
    arbejdsplads = Canvas(root, bg='white')
    arbejdsplads.pack(side=LEFT, expand=YES, fill=BOTH)
    tilslutAfbryd = Button(root, text='Start', command=onStart)
    tilslutAfbryd.pack(fill=BOTH)
    Button(root, text='Åbn',  command=onOpen).pack(fill=BOTH)
    Button(root, text='Klokke',  command=onBeep).pack(fill=BOTH)
    Button(root, text='Afbryd',  command=onQuit).pack(fill=BOTH)
def onStart():
    global rundgang
    rundgang = 1
    tilslutAfbryd.config(text='Stop', command=onStop)
    onTimer()
def onStop():
    global rundgang
    rundgang = 0
    tilslutAfbryd.config(text='Start', command=onStart)
def onOpen():
    global foto
    onStop()
    pick = askopenfilename(initialdir=bibliotek)
    if pick:
        foto = PhotoImage(file=pick)
        arbejdsplads.config(height=foto.height(), width=foto.width())
        arbejdsplads.create_image(2, 2, image=foto, anchor=NW)
def onQuit():
    if askyesno('Verify', 'Vil du slutte?'):
        root.quit()
def onBeep():
    global hyl
    hyl = hyl ^ 1
def onTimer():
    global foto
    if rundgang:
        pick = random.choice(fotos)
        foto = PhotoImage(file=pick)
        arbejdsplads.create_image(2, 2, image=foto, anchor=NW)
        if hyl: root.bell()
        root.after(milSekunder, onTimer)
import sys
if len(sys.argv) == 2:
    bibliotek = sys.argv[1]
else:
    bibliotek = '../gifs' # Forvalgt bibliotek
fotos = glob(bibliotek + '/*.gif')
root = Tk()
opretArvinger(root)
milSekunder = 2000
hyl  = 1
root.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{10cm}
\includegraphics{fotoarkiv.jpg}
\end{minipage}
</figure>
</para -->
</sect1>
</chapter>
