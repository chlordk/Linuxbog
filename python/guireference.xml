<chapter id="python-windows">
<title>Vinduer, knapper og meget mere</title>

<para>
GUI komponenter skal stilles på plads i en kontainer. Det sker primært
med Pack metoden. Medmindre en programmør specificerer (angiver) en
anden rækkefølge, vil Pack placere komponenterne i kontaineren fra
skærmtop til -bund i den rækkefølge, hvori de er listede i programmet.
</para>

<para>
Du har en række valgmuligheder (options), når komponenterne
(tekstboksene, menuerne, knapperne og de øvrige grafiske objekter) skal
placeres i kontaineren (ofte Frame). Option "side" angiver, hvor i
kontaineren, komponentet skal placeres. Sættes side = TOP (er forvalgt
af Python) pakkes komponenterne lodret (vertically). Andre mulige side
værdier er BOTTOM (bund), LEFT (venstre) og RIGHT (højre). Option "fill"
kan være None (den forvalgte værdi), X, Y og BOTH sikrer at et komponent
udfylder al den plads, der er afsat til den i den angivne retning.
Option expand kan tildeles værdierne YES (1) og NO (0). Hvis expand er
sat til YES udvides komponentet til at udfylde al ledig plads i
kontaineren. Optionerne padx og pady indsætter tom plads rundt om
komponentet. Metoden pack_forget fjerner et pakket komponent fra
kontaineren.
</para>

<para>
Hvis Canvas komponentet bliver brugt alene som her, oprettes et fuld færdigt vindue:

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import Canvas</userinput>
<prompt>>>></prompt> <userinput>Canvas().pack()</userinput>
<prompt>>>></prompt> <userinput>from Tkinter import *</userinput>
<prompt>>>></prompt> <userinput>class Kanvas(Canvas):</userinput>
<prompt>...</prompt>     <userinput>def _init_(self):</userinput>
<prompt>...</prompt>         <userinput>Canvas._init_(self).pack()</userinput>
<prompt>...</prompt>
<prompt>>>></prompt>
</screen>
</para>

<para>
Der defineres en klasse, som benytter underklassen Canvas's kode. Denne
klasse tildeles startværdier (initieres heraf forkortelsen init).
Initieringen kaldes en konstruktør eller fuldt ud klassekonstruktøren.
Både den programlinje, hvori klassen defineres (klassehovedet) og
konstruktøren er blokke, så begge steder skal de efterfølgende
programlinjer rykkes ind til højre. Da self først fungerer i og med
initieringen, må det være klart, at self stammer fra selve klassen,
hvorfor det viste eksempel også kunne skrives:

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import *</userinput>
<prompt>>>></prompt> <userinput>class Kanvas(Canvas):</userinput>
<prompt>...</prompt>     <userinput>def _init_(Kanvas):</userinput>
<prompt>...</prompt>             <userinput>Canvas._init_(Kanvas).pack()</userinput>
<prompt>...</prompt>
<prompt>>>></prompt>
</screen>
</para>

<para>
Medmindre en programmør specificerer (angiver) en anden rækkefølge, vil
Pack placere komponenterne i kontaineren fra skærmtop til -bund i den
rækkefølge, hvori de er listede i programmet.
</para>

<para>
<!-- Wange:
     Hmmm hvordan laver man lige prompt/userinput her?
-->
<screen>
from Tkinter import *
from tkMessageBox import askyesno, showerror

class Dialog(Frame): # arver Frame
    def __init__(self, master=None): #Dialogs konstruktør
        Frame.__init__(self, master) # Frames konstruktør
        Pack.config(self)
        self.opretArvinger()

    def Hilsen(self): # arver Dialog
        print "En hilsen fra Bornholm til dig!" #sendes til skal, men kunne være til fil

    def opretArvinger(self): # arver Dialog
        Label(self,  text='Hej! jeg vil gerne i dialog med dig.').pack(side=TOP)
        Button(self, text='Popup 1', command=self.dialog1).pack() # arver opretArvinger
        Button(self, text='Popup 2', command=self.dialog2).pack()
        Button(self, text='Noget til dig',  command=self.Hilsen  ).pack(side=LEFT)
        Button(self, text='Afslut',  command=self.quit   ).pack(side=RIGHT)

    def dialog1(self):  # arver Dialog
        svar = askyesno("Vil du se tkMessageBox\ndialogen i funktion?")
	if svar: self.dialog2()

    def dialog2(self):  # arver Dialog
        showerror("BESKYTTET AFSNIT", "\nHer har du vist ingen adgang min ven...")


</screen>

</para>

<figure id="gui1-billede" float="1">
<title>GUI</title>
<graphic fileref="gui_1.&magic;" scale="60"></graphic>
</figure>

<sect1 id="wid">
<title>Widget klassen</title>

<para>
Et grafisk bruger interface (grafical user inteface heraf forkortelsen
GUI) giver brugeren mulighed for at kommunikere interaktivt med et
program. GUIs sammensættes af GUI komponenter (kaldet widgets - en
forkortelse for finesser i vinduer). Et GUI komponent er et objekt
hvormed en bruger som antydet kan kommunikere interaktivt med et program
via mus og eller tastatur. Ved brug af Tool Command Language (forkortet
TCL) og dets værktøjskit (Tool Kit forkortet Tk - et bibliotek af
fordefinerede klasser, subklasser m.v.) kan Python programmører
konstruere GUIs. Hvordan det gøres skal vi se på i en lang række
eksempler.

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import Frame</userinput>
<prompt>>>></prompt> <userinput>Frame().pack()</userinput>
<prompt>>>></prompt> <userinput># Her ses at Frame er en klasse tilhørende Tkinter:</userinput>
<prompt>>>></prompt> <userinput>Frame</userinput>
<userinput>&lt;class Tkinter.Frame at 0x405ecd4c></userinput>
</screen>

Vi får også at vide, at koden til Frame eller rettere indledningen til
den er pladeret på den hexadecimale adresse \x405ecd4c.
</para>

<!-- Wange:
     Jeg har udkommenteret følgende da det ikke lige giver mening her
     i afsnittet ???

para>
<screen>
>>> frame
&lt;Tkinter.Frame instance at 0x402e8b8c>
>>>
</screen>
</para -->

<para>
Det følgende kald til Tk (from Tkinter import *) kan være farligt, og
bør absolut kun anvendes ved kald, hvor du er sikker, på at kaldet
virkelig kan bruges. Det der er farligt, er at du ved at benytte navne
f.eks. på variabler og funktioner, hvis navne også findes i det
importerede modul, vil blive overstyret (på engelsk overrided). Det
betyder, at det bliver de navne du har tilføjet, der vil fungere og
dermed bestemme dit programs funktion. På den anden side, hvis du er
sikker, på at du ikke vil komme til at overstyre navne i det eller de
importerede modul/moduler, så er det stjernekaldet, du bør bruge. Lad os
lige få en kvittering, på at det forholder sig som nævnt:

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import *</userinput>
<prompt>>>></prompt> <userinput>dir(Tkinter)</userinput>
<userinput>Traceback (most recent call last):</userinput>
<userinput>  File "&lt;stdin&gt;", line 1, in ?</userinput>
<userinput>NameError: name 'Tkinter' is not defined</userinput>
<prompt>>>></prompt>
</screen>
</para>

<para>
Fortolkeren kender ikke Tkinter, hvorfor Tkinter ikke kan eksistere i
dit program. Det er kun det for dit program nødvendige, der bliver
hentet ind. Hvis vi var i tvivl, om hvorvidt Tkinter kan klare kaldet
from Tkinter import *, så er det eneste rigtige, vi kan gøre, at benytte
kaldet import Tkinter i stedet for from Tkinter import *.

<screen>
<prompt>>>></prompt> <userinput>import Tkinter</userinput>
<prompt>>>></prompt> <userinput>Tkinter</userinput>
<userinput>&lt;module 'Tkinter' from '/usr/local/lib/python2.3/lib-tk/Tkinter.pyc'></userinput>
<prompt>>>></prompt> <userinput>'</userinput>
</screen>
</para>

<para>
Funktionen dir kan vise indholdet i et modul. Benyttes det igen, får vi
en udskrift af indholdet i modulet - nu kender fortolkeren Tkinter.
Jeg har ikke taget ret meget af den lange udskrift med her, så lav lige
kontrollen selv også.

<screen>
<prompt>>>></prompt> <userinput>import Tkinter</userinput>
<prompt>>>></prompt> <userinput>dir(Tkinter)</userinput>
<userinput>['ACTIVE', 'ALL', 'ANCHOR', 'ARC', 'At', 'AtEnd', 'AtInsert',.........']</userinput>
<prompt>>>></prompt>
</screen>
</para>

<para>
Et allerede vist eksempel ser således ud:
<screen>
<prompt>>>></prompt> <userinput>from Tkinter import Frame</userinput>
<prompt>>>></prompt> <userinput>Frame().pack()</userinput>
<prompt>>>></prompt>
</screen>
</para>

<para>
Sublassen Frame blev importeret og derefter anvendt direkte. Da det var
selve Frame, der blev importeret og brugt, må det være indlysende, at
der i kaldet  Frame().pack() ikke bliver tilført nogen anden form for
kode - Frames parameterliste er da også tom. Det behøver den ikke at
være. Det følgende eksempel har nøjagtig samme funktion som det
ovenstående. parent = None fortæller nøjagtig det samme, at der ikke
kommer nogen form for kode til den, der er indeholdt i Frame - der er
ingen parent (direkte oversat forældre på dansk mor).

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import Frame</userinput>
<prompt>>>></prompt> <userinput>Frame(parrent = None).pack()</userinput>
<prompt>>>></prompt>
</screen>
</para>

<para>
Subklassen arver fra Frame, så subklassens self refererer til Frame som den kommer fra
Tkinter. mor = None kan godt forvirre lidt på dette sted, for Klasse har jo Frame til mor, så reelt er der en mor, men Klasse er på arvetidspunktet  som alle andre klassearvinger en direkte kopi af moderen. De tre eksemplers første 4 linjer ændrer ikke noget som
helst på arvegodset, så mor = None fortæller konkret, at Frame ingen mor har, og det er jo korrekt. Når det er fastslået, er det også
klart, at self repræsenterer selve subklassen Klasse. Når det er tilfældet, vil det samme eksempel også kunne skrives således:
</para>
<para>
<screen>
from Tkinter import *
class Klasse(Frame):                 # Opret subklasse
    def __init__(Klasse, side=TOP):
        Frame.__init__(Klasse)       # Subklassekonstruktor
        Klasse.pack()
        Klasse.make_widgets()        # metodekald
    def make_widgets(Klasse):
        Button(Klasse,
            text="Klik her", command=Klasse.quit).pack(side=LEFT)
if __name__ == '__main__': Klasse().mainloop()
</screen>
</para>
<para>
<screen>
import tkSimpleDialog
x = tkSimpleDialog.askinteger("Vælg et heltal",
"mellem 1 og 6:",initialvalue = 1, minvalue = 1, maxvalue = 6)
</screen>
</para>

<sect2 id="wid.rammen">
<title>Frame underklasse i Widget</title>
<para>
Frame komponentets formål er at være kontainer for andre komponenter. Det før viste eksempel kunne bl.a. også skrives således:
</para>
<para>
<screen>
I dette dette eksempel udnyttes det importerede modul direkte.
from Tkinter import Frame
Frame().pack()
</screen>
</para>
<para>
<screen>
Her oprettes og bruges en kopi af det importerede modul.
>>> from Tkinter import Frame
>>> frame = Frame()
>>> frame.pack()
>>>
>>> from Tkinter import *
>>> frame = Frame()
>>> frame.pack()
>>>
>>> from Tkinter import *
>>> frame = Frame().pack(expand = YES, fill = BOTH)
>>>
</screen>
</para>
<para>
Frame er subklasse i Widget klassen (barn af Widget). Frame arver dermed Widget klassens egenskaber. Det betyder imidlertid ikke, at alle egenskaber i fuldt omfang kan overføres til barnet - pack vil altid være knyttet til moderobjektet - i dette tilfælde til Frame. Derfor rykker pack()  op på den programlinje, hvori objektkopien (barnet) oprettes:
</para>
<para>
<screen>
>>> # Her importeres hele Tkinter modulet:
>>> import Tkinter
>>> # Her ser vi, hvad Tkinter er for noget:
>>> Tkinter
&lt;module 'Tkinter' from '/usr/local/lib/python2.3/lib-tk/Tkinter.pyc'>
>>>
</screen>
</para>
<para>
Svaret var, at Tkinter er et modul, at det blev importeret fra /usr/local/lib/python2.3/lib-tk/ biblioteket og at det var fra en kompileret
fil Tkinter.pyc - det ses på at den sædvanlige filtype py er udvidet med et c. Det normale er, at en kompileret fil er væsentlig hurtigere, men sådan er det ikke i Python. Her kan der vindes ganske ubetydelig tid, lige i det øjeblik koden hentes ind i computeren ellers ikke.
</para>
<para>
<screen>
>>> from Tkinter import Frame
>>> Her stilles Frames objekter på plads:
>>> Frame().pack()
</screen>
</para>
<para>
<screen>
>>> # Her ses at Frame er en klasse tilhørende Tkinter:
>>> Frame
&lt;class Tkinter.Frame at 0x405ecd4c&gt;
</screen>
</para>
<para>
Vi får også at vide, at koden til Frame eller rettere indledningen til den er pladeret på den hexadecimale adresse 405ecd4c.
</para>
<para>
<screen>
>>> frame
&lt;Tkinter.Frame instance at 0x402e8b8c&gt;
>>>
</screen>
</para>
<para>
>>> from Tkinter import *
>>> class vindue(Frame):
...     def _init_(self):
...             Frame._init_(self)
...             self.pack(expand = YES, fill = BOTH)
...
</para>
<para>
<screen>
Programlinjen
 Frame().pack(expand = YES, fill = BOTH)
genkendes let i:
Frame._init_(self)
self.pack(expand = YES, fill = BOTH)
</screen>
</para>
<figure id="widget1-billede" float="1">
<title>Widget</title>
<graphic fileref="w1.&magic;" scale="60"></graphic>
</figure>
</sect2>

<sect2 id="wid.labelen">
<title>Label underklasse i Widget</title>
<para>
En label kan vise ikke editerbar tekst plus ikoner.
</para>

<figure id="widget2-billede" float="1">
<title>Widget</title>
<graphic fileref="w2.&magic;" scale="60"></graphic>
</figure>

<para>
Af fordefinerede ikoner er der følgende:
</para>
<para>
ikoner = ["error","hourglass","info", "questhead","question",
"warning", "gray75", "gray50", "gray25", "gray12"]
</para>
<para>
from Tkinter import *
win = Tk()
ikoner = ["error","hourglass","info", "questhead","question",
"warning", "gray75", "gray50", "gray25", "gray12"]
ikon = []
for i in range(0,len(ikoner)):
	ikon = ikoner[i]
	Label(win,bitmap = ikon).pack(expand = YES, fill= Y)
</para>
<para>
</para>
<para>
>>> from Tkinter import *
>>> win = Tk()
>>> Label(win,text = "Tekst kan skrives i label.").pack(expand = NO, fill = X)
>>>
</para>
<para>
>>> from Tkinter import *
>>> root = Tk()
>>> Label(root,text = "Men teksten kan ikke rettes.").pack(expand = YES, fill = X)
>>>
</para>
<para>
from Tkinter import *
root = Tk()
skrift = ("times", 20, "bold")
label = Label(root, text="Der kan skrives paa en label.")
label.config(bg="black", fg="white")
label.config(font=skrift)
label.config(height=4, width=30)  # plads til 4 linjer a 30 tegn
label.pack(expand=YES, fill=BOTH)
root.mainloop()
</para>
<para>
from Tkinter import *
# label1, label2 og label3 arver Label klassen med dens pack funktion (metode)
label1 = Label(text ="Enkelt, men omfattende.").pack(expand = NO, side = LEFT)
label2 = Label(text ="Lige i centrum.").pack(expand = NO, side = TOP)
label3 = Label(text ="Total trods enkel.").pack(expand = NO, side = RIGHT)
mainloop()
</para>
<para>
eller f.eks. :
</para>
<para>
from Tkinter import *
label1 = Label(text ="Enkelt, men omfattende.").pack(expand = YES, side = LEFT)
label2 = Label(text ="Lige i centrum.").pack(expand = YES, side = TOP)
label3 = Label(text ="Total trods enkel.").pack(expand = YES, side = RIGHT)
mainloop()
</para>
<para>
from Tkinter import *
root = Tk()
skrift = ("times", 20, "bold")
label = Label(root, text="Der kan skrives paa en label.")
label.config(bg="black", fg="white")
label.config(font=skrift)
label.config(height=4, width=30)  # plads til 4 linjer a 30 tegn
label.pack(expand=YES, fill=BOTH)
root.mainloop()
</para>
<para>
<screen>
from Tkinter import *
class LabelDemo( Frame ):
   def __init__( self ):  # LabelDemos konstruktør
      Frame.__init__( self )   # mor Frames konstruktør
      self.pack( expand = YES, fill = BOTH )
      self.master.title( "Labels" )
      self.label1 = Label( self, text = "Label med tekst" )
      self.label1.pack()
      self.label2 = Label( self,
         text = "Label med tekst og bitmap (ikon)" )
      self.label2.pack( side = LEFT )
      self.label3 = Label( self, bitmap = "questhead" )
      self.label3.pack( side = LEFT )
def main():
   LabelDemo().mainloop()
if __name__ == "__main__":
   main()
</screen>
</para>

<figure id="widget3-billede" float="1">
<title>Widget 3</title>
<graphic fileref="w2_2.&magic;" scale="60"></graphic>
</figure>
</sect2>

<sect2 id="wid.enLinjet">
<title>Entry underklasse i Widget</title>
<para>
Entry er et en-linjes input område, der kan modtage input fra tastaturet eller vise information.
</para>
<para>
<screen>
>>> from Tkinter import *
>>> Entry().pack()
>>> from Tkinter import *
>>> root = Tk()
>>> Entry(root).pack()
>>>
from Tkinter import *
root = Tk()
Directions = Label(root, text ='Hvilken fil ønskes hentet?')
Directions.config(anchor=W)
inputBox = Entry(root, width=60)
Directions.pack()
inputBox.pack()
mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{12cm}
\includegraphics{w3_1.jpg}
\end{minipage}
</figure>
</para -->
<para>
<screen>
from Tkinter import *
from tkMessageBox import *
class EntryDemo( Frame ):
   def __init__( self ):
      Frame.__init__( self )
      self.pack( expand = YES, fill = BOTH )
      self.master.title( "Test datamodtagere" )
      self.master.geometry( "325x100" )
      self.frame1 = Frame( self )
      self.frame1.pack( pady = 5 )
      # text1 oprettes som barnebarn af Frame
      # entry er endnu en underklasse i Widget klassen (læs barn af)
      self.text1 = Entry( self.frame1, name = "tekst1" )
      self.text1.bind( "&lt;Return&gt;", self.visIndhold )
      self.text1.pack( side = LEFT, padx = 5 )
      self.text2 = Entry( self.frame1, name = "tekst2" )
      self.text2.insert( INSERT, "Skriv tekst her" )
      self.text2.bind( "&lt;Return&gt;", self.visIndhold )
      self.text2.pack( side = LEFT, padx = 5 )
      self.frame2 = Frame( self )
      self.frame2.pack( pady = 5 )
      self.text3 = Entry( self.frame2, name = "tekst3" )
      self.text3.insert( INSERT, "Ikke editerbar tekstboks" )
      self.text3.config( state = DISABLED )
      self.text3.bind( "&lt;Return&gt;", self.visIndhold )
      self.text3.pack( side = LEFT, padx = 5 )
      self.text4 = Entry( self.frame2, name = "tekst4",
                          show = "*" )
      self.text4.insert( INSERT, "Hemmelig tekst" )
      self.text4.bind( "&lt;Return&gt;", self.visIndhold )
      self.text4.pack( side = LEFT, padx = 5 )
   def visIndhold( self, event ):
      navn = event.widget.winfo_name()
      indhold = event.widget.get()
      showinfo( "Melding", navn + ": " + indhold )
def main():
   EntryDemo().mainloop()
if __name__ == "__main__":
   main()
</screen>
</para>
<para>
</para>
<!-- para>
<figure>
\begin{minipage}{15cm}
\includegraphics{w3.jpg}
\end{minipage}
</figure>
</para -->
<para>
</para>
</sect2>

<sect2 id="wid.tekstboks">
<title>Text underklasse i Widget</title>
<para>
Text modtager input fra tastaturet eller viser information. I modsætning til Entry komponentet er Text et areal, der kan
modtage mange tekstlinjer.
</para>
<para>
<screen>
from Tkinter import *
class tekstFunktioner(Frame):
    def __init__(self, parent=None, tekst='', indfil=None):
        Frame.__init__(self, parent)
        self.pack(expand=YES, fill=BOTH)
        self.opretArvinger()
        self.tekstvalg(tekst, indfil)
    
    def opretArvinger(self):
        rulleskakt = Scrollbar(self)
        tekst = Text(self, relief=SUNKEN)
        rulleskakt.config(command=tekst.yview)      # xlink rulleskakt og tekst
        tekst.config(yscrollcommand=rulleskakt.set)    # flyttes en flyttes alle
        rulleskakt.pack(side=RIGHT, fill=Y)            # pack først = clip sidst
        tekst.pack(side=LEFT, expand=YES, fill=BOTH)   # tekst clipped først
        self.tekst = tekst

    def tekstvalg(self, tekst='', indfil=None):
        if indfil:
            tekst = open(indfil, 'r').read()
        self.tekst.delete('1.0', END)                       # slet hele teksten
        self.tekst.insert('1.0', tekst)                       # tekst ind linje 1 pos 0
        self.tekst.mark_set(INSERT, '1.0')     # set insert cursor
        self.tekst.focus()                                            # gem brugervalg

    def hentTekst(self):                                        # returner streng
        return self.tekst.get('1.0', END+'-1c')  # hele teksten

if __name__ == '__main__':
    root = Tk()
    try:
        streng = tekstFunktioner(indfil=sys.argv[1])  # filnavn på kommandolinje
    except IndexError:
        streng = tekstFunktioner(tekst='Tekst\nindsættes her')
</screen>
</para>
<para>
    def visTekst(event): print repr(streng.hentTekst())     # vis tekst i skal
    root.bind('&lt;Key-Escape&gt;', visTekst)      # klik escape tast = dump tekst
    root.mainloop()
</para>
<!-- para>
<figure>
\begin{minipage}{15cm}
\includegraphics{w4.jpg}
\end{minipage}
</figure>
</para -->
<para>
</para>
<para>
<screen>
from Tkinter import *
</screen>
</para>
<para>
<screen>
# Trin 1: Opret den applikations-klasse (program-klasse), hvori GUI
# og haendelses-metoder (event handling methods) defineres
class Klasse(Frame):
	def __init__(self):
		Frame.__init__(self)
		self.tekstboks = Text(self)
		self.tekstboks.bind("&lt;space&gt;", self.Afslut)
		self.tekstboks.bind("&lt;Key&gt;", self.modtagTastensNummer)
		self.tekstboks.pack()
		self.pack()
	def Afslut(self,event):
		import sys
		sys.exit()
	def modtagTastensNummer(self,event):
		str = "%d\n" % event.keycode
		self.tekstboks.insert(END, str)
		return "break"
# Opret arving og start haendelsesloekken
barn = Klasse()
barn.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{15cm}
\includegraphics{w4_2.jpg}
\end{minipage}
</figure>
</para -->
<para>
<screen>
from Tkinter import *
root = Tk()
def melding(event): print "Modtog melding om klik på knap"
text = Text()
text.config(font=("times", 18, "normal"))    # skrift 18 punkts normal
text.config(height=40, width=60)            # plads til 40 linjer a 60 tegn
text.pack(expand=YES, fill=BOTH)
text.insert(END, "Dette er\n\nmeningen\n\nmed livet.\n\n")   # indsaetter 6 linjer
#linje 1  sender "Modtog melding om klik på knap" til skal (shell)
knap = Button(text, text="Python er andet end slanger.", command=lambda:melding(1))
knap.pack()
text.window_create(END, window=knap)    # indsaetter foto
text.insert(END, "\n\n")
foto  = PhotoImage(file="skyer.gif")
text.image_create(END, image=foto)
# udvider de 6 tekststrenge ovenfor
text.tag_add("udskrift", "1.6", "1.8")
text.tag_add("udskrift", "3.0", "3.8")
text.tag_add("udskrift", "5.4", "5.9")
text.tag_config("udskrift", background="light green")
text.tag_config("udskrift", foreground="red")
text.tag_config("udskrift", font=("helvetica", 24, "underline italic bold"))
text.tag_bind("udskrift", "&lt;Double-1&gt;", melding)
root.mainloop()
</screen>
</para>
<para>
<screen>
from Tkinter import *
root = Tk()
def melding(event): print "Modtog melding om klik på knap"
text = Text()
text.config(font=("times", 18, "normal"))    # skrift 18 punkts normal
text.config(height=40, width=60)            # plads til 40 linjer a 60 tegn
text.pack(expand=YES, fill=BOTH)
text.insert(END, "Dette er\n\nmeningen\n\nmed livet.\n\n")   # indsaetter 6 linjer
#linje 1  sender "Modtog melding om klik på knap" til skal (shell)
knap = Button(text, text="Python er andet end slanger.", command=lambda:melding(1))
knap.pack()
text.window_create(END, window=knap)                          # indsaetter foto
text.insert(END, "\n\n")
foto = PhotoImage(file="skyer2.gif")
text.image_create(END, image=foto)
# udvider de 6 tekststrenge ovenfor
text.tag_add("udskrift", "1.6", "1.8")
text.tag_add("udskrift", "3.0", "3.8")
text.tag_add("udskrift", "5.4", "5.9")
text.tag_config("udskrift", background="light green")
text.tag_config("udskrift", foreground="red")
text.tag_config("udskrift", font=("helvetica", 24, "underline italic bold"))
text.tag_bind("udskrift", "&lt;Double-1&gt;", melding)
root.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{20cm}
\includegraphics{w4_3.jpg}
\end{minipage}
</figure>
</para -->
</sect2>

<sect2 id="wid.knap">
<title>Button underklasse i Widget</title>
<para>
Button  er fordefineret som et komponent tilhørende Widget modulet.
Ved klik med musens markør på knap kan funktion (metode) kaldes.
</para>
<para>
<screen>
from Tkinter import *
class Arving(Frame):   # Klassehovede Arving er barn af  Frame
    def __init__(Arving, mor=None):
        Frame.__init__(Arving, mor)   # initialiser superklasse (superclass)
        Arving.pack()
        Arving.data = 10
        Arving.opret_arvinger()             # forener arvinger med mor
    def opret_arvinger(Arving):
        widget = Button(Arving, text='Knaptekst!', command=Arving.message)
        widget.pack(side=LEFT)
    def message(Arving):
        Arving.data = Arving.data + 1
        print 'Sum %s' % Arving.data # udskriver på skal (kunne være til fil)
if __name__ == '__main__': Arving().mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{12cm}
\includegraphics{w5_3.jpg}
\end{minipage}
</figure>
</para -->
<para>
<screen>
import sys
from Tkinter import *
widget = Button(None, text='Afslut', command=sys.exit)
widget.pack()
widget.mainloop()
>>> # Eksemplet viser funktionskald fra knap
>>> from Tkinter import *
>>> def f(): print "Hej! Jeg er her."
...
>>> Button(text = "Funktionskald", command = f()).pack( pady = 5 )
Hej! Jeg er her.
>>>
</screen>
</para>
<para>
I Python bruger man ofte en såkaldt callback handler. Herved forstår
man en funktion, som den i det følgende eksempel. En callback handler
er en ganske normal metode (funktion) alene med den forskel, at modulet
sys importeres direkte i den, og den i modulet fordefinerede metode
exit() kaldes. Dens eneste formål er at gøre en udgang af en løkke her
mainloop() mulig.
</para>
<para>
<screen>
from Tkinter import *
def quit():                      # en bruger callback handler
    print 'Afslut'       	 # skriver til skal (shell)
    import sys; sys.exit()
knapBarn = Button(None, text='Afslut', command=quit) # command=quit funktionskald
knapBarn.pack()
knapBarn.mainloop()
from Tkinter import *
Button(text='Klik her', padx=10, pady=10).pack(expand = NO, fill = X)
>>> from Tkinter import *
>>> root = Tk()
>>> def Funktion(navn) : print "Hej", navn
...
>>> Button(root,text = "Klik her", command = lambda navn =
"Olsen": Funktion(navn)).pack()
>>> Hej Olsen
from Tkinter import *
knap = Button(text='Klik her', padx=10, pady=10)
knap.pack(padx=20, pady=20)
knap.config(cursor='gumby')
knap.config(bd=8, relief=RAISED)
knap.config(bg='dark green', fg='white')
knap.config(font=('times', 20, 'underline bold italic'))
mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{6cm}
\includegraphics{w5.jpg}
\end{minipage}
</figure>
</para -->
<para>
<screen>
from Tkinter import *
class Arving(Frame):   # Klassehovede Arving er barn af  Frame
    def __init__(Arving, mor=None):
        Frame.__init__(Arving, mor)   # initialiser superklasse (superclass)
        Arving.pack()
        Arving.data = 10
        Arving.opret_arvinger()             # forener arvinger med mor
    def opret_arvinger(Arving):
        widget = Button(Arving, text='Knaptekst!', command=Arving.message)
        widget.pack(side=LEFT)
    def message(Arving):
        Arving.data = Arving.data + 1
        print 'Sum %s' % Arving.data # udskriver på skal (kunne være til fil)
if __name__ == '__main__': Arving().mainloop()
</screen>
</para>
<para>
<screen>
from Tkinter import *
class knapRamme( Frame ):
   def __init__( self ):
      Frame.__init__( self )
      self.master.title( "Knap oprettelse" )
      self.master.geometry( "400x150" )
      self.pack( expand= YES, fill = BOTH )
      self.knap1 = Button( self, text = "Opret ny knap",
         command = self.opretNyKnap ) # funktions kald
      self.knap1.pack( side = TOP )
      self.knap2 = Button( self,
         text = "expand= NO, fill = BOTH" )
      self.knap2.pack( side = BOTTOM, fill = BOTH )
      self.knap3 = Button( self,
         text = "expand= YES, fill = X" )
      self.knap3.pack( side = LEFT, expand= YES, fill = X )
      self.knap4 = Button( self,
         text = "expand= YES, fill = Y" )
      self.knap4.pack( side = RIGHT, expand= YES, fill = Y )
   def opretNyKnap( self ):
      Button( self, text = "Ny knap" ).pack( pady = 5 )
def main():
   knapRamme().mainloop()
if __name__ == "__main__":
   main()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{12cm}
\includegraphics{w5_2.jpg}
\end{minipage}
</figure>
</para -->
</sect2>

<sect2 id="wid.radioknap">
<title>Radiobutton underklasse i Widget</title>
<para>
<screen>
from Tkinter import *
root = Tk()
var  = IntVar()
for i in range(10):
    radioknap= Radiobutton(root, text=str(i), value=i, variable=var)
    radioknap.pack(side=LEFT)
root.mainloop()
print var.get()
</screen>
</para>
<para>
<screen>
from Tkinter import *
root = Tk()
var = StringVar()
for i in range(6):
    radioknap= Radiobutton(root, text=str(i), value=i, variable=var)
    radioknap.pack(side = RIGTH)
root.mainloop()
print var.get()
</screen>
</para>
</sect2>

<sect2 id="wid.valgmenu">
<title>Menu underklasse i Widget</title>
<para>
Menu komponentet kan vise en liste af værdier, hvorfra brugeren kan vælge.
</para>
<para>
<screen>
*+
import sys
from Tkinter import *
win = Tk()
menulinje = Menu(win)
win.config(menu = menulinje)
filmenu = Menu(menulinje)
menulinje.add_cascade(label = "Filer", menu = filmenu)
def udskriv(): print "Udskriv data"
def gem(): print "Gem fil"
filmenu.add_command(label = "Udskriv", command = udskriv)
filmenu.add_command(label = "Gem", command = gem)
filmenu.add_separator()
filmenu.add_command(label = "Afslut", command = sys.exit)
win.mainloop()
v = IntVar()
filmenu.add_radiobutton(label = "Udskriv", var = v, value = 1
filmenu.add_radiobutton(label = "Gem", var = v, value = 2
filmenu.add_radiobutton(label = "Afslut", var = v, value = 3
v = IntVar()
filmenu.add_checkbutton(label = "Hent", var = v, command = hent)
</screen>
</para>
<para>
<screen>
from Tkinter import *
import sys
root = Tk()
menubar = Menu(root)
root.config(menu = menubar)
filmenu = Menu(menubar)
menubar.add_cascade(label = "Filer", menu = filmenu)
def Hent(): print "Hent fil procedurekald ind her"
def Gem(): print "Gem fil procedurekald ind her"
filmenu.add_command(label = "Hent fil", command = Hent)
filmenu.add_command(label = "Gem fil", command = Gem)
filmenu.add_separator()
filmenu.add_command(label = "Luk ned",
command = sys.exit)
root.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{10cm}
\includegraphics{w8.jpg}
\end{minipage}
</figure>
</para -->
</sect2>

<sect2 id="wid.tegneflade">
<title>Canvas underklasse i Widget</title>
<para>
</para>
<para>
<screen>
>>> from Tkinter import *
>>> canvas = Tk()
>>> Canvas(canvas,bg = "light green").pack(expand = YES, fill = BOTH)
</screen>
</para>
<para>
<screen>
from Tkinter import *
spor = 0
class KanvasEvents:
    def __init__(self, parent=None):
        canvasArving = Canvas(width=300, height=300, bg="light green")
        canvasArving.pack()
        canvasArving.bind("&lt;ButtonPress-1&gt;", self.Opstart)
        canvasArving.bind("&lt;B1-Motion&gt;",     self.slet_og_gentegn)
        canvasArving.bind("&lt;Double-1&gt;",      self.slet)
        canvasArving.bind("&lt;ButtonPress-3&gt;", self.flyt)
        self.canvasArving = canvasArving
        self.drawn  = None
        self.kinds = [canvasArving.create_oval, canvasArving.create_rectangle]
    def Opstart(self, event):
        self.shape = self.kinds[0]
        self.kinds = self.kinds[1:] + self.kinds[:1]
        self.start = event
        self.drawn = None
    def slet_og_gentegn(self, event):
        canvasArving = event.widget
        if self.drawn: canvasArving.delete(self.drawn)
        objectId = self.shape(self.start.x, self.start.y, event.x, event.y)
        if spor: print objectId
        self.drawn = objectId
    def slet(self, event):
        event.widget.delete("all")
    def flyt(self, event):
        if self.drawn:
            if spor: print self.drawn
            canvasArving = event.widget
            diffX, diffY = (event.x - self.start.x), (event.y - self.start.y)
            canvasArving.move(self.drawn, diffX, diffY)
            self.start = event
if __name__ == "__main__":
    KanvasEvents()
    mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{15cm}
\includegraphics{w9_1.jpg}
\end{minipage}
</figure>
</para -->
<para>
<screen>
from Tkinter import *
trace = 0
class KanvasEvents:
    def __init__(self, parent=None):
        canvasArving = Canvas(width=300, height=300,
	 bg="light green")
        canvasArving.pack()
        canvasArving.bind("&lt;ButtonPress-1&gt;", self.Opstart)
        canvasArving.bind("&lt;B1-Motion&gt;",     self.slet_og_gentegn)
        canvasArving.bind("&lt;Double-1&gt;",      self.slet)
        canvasArving.bind("&lt;ButtonPress-3&gt;", self.flyt)
        self.canvasArving = canvasArving
        self.drawn  = None
        self.kinds = [canvasArving.create_oval, canvasArving.create_rectangle]
    def Opstart(self, event):
        self.shape = self.kinds[0]
        self.kinds = self.kinds[1:] + self.kinds[:1]
        self.start = event
        self.drawn = None
    def slet_og_gentegn(self, event):
        canvasArving = event.widget
        if self.drawn: canvasArving.delete(self.drawn)
        objectId = self.shape(self.start.x, self.start.y, event.x, event.y)
        if trace: print objectId
        self.drawn = objectId
    def slet(self, event):
        event.widget.delete("all")
    def flyt(self, event):
        if self.drawn:
            if trace: print self.drawn
            canvasArving = event.widget
            diffX, diffY = (event.x - self.start.x), (event.y - self.start.y)
            canvasArving.move(self.drawn, diffX, diffY)
            self.start = event
if __name__ == "__main__":
    KanvasEvents()
    mainloop()
</screen>
</para>
<para>
<screen>
from Tkinter import *
canvas = Canvas(width=500, height=500, bg="light green")
canvas.pack(expand=YES, fill=BOTH)
canvas.create_line(100, 100, 200, 200)      # fraX, fraY, tilX, tilY
canvas.create_line(100, 200, 200, 300)      # tegn  geometr.  former
for i in range(1, 20, 2):
    canvas.create_line(0, i, 50, i)
canvas.create_oval(50, 50, 200, 200, width=2, fill="blue")
canvas.create_arc(200, 200, 300, 100)
canvas.create_rectangle(200, 200, 300, 300, width=5, fill="red")
canvas.create_line(50, 300, 150, 150, width=10, fill="grey")
foto=PhotoImage(file="skyer.gif")
canvas.create_image(350, 300, image=foto, anchor=NW)  # indsaet foto
label = Label(canvas, text="Python er for dig", fg="white", bg="black")
label.pack()
canvas.create_window(100, 100, window=label)        # indsaet en label
canvas.create_text(100, 280, text="og for mig")     # tegn noget tekst
mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{25cm}
\includegraphics{w9.jpg}
\end{minipage}
</figure>
</para -->
</sect2>

<sect2 id="wid.skala">
<title>Scale underklasse i Widget</title>
<para>
<screen>
from Tkinter import *
root = Tk()
skala = Scale(root, from_=-100, to=100, tickinterval=50, resolution=10)
skala.pack(expand=YES, fill=Y)
def metode(): print skala.get() #udskriver i skal (shell)
Button(root, text='status', command= metode).pack(side=RIGHT)
root.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{8cm}
\includegraphics{w10.jpg}
\end{minipage}
</figure>
</para -->
</sect2>

<sect2 id="wid.listeboks">
<title>Listbox underklasse i Widget</title>
<para>
<screen>
Eksemplet viser en udvidet listeboks:
from Tkinter import *
class Listeboks(Frame):
    def __init__(self, mor,elementer):
        Frame.__init__(self,mor)
        self.elementer = []
        for element,w in elementer:
            frame = Frame(self); frame.pack(side=LEFT, expand=YES, fill=BOTH)
            Label(frame, text=element, borderwidth=1, relief=RAISED).pack(fill=X)
            label = Listbox(frame, width=w, borderwidth=0, selectborderwidth=0,
                         relief=FLAT, exportselection=FALSE)
            label.pack(expand=YES, fill=BOTH)
            self.elementer.append(label)
            label.bind('&lt;B1-Motion&gt;', lambda e, s=self: s._select(e.y))
            label.bind('&lt;Button-1&gt;', lambda e, s=self: s._select(e.y))
            label.bind('&lt;Leave&gt;', lambda e: 'break')
            label.bind('&lt;B2-Motion&gt;', lambda e, s=self: s._b2motion(e.x, e.y))
            label.bind('&lt;Button-2&gt;', lambda e, s=self: s._button2(e.x, e.y))
        frame = Frame(self); frame.pack(side=LEFT, fill=Y)
        Label(frame, borderwidth=1, relief=RAISED).pack(fill=X)
        rulleskakt = Scrollbar(frame, orient=VERTICAL, command=self._scroll)
        rulleskakt.pack(expand=YES, fill=Y)
        self.elementer[0]['yscrollcommand']=rulleskakt.set
    def _select(self, y):
        row = self.elementer[0].nearest(y)
        self.selection_clear(0, END)
        self.selection_set(row)
        return 'break'
    def _button2(self, x, y):
        for element in self.elementer: element.scan_mark(x, y)
        return 'break'
    def _b2motion(self, x, y):
        for element in self.elementer: element.scan_dragto(x, y)
        return 'break'
    def _scroll(self, *args):
        for element in self.elementer:
            apply(element.yview, args)
    def curselection(self):
        return self.elementer[0].curselection()
    def slet(self, begynd, slut=None):
        for element in self.elementer:
            element.slet(begynd, slut)
    def hent(self, begynd, slut=None):
        result = []
        for element in self.elementer:
            result.append(element.hent(begynd,slut))
        if slut: return apply(map, [None] + result)
        return result
    def indeks(self, indeks):
        self.elementer[0].indeks(indeks)
    def insert(self, indeks, *elements):
        for e in elements:
            i = 0
            for element in self.elementer:
                element.insert(indeks, e[i])
                i = i + 1
    def size(self):
        return self.elementer[0].size()
    def see(self, indeks):
        for element in self.elementer:
            element.see(indeks)
    def selection_anchor(self, indeks):
        for element in self.elementer:
            element.selection_anchor(indeks)
    def selection_clear(self, begynd, slut=None):
        for element in self.elementer:
            element.selection_clear(begynd, slut)
    def selection_includes(self, indeks):
        return self.elementer[0].selection_includes(indeks)
    def selection_set(self, begynd, slut=None):
        for element in self.elementer:
            element.selection_set(begynd, slut)
if __name__ == '__main__':
    win = Tk()
    Label(win, text='Listeboks').pack()
    listeboks = Listeboks(win, (("Overskrift 1", 20), ("Overskrift  2", 10),
    ("Overskrift  3", 10)))
    listeboks.insert(END,("del 1", "del 2", "del 3"))
    listeboks.insert(END,("del 4", "del 5", "del 6"))
    listeboks.insert(END,("del 7", "del 8", "del 9"))
    listeboks.pack(expand=YES,fill=BOTH)
    win.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{15cm}
\includegraphics{w11.jpg}
\end{minipage}
</figure>
</para -->
</sect2>

<sect2 id="wid.rulleskakt">
<title>Scrollbar underklasse i Widget</title>
<para>
Kan vise rulleskakt i canvas, text og list elementer. Eksemplet er vist udfyldeligt under beskrivelsen af Listbox underklassen se evt. der også, men først lige et par eksempler her:
</para>
<para>
<screen>
from Tkinter import *
root = Tk()
class Rulleskakten(Frame):
    def __init__(self, master, **kw):
        apply(Frame.__init__, (self, master), kw)
        vscrollbar = Scrollbar(self, orient=VERTICAL)
        self.canvas = Canvas(self)
        vscrollbar.config(command=self._vscroll)
        vscrollbar.pack(fill=Y, side=RIGHT)
        self.canvas.pack(expand=1, fill=BOTH, side=LEFT)
    def _vscroll(self, type, *arg):
        print type
        if type == 'moveto':
            for i in arg:
                print i
f = Rulleskakten(root)
f.pack(expand=1, fill=BOTH)
root.mainloop()
</screen>
</para>
<para>
<screen>
Eks. 2
import Tkinter
class AutoRulleskakt(Tkinter.Scrollbar):
    def set(self, lo, hi):
	self.after(100,lambda s=self,l=lo,h=hi: s._set(l,h))
    def _set(self,lo,hi):
        print lo, hi
        if float(lo) <= 0.0 and float(hi) >= 1.0:
            self.tk.call("grid", "remove", self)
        else:
            self.grid()
        Tkinter.Scrollbar.set(self, lo, hi)
root = Tkinter.Tk()
frame = Tkinter.Frame(root)
frame.grid()
frame.columnconfigure(0, weight=1)
frame.rowconfigure(0, weight=1)
scrollFrame = Tkinter.Frame(frame)
scrollFrame.columnconfigure(1, weight=1)
scrollFrame.rowconfigure(1, weight=1)
scrollFrame.grid(sticky='news')
vscrollbar = AutoRulleskakt(scrollFrame)
vscrollbar.grid(row=1, column=2, sticky='ns')
hscrollbar = AutoRulleskakt(scrollFrame, orient='horizontal')
hscrollbar.grid(row=2, column=1, sticky='ew')
borderframe = Tkinter.Frame(scrollFrame)
borderframe.rowconfigure(0, weight=1)
borderframe.columnconfigure(0, weight=1)
borderframe.grid(row=1, column=1, sticky='news')
canvas = Tkinter.Canvas(borderframe,
        highlightthickness=0,
        borderwidth=0,
        background = 'green',
        width = 300,
        height = 200,
        scrollregion = (0, 0, 301, 200),
        yscrollcommand=vscrollbar.set,
        xscrollcommand=hscrollbar.set)
canvas.grid(sticky='news')
vscrollbar.config(command=canvas.yview)
hscrollbar.config(command=canvas.xview)
root.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{15cm}
\includegraphics{w12.jpg}
\end{minipage}
</figure>
</para -->
</sect2>

<sect2 id="wid.menuknap">
<title>Menubutton underklasse i Widget</title>
<para>
Menubutton viser popup eller pull-down menu.
</para>
<para>
<screen>
from Tkinter import *
root    = Tk()
menuknap = Menubutton(root, text='Byer')
picks   = Menu(menuknap)
menuknap.config(menu=picks)
picks.add_command(label='Hasle',  command=root.quit)
picks.add_command(label='Aakirkeby',  command=root.quit)
picks.add_command(label='Gudhjem', command=root.quit)
menuknap.pack()
menuknap.config(bg='white', bd=4, relief=RAISED)
root.mainloop()
</screen>
</para>
</sect2>

<sect2 id="wid.optmenuknap">
<title>OptionMenu underklasse i Widget</title>
<!-- para>
<figure>
\begin{minipage}{10cm}
\includegraphics{w14.jpg}
\end{minipage}
</figure>
</para -->
<para>
som menuknap, men viser valgmenu.
</para>
<para>
<screen>
from Tkinter import *
win = Tk()
var1 = StringVar()
var2 = StringVar()
opt1 = OptionMenu(win, var1, 'byer', 'Gudhjem',  'Tejn')
opt2 = OptionMenu(win, var2, 'erhverv',  'turisme', 'fiskeri')
opt1.pack(fill=X)
opt2.pack(fill=X)
var1.set('byer')
var2.set('erhverv')
def state(): print var1.get(), var2.get()
Button(win, command=state, text='Valgmenu').pack()
win.mainloop()
</screen>
</para>
</sect2>

<sect2 id="python-bibfunk">
 <title>Biblioteksfunktioner</title>
 <para>
<screen>
eks. 1
>>> # Opret et bibliotek (en folder):
>>> import os
>>> os.mkdir("bibliotek")
eks. 2
>>> # Opret bibliotek i bibliotek:
>>> import os
>>> os.mkdir("bibliotek/bib2")
</screen>
<!-- figure>
\begin{minipage}{10cm}
\includegraphics{biblioteker.jpg}
\end{minipage}
</figure -->
</para>
<para>
<screen>
eks. 3
Eller naturligvis som:
>>> import os
>>> os.mkdir("bibliotek")
>>> os.mkdir("bibliotek/bib1")
>>> os.mkdir("bibliotek/bib2")
</screen>
</para>
<para>
eks. 4
Alternativ opret bibliotek i bibliotek:
>>> import os
>>> os.mkdir("/home/bruger/bibliotek/bib1/bib2")
</para>
<para>
<screen>
eks. 5
>>> # Skift til bibliotek og
>>> # opret bibliotek i det:
>>> import os
>>> os.chdir("bibliotek")
>>> os.mkdir("bib1")
</screen>
</para>
<para>
Ser du på Pythons faq (kan findes på www.python.org), vil du konstatere, at der
er lavet en lang række mere eller mindre kunstfærdige
løsninger på netop et eksempel som eks. 5 Udviklingen
af sådanne ting kan måske være meget interessante, men
skal tingene være praktisk anvendelige, er der nok ofte
mere konstruktive løsninger. Hvis man som her ønsker at
oprette et bibliotek i et bibliotek, må man kunne skifte
til sidstnævnte som eks. os.chdir("bibliotek"). I dette 
tilfælde, er det nødvendigt at befinde sig det sted,
hvor bibliotek eksisterer.
</para>
<para>
<screen>
>>> import os
>>> os.chdir("bibliotek")
Traceback (most recent call last):
  File "&lt;pyshell\#4&gt;", line 1, in -toplevel-
    os.chdir("bibliotek")
OSError: [Errno 2] No such file or directory: 'bibliotek'
>>> 
</screen>
</para>
<para>
Da det seneste kald var os.chdir("bibliotek"), og dette 
bibliotek ikke findes får vi en af Pythons normalt fremragende 
fejlmeldinger, hvad den også er denne gang. Den er virkelig god,
men gamle Comal 80 har mig bekendt været det eneste computersprog,
der nogensinde har eksisteret på dansk og dermed i stand til at 
give danske fejlmeldinger, så computersprog og engelsk er det 
normale.
</para>
<para>
Men selvom fejlmeldingen er fremragende, så er vi ligesom nødt til 
at bruge den konstruktivt, hvad vi har mulighed for med try..except,
som jeg også er inde på flere andre steder i bogen.
</para>
<para>
<screen>
eks. 6//
skift biblioteksnavn:
>>> import os
>>> os.rename("/home/bruger/bibliotek","/home/bruger/folder")
</screen>
</para>
<para>
eks. 7//
Fjern bibliotek:
>>> import os
>>> os.chdir("bibliotek")
>>> os.rmdir("bib1")
</para>
<para>
<screen>
eks. 8//
Alternativ fjern bibliotek:
>>> import os
>>> os.chdir("bibliotek")
>>> os.rmdir("/home/bruger/bibliotek/bib1")
</screen>
</para>
</sect2>
</sect1>
</chapter>
