<chapter id="python-library-ref">
<title>Biblioteks reference</title>
<sect1 id="rep">
<title>Repr funktionen</title>

<para>
<screen>
Eksempler på anvendelse af repr funktionen:
>>> print "Rønne"
Rønne
>>> print str("Rønne")
Rønne
>>> print repr("Rønne")
'R\xf8nne'

>>> str(0.1)
'0.1'
>>> repr(0.1)
'0.10000000000000001'

>>> x = 10 * 3.25
y = 200 * 200
s = 'Værdien af x er ' + repr(x) + ', af y er den ' + repr(y) + '...'
print s>>> >>> >>>
Værdien af x er 32.5, af y er den 40000...

>>> x = 20; y = x ** 3
>>> repr((x, y, ('tomater', 'ostemad')))
"(20, 8000, ('tomater', 'ostemad'))"
>>>
</screen>
</para>
</sect1>

<sect1 id="python-strings">
<title>Tekststrenge</title>
<para>
En tekststreng er alt mellem dobbelte eller enkelte anførselstegn
<screen>
Tekststeng mellem dobbelte anførselstegn:
>>> print "Velkommen til Python!"
Velkommen til Python!
</screen>
</para>
<para>
Tekststeng mellem enkelte anførselstegn:
>>> print 'Velkommen til Python!'
Velkommen til Python!
</para>
<para>
print "Tekststreng med \"dobbelte anførselstegn.\""
print 'En streng med "dobbelte anførselstegn."'
print 'Tekststreng med \'enkelte anførselstegn.\''
print "En streng med 'enkelte anførselstegn.'"
print """Strengen her har "dobbelte anførselstegn"og 'enkelte anførselstegn'.
   Du kan tilmed udskrive over flere linjer."""
print '''Denne streng har også "dobbelte"og 'enkelte' anførselstegn.'''
</para>
<para>
Anførselstegnene skal være samme slags:
>>> 'Velkommen til Python! "
SyntaxError: EOL while scanning single-quoted string
</para>
<para>
>>> "Velkommen til Python! '
SyntaxError: EOL while scanning single-quoted string
</para>
<para>
print "Velkommen\ntil\n\nPython!"
</para>
<para>
Strenge kan lægges sammen:
>>> print "Velkommen " + 'til Python'
Velkommen til Python
</para>
<para>
Strenge kan gentages:
>>> print "Velkommen til Python! " * 3
Velkommen til Python! Velkommen til Python! Velkommen til Python!
</para>
<para>
>>> 'Velkommen til Python! ' * 3
'Velkommen til Python! Velkommen til Python! Velkommen til Python! '
</para>
<para>
Strenge kan sammenlignes:
>>> "æøå" < "ÆØÅ"
False
>>> "ÆØÅ" < "æøå"
True
>>>
>>> 'Python' < 'Pascal'<'ABC' < 'C'
False
>>>
>>> 'ABC' > 'C' < 'Pascal' < 'Python'
True
>>>
'ABC' < 'C' < 'Pascal' < 'Python'
False
>>> 'ABC' == 'C' == 'Pascal' == 'Python'
False
>>>
>>> 4 == "fire"
False
>>>
</para>
<para>
</para>
<para>
Strenge kan indskrives med raw_input:
integer1 = raw_input( "Skriv et helt tal: " )  # read en streng
integer1 = int( integer1 )   # Konverter strengen til heltal
</para>
<para>
heltal2 = raw_input( "Enter endnu et heltal: " ) # indskriv streng
integer2 = int( heltal2 )   # et heltal og an integer er det samme
</para>
<para>
 # Kopier indholdet i integer1 og heltal2 til sum
sum = integer1 + heltal2
</para>
<para>
print "Summen af de to heltal er ", sum
</para>
<para>
Linjeskifte indsættes med \n
>>> print "Velkommen\ntil\n\nPython!"
Velkommen
til
</para>
<para>
Python!
</para>
<para>
Tabulatorskifte indsættes med \t
>>> print "Velkommen\ttil\t\tPython!"
Velkommen       til             Python!
Bemærk her at tekstfunktionerne oftes knyttes til tekststrengen
som f.eks. streng.funktionsnavn()
</para>
<para>
# Skriv første streng og konverter til heltal
tal1 = raw_input( "Indskriv første integer: " )
tal1 = int( tal1)
</para>
<para>
# Skriv anden streng og konverter til heltal
tal2 = raw_input( "Indskriv anden integer: " )
tal2 = int( tal2)
</para>
<para>
if tal1 == tal2:
   print "%d er lig med %d" % ( tal1, tal2)
</para>
<para>
if tal1!= 2:
   print "%d er forskellig fra %d" % ( tal1, tal2)
</para>
<para>
if tal1< 2:
   print "%d er mindre end %d" % ( tal1, tal2)
</para>
<para>
if tal1> 2:
   print "%d er større end %d" % ( tal1, tal2)
</para>
<para>
if tal1<= 2:
   print "%d er mindre end eller lig med %d" % ( tal1, tal2)
</para>
<para>
if tal1>= 2:
   print "%d er større end eller lig med %d" % ( tal1, tal2)
</para>
<para>
>>> heltal = 414
>>> heltal
414
>>> print heltal
414
>>> print "Decimaltal %d" % heltal
Decimaltal 414
>>> print "Hexadecimal tal %x" % heltal
Hexadecimal tal 19e
</para>
<para>
</para>
<para>
>>> for i in range(1,10):
...     print "Oktale tal: %o"%i
...
Oktale tal: 1
Oktale tal: 2
Oktale tal: 3
Oktale tal: 4
Oktale tal: 5
Oktale tal: 6
Oktale tal: 7
Oktale tal: 10
Oktale tal: 11
</para>
<para>
>>> kommatal = 12.4
>>> print "Kommatal (float) %f" % kommatal
Kommatal (float) 12.400000
>>> print "Forvalgt eksponent %e" % kommatal
Forvalgt eksponentnotation 1.240000e+01
</para>
<para>
>>> # Udskriver med fordefineret tabulatorbredde 8 tegn
>>> heltal = 414
>>> print "Højre justeret heltal (%8d)" % heltal
Højre justeret heltal (     414)
>>> print "Venstre justeret heltal (%-8d)" % heltal
Venstre justeret heltal (414     )
</para>
<para>
streng = "Streng formatering"
>>> heltal = 25
>>> print "Gennemtving 8 cifre i heltal %.8d" % heltal
Gennemtving  8 cifre i heltal 00000025
</para>
<para>
>>> kommatal = 12.1
>>> print "Gennemtving 6 cifre efter komme i float %.6f " % kommatal
Gennemtving 6 cifre efter komme i float 12.100000
</para>
<para>
</para>
<para>
>>> streng = "I alle de riger og lande..."
>>> print "(%.15s) (%.5s)" % ( streng, streng )
(I alle de riger) (I all)
</para>
<para>
En streng er en liste. Her udskrives streng som liste:
>>> s = "Dette er en streng."
>>> l = len(s) # len finder strenglængde
>>> for i in range(0,l):
...     print s[i],
...
D e t t e   e r   e n   s t r e n g .
</para>
<para>
</para>
<para>
eks. 1
capitalize() funktionen konverterer strengens
første bogstav til "stort" bogstav.
</para>
<para>
>>> import string
>>> "dette er en mulig anvendelse".capitalize()
'Dette er en mulig anvendelse'
</para>
<para>
eks. 2 Eksempel 1 på en anden måde
</para>
<para>
<screen>
>>> import string
>>> streng = "rødgrød med fløde er godt."
>>> streng.capitalize()
'R\xf8dgr\xf8d med fl\xf8de er godt.'
ELLER:
>>> print streng.capitalize()
Rødgrød med fløde er godt.
</screen>
</para>
<para>
De fleste af de mange andre tekstfunktioner anvendes svarende til eksempel
1 og 2 ovenfor. BEMÆRK hvordan de danske specialtegn erstattes med
hexadecimale værdier i den første udskrift. Det skyldes, at Python
benytter 2 forskellige funktioner i immediate mode ved returneringen
str() og repr(), hvad følgende kan vise:
</para>
<para>
<screen>
>>> print str("rødgrød med fløde er godt.")
rødgrød med fløde er godt.
>>> print repr("rødgrød med fløde er godt.")
'r\xf8dgr\xf8d med fl\xf8de er godt.'
</screen>
</para>
<para>
eks. 3
center(bredde)funktionen placerer en delstreng i en streng, hvis længde
angives af det tal, der indsættes i parameterlisten her markeret med
variablen bredde.
</para>
<para>
<screen>
>>> import string
>>> streng = "Rønne er hovedstaden på Bornholm."
>>> s = streng.center(60)
>>> s
'             R\xf8nne er hovedstaden p\xe5 Bornholm.              '
>>> print s
             Rønne er hovedstaden på Bornholm.
</screen>
</para>
<para>
<screen>
Samme eksempel mere "naturlig":
>>> import string
>>> print "Rønne er hovedstaden på Bornholm.".center(60)
             Rønne er hovedstaden på Bornholm.
</screen>
</para>
<para>
eks. 4//
count(delstreng,begyndMed,slutMed) tæller antal forekomster af delstreng
i streng.
</para>
<para>
<screen>
>>> import string
>>> streng = "Rønne og Åkirkeby er to bornholmske byer."
>>> # Da der ikke er angivet hverken start- eller slutpunkt
>>> # tælles der op i hele strengen.
>>> streng.count("e")
5
>>> streng.count("e",6,15)
1
</screen>
</para>
<para>
<screen>
Eller:
>>> import string
>>> "Rønne og Åkirkeby er to bornholmske byer.".count("e")
5
</screen>
</para>
<para>
eks. 5
endswith(delstreng, startplads, slutplads) funktionen fortæller, det
den siger - om det er sandt/falskt at strengen slutter delstrengen. Som
vi har set andre steder, så er 1 lig med sand, mens 0 betyder falsk.
</para>
<para>
<screen>
>>> import string
>>> streng = "Hammershus er Nordeuropas største borgruin."
>>> streng.endswith(".")
1
>>> streng.endswith("n",10, len(streng) - 1)
1
>>> streng.endswith("n",10,12)
0
</screen>
</para>
<para>
<screen>
Eller:
>>> import string
>>> s1 = "Hammershus er Nordeuropas største borgruin.".endswith(".")
>>> strenglengde = len("Hammershus er Noreuropas største borgruin")
>>> s2 = "Hammershus er Nordeuropas største borgruin.".endswith("n",10,strenglengde)
>>> s3 = "Hammershus er Nordeuropas største borgruin.".endswith("n",10,12)
>>> print s1, s2, s3
True True False
>>> s1, s2, s3
(True, True, False)
</screen>
</para>
<para>
Det første af de to eksempler er udført i Python 2.2, det sidste i
Python 2.3 derfor forskellen i returneringen af sandhedsværdierne.
</para>
<para>
eks. 6//
expandtabs([antalTomme]) returnerer en ny streng, hvori alle
tabulatorstop er erstattet af mellemrum. Det valgfrie argument
antalTomme specificerer antal mellemrum  der erstatter en
tabulatorindrykning. Det forvalgte antal er 8 tegn mellem hvert
tabulatorstop.
Bemærk \t for tabulator.
</para>
<para>
>>> import string
</para>
<para>
<screen>
>>> t = "En streng\t streng"
>>> t
'En streng\t streng'
>>> t.expandtabs(30)
'En streng                      streng'
</screen>
</para>
<para>
eks. 7
find(delstreng,startplads, slutplads) viser en delstrengs position i
en streng.
</para>
<para>
<screen>
>>> import string
>>> streng = "Børnene leger i skolegården."
>>> streng.find("ø")
1
>>> streng.find("å")
22
</screen>
</para>
<para>
</para>
<para>
Hvis du tæller efter, synes det som om Python er gal på den - kan Python
ikke regne? Jo, men det er vist et faktum i alle normale computersprog,
at en streng er en form for tabel, og så er den god nok, for det er
vist også fast, at en tabels første værdi er placeret som tabelelement
nummer nul. Det betyder, at ø reelt er element nummer 1 og å element
nummer 22 som vist ovenfor. Du kan opnå den "rigtige" position således:
</para>
<para>
<screen>
>>> streng.find("ø") + 1
2
</screen>
</para>
<para>
<screen>
Funktionen returnerer -1, hvis ikke delstrengen findes.
>>> streng.find("ø",2,)
-1
</screen>
</para>
<para>
eks. 8
index(delstreng, startplads, slutplads) viser en delstrengs position i
en streng. Udfører samme funktion som find(delstreng, startplads,
slutplads), men i stedet for at returnere -1 returneres en ValueError
exception, hvis ikke delstrengen findes i strengen.
</para>
<para>
<screen>
>>> import string
>>> streng = "Børnene leger i skolegården."
>>> streng.index("ø")
1
>>> streng.index("å")
22
>>> streng.index("q")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ValueError: substring not found in string.index
</screen>
</para>
<para>
Python melder to ting 1: fejlen findes i linje 1 (tabelcelle 2)
og 2: delstrengen "ø" blev ikke fundet.
</para>
<para>
eks. 9
isalnum() returnerer 1 (sand), hvis strengen ene og alene indeholder
alfanummeriske tegn (bogstaver og tal) ellers returneres nul.
</para>
<para>
<screen>
>>> import string
>>> streng = "Bornholm2003"
>>> streng.isalnum()
1
>>> streng = "Bornholm 2003"
>>> streng.isalnum()
0
</screen>
</para>
<para>
Der er en ASCII 32 (mellemrum) i strengen derfor 0.
</para>
<para>
<screen>
eller:
>>> import string
>>> print "Bornholm2003".isalnum(),"Bornholm 2003".isalnum()
True False
</screen>
</para>
<para>
eks. 10
isalpha() returnerer 1 hvis strengen ene og alene indeholder alfabetiske
karakterer  (bogstaver) ellers returneres 0
<screen>
>>> import string
>>> streng = "Børnenelegeriskolegården"
>>> streng.isalpha()
1
>>> streng = "Børnene leger i skolegården."
>>> streng.isalpha()
0
</screen>
</para>
<para>
eks. 11
isdigit() returnerer 1, hvis strengen ene og alene indeholder tal,
ellers returneres 0.
</para>
<para>
<screen>
>>> import string
>>> streng ="0123456789"
>>> streng.isdigit()
1
>>> streng ="0123456789 "
>>> streng.isdigit()
0
>>> streng ="0.123456789"
>>> streng.isdigit()
0
</screen>
</para>
<para>
eks. 12
islower() funktionen returnerer 1, hvis alle bogstaver i strengen er
"små".
</para>
<para>
<screen>
>>> import string
>>> streng = "det er efterår nu"
>>> streng.islower()
1
>>> streng = "Det er efterår nu"
>>> streng.islower()
0
>>> streng = "vi er i efteråret 2003"
>>> streng.islower()
1
</screen>
</para>
<para>
<screen>
eller:
>>> import string
>>> "vi er i efteråret 2003.".islower()
True
</screen>
</para>
<para>
eks. 13
isspace() returnerer 1, hvis strengen ene og alene indeholder tomme
(ASCII 32) ellers returneres 0.
</para>
<para>
<screen>
>>> streng = ""
>>> streng.isspace()
0
>>> streng = " "
>>> streng.isspace()
1
>>> streng = "    "
>>> streng.isspace()
1
>>> streng = " 1 "
>>> streng.isspace()
0
>>> streng = " K "
>>> streng.isspace()
0
</screen>
</para>
<para>
eks. 14
istitle() I en engelsk bogtittel begynder det enkelte ord (som regel)
med "store" bogstaver, deraf funktionsnavnet. Selve funktionen
returnerer derfor 1, hvis der ene og alene forekommer "store" bogstaver
som de enkelte ords første bogstav ellers returneres 0. Det kan føre
til, at selv velkendte stavemåder kan returnere nul og omvendt, hvad
dette eksempel vil vise:
</para>
<para>
<screen>
>>> # Først den forkerte stavemåde:
>>> streng = "Suse Linux"
>>> streng.istitle()
1
>>> # Så den rigtige stavemåde:
>>> import string
>>> streng = "SuSE Linux"
>>> streng.istitle()
0
</screen>
</para>
<para>
eks. 15//
isupper() funktionen returnerer 1, hvis alle bogstaver i strengen er "store".
</para>
<para>
<screen>
>>> import string
>>> streng = "SuSE Linux" # normale skrivemåde
>>> streng.isupper()
0
>>> streng = "SUSE LINUX" # unormal skrivemåde
>>> streng.isupper()
1
>>> streng = "SUSE LINUX 8.2"
>>> streng.isupper()
1
</screen>
</para>
<para>
</para>
<para>
eks. 16
join(sekvens) knytter en strengliste (eller en delstreng) sammen med
streng som "ordstyrer" og danner en lang streng.
</para>
<para>
<screen>
>>> import string
>>> strengliste  = ["1","2","3","4","5","6"]
>>> streng
'123456'
</screen>
</para>
<para>
eller:
>>> streng = "".join(strengliste) + str(89)
>>> streng
'12345689'
</para>
<para>
<screen>
eller:
>>> ". listeelement   ".join(strengliste) + ". listeelement."
'1. listeelement   2. listeelement   3. listeelement
4. listeelement   5. listeelement   6. listeelement.'
>>>
</screen>
</para>
<para>
eks. 17
ljust(bredde) ligner center(bredde) funktionen, hvis anvendelse
tidligere er vist. Her placeres delstrengen bare venstrejusteret i den
tomme streng, hvis længde angives med breddeargumentet.
</para>
<para>
<screen>
>>> import string
>>> streng = "Venstrejusteret".ljust(20)
>>> streng
'Venstrejusteret     '
</screen>
</para>
<para>
</para>
<para>
eks. 18//
lower() lower() konverterer alle bogstaver til "små".
</para>
<para>
<screen>
>>> import string
>>> "DETTE ER KUN EN TESTSTRENG".lower()
'dette er kun en teststreng'
</screen>
</para>
<para>
<screen>
"Der skal 12 til et dusin.".lower()
'der skal 12 til et dusin.'
</screen>
</para>
<para>
eks. 19//
lstrip() fjerner tomme (ASCII 32) i strengens begyndelse - venstre side.
</para>
<para>
<screen>
>>> import string
"    Dette er en teststreng.".lstrip()
'Dette er en teststreng.'
</screen>
</para>
<para>
eks. 20
replace(gamle,nye,maksimale) erstatter en "gammel" tekstsreng med en ny.
Hvis du ikke ønsker at udskifte samtlig eksistende "gamle" med nye, kan
et maksimalt antal udskiftninger angives.
</para>
<para>
<screen>
>>> import string
>>> "En plads i haven".replace("hav","sol")
'En plads i solen'
</screen>
</para>
<para>
<screen>
>>> 20 udskiftninger er ikke mulig, da der kun er 1
>>> "En plads i haven".replace("hav","sol",20)
'En plads i solen'
</screen>
</para>
<para>
eks. 21
rfind(delstreng , startplads, slutplads) finder positionen af den sidste
delstreng i en streng. Hvis delstrengen ikke findes returneres -1.
</para>
<para>
<screen>
>>> import string
>>> streng = "Der er en klippefast grund til at besøge Bornholm."
>>> streng.rfind("e")
39
</screen>
</para>
<para>
<screen>
eller:
>>> import string
>>> "Der er en klippefast grund til at besøge Bornholm.".rfind("e")
39
</screen>
</para>
<para>
<screen>
eller:
>>> import string
>>> l = len("Der er en klippefast grund til at besøge Bornholm.")
>>> "Der er en klippefast grund til at besøge Bornholm.".rfind("e",len(streng) - 10,l)
-1
</screen>
</para>
<para>
eks. 22
rindex(delstreng,startpunkt,slutpunkt) virker fuldstændig som rfind
funktionen, men i stedet for at returnere -1, hvis delstrengen ikke
findes returneres en ValueError.
</para>
<para>
<screen>
>>> import string
>>> streng = "Tidligere anvendtes Dueoddes sand i timeglas."
>>> streng.rindex("i")
37
>>> streng.rindex("ven")
12
>>> streng.rindex("dk")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ValueError: substring not found in string.rindex
</screen>
</para>
<para>
Fejlmeldingen siger, at delstrengen "dk" ikke findes i streng.
</para>
<para>
eks. 23//
rjust(bredde) svarer til center(bredde) og ljust(bredde) bortset fra at delstrengen her placeres højrejusteret i strengen.
</para>
<para>
<screen>
>>> import string
>>> "h".rjust(30)
'                             h' # Et enkelt bogstav er også en streng.
</screen>
</para>
<para>
eks. 24//
rstrip() fjerner tomme (ASCII 32) i HØJRE side af en streng.
</para>
<para>
<screen>
>>> # Python 2.2 afvikling:
>>> import string
>>> "    En unødvendig lang streng        ".rstrip()
'    En un\xf8dvendig lang streng'
>>> # Python 2.3 afvikling:
>>> import string
>>> print "    En unødvendig lang streng        ".rstrip()
    En unødvendig lang streng
</screen>
</para>
<para>
eks. 25
split(seperator) Opdeler tekststreng i delstrenge, der indsættes i
liste. Hvis ikke der indsættes seperator deles ved ASCII 32
(mellemrum).
</para>
<para>
<screen>
>>> import string
>>> "Dette er kun en teststreng.".split()
['Dette', 'er', 'kun', 'en', 'teststreng.']
</screen>
</para>
<para>
<screen>
>>> "Dette\n er\n kun\n en teststreng.".split("\n")
['Dette', ' er', ' kun', ' en teststreng.']
</screen>
</para>
<para>
eks. 26
split(seperator) Retuarnerer en liste af delstrenge dannet ved at dele
den oprindelige streng ved hver seperator. Hvis seperatoren ikke
anvendes eller er sat til None, deles strengen ved hver mellemrum 
(ASCII 32)
</para>
<para>
<screen>
>>> import string
>>> "Tejn\nog\nGudjem\n er\nvelkendte turistbyer.".split()
['Tejn', 'og', 'Gudjem', 'er', 'velkendte', 'turistbyer.']
>>> "Tejn\nog\nGudjem\n er\nvelkendte turistbyer.".split("\n")
['Tejn', 'og', 'Gudjem', ' er', 'velkendte turistbyer.']
</screen>
</para>
<para>
eks. 27
splitlines([1])returnerer en liste af delstrenge fremkommet ved at
dele den oprindelige streng ved hver ny linje karakter. Hvis
parameteret 1 indsættes bevares ny linje skiftet i delstrengene se
nederste del af eksemplet.
</para>
<para>
<screen>
>>> import string
>>> "Dette er\nen meget \nlang streng, \n der deles\ni delstrenge.".splitlines(1)
['Dette er\n', 'en meget \n', 'lang streng, \n', ' der deles\n', 'i delstrenge.']
>>> "Dette er en meget lang streng, der deles i delstrenge.".splitlines()
['Dette er en meget lang streng, der deles i delstrenge.']
>>> "Dette er\nen meget \nlang streng, \n der deles\ni delstrenge.".splitlines()
['Dette er', 'en meget ', 'lang streng, ', ' der deles', 'i delstrenge.']
</screen>
</para>
<para>
eks. 28
startswith(delstreng,startpunkt,slutpunkt) returnerer 1, hvis strengen
begynder med delstrengen ellers nul.
</para>
<para>
<screen>
>>> import string
>>> "Denne streng er en violinstreng.".startswith("Den")
1
>>> "Denne streng er en violinstreng.".startswith("en")
0
</screen>
</para>
<para>
eks. 29//
strip() fjerner mellemrum i strengens begyndelse og slutning
<screen>
>>> # Python 2.2 afvikling:
>>> import string
>>> "      Har du været på Christiansø?     ".strip()
'Har du v\xe6ret p\xe5 Christians\xf8?'
>>> import string
>>> "      Har du været på Christiansø?     ".strip()
'Har du v\xe6ret p\xe5 Christians\xf8?'
>>> print "      Har du været på Christiansø?     ".strip()
Har du været på Christiansø?
</screen>
</para>
<para>
eks. 30//
swapcase() konverterer alle "store" bogstaver til små og omvendt.
</para>
<para>
<screen>
>>> import string
>>> "dANMARK ER VEL TRODS ALT ET GODT LAND.".swapcase()
'Danmark er vel trods alt et godt land.'
>>> "eR DANSKERNE ALT?".swapcase()
'Er danskerne alt?'
</screen>
</para>
<para>
eks. 31
title() Returnerer en streng, hvori første bogstav af strengens
enkeltord og kun dem er med stort begyndelsesbogstav.
</para>
<para>
<screen>
>>> import string
>>> "er uldjyder lådne?".title()
'Er Uldjyder L\xe5dne?'
</screen>
</para>
<para>
>>> "eR brAndMænd meget iltre?".title()
'Er Brandm\xe6nd Meget Iltre?'
</para>
<para>
<screen>
eller:
>>> import string
>>> "er uldjyder lådne?".title()
'Er Uldjyder L\xe5dne?'
>>> s = "er uldjyder lådne?".title()
>>> print s
Er Uldjyder Lådne?
</screen>
</para>
<para>
eks. 32//
\upper() konverterer alle bogstaver til "store" bogstaver
</para>
<para>
<screen>
>>> import string
>>> "var forfatteren nexø fra nexø?".upper()
'VAR FORFATTEREN NEX\xd8 FRA NEX\xd8?'
</screen>
</para>
<para>
eller:
>>> import string
>>> "var forfatteren nexø fra nexø?".upper()
'VAR FORFATTEREN NEX\xd8 FRA NEX\xd8?'
>>> print "var forfatteren nexø fra nexø?".upper()
VAR FORFATTEREN NEXØ FRA NEXØ?
</para>
<para>
Brødmaskinen (slicing):
>>> streng = "naturlig"
>>> streng[4]
'r'
>>> streng[0:2]
'na'
>>> streng[2:4]
'tu'
>>> streng[:2]
'na'
>>> streng[2:]
'turlig'
>>> 'u' + streng[1:]
'uaturlig'
>>> streng[:2] + streng[2:]
'naturlig'
>>> streng[:3] + streng[3:]
'naturlig'
>>>
</para>
<para>
<screen>
zfill funktionen gør det, den siger fylder op med zeros (nuller)
opfyldningen sker altid til venstre:
import string
string.zfill('12', 5)
'00012'
string.zfill('-3.14', 7)
'-003.14'
string.zfill('3.14159265359', 5)
'3.14159265359'
</screen>
</para>
</sect1>

<sect1 id="python-range">
<title>Range</title>
<para>
<screen>
syntaks: range(begynd, slut - 1, step) - slut er nødvendig.
>>> range(11)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9.10]
>>> range(0,21,2)
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
>>> range(0,40,3)
[0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39]
>>> range(1,-11,-1)
[1, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10]
>>> range(40,0,-5)
[40, 35, 30, 25, 20, 15, 10, 5]
>>> for i in range(1,11):
...     print i,
...
1 2 3 4 5 6 7 8 9 10
Range fungerer også ved nedtælling:
>>> for i in range(10,0, -1):
...     print i,
...
10 9 8 7 6 5 4 3 2 1
>>> for i in range(100,0, -5):
...     print i,
...
100 95 90 85 80 75 70 65 60 55 50 45 40 35 30 25 20 15 10 5
>>>
2 metoder til udskrift af kvadrat- og kubiktal:
>>> import string
>>> for x in range(1, 11):
...     print string.rjust(repr(x), 2), string.rjust(repr(x*x), 3),
...     print string.rjust(repr(x*x*x), 4)
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
>>> for x in range(1,11):
...     print '%2d %3d %4d' % (x, x*x, x*x*x)
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
</screen>
</para>
</sect1>

<sect1 id="python-filer">
<title>Læs og skriv filer</title>
<para>
<screen>
heleTeksten= open('filnavn.txt').read()    # hent hele indholdet i en tekstfil
alleData = open('fuldeFilsti', 'rb').read() # hent hele indholdet i en binær fil

filObjekt  = open('filnavn.txt')
heleTeksten = filObjekt.read()
filObjekt.close()
listeAfAlleLinjer = filObjekt.readlinjes()
listeAfAlleLinjer = filObjekt.read().splitlinjes(1)
listeAfAlleLinjer = filObjekt.read().splitlinjes()
listeAfAlleLinjer = filObjekt.read().split('\n')
listeAfAlleLinjer = list(filObjekt)

filObjekt = open('fuldeFilsti', 'rb')
while 1:
    blok = filObjekt.read(100)
    if not blok: break
    anvend blokken (f.eks. til udskrift)
filObjekt.close()

for linje in open('filnavn.txt'):
    print linje

filObjekt = open('filnavn.txt')
while 1:
    linje = filObjekt.readlinje()
    if not linje: break
    print linje
filObjekt.close()
</screen>
</para>
<para>
<screen>
open('filnavn.txt', 'w').write(heleTeksten)  # skriv tekst til en tekstfil
open('fuldeFilsti', 'wb').write(alleData)    # skriv binære data til en binær fil

filObjekt = open('filnavn.txt', 'w')
filObjekt.write(heleTeksten)
filObjekt.close()

filObjekt.writelines(listeAfAlleTekststrenge)
open('fuldeFilsti', 'wb').writelines(listeAfAlleDataStrenge)
</screen>
</para>

<sect2 id="python-filer-2">
<title>Hent fil linje for linje</title>

<programlisting>
import linecache

fuldeFilsti = "autoexec.bat"
valgteLinjenummer = 0

linjen = linecache.getline(fuldeFilsti, valgteLinjenummer)

# getline er fordefineret i Python
def getline(fuldeFilsti, valgteLinjenummer):
    if valgteLinjenummer < 1: return ''
    aktuelleLinjeNummer = 0
    for linje in open(fuldeFilsti):
        aktuelleLinjeNummer += 1
        if aktuelleLinjeNummer == valgteLinjenummer: return linje
    return ''

for linje in open(fuldeFilsti).xreadlines():
	print linje
</programlisting>
</sect2>

<sect2 id="python-filer-3">
<title>Find antal linjer i tekstfil</title>

<para>
<screen>
import linecache
fuldeFilsti = "autoexec.bat"

antalLinjer = len(open(fuldeFilsti).readlines())
print antalLinjer
</screen>
</para>
</sect2>

<sect2 id="python-filer-4">
<title>Skriv til udfil</title>

<programlisting>
import sys
try:
   udfil = open( "filnavn.txt", "w" )
except IOError, melding:
   	print >> sys.stderr, "Fejlmelding:", melding
   	sys.exit( 1 )

udtekst = ""
tekst = " "

while len(tekst) > 0:
	tekst = raw_input( "Skriv tekstlinje (tom lukker fil): " )
	udtekst += tekst + "\n"

print >> udfil, udtekst        # skriv tekst til udfil
udfil.close()
print "Udfilen er lukket."
</programlisting>

<para>
Kørselsresultat:
<screen>
python udfilNy.py
Skriv tekstlinje (tom lukker fil): Ny tekst i ny udfil."
Skriv tekstlinje (tom lukker fil):
Udfilen er lukket.
</screen>
</para>
<para>
Indhold i den nyoprettede filnavn.txt
Ny
fil i ny udfil
</para>
</sect2>

<sect2 id="python-filer-5">
<title>Hent fil i Python (Linux) bibliotek</title>
<para>
<screen>
import sys
try:
   indfil = open( "/usr/lib/python2.2/calendar.py", "r" )
except IOError:
   print >> sys.stderr, "Filen blev ikke hentet ind."
   sys.exit( 1 )

indtekst = indfil.read()
print str(indtekst)
indfil.close()
print
print "Filen er lukket."

import sys
try:
   udfil = open( "filnavn.txt", "wb" )
except IOError, melding:
   	print >> sys.stderr, "Fejlmelding:", melding
   	sys.exit( 1 )

udtekst = ""
tekst = " "

while len(tekst) > 0:
	tekst = raw_input( "Skriv tekstlinje (tom lukker fil): " )
	udtekst += tekst + "\n"

print >> udfil, str(udtekst )      # skriv tekst til udfil
udfil.close()
print "Udfilen er lukket."
</screen>
</para>
</sect2>

<sect2 id="python-filer-6">
<title>Gem liste i fil</title>
<para>
<screen>
import sys
try:
   udfil = open( "filnavn.txt", "w" )
except IOError, melding:
   	print >> sys.stderr, "Fejlmelding:", melding
   	sys.exit( 1 )
</screen>
</para>
<para>
liste = [1,2,3,4,5,6,7,8,9]
</para>
<para>
print >> udfil, str(liste )      # skriv liste  til udfil
udfil.close()
print "Udfilen er lukket."
</para>
<para>
filnavn.txt kontrol viser indholdet:
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</para>
</sect2>

<sect2 id="python-filer-7">
<title>Udvid fil (append)</title>
<para>
<screen>
import sys
try:
   udfil = open( "filnavn.txt", "a" )
except IOError, melding:
   	print >> sys.stderr, "Fejlmelding:", melding
   	sys.exit( 1 )
udtekst = ""
tekst = " "
while len(tekst) > 0:
	tekst = raw_input( "Skriv tekstlinje (tom lukker fil): " )
	udtekst += tekst + "\n"
print >> udfil, str(udtekst )      # skriv tekst til udfil
udfil.close()
print "Udfilen er lukket."
</screen>
</para>
</sect2>

<sect2 id="python-filer-8">
<title>Læs fra fil</title>

<programlisting>
import sys
try:
   udfil = open( "filnavn.txt", "w" )
except IOError, melding:
   	print >> sys.stderr, "Fejlmelding:", melding
   	sys.exit( 1 )

udtekst = ""
tekst = " "

while len(tekst) > 0:
	tekst = raw_input( "Skriv tekstlinje (tom lukker fil): " )
	udtekst += tekst + "\n"

print >> udfil, str(udtekst )      # skriv tekst til udfil
udfil.close()
print "Udfilen er lukket."
</programlisting>
<para>
BEMÆRK:  str funktionen kræves a.h.t. dansk/norske specialtegn.
</para>
<para>
Kørselsresultat:
ajbo@linux:~> python indfil.py
['Microsoft får en ordentlig bredside i en ny rapport fra den amerikanske \n',
'organisation Computer & Communications Industry Association (CCIA). Manglen \n',
 'på ordentlig sikkerhed i Microsofts programmer og det faktum, at Windows er \n',
 'det mest udbredte styresystem i verden, betyder tilsammen, at verden generelt \n',
 'er blevet mere sårbar overfor trusler mod sikkerheden, konkluderer rapporten.\n']
</para>
<para>
Filen er lukket.
ajbo@linux:~>
</para>
<para>
Teksten er uddrag fra en Netavisen Infopaq mail udsendt/modtaget 24. sept 03
</para>
</sect2>

<sect2 id="python-filer-9">
<title>Skriv bytes til udfil</title>
<para>
<programlisting>
import sys
try:
   udfil = open( "filnavn.txt", "wb" )
except IOError, melding:
   	print >> sys.stderr, "Fejlmelding:", melding
   	sys.exit( 1 )

udtekst = ""
tekst = " "

while len(tekst) > 0:
	tekst = raw_input( "Skriv tekstlinje (tom lukker fil): " )
	udtekst += tekst + "\n"

print >> udfil, str(udtekst )      # skriv tekst til udfil
udfil.close()
print "Udfilen er lukket."
</programlisting>
</para>
<para>
Fra kørselsresultat:
filnavn.txt indeholder:
Nu går vi over til at udsende teksten i antal bytes.
Flere bytes skrives til filen.
</para>
</sect2>

<sect2 id="python-filer-10">
<title>Hent bytes fra fil</title>

<para>
<programlisting>
import sys

try:
   indfil = open( "filnavn.txt", "rb" )
except IOError:
   print >> sys.stderr, "Filen blev ikke hentet ind."
   sys.exit( 1 )

indtekst = indfil.readlines()
print str(indtekst)
indfil.close()
print
print "Filen er lukket."
</programlisting>
</para>
<para>
Kørselsresultat:
<screen>
ajbo@linux:~> python indfilBytes.py
['Nu går vi over til at udsende teksten i antal bytes.\n',
 'Flere bytes skrives til filen.\n', '\n', '\n']
Filen er lukket.
ajbo@linux:~>
</screen>
</para>
</sect2>

<sect2 id="python-filer-11">
<title>Hent bytes fra fil eksempel 2</title>
<para>
Til dette eksempel har jeg benyttet command.com fra Microsoft Windows Me
</para>
<programlisting>
import sys

try:
	indfil = open( "/windows/C/command.com", "rb" )
except IOError:
   	print >> sys.stderr, "Filen blev ikke hentet ind."
   	sys.exit( 1 )

indtekst = indfil.read()
print str(indtekst)
indfil.close()
print
print "Filen er lukket."
</programlisting>
<para>
Kørselsresultat (uddrag af den store udskrift):
enhed   Den terminalenhed, som du vil bruge, f.eks. COM1.
1Viser eller indstiller datoen.
</para>
<para>
DATE [dato]
</para>
<para>
Skriv DATE uden parametre for at f vist den aktuelle datoindstilling og
for at kunne angive en ny. Tryk p ENTER for at beholde den nuvrende dato.
aSletter en eller flere filer.
</para>
</sect2>

<sect2 id="python-filer-12">
<title>Hent bytes fra fil eksempel 3</title>
<para>
I dette eksempel læses filen vinduer.jpg, der også benyttes et andet
sted i bogen.
</para>
<programlisting>
import sys
try:
   indfil = open( "vinduer.jpg", "rb" )
except IOError:
   print >> sys.stderr, "Filen blev ikke hentet ind."
   sys.exit( 1 )

indtekst = indfil.read()
print str(indtekst)
indfil.close()
print
print "Filen er lukket."
</programlisting>
<para>
Kørselsresultat (ganske kort uddrag af returgodset)
<screen>
python indfilBytes3.py
ÿØÿàJFIFHHÿþLEAD Technologies Inc. V1.01ÿÛC
</screen>
</para>
</sect2>

<sect2 id="python-filer-13">
<title>Søg og erstat tekst i fil</title>

<programlisting>
#!/usr/bin/env python
import os, sys

antalArgumenter = len(sys.argv)

if not 3 <= antalArgumenter <= 5:
    print "Anvend: %s tekstAtFinde erstatningsTekst [indfil [udfil]]" % \
        os.path.basename(sys.argv[0])
else:
    findeTekst = sys.argv[1]
    erstatteTekst = sys.argv[2]
    input = sys.stdin
    output = sys.stdout
    if antalArgumenter > 3:
        input = open(sys.argv[3])
    if antalArgumenter > 4:
        output = open(sys.argv[4], 'w')
    for s in input.xreadlines():
        output.write(s.replace(findeTekst, erstatteTekst))
    output.close()
    input.close()
</programlisting>
<para>
<screen>
 Et kørselsresultat:
python erstatTekst.py
Anvend: erstatTekst.py tekstAtFinde erstatningsTekst [indfil [udfil]]
</screen>
Når filen søges afviklet uden de nødvendige parametre udskrives der som
vist en anvisning på, hvordan kaldet skal foregå. sys.argv[0] er selve
programmets navn (erstatTekst.py). I Python bøger er det normalt at
angive valgfrie parametre i firkantede parenteser. Det er altså i
herværende tilfælde ikke absolut nødvendigt at angive en indfils navn,
det samme er tilfældet med en udfils navn. Udeladelse af de to navne er
imidlertid upraktisk i det aktuelle tilfælde, så et kald kunne være:
<screen>
python erstatTekst.py "Microsoft" "Linux" "/windows/C/autoexec.bat" "autoexec.bat"
</screen>
Der er bare det ved det, at ordet "Microsoft" næppe forekommer i
autoexec.bat filen. Resultatet vil altså alene blive at filen bliver
kopieret fra Microsoft Windows biblioteket til rodbiblioteket i Linux,
men det kan jo også være fint nok.
</para>
<para>
<screen>
import os, sys, string
indfil = open( "/windows/C/autoexec.bat", "r" )
udfil = open( "autoexec.bat", "w" )
findeTekst = "WINDOWS"; erstatteTekst = "Linux"
for s in indfil.readlines():
	udfil.write(string.replace(s, findeTekst, erstatteTekst))
indfil.close
udfil.close
</screen>
</para>
<para>
Før programafvikling:
SET windir=C:\WINDOWS
SET winbootdir=C:\WINDOWS
SET COMSPEC=C:\WINDOWS\COMMAND.COM
SET PATH=C:\WINDOWS;C:\WINDOWS\COMMAND
SET PROMPT=$p$g
SET TEMP=C:\WINDOWS\TEMP
SET TMP=C:\WINDOWS\TEMP
</para>
<para>
Efter programafvikling:
SET windir=C:\Linux
SET winbootdir=C:\Linux
SET COMSPEC=C:\Linux\COMMAND.COM
SET PATH=C:\Linux;C:\Linux\COMMAND
SET PROMPT=$p$g
SET TEMP=C:\Linux\TEMP
SET TMP=C:\Linux\TEMP
</para>
<para>
De to linjer:
for s in indfil.readlines():
	udfil.write(string.replace(s, findeTekst, erstatteTekst))
</para>
<para>
Kan også skrives:
for s in indfil:
	udfil.write(s.replace(findeTekst, erstatteTekst))
</para>
<para>
Lad Python fortælle, hvad et modul indeholder:
<screen>
>>> sys
&lt;module 'sys' (built-in)>
</screen>
</para>
<para>
returstrengen fortæller, at sys er et i Python indbygget (fordefineret)
modul. sys inkluderes i dette eksempel ene og alene for at kunne lukke
programmet ned, når der klikkes på knappen. Herved udføres kommandoen
root.exit
</para>
<para>
I interaktiv mode kan det undertiden være vanskeligt at få kørslen
stoppet og komme ud af programmet. I Windows kan du komme ud ved at
trykke på Ctrl og Z tasten samtidig. I Linux skulle du kunne komme ud
ved at trykke samtidig på Ctrl og D. I SuSE 8.2 skal du imidlertid
trykke Ctrl C for at komme ud. Men det korte og det lange er, at
sys.exit og nævnte tastetryk har samme virkning.
</para>
<para>
Vi kan også få at se, hvad modulet indeholder:
</para>
<para>
<screen>
>>> import sys
>>> dir (sys)
['__displayhook__', '__doc__', '__excepthook__', '__name__', '__stderr__',
'__stdin__', '__stdout__', '_getframe', 'argv', 'builtin_module_names',
'byteorder', 'copyright', 'displayhook', 'dllhandle', 'exc_info',
'exc_type', 'excepthook', 'exec_prefix', 'executable', 'exit',
'getdefaultencoding', 'getrecursionlimit', 'getrefcount',
'hexversion', 'last_traceback', 'last_type', 'last_value',
'maxint', 'maxunicode', 'modules', 'path', 'platform', 'prefix', 'ps1',
'setcheckinterval', 'setprofile', 'setrecursionlimit', 'settrace', 'stderr',
'stdin', 'stdout', 'version', 'version_info', 'warnoptions', 'winver']
</screen>
</para>
</sect2>
</sect1>

<sect1 id="python-tid">
 <title>Tidsfunktioner</title>

 <para>
  Tidsfunktioner
 </para>

<sect2 id="python-tid-1">
<title>Timemodulet</title>

<screen>
>>> import time
>>> type(time) # unødvendigt bevis for dig
&lt;type 'module'>

>>> time.time()
1064465521.312474
>>> time.gmtime()
(2003, 9, 25, 4, 53, 17, 3, 268, 0)
>>> time.localtime()
(2003, 9, 25, 6, 53, 46, 3, 268, 1)
>>> time.asctime()
'Thu Sep 25 06:54:19 2003'
>>> t = time.localtime()
>>> aar = t[0]
>>> aar
2003
>>> maaned = t[1]
>>> maaned
9
>>> dag = t[2]
>>> dag
25

>>> # pausefunktion
>>> # kontrol :   >>>  fremkommer efter pause på 10 sekunder.
>>> time.sleep(10)
>>>
</screen>
</sect2>

<sect2 id="python-tid-2">
<title>Datetime modulet</title>

<screen>
>>> import datetime
>>> type(datetime)  # unødvendigt bevis for dig
&lt;type 'module'>

>>> nu = datetime.datetime.now()
>>> nu.isoformat()
'2003-09-25T05:41:32.611578'
>>> nu.ctime()
'Thu Sep 25 05:41:32 2003'
>>> nu.strftime("%D %d %b")
'09/25/03 25 Sep')
>>> nu.strftime("%D %d")
'09/25/03 25'

>>> Dag = nu.strftime("%d")
>>> Dag
'25'

>>> Timetal24 = nu.strftime("%H")
>>> Timetal24
'07'

>>> Timetal12 = nu.strftime("%I")
>>> Timetal12
'07'

>>> AmPmLokal = nu.strftime("%p")
>>> AmPmLokal
'AM'
>>> EngelskEfterskrift = nu.strftime("%H") + nu.strftime("%p")
>>> EngelskEfterskrift
'07AM'
>>> # eller:
>>> EngelskEfterskrift = nu.strftime("%H") + nu.strftime("%p")
>>> EngelskEfterskrift = nu.strftime("%H") + " " + nu.strftime("%p")
>>> EngelskEfterskrift
'07 AM'

>>> # Funktionen beregner ugenummeret 1 for lavt
>>> # derfor nedenstående omregning
>>> Ugenummer = int(Ugenummer) + 1
>>> Ugenummer
39
>>> # konverteret til streng:
>>> Ugenummer = str(Ugenummer)
>>> Ugenummer
'39'

>>> # Søndag er ugens første dag (element 0)
>>> UgedagDecimal = nu.strftime("%w")
>>> UgedagDecimal
'4'

>>> AArstalKort = nu.strftime("%y")
>>> AArstalKort
'03'

>>> AArstalLang = nu.strftime("%Y")
>>> AArstalLang
'2003'
</screen>
</sect2>
</sect1>
</chapter>

<chapter id="vkm">
 <title>Vinduer, knapper og meget mere</title>
 <para>
GUI komponenter skal stilles på plads i en kontainer. Det sker primært med Pack metoden.
</para>
<para>
Medmindre en programmør specificerer (angiver) en anden rækkefølge, vil Pack placere komponenterne i kontaineren fra skærmtop til -bund i den rækkefølge, hvori de er listede i programmet.
</para>
<para>
Du har en række valgmuligheder (options), når komponenterne (tekstboksene, menuerne, knapperne og de øvrige grafiske objekter) skal placeres i kontaineren (ofte Frame). Option "side" angiver, hvor i kontaineren, komponentet skal placeres.
Sættes side = TOP (er forvalgt af Python) pakkes komponenterne lodret (vertically). Andre mulige side værdier er BOTTOM
(bund), LEFT (venstre) og RIGHT (højre). Option "fill" kan være NONE (den forvalgte værdi), X, Y og BOTH sikrer at et komponent udfylder al den plads, der er afsat til den i den angivne retning. Option expand kan tildeles værdierne YES
(1) og NO (0). Hvis expand er sat til YES udvides komponentet til at udfylde al ledig plads i kontaineren. Optionerne padx og pady indsætter tom plads rundt om komponentet. Metoden pack_forget fjerner et pakket komponent fra kontaineren.
</para>
<para>
Hvis Canvas komponentet bliver brugt alene som her, oprettes et fuld færdigt vindue:
</para>
<para>
<screen>
>>> from Tkinter import Canvas
>>> Canvas().pack()
>>> from Tkinter import *
>>> class Kanvas(Canvas):
...     def _init_(self):
...             Canvas._init_(self).pack()
...
>>>
</screen>
</para>
<para>
Der defineres en klasse, som benytter underklassen Canvas's kode. Denne klasse tildeles startværdier (initieres heraf forkortelsen init). Initieringen kaldes en konstruktør eller fuldt ud klassekonstruktøren. Både den programlinje, hvori klassen defineres (klassehovedet) og konstruktøren er blokke, så begge steder skal de efterfølgende programlinjer rykkes ind til højre. Da self først fungerer i og med initieringen, må det være klart, at self stammer fra selve klassen, hvorfor det viste eksempel også kunne skrives:
</para>
<para>
<screen>
>>> from Tkinter import *
>>> class Kanvas(Canvas):
...     def _init_(Kanvas):
...             Canvas._init_(Kanvas).pack()
...
>>>
</screen>
</para>
<para>
Medmindre en programmør specificerer (angiver) en anden rækkefølge, vil Pack placere komponenterne i kontaineren fra skærmtop til -bund i den rækkefølge, hvori de er listede i programmet.
</para>
<para>
<screen>
from Tkinter import *
from tkMessageBox import askyesno, showerror

class Dialog(Frame): # arver Frame
    def __init__(self, master=None): #Dialogs konstruktør
        Frame.__init__(self, master) # Frames konstruktør
        Pack.config(self)
        self.opretArvinger()

    def Hilsen(self): # arver Dialog
        print "En hilsen fra Bornholm til dig!" #sendes til skal, men kunne være til fil

    def opretArvinger(self): # arver Dialog
        Label(self,  text='Hej! jeg vil gerne i dialog med dig.').pack(side=TOP)
        Button(self, text='Popup 1', command=self.dialog1).pack() # arver opretArvinger
        Button(self, text='Popup 2', command=self.dialog2).pack()
        Button(self, text='Noget til dig',  command=self.Hilsen  ).pack(side=LEFT)
        Button(self, text='Afslut',  command=self.quit   ).pack(side=RIGHT)

    def dialog1(self):  # arver Dialog
        svar = askyesno("Vil du se tkMessageBox\ndialogen i funktion?")
	if svar: self.dialog2()

    def dialog2(self):  # arver Dialog
        showerror("BESKYTTET AFSNIT", "\nHer har du vist ingen adgang min ven...")


</screen>

 <!-- figure>
  \begin{minipage}{12cm}
  \includegraphics{gui_1.jpg}
  \end{minipage}>
 </figure -->
</para>
</chapter>
<chapter id="wid">
 <title>Widget klassen</title>
 <para>
Et grafisk bruger interface (grafical user inteface heraf forkortelsen GUI) giver brugeren mulighed for at kommunikere interaktivt med et program. GUIs sammensættes af GUI komponenter (kaldet widgets - en forkortelse for windows finesser). Et GUI komponent er et objekt hvormed en bruger som antydet kan kommunikere interaktivt med et program via mus og eller tastatur. Ved brug af Tool Command Language (forkortet TCL) og dets værktøjskit (Tool Kit forkortet Tk - et bibliotek af fordefinerede klasser, subklasser m.v.) kan Python programmører konstruere GUIs. Hvordan det gøres skal vi se på i en lang række eksempler.
</para>
<para>
<screen>
>>> from Tkinter import Frame
>>> Frame().pack()
</screen>
</para>
<para>
>>> # Her ses at Frame er en klasse tilhørende Tkinter:
>>> Frame
&lt;class Tkinter.Frame at 0x405ecd4c>
</para>
<para>
Vi får også at vide, at koden til Frame eller rettere
indledningen til den er pladeret på den hexadecimale adresse \x405ecd4c.
</para>
<para>
<screen>
>>> frame
&lt;Tkinter.Frame instance at 0x402e8b8c>
>>>
</screen>
</para>
<para>
Det følgende kald til Tk (from Tkinter import *) kan være farligt, og bør absolut kun anvendes ved kald, hvor du er sikker, på at kaldet virkelig kan bruges. Det der er farligt, er at du ved at benytte navne f.eks. på variabler og funktioner, hvis navne også findes i det importerede modul, vil blive overstyret  (på engelsk overrided). Det betyder, at det bliver de navne du har tilføjet, der vil fungere og dermed bestemme dit programs funktion. På den anden side, hvis du er sikker, på at du ikke vil komme til at overstyre navne i det eller de importerede modul/moduler, så er det stjernekaldet, du bør bruge. Lad os lige få en kvittering, på at det forholder sig som nævnt:
</para>
<para>
<screen>
>>> from Tkinter import *
>>> dir(Tkinter)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
NameError: name 'Tkinter' is not defined
>>>
</screen>
</para>
<para>
Fortolkeren kender ikke Tkinter, hvorfor Tkinter ikke kan eksistere i dit program. Det er kun det for dit program nødvendige, der bliver hentet ind. Hvis vi var i tvivl, om hvorvidt Tkinter kan klare kaldet from Tkinter import *, så er det eneste rigtige, vi kan gøre, at benytte kaldet import Tkinter i stedet for from Tkinter import *.
</para>
<para>
<screen>
>>> import Tkinter
>>> Tkinter
&lt;module 'Tkinter' from '/usr/local/lib/python2.3/lib-tk/Tkinter.pyc'>
>>> '
</screen>
</para>
<para>
Funktionen dir kan vise indholdet i et modul. Benyttes det igen, får vi en udskrift af indholdet i modulet - nu kender fortolkeren Tkinter. Jeg har ikke taget ret meget af den lange udskrift med her, så lav lige kontrollen selv også.
</para>
<para>
<screen>
>>> import Tkinter
>>> dir(Tkinter)
['ACTIVE', 'ALL', 'ANCHOR', 'ARC', 'At', 'AtEnd', 'AtInsert',.........']
>>>
</screen>
</para>
<para>
<screen>
Et allerede vist eksempel så således ud:
>>> from Tkinter import Frame
>>> Frame().pack()
>>>
</screen>
</para>
<para>
Sublassen Frame blev importeret og derefter anvendt direkte. Da det var selve Frame, der blev importeret og brugt, må det være indlysende, at der i kaldet  Frame().pack() ikke bliver tilført nogen anden form for kode - Frames parameterliste er da også tom. Det behøver den ikke at være. Det følgende eksempel har nøjagtig samme funktion som det ovenstående. parrent = None fortæller nøjagtig det samme, at der ikke kommer nogen form for kode til den, der er indeholdt i Frame - der er ingen parrent (direkte oversat forældre på dansk mor).
</para>
<para>
<screen>
>>> from Tkinter import Frame
>>> Frame(parrent = None).pack()
>>>
</screen>
</para>
<para>
Subklassen arver fra Frame, så subklassens self refererer til Frame som den kommer fra
Tkinter. mor = None kan godt forvirre lidt på dette sted, for Klasse har jo Frame til mor, så reelt er der en mor, men Klasse er på arvetidspunktet  som alle andre klassearvinger en direkte kopi af moderen. De tre eksemplers første 4 linjer ændrer ikke noget som
helst på arvegodset, så mor = None fortæller konkret, at Frame ingen mor har, og det er jo korrekt. Når det er fastslået, er det også
klart, at self repræsenterer selve subklassen Klasse. Når det er tilfældet, vil det samme eksempel også kunne skrives således:
</para>
<para>
<screen>
from Tkinter import *
class Klasse(Frame):                 # Opret subklasse
    def __init__(Klasse, side=TOP):
        Frame.__init__(Klasse)       # Subklassekonstruktor
        Klasse.pack()
        Klasse.make_widgets()        # metodekald
    def make_widgets(Klasse):
        Button(Klasse,
            text="Klik her", command=Klasse.quit).pack(side=LEFT)
if __name__ == '__main__': Klasse().mainloop()
</screen>
</para>
<para>
<screen>
import tkSimpleDialog
x = tkSimpleDialog.askinteger("Vælg et heltal",
"mellem 1 og 6:",initialvalue = 1, minvalue = 1, maxvalue = 6)
</screen>
</para>

 <sect1 id="wid.rammen">
  <title>Frame underklasse i Widget</title>
  <para>
Frame komponentets formål er at være kontainer for andre komponenter. Det før viste eksempel kunne bl.a. også skrives således:
</para>
<para>
<screen>
I dette dette eksempel udnyttes det importerede modul direkte.
from Tkinter import Frame
Frame().pack()
</screen>
</para>
<para>
<screen>
Her oprettes og bruges en kopi af det importerede modul.
>>> from Tkinter import Frame
>>> frame = Frame()
>>> frame.pack()
>>>
>>> from Tkinter import *
>>> frame = Frame()
>>> frame.pack()
>>>
>>> from Tkinter import *
>>> frame = Frame().pack(expand = YES, fill = BOTH)
>>>
</screen>
</para>
<para>
Frame er subklasse i Widget klassen (barn af Widget). Frame arver dermed Widget klassens egenskaber. Det betyder imidlertid ikke, at alle egenskaber i fuldt omfang kan overføres til barnet - pack vil altid være knyttet til moderobjektet - i dette tilfælde til Frame. Derfor rykker pack()  op på den programlinje, hvori objektkopien (barnet) oprettes:
</para>
<para>
<screen>
>>> # Her importeres hele Tkinter modulet:
>>> import Tkinter
>>> # Her ser vi, hvad Tkinter er for noget:
>>> Tkinter
&lt;module 'Tkinter' from '/usr/local/lib/python2.3/lib-tk/Tkinter.pyc'>
>>>
</screen>
</para>
<para>
Svaret var, at Tkinter er et modul, at det blev importeret fra /usr/local/lib/python2.3/lib-tk/ biblioteket og at det var fra en kompileret
fil Tkinter.pyc - det ses på at den sædvanlige filtype py er udvidet med et c. Det normale er, at en kompileret fil er væsentlig hurtigere, men sådan er det ikke i Python. Her kan der vindes ganske ubetydelig tid, lige i det øjeblik koden hentes ind i computeren ellers ikke.
</para>
<para>
<screen>
>>> from Tkinter import Frame
>>> Her stilles Frames objekter på plads:
>>> Frame().pack()
</screen>
</para>
<para>
<screen>
>>> # Her ses at Frame er en klasse tilhørende Tkinter:
>>> Frame
&lt;class Tkinter.Frame at 0x405ecd4c&gt;
</screen>
</para>
<para>
Vi får også at vide, at koden til Frame eller rettere indledningen til den er pladeret på den hexadecimale adresse 405ecd4c.
</para>
<para>
<screen>
>>> frame
&lt;Tkinter.Frame instance at 0x402e8b8c&gt;
>>>
</screen>
</para>
<para>
>>> from Tkinter import *
>>> class vindue(Frame):
...     def _init_(self):
...             Frame._init_(self)
...             self.pack(expand = YES, fill = BOTH)
...
</para>
<para>
<screen>
Programlinjen
 Frame().pack(expand = YES, fill = BOTH)
genkendes let i:
Frame._init_(self)
self.pack(expand = YES, fill = BOTH)
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{8cm}
\includegraphics{w1.jpg}
\end{minipage}
</figure>
</para -->
</sect1>

 <sect1 id="wid.labelen">
  <title>Label underklasse i Widget</title>
  <para>
En label kan vise ikke editerbar tekst plus ikoner.
</para>
<para>
<!-- figure>
\begin{minipage}{12cm}
\includegraphics{w2.jpg}
\end{minipage}
</figure -->
</para>
<para>
</para>
<para>
Af fordefinerede ikoner er der følgende:
</para>
<para>
ikoner = ["error","hourglass","info", "questhead","question",
"warning", "gray75", "gray50", "gray25", "gray12"]
</para>
<para>
from Tkinter import *
win = Tk()
ikoner = ["error","hourglass","info", "questhead","question",
"warning", "gray75", "gray50", "gray25", "gray12"]
ikon = []
for i in range(0,len(ikoner)):
	ikon = ikoner[i]
	Label(win,bitmap = ikon).pack(expand = YES, fill= Y)
</para>
<para>
</para>
<para>
>>> from Tkinter import *
>>> win = Tk()
>>> Label(win,text = "Tekst kan skrives i label.").pack(expand = NO, fill = X)
>>>
</para>
<para>
>>> from Tkinter import *
>>> root = Tk()
>>> Label(root,text = "Men teksten kan ikke rettes.").pack(expand = YES, fill = X)
>>>
</para>
<para>
from Tkinter import *
root = Tk()
skrift = ("times", 20, "bold")
label = Label(root, text="Der kan skrives paa en label.")
label.config(bg="black", fg="white")
label.config(font=skrift)
label.config(height=4, width=30)  # plads til 4 linjer a 30 tegn
label.pack(expand=YES, fill=BOTH)
root.mainloop()
</para>
<para>
from Tkinter import *
# label1, label2 og label3 arver Label klassen med dens pack funktion (metode)
label1 = Label(text ="Enkelt, men omfattende.").pack(expand = NO, side = LEFT)
label2 = Label(text ="Lige i centrum.").pack(expand = NO, side = TOP)
label3 = Label(text ="Total trods enkel.").pack(expand = NO, side = RIGHT)
mainloop()
</para>
<para>
eller f.eks. :
</para>
<para>
from Tkinter import *
label1 = Label(text ="Enkelt, men omfattende.").pack(expand = YES, side = LEFT)
label2 = Label(text ="Lige i centrum.").pack(expand = YES, side = TOP)
label3 = Label(text ="Total trods enkel.").pack(expand = YES, side = RIGHT)
mainloop()
</para>
<para>
from Tkinter import *
root = Tk()
skrift = ("times", 20, "bold")
label = Label(root, text="Der kan skrives paa en label.")
label.config(bg="black", fg="white")
label.config(font=skrift)
label.config(height=4, width=30)  # plads til 4 linjer a 30 tegn
label.pack(expand=YES, fill=BOTH)
root.mainloop()
</para>
<para>
<screen>
from Tkinter import *
class LabelDemo( Frame ):
   def __init__( self ):  # LabelDemos konstruktør
      Frame.__init__( self )   # mor Frames konstruktør
      self.pack( expand = YES, fill = BOTH )
      self.master.title( "Labels" )
      self.label1 = Label( self, text = "Label med tekst" )
      self.label1.pack()
      self.label2 = Label( self,
         text = "Label med tekst og bitmap (ikon)" )
      self.label2.pack( side = LEFT )
      self.label3 = Label( self, bitmap = "questhead" )
      self.label3.pack( side = LEFT )
def main():
   LabelDemo().mainloop()
if __name__ == "__main__":
   main()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{12cm}
\includegraphics{w2_2.jpg}
\end{minipage}
</figure>
</para -->
</sect1>

 <sect1 id="wid.enLinjet">
  <title>Entry underklasse i Widget</title>
  <para>
Entry er et en-linjes input område, der kan modtage input fra tastaturet eller vise information.
</para>
<para>
<screen>
>>> from Tkinter import *
>>> Entry().pack()
>>> from Tkinter import *
>>> root = Tk()
>>> Entry(root).pack()
>>>
from Tkinter import *
root = Tk()
Directions = Label(root, text ='Hvilken fil ønskes hentet?')
Directions.config(anchor=W)
inputBox = Entry(root, width=60)
Directions.pack()
inputBox.pack()
mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{12cm}
\includegraphics{w3_1.jpg}
\end{minipage}
</figure>
</para -->
<para>
<screen>
from Tkinter import *
from tkMessageBox import *
class EntryDemo( Frame ):
   def __init__( self ):
      Frame.__init__( self )
      self.pack( expand = YES, fill = BOTH )
      self.master.title( "Test datamodtagere" )
      self.master.geometry( "325x100" )
      self.frame1 = Frame( self )
      self.frame1.pack( pady = 5 )
      # text1 oprettes som barnebarn af Frame
      # entry er endnu en underklasse i Widget klassen (læs barn af)
      self.text1 = Entry( self.frame1, name = "tekst1" )
      self.text1.bind( "&lt;Return&gt;", self.visIndhold )
      self.text1.pack( side = LEFT, padx = 5 )
      self.text2 = Entry( self.frame1, name = "tekst2" )
      self.text2.insert( INSERT, "Skriv tekst her" )
      self.text2.bind( "&lt;Return&gt;", self.visIndhold )
      self.text2.pack( side = LEFT, padx = 5 )
      self.frame2 = Frame( self )
      self.frame2.pack( pady = 5 )
      self.text3 = Entry( self.frame2, name = "tekst3" )
      self.text3.insert( INSERT, "Ikke editerbar tekstboks" )
      self.text3.config( state = DISABLED )
      self.text3.bind( "&lt;Return&gt;", self.visIndhold )
      self.text3.pack( side = LEFT, padx = 5 )
      self.text4 = Entry( self.frame2, name = "tekst4",
                          show = "*" )
      self.text4.insert( INSERT, "Hemmelig tekst" )
      self.text4.bind( "&lt;Return&gt;", self.visIndhold )
      self.text4.pack( side = LEFT, padx = 5 )
   def visIndhold( self, event ):
      navn = event.widget.winfo_name()
      indhold = event.widget.get()
      showinfo( "Melding", navn + ": " + indhold )
def main():
   EntryDemo().mainloop()
if __name__ == "__main__":
   main()
</screen>
</para>
<para>
</para>
<!-- para>
<figure>
\begin{minipage}{15cm}
\includegraphics{w3.jpg}
\end{minipage}
</figure>
</para -->
<para>
</para>
</sect1>

 <sect1 id="wid.tekstboks">
  <title>Text underklasse i Widget</title>
  <para>
Text modtager input fra tastaturet eller viser information. I modsætning til Entry komponentet er Text et areal, der kan
modtage mange tekstlinjer.
</para>
<para>
<screen>
from Tkinter import *
class tekstFunktioner(Frame):
    def __init__(self, parent=None, tekst='', indfil=None):
        Frame.__init__(self, parent)
        self.pack(expand=YES, fill=BOTH)
        self.opretArvinger()
        self.tekstvalg(tekst, indfil)
    
    def opretArvinger(self):
        rulleskakt = Scrollbar(self)
        tekst = Text(self, relief=SUNKEN)
        rulleskakt.config(command=tekst.yview)      # xlink rulleskakt og tekst
        tekst.config(yscrollcommand=rulleskakt.set)    # flyttes en flyttes alle
        rulleskakt.pack(side=RIGHT, fill=Y)            # pack først = clip sidst
        tekst.pack(side=LEFT, expand=YES, fill=BOTH)   # tekst clipped først
        self.tekst = tekst

    def tekstvalg(self, tekst='', indfil=None):
        if indfil:
            tekst = open(indfil, 'r').read()
        self.tekst.delete('1.0', END)                       # slet hele teksten
        self.tekst.insert('1.0', tekst)                       # tekst ind linje 1 pos 0
        self.tekst.mark_set(INSERT, '1.0')     # set insert cursor
        self.tekst.focus()                                            # gem brugervalg

    def hentTekst(self):                                        # returner streng
        return self.tekst.get('1.0', END+'-1c')  # hele teksten

if __name__ == '__main__':
    root = Tk()
    try:
        streng = tekstFunktioner(indfil=sys.argv[1])  # filnavn på kommandolinje
    except IndexError:
        streng = tekstFunktioner(tekst='Tekst\nindsættes her')
</screen>
</para>
<para>
    def visTekst(event): print repr(streng.hentTekst())     # vis tekst i skal
    root.bind('&lt;Key-Escape&gt;', visTekst)      # klik escape tast = dump tekst
    root.mainloop()
</para>
<!-- para>
<figure>
\begin{minipage}{15cm}
\includegraphics{w4.jpg}
\end{minipage}
</figure>
</para -->
<para>
</para>
<para>
<screen>
from Tkinter import *
</screen>
</para>
<para>
<screen>
# Trin 1: Opret den applikations-klasse (program-klasse), hvori GUI
# og haendelses-metoder (event handling methods) defineres
class Klasse(Frame):
	def __init__(self):
		Frame.__init__(self)
		self.tekstboks = Text(self)
		self.tekstboks.bind("&lt;space&gt;", self.Afslut)
		self.tekstboks.bind("&lt;Key&gt;", self.modtagTastensNummer)
		self.tekstboks.pack()
		self.pack()
	def Afslut(self,event):
		import sys
		sys.exit()
	def modtagTastensNummer(self,event):
		str = "%d\n" % event.keycode
		self.tekstboks.insert(END, str)
		return "break"
# Opret arving og start haendelsesloekken
barn = Klasse()
barn.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{15cm}
\includegraphics{w4_2.jpg}
\end{minipage}
</figure>
</para -->
<para>
<screen>
from Tkinter import *
root = Tk()
def melding(event): print "Modtog melding om klik på knap"
text = Text()
text.config(font=("times", 18, "normal"))    # skrift 18 punkts normal
text.config(height=40, width=60)            # plads til 40 linjer a 60 tegn
text.pack(expand=YES, fill=BOTH)
text.insert(END, "Dette er\n\nmeningen\n\nmed livet.\n\n")   # indsaetter 6 linjer
#linje 1  sender "Modtog melding om klik på knap" til skal (shell)
knap = Button(text, text="Python er andet end slanger.", command=lambda:melding(1))
knap.pack()
text.window_create(END, window=knap)    # indsaetter foto
text.insert(END, "\n\n")
foto  = PhotoImage(file="skyer.gif")
text.image_create(END, image=foto)
# udvider de 6 tekststrenge ovenfor
text.tag_add("udskrift", "1.6", "1.8")
text.tag_add("udskrift", "3.0", "3.8")
text.tag_add("udskrift", "5.4", "5.9")
text.tag_config("udskrift", background="light green")
text.tag_config("udskrift", foreground="red")
text.tag_config("udskrift", font=("helvetica", 24, "underline italic bold"))
text.tag_bind("udskrift", "&lt;Double-1&gt;", melding)
root.mainloop()
</screen>
</para>
<para>
<screen>
from Tkinter import *
root = Tk()
def melding(event): print "Modtog melding om klik på knap"
text = Text()
text.config(font=("times", 18, "normal"))    # skrift 18 punkts normal
text.config(height=40, width=60)            # plads til 40 linjer a 60 tegn
text.pack(expand=YES, fill=BOTH)
text.insert(END, "Dette er\n\nmeningen\n\nmed livet.\n\n")   # indsaetter 6 linjer
#linje 1  sender "Modtog melding om klik på knap" til skal (shell)
knap = Button(text, text="Python er andet end slanger.", command=lambda:melding(1))
knap.pack()
text.window_create(END, window=knap)                          # indsaetter foto
text.insert(END, "\n\n")
foto = PhotoImage(file="skyer2.gif")
text.image_create(END, image=foto)
# udvider de 6 tekststrenge ovenfor
text.tag_add("udskrift", "1.6", "1.8")
text.tag_add("udskrift", "3.0", "3.8")
text.tag_add("udskrift", "5.4", "5.9")
text.tag_config("udskrift", background="light green")
text.tag_config("udskrift", foreground="red")
text.tag_config("udskrift", font=("helvetica", 24, "underline italic bold"))
text.tag_bind("udskrift", "&lt;Double-1&gt;", melding)
root.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{20cm}
\includegraphics{w4_3.jpg}
\end{minipage}
</figure>
</para -->
</sect1>

 <sect1 id="wid.knap">
  <title>Button underklasse i Widget</title>
  <para>
Button  er fordefineret som et komponent tilhørende Widget modulet.
Ved klik med musens markør på knap kan funktion (metode) kaldes.
</para>
<para>
<screen>
from Tkinter import *
class Arving(Frame):   # Klassehovede Arving er barn af  Frame
    def __init__(Arving, mor=None):
        Frame.__init__(Arving, mor)   # initialiser superklasse (superclass)
        Arving.pack()
        Arving.data = 10
        Arving.opret_arvinger()             # forener arvinger med mor
    def opret_arvinger(Arving):
        widget = Button(Arving, text='Knaptekst!', command=Arving.message)
        widget.pack(side=LEFT)
    def message(Arving):
        Arving.data = Arving.data + 1
        print 'Sum %s' % Arving.data # udskriver på skal (kunne være til fil)
if __name__ == '__main__': Arving().mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{12cm}
\includegraphics{w5_3.jpg}
\end{minipage}
</figure>
</para -->
<para>
<screen>
import sys
from Tkinter import *
widget = Button(None, text='Afslut', command=sys.exit)
widget.pack()
widget.mainloop()
>>> # Eksemplet viser funktionskald fra knap
>>> from Tkinter import *
>>> def f(): print "Hej! Jeg er her."
...
>>> Button(text = "Funktionskald", command = f()).pack( pady = 5 )
Hej! Jeg er her.
>>>
</screen>
</para>
<para>
I Python bruger man ofte en såkaldt callback handler. Herved forstår
man en funktion, som den i det følgende eksempel. En callback handler
er en ganske normal metode (funktion) alene med den forskel, at modulet
sys importeres direkte i den, og den i modulet fordefinerede metode
exit() kaldes. Dens eneste formål er at gøre en udgang af en løkke her
mainloop() mulig.
</para>
<para>
<screen>
from Tkinter import *
def quit():                      # en bruger callback handler
    print 'Afslut'       	 # skriver til skal (shell)
    import sys; sys.exit()
knapBarn = Button(None, text='Afslut', command=quit) # command=quit funktionskald
knapBarn.pack()
knapBarn.mainloop()
from Tkinter import *
Button(text='Klik her', padx=10, pady=10).pack(expand = NO, fill = X)
>>> from Tkinter import *
>>> root = Tk()
>>> def Funktion(navn) : print "Hej", navn
...
>>> Button(root,text = "Klik her", command = lambda navn =
"Olsen": Funktion(navn)).pack()
>>> Hej Olsen
from Tkinter import *
knap = Button(text='Klik her', padx=10, pady=10)
knap.pack(padx=20, pady=20)
knap.config(cursor='gumby')
knap.config(bd=8, relief=RAISED)
knap.config(bg='dark green', fg='white')
knap.config(font=('times', 20, 'underline bold italic'))
mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{6cm}
\includegraphics{w5.jpg}
\end{minipage}
</figure>
</para -->
<para>
<screen>
from Tkinter import *
class Arving(Frame):   # Klassehovede Arving er barn af  Frame
    def __init__(Arving, mor=None):
        Frame.__init__(Arving, mor)   # initialiser superklasse (superclass)
        Arving.pack()
        Arving.data = 10
        Arving.opret_arvinger()             # forener arvinger med mor
    def opret_arvinger(Arving):
        widget = Button(Arving, text='Knaptekst!', command=Arving.message)
        widget.pack(side=LEFT)
    def message(Arving):
        Arving.data = Arving.data + 1
        print 'Sum %s' % Arving.data # udskriver på skal (kunne være til fil)
if __name__ == '__main__': Arving().mainloop()
</screen>
</para>
<para>
<screen>
from Tkinter import *
class knapRamme( Frame ):
   def __init__( self ):
      Frame.__init__( self )
      self.master.title( "Knap oprettelse" )
      self.master.geometry( "400x150" )
      self.pack( expand= YES, fill = BOTH )
      self.knap1 = Button( self, text = "Opret ny knap",
         command = self.opretNyKnap ) # funktions kald
      self.knap1.pack( side = TOP )
      self.knap2 = Button( self,
         text = "expand= NO, fill = BOTH" )
      self.knap2.pack( side = BOTTOM, fill = BOTH )
      self.knap3 = Button( self,
         text = "expand= YES, fill = X" )
      self.knap3.pack( side = LEFT, expand= YES, fill = X )
      self.knap4 = Button( self,
         text = "expand= YES, fill = Y" )
      self.knap4.pack( side = RIGHT, expand= YES, fill = Y )
   def opretNyKnap( self ):
      Button( self, text = "Ny knap" ).pack( pady = 5 )
def main():
   knapRamme().mainloop()
if __name__ == "__main__":
   main()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{12cm}
\includegraphics{w5_2.jpg}
\end{minipage}
</figure>
</para -->
</sect1>

 <sect1 id="wid.radioknap">
  <title>Radiobutton underklasse i Widget</title>
  <para>
<screen>
from Tkinter import *
root = Tk()
var  = IntVar()
for i in range(10):
    radioknap= Radiobutton(root, text=str(i), value=i, variable=var)
    radioknap.pack(side=LEFT)
root.mainloop()
print var.get()
</screen>
</para>
<para>
<screen>
from Tkinter import *
root = Tk()
var = StringVar()
for i in range(6):
    radioknap= Radiobutton(root, text=str(i), value=i, variable=var)
    radioknap.pack(side = RIGTH)
root.mainloop()
print var.get()
</screen>
</para>
</sect1>

 <sect1 id="wid.valgmenu">
  <title>Menu underklasse i Widget</title>
  <para>
Menu komponentet kan vise en liste af værdier, hvorfra brugeren kan vælge.
</para>
<para>
<screen>
*+
import sys
from Tkinter import *
win = Tk()
menulinje = Menu(win)
win.config(menu = menulinje)
filmenu = Menu(menulinje)
menulinje.add_cascade(label = "Filer", menu = filmenu)
def udskriv(): print "Udskriv data"
def gem(): print "Gem fil"
filmenu.add_command(label = "Udskriv", command = udskriv)
filmenu.add_command(label = "Gem", command = gem)
filmenu.add_separator()
filmenu.add_command(label = "Afslut", command = sys.exit)
win.mainloop()
v = IntVar()
filmenu.add_radiobutton(label = "Udskriv", var = v, value = 1
filmenu.add_radiobutton(label = "Gem", var = v, value = 2
filmenu.add_radiobutton(label = "Afslut", var = v, value = 3
v = IntVar()
filmenu.add_checkbutton(label = "Hent", var = v, command = hent)
</screen>
</para>
<para>
<screen>
from Tkinter import *
import sys
root = Tk()
menubar = Menu(root)
root.config(menu = menubar)
filmenu = Menu(menubar)
menubar.add_cascade(label = "Filer", menu = filmenu)
def Hent(): print "Hent fil procedurekald ind her"
def Gem(): print "Gem fil procedurekald ind her"
filmenu.add_command(label = "Hent fil", command = Hent)
filmenu.add_command(label = "Gem fil", command = Gem)
filmenu.add_separator()
filmenu.add_command(label = "Luk ned",
command = sys.exit)
root.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{10cm}
\includegraphics{w8.jpg}
\end{minipage}
</figure>
</para -->
</sect1>

 <sect1 id="wid.tegneflade">
  <title>Canvas underklasse i Widget</title>
  <para>
</para>
<para>
<screen>
>>> from Tkinter import *
>>> canvas = Tk()
>>> Canvas(canvas,bg = "light green").pack(expand = YES, fill = BOTH)
</screen>
</para>
<para>
<screen>
from Tkinter import *
spor = 0
class KanvasEvents:
    def __init__(self, parent=None):
        canvasArving = Canvas(width=300, height=300, bg="light green")
        canvasArving.pack()
        canvasArving.bind("&lt;ButtonPress-1&gt;", self.Opstart)
        canvasArving.bind("&lt;B1-Motion&gt;",     self.slet_og_gentegn)
        canvasArving.bind("&lt;Double-1&gt;",      self.slet)
        canvasArving.bind("&lt;ButtonPress-3&gt;", self.flyt)
        self.canvasArving = canvasArving
        self.drawn  = None
        self.kinds = [canvasArving.create_oval, canvasArving.create_rectangle]
    def Opstart(self, event):
        self.shape = self.kinds[0]
        self.kinds = self.kinds[1:] + self.kinds[:1]
        self.start = event
        self.drawn = None
    def slet_og_gentegn(self, event):
        canvasArving = event.widget
        if self.drawn: canvasArving.delete(self.drawn)
        objectId = self.shape(self.start.x, self.start.y, event.x, event.y)
        if spor: print objectId
        self.drawn = objectId
    def slet(self, event):
        event.widget.delete("all")
    def flyt(self, event):
        if self.drawn:
            if spor: print self.drawn
            canvasArving = event.widget
            diffX, diffY = (event.x - self.start.x), (event.y - self.start.y)
            canvasArving.move(self.drawn, diffX, diffY)
            self.start = event
if __name__ == "__main__":
    KanvasEvents()
    mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{15cm}
\includegraphics{w9_1.jpg}
\end{minipage}
</figure>
</para -->
<para>
<screen>
from Tkinter import *
trace = 0
class KanvasEvents:
    def __init__(self, parent=None):
        canvasArving = Canvas(width=300, height=300,
	 bg="light green")
        canvasArving.pack()
        canvasArving.bind("&lt;ButtonPress-1&gt;", self.Opstart)
        canvasArving.bind("&lt;B1-Motion&gt;",     self.slet_og_gentegn)
        canvasArving.bind("&lt;Double-1&gt;",      self.slet)
        canvasArving.bind("&lt;ButtonPress-3&gt;", self.flyt)
        self.canvasArving = canvasArving
        self.drawn  = None
        self.kinds = [canvasArving.create_oval, canvasArving.create_rectangle]
    def Opstart(self, event):
        self.shape = self.kinds[0]
        self.kinds = self.kinds[1:] + self.kinds[:1]
        self.start = event
        self.drawn = None
    def slet_og_gentegn(self, event):
        canvasArving = event.widget
        if self.drawn: canvasArving.delete(self.drawn)
        objectId = self.shape(self.start.x, self.start.y, event.x, event.y)
        if trace: print objectId
        self.drawn = objectId
    def slet(self, event):
        event.widget.delete("all")
    def flyt(self, event):
        if self.drawn:
            if trace: print self.drawn
            canvasArving = event.widget
            diffX, diffY = (event.x - self.start.x), (event.y - self.start.y)
            canvasArving.move(self.drawn, diffX, diffY)
            self.start = event
if __name__ == "__main__":
    KanvasEvents()
    mainloop()
</screen>
</para>
<para>
<screen>
from Tkinter import *
canvas = Canvas(width=500, height=500, bg="light green")
canvas.pack(expand=YES, fill=BOTH)
canvas.create_line(100, 100, 200, 200)      # fraX, fraY, tilX, tilY
canvas.create_line(100, 200, 200, 300)      # tegn  geometr.  former
for i in range(1, 20, 2):
    canvas.create_line(0, i, 50, i)
canvas.create_oval(50, 50, 200, 200, width=2, fill="blue")
canvas.create_arc(200, 200, 300, 100)
canvas.create_rectangle(200, 200, 300, 300, width=5, fill="red")
canvas.create_line(50, 300, 150, 150, width=10, fill="grey")
foto=PhotoImage(file="skyer.gif")
canvas.create_image(350, 300, image=foto, anchor=NW)  # indsaet foto
label = Label(canvas, text="Python er for dig", fg="white", bg="black")
label.pack()
canvas.create_window(100, 100, window=label)        # indsaet en label
canvas.create_text(100, 280, text="og for mig")     # tegn noget tekst
mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{25cm}
\includegraphics{w9.jpg}
\end{minipage}
</figure>
</para -->
</sect1>

 <sect1 id="wid.skala">
  <title>Scale underklasse i Widget</title>
  <para>
<screen>
from Tkinter import *
root = Tk()
skala = Scale(root, from_=-100, to=100, tickinterval=50, resolution=10)
skala.pack(expand=YES, fill=Y)
def metode(): print skala.get() #udskriver i skal (shell)
Button(root, text='status', command= metode).pack(side=RIGHT)
root.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{8cm}
\includegraphics{w10.jpg}
\end{minipage}
</figure>
</para -->
</sect1>

 <sect1 id="wid.listeboks">
  <title>Listbox underklasse i Widget</title>
  <para>
<screen>
Eksemplet viser en udvidet listeboks:
from Tkinter import *
class Listeboks(Frame):
    def __init__(self, mor,elementer):
        Frame.__init__(self,mor)
        self.elementer = []
        for element,w in elementer:
            frame = Frame(self); frame.pack(side=LEFT, expand=YES, fill=BOTH)
            Label(frame, text=element, borderwidth=1, relief=RAISED).pack(fill=X)
            label = Listbox(frame, width=w, borderwidth=0, selectborderwidth=0,
                         relief=FLAT, exportselection=FALSE)
            label.pack(expand=YES, fill=BOTH)
            self.elementer.append(label)
            label.bind('&lt;B1-Motion&gt;', lambda e, s=self: s._select(e.y))
            label.bind('&lt;Button-1&gt;', lambda e, s=self: s._select(e.y))
            label.bind('&lt;Leave&gt;', lambda e: 'break')
            label.bind('&lt;B2-Motion&gt;', lambda e, s=self: s._b2motion(e.x, e.y))
            label.bind('&lt;Button-2&gt;', lambda e, s=self: s._button2(e.x, e.y))
        frame = Frame(self); frame.pack(side=LEFT, fill=Y)
        Label(frame, borderwidth=1, relief=RAISED).pack(fill=X)
        rulleskakt = Scrollbar(frame, orient=VERTICAL, command=self._scroll)
        rulleskakt.pack(expand=YES, fill=Y)
        self.elementer[0]['yscrollcommand']=rulleskakt.set
    def _select(self, y):
        row = self.elementer[0].nearest(y)
        self.selection_clear(0, END)
        self.selection_set(row)
        return 'break'
    def _button2(self, x, y):
        for element in self.elementer: element.scan_mark(x, y)
        return 'break'
    def _b2motion(self, x, y):
        for element in self.elementer: element.scan_dragto(x, y)
        return 'break'
    def _scroll(self, *args):
        for element in self.elementer:
            apply(element.yview, args)
    def curselection(self):
        return self.elementer[0].curselection()
    def slet(self, begynd, slut=None):
        for element in self.elementer:
            element.slet(begynd, slut)
    def hent(self, begynd, slut=None):
        result = []
        for element in self.elementer:
            result.append(element.hent(begynd,slut))
        if slut: return apply(map, [None] + result)
        return result
    def indeks(self, indeks):
        self.elementer[0].indeks(indeks)
    def insert(self, indeks, *elements):
        for e in elements:
            i = 0
            for element in self.elementer:
                element.insert(indeks, e[i])
                i = i + 1
    def size(self):
        return self.elementer[0].size()
    def see(self, indeks):
        for element in self.elementer:
            element.see(indeks)
    def selection_anchor(self, indeks):
        for element in self.elementer:
            element.selection_anchor(indeks)
    def selection_clear(self, begynd, slut=None):
        for element in self.elementer:
            element.selection_clear(begynd, slut)
    def selection_includes(self, indeks):
        return self.elementer[0].selection_includes(indeks)
    def selection_set(self, begynd, slut=None):
        for element in self.elementer:
            element.selection_set(begynd, slut)
if __name__ == '__main__':
    win = Tk()
    Label(win, text='Listeboks').pack()
    listeboks = Listeboks(win, (("Overskrift 1", 20), ("Overskrift  2", 10),
    ("Overskrift  3", 10)))
    listeboks.insert(END,("del 1", "del 2", "del 3"))
    listeboks.insert(END,("del 4", "del 5", "del 6"))
    listeboks.insert(END,("del 7", "del 8", "del 9"))
    listeboks.pack(expand=YES,fill=BOTH)
    win.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{15cm}
\includegraphics{w11.jpg}
\end{minipage}
</figure>
</para -->
</sect1>

 <sect1 id="wid.rulleskakt">
  <title>Scrollbar underklasse i Widget</title>
  <para>
Kan vise rulleskakt i canvas, text og list elementer. Eksemplet er vist udfyldeligt under beskrivelsen af Listbox underklassen se evt. der også, men først lige et par eksempler her:
</para>
<para>
<screen>
from Tkinter import *
root = Tk()
class Rulleskakten(Frame):
    def __init__(self, master, **kw):
        apply(Frame.__init__, (self, master), kw)
        vscrollbar = Scrollbar(self, orient=VERTICAL)
        self.canvas = Canvas(self)
        vscrollbar.config(command=self._vscroll)
        vscrollbar.pack(fill=Y, side=RIGHT)
        self.canvas.pack(expand=1, fill=BOTH, side=LEFT)
    def _vscroll(self, type, *arg):
        print type
        if type == 'moveto':
            for i in arg:
                print i
f = Rulleskakten(root)
f.pack(expand=1, fill=BOTH)
root.mainloop()
</screen>
</para>
<para>
<screen>
Eks. 2
import Tkinter
class AutoRulleskakt(Tkinter.Scrollbar):
    def set(self, lo, hi):
	self.after(100,lambda s=self,l=lo,h=hi: s._set(l,h))
    def _set(self,lo,hi):
        print lo, hi
        if float(lo) <= 0.0 and float(hi) >= 1.0:
            self.tk.call("grid", "remove", self)
        else:
            self.grid()
        Tkinter.Scrollbar.set(self, lo, hi)
root = Tkinter.Tk()
frame = Tkinter.Frame(root)
frame.grid()
frame.columnconfigure(0, weight=1)
frame.rowconfigure(0, weight=1)
scrollFrame = Tkinter.Frame(frame)
scrollFrame.columnconfigure(1, weight=1)
scrollFrame.rowconfigure(1, weight=1)
scrollFrame.grid(sticky='news')
vscrollbar = AutoRulleskakt(scrollFrame)
vscrollbar.grid(row=1, column=2, sticky='ns')
hscrollbar = AutoRulleskakt(scrollFrame, orient='horizontal')
hscrollbar.grid(row=2, column=1, sticky='ew')
borderframe = Tkinter.Frame(scrollFrame)
borderframe.rowconfigure(0, weight=1)
borderframe.columnconfigure(0, weight=1)
borderframe.grid(row=1, column=1, sticky='news')
canvas = Tkinter.Canvas(borderframe,
        highlightthickness=0,
        borderwidth=0,
        background = 'green',
        width = 300,
        height = 200,
        scrollregion = (0, 0, 301, 200),
        yscrollcommand=vscrollbar.set,
        xscrollcommand=hscrollbar.set)
canvas.grid(sticky='news')
vscrollbar.config(command=canvas.yview)
hscrollbar.config(command=canvas.xview)
root.mainloop()
</screen>
</para>
<!-- para>
<figure>
\begin{minipage}{15cm}
\includegraphics{w12.jpg}
\end{minipage}
</figure>
</para -->
</sect1>

 <sect1 id="wid.menuknap">
  <title>Menubutton underklasse i Widget</title>
  <para>
Menubutton viser popup eller pull-down menu.
</para>
<para>
<screen>
from Tkinter import *
root    = Tk()
menuknap = Menubutton(root, text='Byer')
picks   = Menu(menuknap)
menuknap.config(menu=picks)
picks.add_command(label='Hasle',  command=root.quit)
picks.add_command(label='Aakirkeby',  command=root.quit)
picks.add_command(label='Gudhjem', command=root.quit)
menuknap.pack()
menuknap.config(bg='white', bd=4, relief=RAISED)
root.mainloop()
</screen>
</para>
</sect1>

 <sect1 id="wid.optmenuknap">
  <title>OptionMenu underklasse i Widget</title>
  <!-- para>
<figure>
\begin{minipage}{10cm}
\includegraphics{w14.jpg}
\end{minipage}
</figure>
</para -->
<para>
som menuknap, men viser valgmenu.
</para>
<para>
<screen>
from Tkinter import *
win = Tk()
var1 = StringVar()
var2 = StringVar()
opt1 = OptionMenu(win, var1, 'byer', 'Gudhjem',  'Tejn')
opt2 = OptionMenu(win, var2, 'erhverv',  'turisme', 'fiskeri')
opt1.pack(fill=X)
opt2.pack(fill=X)
var1.set('byer')
var2.set('erhverv')
def state(): print var1.get(), var2.get()
Button(win, command=state, text='Valgmenu').pack()
win.mainloop()
</screen>
</para>
</sect1>

<sect1 id="python-bibfunk">
 <title>Biblioteksfunktioner</title>
 <para>
<screen>
eks. 1
>>> # Opret et bibliotek (en folder):
>>> import os
>>> os.mkdir("bibliotek")
eks. 2
>>> # Opret bibliotek i bibliotek:
>>> import os
>>> os.mkdir("bibliotek/bib2")
</screen>
<!-- figure>
\begin{minipage}{10cm}
\includegraphics{biblioteker.jpg}
\end{minipage}
</figure -->
</para>
<para>
<screen>
eks. 3
Eller naturligvis som:
>>> import os
>>> os.mkdir("bibliotek")
>>> os.mkdir("bibliotek/bib1")
>>> os.mkdir("bibliotek/bib2")
</screen>
</para>
<para>
eks. 4
Alternativ opret bibliotek i bibliotek:
>>> import os
>>> os.mkdir("/home/bruger/bibliotek/bib1/bib2")
</para>
<para>
<screen>
eks. 5
>>> # Skift til bibliotek og
>>> # opret bibliotek i det:
>>> import os
>>> os.chdir("bibliotek")
>>> os.mkdir("bib1")
</screen>
</para>
<para>
Ser du på Pythons faq (kan findes på www.python.org), vil du konstatere, at der
er lavet en lang række mere eller mindre kunstfærdige
løsninger på netop et eksempel som eks. 5 Udviklingen
af sådanne ting kan måske være meget interessante, men
skal tingene være praktisk anvendelige, er der nok ofte
mere konstruktive løsninger. Hvis man som her ønsker at
oprette et bibliotek i et bibliotek, må man kunne skifte
til sidstnævnte som eks. os.chdir("bibliotek"). I dette 
tilfælde, er det nødvendigt at befinde sig det sted,
hvor bibliotek eksisterer.
</para>
<para>
<screen>
>>> import os
>>> os.chdir("bibliotek")
Traceback (most recent call last):
  File "&lt;pyshell\#4&gt;", line 1, in -toplevel-
    os.chdir("bibliotek")
OSError: [Errno 2] No such file or directory: 'bibliotek'
>>> 
</screen>
</para>
<para>
Da det seneste kald var os.chdir("bibliotek"), og dette 
bibliotek ikke findes får vi en af Pythons normalt fremragende 
fejlmeldinger, hvad den også er denne gang. Den er virkelig god,
men gamle Comal 80 har mig bekendt været det eneste computersprog,
der nogensinde har eksisteret på dansk og dermed i stand til at 
give danske fejlmeldinger, så computersprog og engelsk er det 
normale.
</para>
<para>
Men selvom fejlmeldingen er fremragende, så er vi ligesom nødt til 
at bruge den konstruktivt, hvad vi har mulighed for med try..except,
som jeg også er inde på flere andre steder i bogen.
</para>
<para>
<screen>
eks. 6//
skift biblioteksnavn:
>>> import os
>>> os.rename("/home/bruger/bibliotek","/home/bruger/folder")
</screen>
</para>
<para>
eks. 7//
Fjern bibliotek:
>>> import os
>>> os.chdir("bibliotek")
>>> os.rmdir("bib1")
</para>
<para>
<screen>
eks. 8//
Alternativ fjern bibliotek:
>>> import os
>>> os.chdir("bibliotek")
>>> os.rmdir("/home/bruger/bibliotek/bib1")
</screen>
</para>
</sect1>
</chapter>

<chapter id="python-internettet">
 <title>Med Python på internettet</title>

 <para>
I en tid, hvor det ikke er ualmindeligt at modtage mails fra en meget stor del af den globale verden, kan det være rart
at se, hvilken server, det måtte være, hvorfra der sendes til en. I Python kan det ske særdeles enklet. De tre forholdsvis
ens eksempler, jeg nu vil vise, er så selvforklarende, at jeg kun vil tilføje, at Date: viser, hvornår jeg hentede de viste info ind. Dog skal tillægges 2 timer grundet forskellen i længdegrad fra Rønne til London og sommertiden. Endelig skal jeg
gøre opmærksom, på at Content-Length: informationen viser det antal bytes, der er i indexfilen og ikke andet. Jeg finder det selv interessant at se, hvilken server den besøgte benytter. Jeg kunne ikke lade være med at tage såvel folketingets
som Alt Om Datas udskrift med, fordi førstnævnte har vedtaget, at det offentlige skal bruge open source - og så bruger samme
folketing endda en ældre version af Microsofts server (version 4) - der er ingen forbindelse mellem påstanden om at ville
bruge eksempelvis Linux og så det at gøre det.
</para>

<para>
<screen>
>>> from urllib import urlopen
>>> dokument = urlopen("http://www.python.org").read
>>> # Her er der en kort pause mens URL kontaktes
>>> dokument = urlopen("http://www.python.org")
>>> print dokument.info()
Date: Thu, 07 Aug 2003 19:13:13 GMT
Server: Apache/1.3.26 (Unix)
Last-Modified: Wed, 06 Aug 2003 23:54:30 GMT
ETag: "5a750c-3ac2-3f319536"
Accept-Ranges: bytes
Content-Length: 15042
Connection: close
Content-Type: text/html

>>> from urllib import urlopen
>>> dokument = urlopen("http://www.folketinget.dk").read
>>> dokument = urlopen("http://www.folketinget.dk")
>>> print dokument.info()
Server: Microsoft-IIS/4.0
Date: Fri, 08 Aug 2003 03:40:56 GMT
Content-Type: text/html
Set-Cookie: ASPSESSIONIDTBRRRBAB=DBJEHKFBCNBPDGMCPBIKLJJG; path=/
Cache-control: private


>>> from urllib import urlopen
>>> dokument = urlopen("http://www.aod.dk").read
>>> dokument = urlopen("http://www.aod.dk")
>>> print dokument.info()
Server: Microsoft-IIS/5.0
Date: Fri, 08 Aug 2003 03:21:45 GMT
X-Powered-By: ASP.NET
X-AspNet-Version: 1.1.4322
Set-Cookie: ASP.NET_SessionId=dmbwzz455wrgrsmlwyhtyq45; path=/
Cache-Control: private
Content-Type: text/html; charset=iso-8859-1
Content-Length: 23164

>>> import ftplib
>>> # host kan læses som stedet, hvor filen er placeret.
>>> ftp = ftplib.FTP("ftp.host.dk")
>>> ftp.login("brugernavn skal ind her","password skal ind her")
'230 User brugernavn logged in.'

Hent dokument fra url på Web
>>> from urllib import urlopen
>>> dokument = urlopen("http://www.sslug.dk").read()
>>> print dokument

<!-- 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD><TITLE>SSLUG - Sk&aring;ne Sj&aelig;lland Linux User Group</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
... -->
</screen>
</para>
</chapter>
