<chapter id="python-library-ref">
<title>Biblioteks reference</title>
<sect1 id="rep">
<title>Repr funktionen</title>

<para>
<screen>
Eksempler på anvendelse af repr funktionen:
>>> print "Rønne"
Rønne
>>> print str("Rønne")
Rønne
>>> print repr("Rønne")
'R\xf8nne'

>>> str(0.1)
'0.1'
>>> repr(0.1)
'0.10000000000000001'

>>> x = 10 * 3.25
y = 200 * 200
s = 'Værdien af x er ' + repr(x) + ', af y er den ' + repr(y) + '...'
print s>>> >>> >>>
Værdien af x er 32.5, af y er den 40000...

>>> x = 20; y = x ** 3
>>> repr((x, y, ('tomater', 'ostemad')))
"(20, 8000, ('tomater', 'ostemad'))"
>>>
</screen>
</para>
</sect1>

<sect1 id="python-strings">
<title>Tekststrenge</title>
<para>
En tekststreng er alt mellem dobbelte eller enkelte anførselstegn
<screen>
Tekststeng mellem dobbelte anførselstegn:
>>> print "Velkommen til Python!"
Velkommen til Python!
</screen>
</para>
<para>
Tekststeng mellem enkelte anførselstegn:
>>> print 'Velkommen til Python!'
Velkommen til Python!
</para>
<para>
print "Tekststreng med \"dobbelte anførselstegn.\""
print 'En streng med "dobbelte anførselstegn."'
print 'Tekststreng med \'enkelte anførselstegn.\''
print "En streng med 'enkelte anførselstegn.'"
print """Strengen her har "dobbelte anførselstegn"og 'enkelte anførselstegn'.
   Du kan tilmed udskrive over flere linjer."""
print '''Denne streng har også "dobbelte"og 'enkelte' anførselstegn.'''
</para>
<para>
Anførselstegnene skal være samme slags:
>>> 'Velkommen til Python! "
SyntaxError: EOL while scanning single-quoted string
</para>
<para>
>>> "Velkommen til Python! '
SyntaxError: EOL while scanning single-quoted string
</para>
<para>
print "Velkommen\ntil\n\nPython!"
</para>
<para>
Strenge kan lægges sammen:
>>> print "Velkommen " + 'til Python'
Velkommen til Python
</para>
<para>
Strenge kan gentages:
>>> print "Velkommen til Python! " * 3
Velkommen til Python! Velkommen til Python! Velkommen til Python!
</para>
<para>
>>> 'Velkommen til Python! ' * 3
'Velkommen til Python! Velkommen til Python! Velkommen til Python! '
</para>
<para>
Strenge kan sammenlignes:
>>> "æøå" < "ÆØÅ"
False
>>> "ÆØÅ" < "æøå"
True
>>>
>>> 'Python' < 'Pascal'<'ABC' < 'C'
False
>>>
>>> 'ABC' > 'C' < 'Pascal' < 'Python'
True
>>>
'ABC' < 'C' < 'Pascal' < 'Python'
False
>>> 'ABC' == 'C' == 'Pascal' == 'Python'
False
>>>
>>> 4 == "fire"
False
>>>
</para>
<para>
</para>
<para>
Strenge kan indskrives med raw_input:
integer1 = raw_input( "Skriv et helt tal: " )  # read en streng
integer1 = int( integer1 )   # Konverter strengen til heltal
</para>
<para>
heltal2 = raw_input( "Enter endnu et heltal: " ) # indskriv streng
integer2 = int( heltal2 )   # et heltal og an integer er det samme
</para>
<para>
 # Kopier indholdet i integer1 og heltal2 til sum
sum = integer1 + heltal2
</para>
<para>
print "Summen af de to heltal er ", sum
</para>
<para>
Linjeskifte indsættes med \n
>>> print "Velkommen\ntil\n\nPython!"
Velkommen
til
</para>
<para>
Python!
</para>
<para>
Tabulatorskifte indsættes med \t
>>> print "Velkommen\ttil\t\tPython!"
Velkommen       til             Python!
Bemærk her at tekstfunktionerne oftes knyttes til tekststrengen
som f.eks. streng.funktionsnavn()
</para>
<para>
# Skriv første streng og konverter til heltal
tal1 = raw_input( "Indskriv første integer: " )
tal1 = int( tal1)
</para>
<para>
# Skriv anden streng og konverter til heltal
tal2 = raw_input( "Indskriv anden integer: " )
tal2 = int( tal2)
</para>
<para>
if tal1 == tal2:
   print "%d er lig med %d" % ( tal1, tal2)
</para>
<para>
if tal1!= 2:
   print "%d er forskellig fra %d" % ( tal1, tal2)
</para>
<para>
if tal1< 2:
   print "%d er mindre end %d" % ( tal1, tal2)
</para>
<para>
if tal1> 2:
   print "%d er større end %d" % ( tal1, tal2)
</para>
<para>
if tal1<= 2:
   print "%d er mindre end eller lig med %d" % ( tal1, tal2)
</para>
<para>
if tal1>= 2:
   print "%d er større end eller lig med %d" % ( tal1, tal2)
</para>
<para>
>>> heltal = 414
>>> heltal
414
>>> print heltal
414
>>> print "Decimaltal %d" % heltal
Decimaltal 414
>>> print "Hexadecimal tal %x" % heltal
Hexadecimal tal 19e
</para>
<para>
</para>
<para>
>>> for i in range(1,10):
...     print "Oktale tal: %o"%i
...
Oktale tal: 1
Oktale tal: 2
Oktale tal: 3
Oktale tal: 4
Oktale tal: 5
Oktale tal: 6
Oktale tal: 7
Oktale tal: 10
Oktale tal: 11
</para>
<para>
>>> kommatal = 12.4
>>> print "Kommatal (float) %f" % kommatal
Kommatal (float) 12.400000
>>> print "Forvalgt eksponent %e" % kommatal
Forvalgt eksponentnotation 1.240000e+01
</para>
<para>
>>> # Udskriver med fordefineret tabulatorbredde 8 tegn
>>> heltal = 414
>>> print "Højre justeret heltal (%8d)" % heltal
Højre justeret heltal (     414)
>>> print "Venstre justeret heltal (%-8d)" % heltal
Venstre justeret heltal (414     )
</para>
<para>
streng = "Streng formatering"
>>> heltal = 25
>>> print "Gennemtving 8 cifre i heltal %.8d" % heltal
Gennemtving  8 cifre i heltal 00000025
</para>
<para>
>>> kommatal = 12.1
>>> print "Gennemtving 6 cifre efter komme i float %.6f " % kommatal
Gennemtving 6 cifre efter komme i float 12.100000
</para>
<para>
</para>
<para>
>>> streng = "I alle de riger og lande..."
>>> print "(%.15s) (%.5s)" % ( streng, streng )
(I alle de riger) (I all)
</para>
<para>
En streng er en liste. Her udskrives streng som liste:
>>> s = "Dette er en streng."
>>> l = len(s) # len finder strenglængde
>>> for i in range(0,l):
...     print s[i],
...
D e t t e   e r   e n   s t r e n g .
</para>
<para>
</para>
<para>
eks. 1
capitalize() funktionen konverterer strengens
første bogstav til "stort" bogstav.
</para>
<para>
>>> import string
>>> "dette er en mulig anvendelse".capitalize()
'Dette er en mulig anvendelse'
</para>
<para>
eks. 2 Eksempel 1 på en anden måde
</para>
<para>
<screen>
>>> import string
>>> streng = "rødgrød med fløde er godt."
>>> streng.capitalize()
'R\xf8dgr\xf8d med fl\xf8de er godt.'
ELLER:
>>> print streng.capitalize()
Rødgrød med fløde er godt.
</screen>
</para>
<para>
De fleste af de mange andre tekstfunktioner anvendes svarende til eksempel
1 og 2 ovenfor. BEMÆRK hvordan de danske specialtegn erstattes med
hexadecimale værdier i den første udskrift. Det skyldes, at Python
benytter 2 forskellige funktioner i immediate mode ved returneringen
str() og repr(), hvad følgende kan vise:
</para>
<para>
<screen>
>>> print str("rødgrød med fløde er godt.")
rødgrød med fløde er godt.
>>> print repr("rødgrød med fløde er godt.")
'r\xf8dgr\xf8d med fl\xf8de er godt.'
</screen>
</para>
<para>
eks. 3
center(bredde)funktionen placerer en delstreng i en streng, hvis længde
angives af det tal, der indsættes i parameterlisten her markeret med
variablen bredde.
</para>
<para>
<screen>
>>> import string
>>> streng = "Rønne er hovedstaden på Bornholm."
>>> s = streng.center(60)
>>> s
'             R\xf8nne er hovedstaden p\xe5 Bornholm.              '
>>> print s
             Rønne er hovedstaden på Bornholm.
</screen>
</para>
<para>
<screen>
Samme eksempel mere "naturlig":
>>> import string
>>> print "Rønne er hovedstaden på Bornholm.".center(60)
             Rønne er hovedstaden på Bornholm.
</screen>
</para>
<para>
eks. 4//
count(delstreng,begyndMed,slutMed) tæller antal forekomster af delstreng
i streng.
</para>
<para>
<screen>
>>> import string
>>> streng = "Rønne og Åkirkeby er to bornholmske byer."
>>> # Da der ikke er angivet hverken start- eller slutpunkt
>>> # tælles der op i hele strengen.
>>> streng.count("e")
5
>>> streng.count("e",6,15)
1
</screen>
</para>
<para>
<screen>
Eller:
>>> import string
>>> "Rønne og Åkirkeby er to bornholmske byer.".count("e")
5
</screen>
</para>
<para>
eks. 5
endswith(delstreng, startplads, slutplads) funktionen fortæller, det
den siger - om det er sandt/falskt at strengen slutter delstrengen. Som
vi har set andre steder, så er 1 lig med sand, mens 0 betyder falsk.
</para>
<para>
<screen>
>>> import string
>>> streng = "Hammershus er Nordeuropas største borgruin."
>>> streng.endswith(".")
1
>>> streng.endswith("n",10, len(streng) - 1)
1
>>> streng.endswith("n",10,12)
0
</screen>
</para>
<para>
<screen>
Eller:
>>> import string
>>> s1 = "Hammershus er Nordeuropas største borgruin.".endswith(".")
>>> strenglengde = len("Hammershus er Noreuropas største borgruin")
>>> s2 = "Hammershus er Nordeuropas største borgruin.".endswith("n",10,strenglengde)
>>> s3 = "Hammershus er Nordeuropas største borgruin.".endswith("n",10,12)
>>> print s1, s2, s3
True True False
>>> s1, s2, s3
(True, True, False)
</screen>
</para>
<para>
Det første af de to eksempler er udført i Python 2.2, det sidste i
Python 2.3 derfor forskellen i returneringen af sandhedsværdierne.
</para>
<para>
eks. 6//
expandtabs([antalTomme]) returnerer en ny streng, hvori alle
tabulatorstop er erstattet af mellemrum. Det valgfrie argument
antalTomme specificerer antal mellemrum  der erstatter en
tabulatorindrykning. Det forvalgte antal er 8 tegn mellem hvert
tabulatorstop.
Bemærk \t for tabulator.
</para>
<para>
>>> import string
</para>
<para>
<screen>
>>> t = "En streng\t streng"
>>> t
'En streng\t streng'
>>> t.expandtabs(30)
'En streng                      streng'
</screen>
</para>
<para>
eks. 7
find(delstreng,startplads, slutplads) viser en delstrengs position i
en streng.
</para>
<para>
<screen>
>>> import string
>>> streng = "Børnene leger i skolegården."
>>> streng.find("ø")
1
>>> streng.find("å")
22
</screen>
</para>
<para>
</para>
<para>
Hvis du tæller efter, synes det som om Python er gal på den - kan Python
ikke regne? Jo, men det er vist et faktum i alle normale computersprog,
at en streng er en form for tabel, og så er den god nok, for det er
vist også fast, at en tabels første værdi er placeret som tabelelement
nummer nul. Det betyder, at ø reelt er element nummer 1 og å element
nummer 22 som vist ovenfor. Du kan opnå den "rigtige" position således:
</para>
<para>
<screen>
>>> streng.find("ø") + 1
2
</screen>
</para>
<para>
<screen>
Funktionen returnerer -1, hvis ikke delstrengen findes.
>>> streng.find("ø",2,)
-1
</screen>
</para>
<para>
eks. 8
index(delstreng, startplads, slutplads) viser en delstrengs position i
en streng. Udfører samme funktion som find(delstreng, startplads,
slutplads), men i stedet for at returnere -1 returneres en ValueError
exception, hvis ikke delstrengen findes i strengen.
</para>
<para>
<screen>
>>> import string
>>> streng = "Børnene leger i skolegården."
>>> streng.index("ø")
1
>>> streng.index("å")
22
>>> streng.index("q")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ValueError: substring not found in string.index
</screen>
</para>
<para>
Python melder to ting 1: fejlen findes i linje 1 (tabelcelle 2)
og 2: delstrengen "ø" blev ikke fundet.
</para>
<para>
eks. 9
isalnum() returnerer 1 (sand), hvis strengen ene og alene indeholder
alfanummeriske tegn (bogstaver og tal) ellers returneres nul.
</para>
<para>
<screen>
>>> import string
>>> streng = "Bornholm2003"
>>> streng.isalnum()
1
>>> streng = "Bornholm 2003"
>>> streng.isalnum()
0
</screen>
</para>
<para>
Der er en ASCII 32 (mellemrum) i strengen derfor 0.
</para>
<para>
<screen>
eller:
>>> import string
>>> print "Bornholm2003".isalnum(),"Bornholm 2003".isalnum()
True False
</screen>
</para>
<para>
eks. 10
isalpha() returnerer 1 hvis strengen ene og alene indeholder alfabetiske
karakterer  (bogstaver) ellers returneres 0
<screen>
>>> import string
>>> streng = "Børnenelegeriskolegården"
>>> streng.isalpha()
1
>>> streng = "Børnene leger i skolegården."
>>> streng.isalpha()
0
</screen>
</para>
<para>
eks. 11
isdigit() returnerer 1, hvis strengen ene og alene indeholder tal,
ellers returneres 0.
</para>
<para>
<screen>
>>> import string
>>> streng ="0123456789"
>>> streng.isdigit()
1
>>> streng ="0123456789 "
>>> streng.isdigit()
0
>>> streng ="0.123456789"
>>> streng.isdigit()
0
</screen>
</para>
<para>
eks. 12
islower() funktionen returnerer 1, hvis alle bogstaver i strengen er
"små".
</para>
<para>
<screen>
>>> import string
>>> streng = "det er efterår nu"
>>> streng.islower()
1
>>> streng = "Det er efterår nu"
>>> streng.islower()
0
>>> streng = "vi er i efteråret 2003"
>>> streng.islower()
1
</screen>
</para>
<para>
<screen>
eller:
>>> import string
>>> "vi er i efteråret 2003.".islower()
True
</screen>
</para>
<para>
eks. 13
isspace() returnerer 1, hvis strengen ene og alene indeholder tomme
(ASCII 32) ellers returneres 0.
</para>
<para>
<screen>
>>> streng = ""
>>> streng.isspace()
0
>>> streng = " "
>>> streng.isspace()
1
>>> streng = "    "
>>> streng.isspace()
1
>>> streng = " 1 "
>>> streng.isspace()
0
>>> streng = " K "
>>> streng.isspace()
0
</screen>
</para>
<para>
eks. 14
istitle() I en engelsk bogtittel begynder det enkelte ord (som regel)
med "store" bogstaver, deraf funktionsnavnet. Selve funktionen
returnerer derfor 1, hvis der ene og alene forekommer "store" bogstaver
som de enkelte ords første bogstav ellers returneres 0. Det kan føre
til, at selv velkendte stavemåder kan returnere nul og omvendt, hvad
dette eksempel vil vise:
</para>
<para>
<screen>
>>> # Først den forkerte stavemåde:
>>> streng = "Suse Linux"
>>> streng.istitle()
1
>>> # Så den rigtige stavemåde:
>>> import string
>>> streng = "SuSE Linux"
>>> streng.istitle()
0
</screen>
</para>
<para>
eks. 15//
isupper() funktionen returnerer 1, hvis alle bogstaver i strengen er "store".
</para>
<para>
<screen>
>>> import string
>>> streng = "SuSE Linux" # normale skrivemåde
>>> streng.isupper()
0
>>> streng = "SUSE LINUX" # unormal skrivemåde
>>> streng.isupper()
1
>>> streng = "SUSE LINUX 8.2"
>>> streng.isupper()
1
</screen>
</para>
<para>
</para>
<para>
eks. 16
join(sekvens) knytter en strengliste (eller en delstreng) sammen med
streng som "ordstyrer" og danner en lang streng.
</para>
<para>
<screen>
>>> import string
>>> strengliste  = ["1","2","3","4","5","6"]
>>> streng
'123456'
</screen>
</para>
<para>
eller:
>>> streng = "".join(strengliste) + str(89)
>>> streng
'12345689'
</para>
<para>
<screen>
eller:
>>> ". listeelement   ".join(strengliste) + ". listeelement."
'1. listeelement   2. listeelement   3. listeelement
4. listeelement   5. listeelement   6. listeelement.'
>>>
</screen>
</para>
<para>
eks. 17
ljust(bredde) ligner center(bredde) funktionen, hvis anvendelse
tidligere er vist. Her placeres delstrengen bare venstrejusteret i den
tomme streng, hvis længde angives med breddeargumentet.
</para>
<para>
<screen>
>>> import string
>>> streng = "Venstrejusteret".ljust(20)
>>> streng
'Venstrejusteret     '
</screen>
</para>
<para>
</para>
<para>
eks. 18//
lower() lower() konverterer alle bogstaver til "små".
</para>
<para>
<screen>
>>> import string
>>> "DETTE ER KUN EN TESTSTRENG".lower()
'dette er kun en teststreng'
</screen>
</para>
<para>
<screen>
"Der skal 12 til et dusin.".lower()
'der skal 12 til et dusin.'
</screen>
</para>
<para>
eks. 19//
lstrip() fjerner tomme (ASCII 32) i strengens begyndelse - venstre side.
</para>
<para>
<screen>
>>> import string
"    Dette er en teststreng.".lstrip()
'Dette er en teststreng.'
</screen>
</para>
<para>
eks. 20
replace(gamle,nye,maksimale) erstatter en "gammel" tekstsreng med en ny.
Hvis du ikke ønsker at udskifte samtlig eksistende "gamle" med nye, kan
et maksimalt antal udskiftninger angives.
</para>
<para>
<screen>
>>> import string
>>> "En plads i haven".replace("hav","sol")
'En plads i solen'
</screen>
</para>
<para>
<screen>
>>> 20 udskiftninger er ikke mulig, da der kun er 1
>>> "En plads i haven".replace("hav","sol",20)
'En plads i solen'
</screen>
</para>
<para>
eks. 21
rfind(delstreng , startplads, slutplads) finder positionen af den sidste
delstreng i en streng. Hvis delstrengen ikke findes returneres -1.
</para>
<para>
<screen>
>>> import string
>>> streng = "Der er en klippefast grund til at besøge Bornholm."
>>> streng.rfind("e")
39
</screen>
</para>
<para>
<screen>
eller:
>>> import string
>>> "Der er en klippefast grund til at besøge Bornholm.".rfind("e")
39
</screen>
</para>
<para>
<screen>
eller:
>>> import string
>>> l = len("Der er en klippefast grund til at besøge Bornholm.")
>>> "Der er en klippefast grund til at besøge Bornholm.".rfind("e",len(streng) - 10,l)
-1
</screen>
</para>
<para>
eks. 22
rindex(delstreng,startpunkt,slutpunkt) virker fuldstændig som rfind
funktionen, men i stedet for at returnere -1, hvis delstrengen ikke
findes returneres en ValueError.
</para>
<para>
<screen>
>>> import string
>>> streng = "Tidligere anvendtes Dueoddes sand i timeglas."
>>> streng.rindex("i")
37
>>> streng.rindex("ven")
12
>>> streng.rindex("dk")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ValueError: substring not found in string.rindex
</screen>
</para>
<para>
Fejlmeldingen siger, at delstrengen "dk" ikke findes i streng.
</para>
<para>
eks. 23//
rjust(bredde) svarer til center(bredde) og ljust(bredde) bortset fra at delstrengen her placeres højrejusteret i strengen.
</para>
<para>
<screen>
>>> import string
>>> "h".rjust(30)
'                             h' # Et enkelt bogstav er også en streng.
</screen>
</para>
<para>
eks. 24//
rstrip() fjerner tomme (ASCII 32) i HØJRE side af en streng.
</para>
<para>
<screen>
>>> # Python 2.2 afvikling:
>>> import string
>>> "    En unødvendig lang streng        ".rstrip()
'    En un\xf8dvendig lang streng'
>>> # Python 2.3 afvikling:
>>> import string
>>> print "    En unødvendig lang streng        ".rstrip()
    En unødvendig lang streng
</screen>
</para>
<para>
eks. 25
split(seperator) Opdeler tekststreng i delstrenge, der indsættes i
liste. Hvis ikke der indsættes seperator deles ved ASCII 32
(mellemrum).
</para>
<para>
<screen>
>>> import string
>>> "Dette er kun en teststreng.".split()
['Dette', 'er', 'kun', 'en', 'teststreng.']
</screen>
</para>
<para>
<screen>
>>> "Dette\n er\n kun\n en teststreng.".split("\n")
['Dette', ' er', ' kun', ' en teststreng.']
</screen>
</para>
<para>
eks. 26
split(seperator) Retuarnerer en liste af delstrenge dannet ved at dele
den oprindelige streng ved hver seperator. Hvis seperatoren ikke
anvendes eller er sat til None, deles strengen ved hver mellemrum 
(ASCII 32)
</para>
<para>
<screen>
>>> import string
>>> "Tejn\nog\nGudjem\n er\nvelkendte turistbyer.".split()
['Tejn', 'og', 'Gudjem', 'er', 'velkendte', 'turistbyer.']
>>> "Tejn\nog\nGudjem\n er\nvelkendte turistbyer.".split("\n")
['Tejn', 'og', 'Gudjem', ' er', 'velkendte turistbyer.']
</screen>
</para>
<para>
eks. 27
splitlines([1])returnerer en liste af delstrenge fremkommet ved at
dele den oprindelige streng ved hver ny linje karakter. Hvis
parameteret 1 indsættes bevares ny linje skiftet i delstrengene se
nederste del af eksemplet.
</para>
<para>
<screen>
>>> import string
>>> "Dette er\nen meget \nlang streng, \n der deles\ni delstrenge.".splitlines(1)
['Dette er\n', 'en meget \n', 'lang streng, \n', ' der deles\n', 'i delstrenge.']
>>> "Dette er en meget lang streng, der deles i delstrenge.".splitlines()
['Dette er en meget lang streng, der deles i delstrenge.']
>>> "Dette er\nen meget \nlang streng, \n der deles\ni delstrenge.".splitlines()
['Dette er', 'en meget ', 'lang streng, ', ' der deles', 'i delstrenge.']
</screen>
</para>
<para>
eks. 28
startswith(delstreng,startpunkt,slutpunkt) returnerer 1, hvis strengen
begynder med delstrengen ellers nul.
</para>
<para>
<screen>
>>> import string
>>> "Denne streng er en violinstreng.".startswith("Den")
1
>>> "Denne streng er en violinstreng.".startswith("en")
0
</screen>
</para>
<para>
eks. 29//
strip() fjerner mellemrum i strengens begyndelse og slutning
<screen>
>>> # Python 2.2 afvikling:
>>> import string
>>> "      Har du været på Christiansø?     ".strip()
'Har du v\xe6ret p\xe5 Christians\xf8?'
>>> import string
>>> "      Har du været på Christiansø?     ".strip()
'Har du v\xe6ret p\xe5 Christians\xf8?'
>>> print "      Har du været på Christiansø?     ".strip()
Har du været på Christiansø?
</screen>
</para>
<para>
eks. 30//
swapcase() konverterer alle "store" bogstaver til små og omvendt.
</para>
<para>
<screen>
>>> import string
>>> "dANMARK ER VEL TRODS ALT ET GODT LAND.".swapcase()
'Danmark er vel trods alt et godt land.'
>>> "eR DANSKERNE ALT?".swapcase()
'Er danskerne alt?'
</screen>
</para>
<para>
eks. 31
title() Returnerer en streng, hvori første bogstav af strengens
enkeltord og kun dem er med stort begyndelsesbogstav.
</para>
<para>
<screen>
>>> import string
>>> "er uldjyder lådne?".title()
'Er Uldjyder L\xe5dne?'
</screen>
</para>
<para>
>>> "eR brAndMænd meget iltre?".title()
'Er Brandm\xe6nd Meget Iltre?'
</para>
<para>
<screen>
eller:
>>> import string
>>> "er uldjyder lådne?".title()
'Er Uldjyder L\xe5dne?'
>>> s = "er uldjyder lådne?".title()
>>> print s
Er Uldjyder Lådne?
</screen>
</para>
<para>
eks. 32//
\upper() konverterer alle bogstaver til "store" bogstaver
</para>
<para>
<screen>
>>> import string
>>> "var forfatteren nexø fra nexø?".upper()
'VAR FORFATTEREN NEX\xd8 FRA NEX\xd8?'
</screen>
</para>
<para>
eller:
>>> import string
>>> "var forfatteren nexø fra nexø?".upper()
'VAR FORFATTEREN NEX\xd8 FRA NEX\xd8?'
>>> print "var forfatteren nexø fra nexø?".upper()
VAR FORFATTEREN NEXØ FRA NEXØ?
</para>
<para>
Brødmaskinen (slicing):
>>> streng = "naturlig"
>>> streng[4]
'r'
>>> streng[0:2]
'na'
>>> streng[2:4]
'tu'
>>> streng[:2]
'na'
>>> streng[2:]
'turlig'
>>> 'u' + streng[1:]
'uaturlig'
>>> streng[:2] + streng[2:]
'naturlig'
>>> streng[:3] + streng[3:]
'naturlig'
>>>
</para>
<para>
<screen>
zfill funktionen gør det, den siger fylder op med zeros (nuller)
opfyldningen sker altid til venstre:
import string
string.zfill('12', 5)
'00012'
string.zfill('-3.14', 7)
'-003.14'
string.zfill('3.14159265359', 5)
'3.14159265359'
</screen>
</para>
</sect1>

<sect1 id="python-range">
<title>Range</title>
<para>
<screen>
syntaks: range(begynd, slut - 1, step) - slut er nødvendig.
>>> range(11)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9.10]
>>> range(0,21,2)
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
>>> range(0,40,3)
[0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39]
>>> range(1,-11,-1)
[1, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10]
>>> range(40,0,-5)
[40, 35, 30, 25, 20, 15, 10, 5]
>>> for i in range(1,11):
...     print i,
...
1 2 3 4 5 6 7 8 9 10
Range fungerer også ved nedtælling:
>>> for i in range(10,0, -1):
...     print i,
...
10 9 8 7 6 5 4 3 2 1
>>> for i in range(100,0, -5):
...     print i,
...
100 95 90 85 80 75 70 65 60 55 50 45 40 35 30 25 20 15 10 5
>>>
2 metoder til udskrift af kvadrat- og kubiktal:
>>> import string
>>> for x in range(1, 11):
...     print string.rjust(repr(x), 2), string.rjust(repr(x*x), 3),
...     print string.rjust(repr(x*x*x), 4)
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
>>> for x in range(1,11):
...     print '%2d %3d %4d' % (x, x*x, x*x*x)
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
</screen>
</para>
</sect1>

<sect1 id="python-filer">
<title>Læs og skriv filer</title>
<para>
<screen>
heleTeksten= open('filnavn.txt').read()    # hent hele indholdet i en tekstfil
alleData = open('fuldeFilsti', 'rb').read() # hent hele indholdet i en binær fil

filObjekt  = open('filnavn.txt')
heleTeksten = filObjekt.read()
filObjekt.close()
listeAfAlleLinjer = filObjekt.readlinjes()
listeAfAlleLinjer = filObjekt.read().splitlinjes(1)
listeAfAlleLinjer = filObjekt.read().splitlinjes()
listeAfAlleLinjer = filObjekt.read().split('\n')
listeAfAlleLinjer = list(filObjekt)

filObjekt = open('fuldeFilsti', 'rb')
while 1:
    blok = filObjekt.read(100)
    if not blok: break
    anvend blokken (f.eks. til udskrift)
filObjekt.close()

for linje in open('filnavn.txt'):
    print linje

filObjekt = open('filnavn.txt')
while 1:
    linje = filObjekt.readlinje()
    if not linje: break
    print linje
filObjekt.close()
</screen>
</para>
<para>
<screen>
open('filnavn.txt', 'w').write(heleTeksten)  # skriv tekst til en tekstfil
open('fuldeFilsti', 'wb').write(alleData)    # skriv binære data til en binær fil

filObjekt = open('filnavn.txt', 'w')
filObjekt.write(heleTeksten)
filObjekt.close()

filObjekt.writelines(listeAfAlleTekststrenge)
open('fuldeFilsti', 'wb').writelines(listeAfAlleDataStrenge)
</screen>
</para>

<sect2 id="python-filer-2">
<title>Hent fil linje for linje</title>

<programlisting>
import linecache

fuldeFilsti = "autoexec.bat"
valgteLinjenummer = 0

linjen = linecache.getline(fuldeFilsti, valgteLinjenummer)

# getline er fordefineret i Python
def getline(fuldeFilsti, valgteLinjenummer):
    if valgteLinjenummer < 1: return ''
    aktuelleLinjeNummer = 0
    for linje in open(fuldeFilsti):
        aktuelleLinjeNummer += 1
        if aktuelleLinjeNummer == valgteLinjenummer: return linje
    return ''

for linje in open(fuldeFilsti).xreadlines():
	print linje
</programlisting>
</sect2>

<sect2 id="python-filer-3">
<title>Find antal linjer i tekstfil</title>

<para>
<screen>
import linecache
fuldeFilsti = "autoexec.bat"

antalLinjer = len(open(fuldeFilsti).readlines())
print antalLinjer
</screen>
</para>
</sect2>

<sect2 id="python-filer-4">
<title>Skriv til udfil</title>

<programlisting>
import sys
try:
   udfil = open( "filnavn.txt", "w" )
except IOError, melding:
   	print >> sys.stderr, "Fejlmelding:", melding
   	sys.exit( 1 )

udtekst = ""
tekst = " "

while len(tekst) > 0:
	tekst = raw_input( "Skriv tekstlinje (tom lukker fil): " )
	udtekst += tekst + "\n"

print >> udfil, udtekst        # skriv tekst til udfil
udfil.close()
print "Udfilen er lukket."
</programlisting>

<para>
Kørselsresultat:
<screen>
python udfilNy.py
Skriv tekstlinje (tom lukker fil): Ny tekst i ny udfil."
Skriv tekstlinje (tom lukker fil):
Udfilen er lukket.
</screen>
</para>
<para>
Indhold i den nyoprettede filnavn.txt
Ny
fil i ny udfil
</para>
</sect2>

<sect2 id="python-filer-5">
<title>Hent fil i Python (Linux) bibliotek</title>
<para>
<screen>
import sys
try:
   indfil = open( "/usr/lib/python2.2/calendar.py", "r" )
except IOError:
   print >> sys.stderr, "Filen blev ikke hentet ind."
   sys.exit( 1 )

indtekst = indfil.read()
print str(indtekst)
indfil.close()
print
print "Filen er lukket."

import sys
try:
   udfil = open( "filnavn.txt", "wb" )
except IOError, melding:
   	print >> sys.stderr, "Fejlmelding:", melding
   	sys.exit( 1 )

udtekst = ""
tekst = " "

while len(tekst) > 0:
	tekst = raw_input( "Skriv tekstlinje (tom lukker fil): " )
	udtekst += tekst + "\n"

print >> udfil, str(udtekst )      # skriv tekst til udfil
udfil.close()
print "Udfilen er lukket."
</screen>
</para>
</sect2>

<sect2 id="python-filer-6">
<title>Gem liste i fil</title>
<para>
<screen>
import sys
try:
   udfil = open( "filnavn.txt", "w" )
except IOError, melding:
   	print >> sys.stderr, "Fejlmelding:", melding
   	sys.exit( 1 )
</screen>
</para>
<para>
liste = [1,2,3,4,5,6,7,8,9]
</para>
<para>
print >> udfil, str(liste )      # skriv liste  til udfil
udfil.close()
print "Udfilen er lukket."
</para>
<para>
filnavn.txt kontrol viser indholdet:
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</para>
</sect2>

<sect2 id="python-filer-7">
<title>Udvid fil (append)</title>
<para>
<screen>
import sys
try:
   udfil = open( "filnavn.txt", "a" )
except IOError, melding:
   	print >> sys.stderr, "Fejlmelding:", melding
   	sys.exit( 1 )
udtekst = ""
tekst = " "
while len(tekst) > 0:
	tekst = raw_input( "Skriv tekstlinje (tom lukker fil): " )
	udtekst += tekst + "\n"
print >> udfil, str(udtekst )      # skriv tekst til udfil
udfil.close()
print "Udfilen er lukket."
</screen>
</para>
</sect2>

<sect2 id="python-filer-8">
<title>Læs fra fil</title>

<programlisting>
import sys
try:
   udfil = open( "filnavn.txt", "w" )
except IOError, melding:
   	print >> sys.stderr, "Fejlmelding:", melding
   	sys.exit( 1 )

udtekst = ""
tekst = " "

while len(tekst) > 0:
	tekst = raw_input( "Skriv tekstlinje (tom lukker fil): " )
	udtekst += tekst + "\n"

print >> udfil, str(udtekst )      # skriv tekst til udfil
udfil.close()
print "Udfilen er lukket."
</programlisting>
<para>
BEMÆRK:  str funktionen kræves a.h.t. dansk/norske specialtegn.
</para>
<para>
Kørselsresultat:
ajbo@linux:~> python indfil.py
['Microsoft får en ordentlig bredside i en ny rapport fra den amerikanske \n',
'organisation Computer & Communications Industry Association (CCIA). Manglen \n',
 'på ordentlig sikkerhed i Microsofts programmer og det faktum, at Windows er \n',
 'det mest udbredte styresystem i verden, betyder tilsammen, at verden generelt \n',
 'er blevet mere sårbar overfor trusler mod sikkerheden, konkluderer rapporten.\n']
</para>
<para>
Filen er lukket.
ajbo@linux:~>
</para>
<para>
Teksten er uddrag fra en Netavisen Infopaq mail udsendt/modtaget 24. sept 03
</para>
</sect2>

<sect2 id="python-filer-9">
<title>Skriv bytes til udfil</title>
<para>
<programlisting>
import sys
try:
   udfil = open( "filnavn.txt", "wb" )
except IOError, melding:
   	print >> sys.stderr, "Fejlmelding:", melding
   	sys.exit( 1 )

udtekst = ""
tekst = " "

while len(tekst) > 0:
	tekst = raw_input( "Skriv tekstlinje (tom lukker fil): " )
	udtekst += tekst + "\n"

print >> udfil, str(udtekst )      # skriv tekst til udfil
udfil.close()
print "Udfilen er lukket."
</programlisting>
</para>
<para>
Fra kørselsresultat:
filnavn.txt indeholder:
Nu går vi over til at udsende teksten i antal bytes.
Flere bytes skrives til filen.
</para>
</sect2>

<sect2 id="python-filer-10">
<title>Hent bytes fra fil</title>

<para>
<programlisting>
import sys

try:
   indfil = open( "filnavn.txt", "rb" )
except IOError:
   print >> sys.stderr, "Filen blev ikke hentet ind."
   sys.exit( 1 )

indtekst = indfil.readlines()
print str(indtekst)
indfil.close()
print
print "Filen er lukket."
</programlisting>
</para>
<para>
Kørselsresultat:
<screen>
ajbo@linux:~> python indfilBytes.py
['Nu går vi over til at udsende teksten i antal bytes.\n',
 'Flere bytes skrives til filen.\n', '\n', '\n']
Filen er lukket.
ajbo@linux:~>
</screen>
</para>
</sect2>

<sect2 id="python-filer-11">
<title>Hent bytes fra fil eksempel 2</title>
<para>
Til dette eksempel har jeg benyttet command.com fra Microsoft Windows Me
</para>
<programlisting>
import sys

try:
	indfil = open( "/windows/C/command.com", "rb" )
except IOError:
   	print >> sys.stderr, "Filen blev ikke hentet ind."
   	sys.exit( 1 )

indtekst = indfil.read()
print str(indtekst)
indfil.close()
print
print "Filen er lukket."
</programlisting>
<para>
Kørselsresultat (uddrag af den store udskrift):
enhed   Den terminalenhed, som du vil bruge, f.eks. COM1.
1Viser eller indstiller datoen.
</para>
<para>
DATE [dato]
</para>
<para>
Skriv DATE uden parametre for at f vist den aktuelle datoindstilling og
for at kunne angive en ny. Tryk p ENTER for at beholde den nuvrende dato.
aSletter en eller flere filer.
</para>
</sect2>

<sect2 id="python-filer-12">
<title>Hent bytes fra fil eksempel 3</title>
<para>
I dette eksempel læses filen vinduer.jpg, der også benyttes et andet
sted i bogen.
</para>
<programlisting>
import sys
try:
   indfil = open( "vinduer.jpg", "rb" )
except IOError:
   print >> sys.stderr, "Filen blev ikke hentet ind."
   sys.exit( 1 )

indtekst = indfil.read()
print str(indtekst)
indfil.close()
print
print "Filen er lukket."
</programlisting>
<para>
Kørselsresultat (ganske kort uddrag af returgodset)
<screen>
python indfilBytes3.py
ÿØÿàJFIFHHÿþLEAD Technologies Inc. V1.01ÿÛC
</screen>
</para>
</sect2>

<sect2 id="python-filer-13">
<title>Søg og erstat tekst i fil</title>

<programlisting>
#!/usr/bin/env python
import os, sys

antalArgumenter = len(sys.argv)

if not 3 <= antalArgumenter <= 5:
    print "Anvend: %s tekstAtFinde erstatningsTekst [indfil [udfil]]" % \
        os.path.basename(sys.argv[0])
else:
    findeTekst = sys.argv[1]
    erstatteTekst = sys.argv[2]
    input = sys.stdin
    output = sys.stdout
    if antalArgumenter > 3:
        input = open(sys.argv[3])
    if antalArgumenter > 4:
        output = open(sys.argv[4], 'w')
    for s in input.xreadlines():
        output.write(s.replace(findeTekst, erstatteTekst))
    output.close()
    input.close()
</programlisting>
<para>
<screen>
 Et kørselsresultat:
python erstatTekst.py
Anvend: erstatTekst.py tekstAtFinde erstatningsTekst [indfil [udfil]]
</screen>
Når filen søges afviklet uden de nødvendige parametre udskrives der som
vist en anvisning på, hvordan kaldet skal foregå. sys.argv[0] er selve
programmets navn (erstatTekst.py). I Python bøger er det normalt at
angive valgfrie parametre i firkantede parenteser. Det er altså i
herværende tilfælde ikke absolut nødvendigt at angive en indfils navn,
det samme er tilfældet med en udfils navn. Udeladelse af de to navne er
imidlertid upraktisk i det aktuelle tilfælde, så et kald kunne være:
<screen>
python erstatTekst.py "Microsoft" "Linux" "/windows/C/autoexec.bat" "autoexec.bat"
</screen>
Der er bare det ved det, at ordet "Microsoft" næppe forekommer i
autoexec.bat filen. Resultatet vil altså alene blive at filen bliver
kopieret fra Microsoft Windows biblioteket til rodbiblioteket i Linux,
men det kan jo også være fint nok.
</para>
<para>
<screen>
import os, sys, string
indfil = open( "/windows/C/autoexec.bat", "r" )
udfil = open( "autoexec.bat", "w" )
findeTekst = "WINDOWS"; erstatteTekst = "Linux"
for s in indfil.readlines():
	udfil.write(string.replace(s, findeTekst, erstatteTekst))
indfil.close
udfil.close
</screen>
</para>
<para>
Før programafvikling:
SET windir=C:\WINDOWS
SET winbootdir=C:\WINDOWS
SET COMSPEC=C:\WINDOWS\COMMAND.COM
SET PATH=C:\WINDOWS;C:\WINDOWS\COMMAND
SET PROMPT=$p$g
SET TEMP=C:\WINDOWS\TEMP
SET TMP=C:\WINDOWS\TEMP
</para>
<para>
Efter programafvikling:
SET windir=C:\Linux
SET winbootdir=C:\Linux
SET COMSPEC=C:\Linux\COMMAND.COM
SET PATH=C:\Linux;C:\Linux\COMMAND
SET PROMPT=$p$g
SET TEMP=C:\Linux\TEMP
SET TMP=C:\Linux\TEMP
</para>
<para>
De to linjer:
for s in indfil.readlines():
	udfil.write(string.replace(s, findeTekst, erstatteTekst))
</para>
<para>
Kan også skrives:
for s in indfil:
	udfil.write(s.replace(findeTekst, erstatteTekst))
</para>
<para>
Lad Python fortælle, hvad et modul indeholder:
<screen>
>>> sys
&lt;module 'sys' (built-in)>
</screen>
</para>
<para>
returstrengen fortæller, at sys er et i Python indbygget (fordefineret)
modul. sys inkluderes i dette eksempel ene og alene for at kunne lukke
programmet ned, når der klikkes på knappen. Herved udføres kommandoen
root.exit
</para>
<para>
I interaktiv mode kan det undertiden være vanskeligt at få kørslen
stoppet og komme ud af programmet. I Windows kan du komme ud ved at
trykke på Ctrl og Z tasten samtidig. I Linux skulle du kunne komme ud
ved at trykke samtidig på Ctrl og D. I SuSE 8.2 skal du imidlertid
trykke Ctrl C for at komme ud. Men det korte og det lange er, at
sys.exit og nævnte tastetryk har samme virkning.
</para>
<para>
Vi kan også få at se, hvad modulet indeholder:
</para>
<para>
<screen>
>>> import sys
>>> dir (sys)
['__displayhook__', '__doc__', '__excepthook__', '__name__', '__stderr__',
'__stdin__', '__stdout__', '_getframe', 'argv', 'builtin_module_names',
'byteorder', 'copyright', 'displayhook', 'dllhandle', 'exc_info',
'exc_type', 'excepthook', 'exec_prefix', 'executable', 'exit',
'getdefaultencoding', 'getrecursionlimit', 'getrefcount',
'hexversion', 'last_traceback', 'last_type', 'last_value',
'maxint', 'maxunicode', 'modules', 'path', 'platform', 'prefix', 'ps1',
'setcheckinterval', 'setprofile', 'setrecursionlimit', 'settrace', 'stderr',
'stdin', 'stdout', 'version', 'version_info', 'warnoptions', 'winver']
</screen>
</para>
</sect2>
</sect1>

<sect1 id="python-tid">
 <title>Tidsfunktioner</title>

 <para>
  Tidsfunktioner
 </para>

<sect2 id="python-tid-1">
<title>Timemodulet</title>

<screen>
>>> import time
>>> type(time) # unødvendigt bevis for dig
&lt;type 'module'>

>>> time.time()
1064465521.312474
>>> time.gmtime()
(2003, 9, 25, 4, 53, 17, 3, 268, 0)
>>> time.localtime()
(2003, 9, 25, 6, 53, 46, 3, 268, 1)
>>> time.asctime()
'Thu Sep 25 06:54:19 2003'
>>> t = time.localtime()
>>> aar = t[0]
>>> aar
2003
>>> maaned = t[1]
>>> maaned
9
>>> dag = t[2]
>>> dag
25

>>> # pausefunktion
>>> # kontrol :   >>>  fremkommer efter pause på 10 sekunder.
>>> time.sleep(10)
>>>
</screen>
</sect2>

<sect2 id="python-tid-2">
<title>Datetime modulet</title>

<screen>
>>> import datetime
>>> type(datetime)  # unødvendigt bevis for dig
&lt;type 'module'>

>>> nu = datetime.datetime.now()
>>> nu.isoformat()
'2003-09-25T05:41:32.611578'
>>> nu.ctime()
'Thu Sep 25 05:41:32 2003'
>>> nu.strftime("%D %d %b")
'09/25/03 25 Sep')
>>> nu.strftime("%D %d")
'09/25/03 25'

>>> Dag = nu.strftime("%d")
>>> Dag
'25'

>>> Timetal24 = nu.strftime("%H")
>>> Timetal24
'07'

>>> Timetal12 = nu.strftime("%I")
>>> Timetal12
'07'

>>> AmPmLokal = nu.strftime("%p")
>>> AmPmLokal
'AM'
>>> EngelskEfterskrift = nu.strftime("%H") + nu.strftime("%p")
>>> EngelskEfterskrift
'07AM'
>>> # eller:
>>> EngelskEfterskrift = nu.strftime("%H") + nu.strftime("%p")
>>> EngelskEfterskrift = nu.strftime("%H") + " " + nu.strftime("%p")
>>> EngelskEfterskrift
'07 AM'

>>> # Funktionen beregner ugenummeret 1 for lavt
>>> # derfor nedenstående omregning
>>> Ugenummer = int(Ugenummer) + 1
>>> Ugenummer
39
>>> # konverteret til streng:
>>> Ugenummer = str(Ugenummer)
>>> Ugenummer
'39'

>>> # Søndag er ugens første dag (element 0)
>>> UgedagDecimal = nu.strftime("%w")
>>> UgedagDecimal
'4'

>>> AArstalKort = nu.strftime("%y")
>>> AArstalKort
'03'

>>> AArstalLang = nu.strftime("%Y")
>>> AArstalLang
'2003'
</screen>
</sect2>
</sect1>
</chapter>

<!-- Wange:
     Jeg mener det næste chapter bør flyttes ud i en seperat fil og
     bør dække bredere end de få eksempler der er vist.
-->
<chapter id="python-internettet">
 <title>Med Python på internettet</title>

 <para>
I en tid, hvor det ikke er ualmindeligt at modtage mails fra en meget stor del af den globale verden, kan det være rart
at se, hvilken server, det måtte være, hvorfra der sendes til en. I Python kan det ske særdeles enklet. De tre forholdsvis
ens eksempler, jeg nu vil vise, er så selvforklarende, at jeg kun vil tilføje, at Date: viser, hvornår jeg hentede de viste info ind. Dog skal tillægges 2 timer grundet forskellen i længdegrad fra Rønne til London og sommertiden. Endelig skal jeg
gøre opmærksom, på at Content-Length: informationen viser det antal bytes, der er i indexfilen og ikke andet. Jeg finder det selv interessant at se, hvilken server den besøgte benytter. Jeg kunne ikke lade være med at tage såvel folketingets
som Alt Om Datas udskrift med, fordi førstnævnte har vedtaget, at det offentlige skal bruge open source - og så bruger samme
folketing endda en ældre version af Microsofts server (version 4) - der er ingen forbindelse mellem påstanden om at ville
bruge eksempelvis Linux og så det at gøre det.
</para>

<para>
<screen>
>>> from urllib import urlopen
>>> dokument = urlopen("http://www.python.org").read
>>> # Her er der en kort pause mens URL kontaktes
>>> dokument = urlopen("http://www.python.org")
>>> print dokument.info()
Date: Thu, 07 Aug 2003 19:13:13 GMT
Server: Apache/1.3.26 (Unix)
Last-Modified: Wed, 06 Aug 2003 23:54:30 GMT
ETag: "5a750c-3ac2-3f319536"
Accept-Ranges: bytes
Content-Length: 15042
Connection: close
Content-Type: text/html

>>> from urllib import urlopen
>>> dokument = urlopen("http://www.folketinget.dk").read
>>> dokument = urlopen("http://www.folketinget.dk")
>>> print dokument.info()
Server: Microsoft-IIS/4.0
Date: Fri, 08 Aug 2003 03:40:56 GMT
Content-Type: text/html
Set-Cookie: ASPSESSIONIDTBRRRBAB=DBJEHKFBCNBPDGMCPBIKLJJG; path=/
Cache-control: private


>>> from urllib import urlopen
>>> dokument = urlopen("http://www.aod.dk").read
>>> dokument = urlopen("http://www.aod.dk")
>>> print dokument.info()
Server: Microsoft-IIS/5.0
Date: Fri, 08 Aug 2003 03:21:45 GMT
X-Powered-By: ASP.NET
X-AspNet-Version: 1.1.4322
Set-Cookie: ASP.NET_SessionId=dmbwzz455wrgrsmlwyhtyq45; path=/
Cache-Control: private
Content-Type: text/html; charset=iso-8859-1
Content-Length: 23164

>>> import ftplib
>>> # host kan læses som stedet, hvor filen er placeret.
>>> ftp = ftplib.FTP("ftp.host.dk")
>>> ftp.login("brugernavn skal ind her","password skal ind her")
'230 User brugernavn logged in.'

Hent dokument fra url på Web
>>> from urllib import urlopen
>>> dokument = urlopen("http://www.sslug.dk").read()
>>> print dokument

<!-- 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD><TITLE>SSLUG - Sk&aring;ne Sj&aelig;lland Linux User Group</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
... -->
</screen>
</para>
</chapter>
