<!-- $Id$ -->
<!-- Skrevet af Carsten Svaneborg - carsten.svaneborg@risoe.dk -->
<sect1 id="CGI-scripts">
<title>CGI-programmer</title>

<para>
Til at programmere CGI-programmer kan man vælge et vilkårligt
programmeringssprog. Til små programmer der udskriver server information kan et
kommandofortolkerprogram være passende. Til sider - når svartiden er kritisk 
eller når der skal udføres komplekse matematiske operationer - kan oversatte
sprog som Ada, C eller C++ anvendes. Men normalt skal kun tekst indlæses og
udskrives og det er en
opgave som programmeringssproget Perl er designet til at løse. Perl er et
fortolket sprog, der er beregnet til at behandle tekst med. Fordi det er et
fortolket sprog så skal perl koden fortolkes hver gang et program udføres,
hvilket tager en del tid. Tilgengæld behøver man ikke at bekymre sig om buffer
overflows i perl, hvilket er den hyppigste fejl i C programmer der anvender
strenge. Hvis man skal udføre mange CGI-programmer kan det være nødventigt at
anvende Fast_Cgi eller Mod_Perl modulet hvis funktion forklares senere.
</para>

<para>
 De følgende afsnit indeholder Perl-eksempler og kodestumper. Funktioner der
 allerede er anvendt i tidligere eksempler er slettet for at holde længden af
 programmerne nede, men der står også hvilke kodestumper der mangler og hvor
 de kan findes.  Mange af disse eksempler kan hentes som et fuldt fungerende
 eksempel. Står der for eksempel <FILENAME>debug.cgi</FILENAME> i Perl-koden
 betyder det, at kodeeksemplet kan hentes fra <ulink url=
 "http://www.sslug.dk/web/eksempler/debug.cgi">http://www.sslug.dk/web/eksempler/debug.cgi</ulink>.
</para>

<sect2 id="cgi-konf">
<title>Opsætning af Apache til at udføre CGI-programmer.</title>

<para>
 Hvis du selv bestyrer en webserver skal den først sættes op til at køre
 filer med endelsen ".cgi" som CGI-programmer. Hvis du bruger et web-hotel så
 vil du sikkert have adgang til noget information om hvor og hvordan
 programmer kan køres på webserveren. Følgende linier skal føjes til Apaches
 opsætningsfil, <filename>httpd.conf</filename>, der normalt findes i
 kataloget <filename>/etc/httpd/conf/</filename>:
</para>

<screen>
AddHandler cgi-script .cgi
ScriptAlias /cgi-bin/ /home/httpd/cgi-bin/
</screen>

<para>
 "Options ExecCGI" skal være slået til for alle kataloger, hvor webserveren
 skal køre programmer. Typisk er der i forvejen et
 <filename>/home/httpd/cgi-bin</filename>-katalog, hvor webserveren har ret
 til at køre programmer:
</para>

<screen>
&lt;Directory /home/httpd/cgi-bin&gt;
  AllowOverride None
  Options ExecCGI
&lt;/Directory&gt;
</screen>

<para>
 Det kan være nødventigt at ændre rettighederne til dette katalog, så du som
 normal bruger kan skrive i det. Det gøres med kommandoen "<command>chmod
 o+rwx /home/httpd/cgi-bin</command>"
</para>

<para>
 Til sidst skal du sikre dig at Apache overhovedet er i stand til at køre
 CGI-programmer, ved at aktivere "mod_cgi":
</para>

<!--  Er det følgende eksempel ikke noget ævl? -->
<screen>
LoadModule dir_module         modules/mod_dir.so
AddModule mod_cgi.c
</screen>

<para>
 Mange af disse ændringer består i at fjerne udkommenteringen (#) i
 eksisterende linier. Når disse ændringer er udført og webserveren har indlæst
 den nye opsætning (kør <command>/etc/rc.d/init.d/httpd reload</command>), så
 vil et program, <filename>runme.cgi</filename>, der ligger i kataloget
 <filename>/home/httpd/cgi-bin/</filename> kunne køres ved at man i en browser
 <!-- oser! --> beder om
 <filename>http://localhost/cgi-bin/runme.cgi</filename>.
</para>

</sect2>

<sect2 id="cgi-komweb">
<title>Kommunikation mellem webserver og CGI-program</title>

<para>
Et program har altid tre data strømme: stdin (Standard input) der er input
fra keybord, stdout (Standard output) der er output til skærmen, og stderr
(Standard error) der er fejl meddelelser og også udskrives til skærmen.
</para>

<para>
Når webserveren udfører et CGI-program vil alle data der udskrives til
stdout blive returneret til browseren. Data der skrives til stderr vil blive
gemt i webserverens fejllog <filename>/var/log/httpd/error_log</filename>.
Programmet kan også modtage data på stdin fra webserveren, dette vil typisk være
data der er indtastet i en webformular eller filer der skal oploades.
CGI-programmet modtager også en række data igennem systemvariable.
</para>

<para>
 I det følgende afsnit vil vi introducere CGI-programmer der returnerer et
 simpelt svar og ikke modtager data, forklare hvordan programmer kan returnere
 forskellige datatyper, og gennemgå hvordan programmer kan modtage data fra
 webformularer og anvende systemvariable til at bestemme for eksempel
 IP-addressen på den webbrowser som ønsker data.
 <!--
 Forklare sikkerhedsproblemerne der er omkring CGI-programmer, og hvordan man
 finder og fjerner fejl i dem.
 -->
</para>

</sect2><!-- cgi-komm -->

<sect2 id="cgi-svar">
<title>Simpelt svar</title>


<para>
Det simpleste eksempel på et CGI-program er et der bare returnerer et svar
for eksempel hvad er klokken. Gem følgende program i
<filename>/home/httpd/cgi-bin/</filename> som <filename>klokken.cgi</filename>
</para>

<screen>
#!/usr/bin/perl -w
#Filnavn: klokken.cgi

#Udskriv header
print "Content-Type: text/plain\r\n";
print "\r\n";

#Udskriv tekst indhold
print "Datoen er ".scalar(localtime);
</screen>

<para>
Køres <filename>klokken.cgi</filename> på kommandolinen får man:
</para>

<screen>
Content-Type: text/plain

Datoen er Thu Jul 20 11:38:08 2000
</screen>

<para>
Prøv nu at hente det i en web browser som
<command>http://localhost/cgi-bin/klokken.cgi</command>. Du skulle gerne kunne se
hvad datoen er. Prøv at reloade siden nogle gange, så du kan se sekunderne gå.
Hvis dette ikke virker så kig i sektionen om 'Typiske Fejl'.
</para>

<para>
 Først udskriver programmet en linie med et "Content-Type"-felt, der fortæller
 webbrowseren, hvilken type data (hvilket filformat) der kommer. Her betyder
 "text/plain" det at indholdet er tekst i et ikke nærmere angivet tegnsæt. Der
 kan være flere felter i HTTP-hovedet og de afsluttes med en tom linie. Alt
 efter den tomme linie er data til læseren.
</para>

<para>
 Tekst er lidt kedeligt, så vi kunne i stedet ønske at returnere HTML. Det kan
 let gøres ved at modificere programmet som følger:
</para>

<screen>
#!/usr/bin/perl -w

#Filnavn: klokken2.cgi

#Udskriv header
print "Content-Type: text/html\r\n";
print "\r\n";

#Vælg tilfældig farve 
my $color=sprintf("%x",int rand 0x1000000);

#Udskriv HTML indhold
print "&lt;H1>Datoen er: ";
print "  &lt;font color=\"#$color\">", scalar(localtime) ,"&lt;/font>";
print "&lt;/H1>";
</screen>

<para>
Programmet vil nu udskrive datoen med store bogstaver og med en tilfældig
farve der ændres hver gang programmet køres (siden genindlæses).
</para>

</sect2><!-- cgi-svar -->

<sect2 id="cgi-mtyper">
<title>Media typer</title>

<para>
Et CGI-program kan  ikke kun returnere tekst, men også en lang række andre
filformater. I Netscape kan man i
Edit/Preferences/Navigator/Applications se hvilke programmer, der udføres når
browseren modtager en fil med en bestemt Media type, hvis Netscape ikke kender
filtypen bliver brugerne bedt om at gemme filen på harddisken.
</para>

<para>
Følgende er en liste af Media-typer for nogle hyppigt anvendte
formater.
</para>

<table>
  <title></title>
<tgroup cols="2" align="char">
  <thead>
    <row>
      <entry>Datatype</entry>
      <entry>Beskrivelse</entry>
    </row>
  </thead>
  <tbody>
    <row>
      <entry>text/plain</entry>
      <entry>Rå tekst - text (.text eller .txt)</entry>
    </row>
    <row>
      <entry>text/html</entry>
      <entry>HTML - tekst (.html eller .htm)</entry>
    </row>
    <row>
      <entry>image/jpeg</entry>
      <entry>JPEG - billeder (.jpeg eller .jpg)</entry>
    </row>
    <row>
      <entry>image/png</entry>
      <entry>PNG - billeder (.png)</entry>
    </row>
    <row>
      <entry>image/gif</entry>
      <entry>GIF - billeder (.gif)</entry>
    </row>
    <row>
      <entry>application/postscript</entry>
      <entry>Postscript - præsentationer (.ps)</entry>
    </row>
    <row>
      <entry>application/x-dvi</entry>
      <entry>DVI-fil (oversat LaTeX-fil - .dvi)</entry>
    </row>
    <row>
      <entry>application/pdf</entry>
      <entry>Portable Document Format fil (.pdf)</entry>
    </row>
    <row>
      <entry>audio/x-mpeg</entry>
      <entry>MPEG-komprimeret lyd (.mp3)</entry>
    </row>
    <row>
      <entry>audio/x-wav</entry>
      <entry>Wave fil (.wav)</entry>
    </row>
    <row>
      <entry>video/x-mpeg2</entry>
      <entry>MPEG animation (.mpeg)</entry>
    </row>
    <row>
      <entry>video/quicktime</entry>
      <entry>Quicktime animation (.mov)</entry>
    </row>
    <row>
      <entry>video/x-msvideo</entry>
      <entry>Microsoft Video (.avi)</entry>
    </row>
  </tbody>
</tgroup>
</table>

</sect2><!-- cgi-mtyper -->

<sect2 id="cgi-headere">
<title>Headere</title>

<para>
Hvis man returnerer et svar med et CGI-program kan det ske at browseren
cacher det, og en reload vil derfor ikke køre programmet igen, men kun vise det
resultat der ligger i cachen. Følgende kode stump browseren og web caches som
squid at programmets uddata ikke skal caches.
</para>

<screen>
#Udskriv header
print "Content-Type: text/html\r\n";

#HTTP 1.1
print "Cache-Control: no-cache\r\n";

#HTTP 1.0 tilbage kompatibel
print "Pragma: no-cache\r\n";
print "\r\n";

#Her udføres resten af programmet
</screen>

<para>
Hvis output kan gemmes i en cache, men man ønsker at kontrollere levetiden
så kan dette gøres med Expires headeren, følgende kode stump viser hvordan
dette gøres:
</para>

<screen>
#Udskriv Header
use POSIX qw(strftime);

#må leve en time i cachen
my $levetid = 1*60*60;

#korrekt format laves med følgende linie
my $date = strftime "%a, %e %b %Y %H:%M:%S GMT", gmtime(time+$levetid);

print "Content-Type: text/html\r\n";
print "Expires: ",$date,"\r\n";
print "\r\n";

#Her udføres resten af programmet
</screen>

<para>
Programmet vil for eksempel udskrive en "Expires: Sat, 29 Jul 2000 16:45:27 GMT"
linie, der betyder at efter den dato er cache versionen forældet. Programmet
fungere ved at time returnere antallet af sekunder, der er gået siden 1 januar
1970, til dette antal sekunder lægges dokumentets levetid, og dette
konverteres af gmtime til en tabel af tidsdata i forhold til GMT, strftime
konvertere den tabel til det format som HTTP standarden forskriver.
</para>

<para>
Mere information om headere kan findes i RFC 1945 og RFC 2068 dokumenterne
der definere HTTP 1.0 og HTTP 1.1 protokollerne.
</para>

</sect2><!-- cgi-headere -->

<sect2 id="cgi-redir">
<title>Redirektion:</title>

<para>
I mange situationer bruges et program til at sende browsereren en bestemt
statisk side ud af mange, statisk i betydningen at indeholdet af siden ikke
ændres af programmet, for eksempel kunne et programm returnere forskellige sider til
forskellige browsere, eller forskellige sider på forskellige tidspunkter af
døgnet eller til forskellige IP addresser. Det kunne også være at man ville
have en jukeboks der spiller en tilfældig lydfil, eller viser et tilfældigt
baggrundbilled hvergang man besøger en side.
</para>

<para>
Istedet for at indlæse en fil og returnere indholdet af filen til browseren
kan et program istedet returnere en omdirigering, der fortæller browseren at den
kan finde svaret på den URL istedet. Syntaxen er "Location: URL".
</para>

<para>Et eksempel:</para>

<para>
Hver gang en browser forsøger at hente et katalog uden at specificere en
index fil, så afsendes "index.html"-filen. Denne funktionalitet specificeres i
<filename>httpd.conf</filename> med linien:
</para>

<screen>
DirectoryIndex index.html index.shtml index.htm index.cgi
</screen>

<para>
Dvs. at index.cgi køres hvis ikke nogen af de andre index filer kan findes
i kataloget. Så gem følgende program som index.cgi i et katalog med en masse
HTML-filer, og hvor der ikke er nogen anden index-fil.
</para>

<screen>
#!/usr/bin/perl -w
#Filnavn: index.cgi

#Lav en liste med indholdet af ./ kataloget
#dvs. samme katalog som index.cgi selv
opendir DIR, "./" or die "Can't list directory /.!\n";

#filtrér listen så den kun indeholder ".html"-filer
my @files = grep /\.html$/, readdir(DIR);

#vælg tilfældigt index i listen
my $no=int rand ($#files+1);

#udskriv en location til dokument no $no
print 'Location: ', $files[$no] ,"\r\n\r\n"; 
</screen>

<para>
 Programmet vil finde alle filer med endelsen ".html" i samme katalog, og
 udskrive en omdirigering til en tilfældig af dem.</para>

<para>Den samme metode kan bruges til at returnere et tilfældigt baggrundbilled
hver gang en person besøger en side. Hvis der ligger en masse JPEG-billeder i
/baggrund kataloget, kan ovenstående program gemmes i /baggrund kataloget, og
modificeres så '\.html' ændres til '\.jpeg', og HTML-koden for sider, der skal
have en tilfældig baggrund er nu:</para>
<screen>&lt;body background="/baggrunde/index.cgi"></screen>

</sect2>

<sect2 id="cgi-wf-get">
<title>Formularer (Get metoden)</title>

<para>CGI-programmer bruges også til at fortolke data, der bliver indtastet i
formularer på nettet, følgende eksempel er en simpel formular, hvor man kan
indtaste et navn og email adresse:
</para>

<screen>
&lt;form action="/cgi-bin/get_metoden.cgi" method="GET"&gt;
   Indtast navn: &lt;input type="text" name="navn"&gt;&lt;br&gt;
   Indtast Email: &lt;input type="text" name="email"&gt;&lt;br&gt;
   &lt;input type="Submit"&gt;
&lt;/form&gt;
</screen>

<para>
I browseren vil det se ud som:
</para>

<para>
<FIGURE ID="cgi-01" FLOAT="1">
<TITLE>Illustration</TITLE>
<GRAPHIC FILEREF="cgi.&magic;"></GRAPHIC>
</FIGURE>
</para>

<para>
Når et navn og en email addresse er indtastet, og der trykkes på Submit
knappen,  så vil browseren sende de indtastede data til webserveren, der
starter get_metoden.cgi-programmet. Dataene overfører webserveren igennem
systemvariablen QUERY_STRING. (C/C++-programmer vil også modtage
dem igennem argz tabellen).
</para>

<para>
Gem følgende program som <filename>get_metoden.cgi</filename> i
<filename>/home/httpd/cgi-bin</filename>:
</para>

<screen>
#!/usr/bin/perl -w

print "Content-Type: text/plain\r\n\r\n";
print $ENV{'QUERY_STRING'};
</screen>

<para>
I eksemplet vist vil get_data.cgi udskrive
"navn=Tux+Penguin&amp;email=Tux%40linux.org". Programmet modtager altså data fra
webformularen, men de ser lidt mystiske ud! Formattet af data er
"variabel1=indtastning1&amp;variabel2=indtastning2&amp;..". Hvor variabel1 og
variabel2 svarer til indeholdet af name feltet i HTML-koden (altså "navn" og
"email").
</para>

<para>
Både navne og indtastninger er URLenkrypterede. Det betyder at at mellemrum
skiftes ud med '+', ligeledes bliver en række karaktere specielt '=','%' og
'&amp;' ombyttet med den tilsvarende hexadecimal kode skrevet som %xx. I
eksemplet blev '@' lavet om til %40.
</para>

<para>
For at URL-afkode en streng skal den altså først klippes i stykker ved
alle '&amp;' karaktere, det giver en tabel af strenge af formen
"variabel=indtastning". Hver streng skal så klippes ved '=' og man får
variabel og indtastning hver for sig, og så skal alle '+' konverteres til
mellemrum og bagefter skal alle %xx konverteres til den tilsvarende ascii
karakter i både variabel og indtastning strengene, en lille detalje er at %00
null karakteren skal fjernes. Det er vigtigt at dette gøres netop i denne
rigtige rækkefølge ellers vil alle '+' karaktere der er indtastet ændres til
mellemrum.
</para>

<para>
Følgende Perl-program laver en URL enkrypteret streng om til en hash %data
af name->indtastning data.
</para>

<screen>
#!/usr/bin/perl

#Filnavn: get_metoden.cgi

sub URLdekrypt
#Udfører url dekryption på en streng.
{
    my ($input)=(@_);

    my ($variabel,$indtastning);
    my %data;

#Klip input strengen ved all '&amp;' karaktere

    my @query=split /&amp;/, $input;

#loop gennem tabellen af "variabel=indtastning" strenge

    foreach (@query)
      {

#Klip ved '='

        ($variabel,$indtastning)=split /=/, $_;

#fix '+' før %xy!

        $variabel    =~ tr/+/ /;
        $indtastning =~ tr/+/ /;

#null karaktere uønskede!
        $variabel    =~ s/%00//g;
        $indtastning =~ s/%00//g;

#substituter %xy med den tilsvarende karakter..

        $variabel    =~ s/%([0-9A-Fa-f]{2})/pack("c",hex($1))/ge;
        $indtastning =~ s/%([0-9A-Fa-f]{2})/pack("c",hex($1))/ge;

#Hvis flere felter har samme navn så konkateneres deres indhold
#separeret af en '|' karakter.

        if ($data{$variabel})
            { $data{$variabel}=$data{$variabel}."|".$indtastning; }
          else
            { $data{$variabel}=$indtastning; } 
      }

   return %data;
}

my %data=URLdekrypt($ENV{'QUERY_STRING'});

#udskriv data
print "Content-Type: text/plain\r\n\r\n";
print "Jeg modtog følgende data:\n";

foreach (sort keys %data)
    {
       print "   $_ = \"$data{$_}\"\n";
    }
</screen>

<para>
Programmet vil udskrive
</para>

<screen>
Jeg modtog følgende data:
    email = "Tux@linux.org"
    navn = "Tux Penguin"
</screen>

<para>
Istedet for at udskrive disse i browseren kunne programmet tilføje navn og
addresse til en database, eller en gæstebog, sende en besked til
addressen, eller hvad nu man kan finde på.
</para>

</sect2><!-- cgi -->

<sect2 id="cgi-wf-post">
<title>Webformulare (Post metoden)</title>


<para>
Rent praktisk returnerer GET-metoden data ved at føje dem til URL'en til
CGI-programmet adskilt af og-tegn (&amp;) og startende med et spørgsmålstegn
(se i browserens titelvindue).  Browseren sender så hele denne URL til
webserveren. GET-metoden har den fordel at man kan lave bogmærker med den side,
som programmet returnerer på basis af de indtastede data, dette bruges typisk
af webindices, så du let kan lave et bogmærke med søgeresulteter. Hvis denne
streng er meget lang kan man komme ud for at browseren eller webserveren går
ned, hvis der er fejl i koden. En
overgang kunne enhver Microsoft Internet Server version 4.0 hackes på den
måde. GET-metoden bør kun bruges til programmer der skal have mindre end
ca. 200 bytes inddata.
</para>

<para>
Alternativt findes POST-metoden for at sende data tilbage til webserveren.
Når et data Post'es så modtager CGI-programmet data på standard input, ligesom
data var indtastet på tastaturet, men de er stadig URL-kodede, og
systemvariablen CONTENT_LENGTH indeholder antallet af bytes der kan
læses. Det har fordelen at meget store datamængder kan returneres uden
problemer. Men det er umuligt at lave et bogmærke til den side, der kommer
tilbage, når man sender data via POST-metoden.
Det tidligere eksempel kan let omskrives til at bruge POST-metoden:
</para>

<screen>
&lt;form action="/cgi-bin/post_metoden.cgi" method="POST"&gt;
   Indtast navn: &lt;input type="text" name="navn"&gt;&lt;br&gt;
   Indtast Email: &lt;input type="text" name="email"&gt;&lt;br&gt;
   &lt;input type="Submit"&gt;
&lt;/form&gt;
</screen>

<screen>
#!/usr/bin/perl

#filnavn: post_metoden.cgi
#URLdekrypt funktionen kommer fra get_metoden.cgi

sub HentPostData
#Returnere en variabel med strengen på stdin
{
#antallet af bytes der venter på stdin
   my $ContentLength = $ENV{"CONTENT_LENGTH"};

   my $input="";

#max 10 kb input.
   my $maxSize=10240;

   if($ContentLength)
    {
       if ($ContentLength&lt;$maxSize)
          {
            read(STDIN,$input,$ContentLength);
          }
        else
          {
            print "Content-Type: text/plain\r\n\r\n";
            print "Script input exceeds acceptible size limit!";
            die "Error! $ENV{'REMOTE_ADDR'} attempted to submit $contentLength bytes!\n"; 
          }
     }

   return $input;
}

my %data=URLdekrypt(HentPostData());

#udskriv data
print "Content-Type: text/plain\r\n\r\n";
print "Jeg modtog følgende data:\n";

foreach (sort keys %data)
    {
       print "   $_ = \"$data{$_}\"\n";
    }
</screen>

<para>
POST-metoden kan modtage lige så store datamænger som man ønsker. Men
antallet af programmer der kan køre parallelt og mængden af hukommelse på den
computer de køre på sætter en grænse. I ovenstående eksempel er grænsen sat
ved 10kb. Hvis en browser forsøger at sende flere data vil CGI-programmet
returnere en fejl til browseren, programmet vil så dø efter at havde gemt en
diagnostisk tekst i webserverens fejllog, den diagnostiske tekst indeholder
$ENV{'REMOTE_ADDR'}, hvilket er IP addressen på den computer der har indsendt
et for stort svar. Det følgende afsnit forklarer hvilke andre data et
CGI-program modtager.
</para>

</sect2>

<sect2 id="cgi-info">
<title>Information tilgængelig for et CGI-program.</title>

<para>
 Når et program udføres, så modtager det information om browserens IP-adresse
 (typisk ikke dens DNS navn), og browserens navn og version. Kun hvis
 programmet befinder sig i et adgangskodebeskyttet katalog kan man få
 information om brugeren, der har indtastet data.
</para>

<para>
I HTML-koden der kalder programmet kan der også indlejres information
for eksempel:
</para>

<screen>
&lt;input type="hidden" navn="hemmelig" value="Jeg er en hemmelig streng"&gt;
</screen>

<para>
Hvis HTML-koden til en formular udskrives af et program, og det program
ønsker at overføre information til det program der modtager de indtastede data,
så kan skjulte felter anvendes. Webbrowseren viser ikke disse felter for
brugeren, og deres indhold returneres uændret til programmet, der modtager de
indtastede data (man bør dog være opmærksom på at "kreative" brugere kan finde
på at pille ved data fra skjulte felter, der derfor altid bør tjekkes lige så
grundigt som synlige felter). I det ovenstående eksempel vil programmet modtage
en variabel med navnet "hemmelig", der har indholdet "Jeg er en hemmelig
streng".
</para>

<para>
CGI-programmer kan også modtage en sti i systemvariablen PATH_INFO, og
argumenter i QUERY_STRING. Disse kommer fra action=".." linien i HTML-koden
for webformularen. Følgende er en række eksempler på hvordan et program kan
kaldes fra HTML-koden i en formular:
</para>

<table>
  <title>URL til CGI-program</title>
<tgroup cols="2" align="char">
  <thead>
    <row>
      <entry>URL til CGI-program</entry>
      <entry>Forklaring</entry>
    </row>
  </thead>
  <tbody>
    <row>
      <entry>/cgi-bin/debug.cgi</entry>
      <entry>Programmet modtager ikke nogen kommandolinieargumenter.</entry>
    </row>
    <row>
      <entry>/cgi-bin/debug.cgi?arg1&amp;arg2&amp;arg3</entry>
      <entry>QUERY_STRING environment variablen vil indeholde strengen
        "arg1&amp;arg2&amp;arg3".</entry>
    </row>
    <row>
      <entry>/cgi-bin/debug.cgi/foo/bar</entry>
      <entry>PATH_INFO environment variablen vil indeholde strengen
      "/foo/bar".</entry>
    </row>
    <row>
      <entry>/cgi-bin/debug.cgi/foo/bar?arg1&amp;arg2&amp;arg3</entry>
      <entry>Både QUERY_STRING og PATH_INFO vil indeholde data.</entry>
    </row>
  </tbody>
</tgroup>
</table>

<para>
Et eksempel på HTML-koden til en formular der anvender kommandolinieargumenter
og skjulte variable:
</para>

<screen>
&lt;form action="/cgi-bin/debug.cgi/foo/bar?arg1&amp;arg2" method="POST"&gt;
   Indtast navn: &lt;input type="text" name="navn"&gt;&lt;br&gt;
   Indtast Email: &lt;input type="text" name="email"&gt;&lt;br&gt;
   &lt;input type="hidden" navn="hemmelig" value="Jeg er en hemmelig streng"&gt;
   &lt;input type="Submit"&gt;
&lt;/form&gt;
</screen>

<para>
Følgende er en liste af de mest interessante environment variable som
CGI-programmer har til rådighed:
</para>

<table>
  <title>Variable</title>
<tgroup cols="2" align="char">
  <thead>
    <row>
      <entry>Variabel</entry>
      <entry>Indhold</entry>
    </row>
  </thead>
  <tbody>
    <row>
      <entry>REQUEST_METHOD</entry>
      <entry>Indeholder GET eller POST. I eksemplet ovenover "POST".</entry>
    </row>
    <row>
      <entry>PATH_INFO</entry>
      <entry>Indeholder stien program-URL'en i formularens HTML-kode. I
        eksemplet ovenover indeholder den "/foo/bar".</entry>
    </row>
    <row>
      <entry>PATH_TRANSLATED</entry>
      <entry>Indeholder PATH_INFO katalog data men relativt til WebRoot. Hvis
        webfiler ligger i /www så vil den i eksemplet indeholde
        "/www/foo/bar".</entry>
    </row>
    <row>
      <entry>QUERY_STRING</entry>
      <entry><para>Get metode: Indeholder URLenkrypted indtastningsdata.
        POST-metode: Indeholder argumenter efter '?' i URL'en til
        CGI-programmet. I eksemplet ovenover indeholder den "Arg1&amp;Arg2"
      </para></entry>
    </row>
    <row>
      <entry>HTTP_ACCEPT</entry>
      <entry>Indeholder de media typer, som browseren kan forstå. En tekst
        browser vil for eksempel ikke forvente grafik.</entry>
    </row>
    <row>
      <entry>HTTP_ACCEPT_CHARSET</entry>
      <entry>Karakterset som browseren kan forstå for eksempel "iso-8859-1,*,utf-8" Dvs.
        en browser der fortrækker et iso-8859-1 dvs. latin1 enkrypteret svar,
        man kan acceptere andre karakterset.</entry>
    </row>
    <row>
      <entry>HTTP_ACCEPT_LANGUAGE</entry>
      <entry>Det sprog som browseren fortrækker et svar på. For en bruger der
        fortrækker Dansk men den indeholde "da, en". (I Netscape sættes sprog
        preferencer i Edit/Preferences/Navigator/Languages)</entry>
    </row>
    <row>
      <entry>HTTP_ACCEPT_ENCODING</entry>
      <entry>Hvis browseren er istand til at klare komprimerede data. for eksempel "gzip,
        compress".</entry>
    </row>
    <row>
      <entry>HTTP_USER_AGENT</entry>
      <entry><para>Identificere brugerens browser. for eksempel Netscape 4.73:

        "Mozilla/4.73 [en] (X11; U; Linux 2.2.16-3 i686)"

        Galeon (en gtk browser baseret på Gecko):

        "Mozilla/5.0 (X11; U; Linux 2.2.16-3 i686; en-US; Galeon)
        Gecko/20000713".
      </para></entry>
    </row>
    <row>
      <entry>REMOTE_ADDR</entry>
      <entry>IP addresse på computer hvor data er blevet indtastet.</entry>
    </row>
    <row>
      <entry>REMOTE_HOST</entry>
      <entry>DNS navnet der svarer til IP adressen i REMOTE_ADDR. Denne
        returneres kun hvis HostNameLookups er slået til i Apache's kontrol
        filer. Det er den ikke som standard da det forsinker Apache at skulle
        lave et DNS opslag for hver forbindelse. (Den var slået til i den
        første netcraft sammenligning mellem Apache og MS Interne Server)</entry>
    </row>
    <row>
      <entry>REMOTE_USER</entry>
      <entry>Hvis programmet ligger i et adgangskodebeskyttet katalog, så
        indeholder REMOTE_USER navnet som brugeren har indtastet sammen med sin
        adgangskode.
        Det er ikke nok at beskytte den HTML-side, der indeholder
        formularen!</entry>
    </row>
  </tbody>
</tgroup>
</table>

</sect2>

<sect2 id="cgi-start">
<title>Et udgangspunkt for et CGI-program</title>

<para>
Det følgende echo.cgi-program kan bruges som udgangspunkt for egne
CGI-programmer og til at finde fejl i formularer. Det kan modtage både GET-
og POST-data, udskriver alle de data det modtager.
</para>

<screen>
#!/usr/bin/perl

#Filnavn: echo.cgi

#URLdekrypt er den samme funktion som i get_metoden.cgi
#HentPostData kommer fra kodestumpen i afsnittet om Post metoden 

my %data;

if ($ENV{'REQUEST_METHOD'} eq "POST") 
   {
      %data= URLdekrypt(HentPostData());                      #Post data
   }
  else
   {
      %data= URLdekrypt($ENV{'QUERY_STRING'});                #Get Data
   }

#Indtastningsdata er nu indlæst i %data

#Udskrivning af data
print "Content-Type: text/plain\r\n\r\n";
print "Variable Modtaget:\n\n";

#udskriv environment variable
print "Environment variable:\n";
foreach (sort keys %ENV)
    {
       print "   $_ = \"$ENV{$_}\"\n";
    }

#udskriv webformular data

if (%data)
{
  print "\nWebformular data:\n";

  foreach (sort keys %data)
    {
       print "   $_ = \"$data{$_}\"\n";
    }
}

#Hvis POST metoden bruges og der er argumenter så udskriv disse.

if ($ENV{'QUERY_STRING'} and $ENV{'REQUEST_METHOD'} eq "POST")
 {
   print "\nArgumenter:\n";

   foreach (split /&amp;/, $ENV{'QUERY_STRING'})
       {
          print "   \"$_\"\n";
       }
}
</screen>

</sect2>

<sect2 id="cgi-fejl">
<title>Typiske fejl</title>

<para>
Apache returnerer "Not Found":
</para>

<para>
Årsagen er at Apache ikke kan finde CGI-programmet.
</para>

<para>Hvis URL'en indeholder /cgi-bin/ kan fejlen skyldes at ScriptAlias ikke er
defineret i srm.conf.</para>

<para>Apache returnere "Forbidden"</para>

<para>Årsagen er at Apache ikke kan udføre programmet.</para>

<para>Problemet skyldes "Option ExecCGI"  ikke er slået til for det katalog som
CGI-programmet ligger i, dette gøres i access.conf. Alternativt kan fejlen
skyldes at Apache ikke har lov til at udføre programmet, det kan typisk kan det
løses ved "chmod o+rx script.cgi".</para>

<para>Apache returnere "Internal Server Error"</para>

<para>Denne fejl betyder at det første der udskrives ikke er en korrekt
formateret header.</para>

<para>Stderr og stdout outputet fra Perl-programmer kan findes i webserverens
fejllog - ofte i <filename>/var/log/httpd/error_log</filename> - og det gør det
let at rette denne type fejl. Et hurtigt syntakscheck er at køre CGI-programmet
på kommandolinien og se om der kommer fejlmeddelelser.</para>

<para>En anden mulighed er at Apache ikke har ret til at læse programmet,
det kan typisk kan løses med "chmod o+r script.cgi". Denne type fejl bliver
også logget i fejlloggen. Bruger Perl-programmet for lang tid vil en
timeout af webserveren også give denne fejl.</para>

<para>Fejlen kan også opstå hvis Perl-fortolkeren ikke ligger i
<filename>/usr/bin/perl</filename>, hvilket er en meget lumsk fejl for når man
kører programmet vil den svare
'script.cgi: command not found' (tcsh) eller 'bash: script.cgi: No such file
or directory', programmet findes og udføres, fejlen skyldes at den ikke kan
finde fortolkeren.</para>

<para>Browseren viser en "The document contained no data.":</para>

<para>Denne fejl kommer hvis programmet kun udskriver et HTTP-hoved, typisk
sker der en fejl i programmet så det dør, og skriver en fejlmeddelelse i
fejlloggen, men undlader at sende en fejlmeddelelse til browseren. I stedet for
<command>die</command>
kan følgende kode stump bruges hvis man i forvejen har udskrevet  headers ($!
er fejl teksten svarende til sidste fejl):</para>

<screen>
sub Fejl
#udskriver fejl til browser og error_log
{
  print "Fejl! $!";
  die "Fejl! $!";
}
</screen>

<para>Problemer med CGI-programmer, der typisk giver fejl:</para>

<para>CGI-programmer køres af webserveren og ikke af dig. typisk er
webserver-processen eget af brugeren 'nobody' i gruppen 'nobody', hvilket
betyder at programmet skal være udførbart og læsbart for alle. Det klares
med <command>chmod o+rx script.cgi</command>.</para>

<para>Hvis programmet skal gemme en fil i et katalog som du ejer, så skal det
katalog være skrivbart for webserveren, det betyder at katalogets mode skal
være executable, readable og writable for at CGI-programmet kan oprette en fil i
det. (<command>chmod o+rwx katalog</command>). Hvis man ikke vil give alle og enhver
adgang til at gemme filer i det katalog kan man bruge suExec som forklaret i
afsnittet om sikkerhedsaspekter.</para>

</sect2>

<sect2 id="cgi-debug">
<title>Fejlfinding i CGI-programmer</title>

<para>Der opstår fejl i alle programmer. CGI-programmer er dog mere besværlige at
debugge fordi de typisk skal køres fra en browser med et korrekt form input
for at generere en bestemt fejl, der typisk viser sig som en "Internal Server
Error" eller "The document contained no data."  i browseren. Og problemet er
nu at finde fejlen.</para>

<para>Al tekst der udskrives til stderr vil udskrives i Apaches fejllog. Dvs.
opstår der en fejl i programmet og det udføre en die "Fatal error occured!",
så vil der ikke udskrives nogen information til browseren men "tail 
/var/log/httpd/error_log" vil udskrive fejl meddelelsen. Det er derfor
praktisk at udskrive en fejl med print før at die kaldes, så fejlen kan ses i
browseren. Apache har nogle</para>

<para>Den hurtigste måde at finde fejl i et lille program på er ved at indsætte print
"Nu gør jeg følgene.." i koden og finde hvor fejlen opstår ved at flytte print
linierne rundt og køre programmet igen og igen og igen...</para>

<para>Men er Perl-programmet meget stort eller komplekst kan det tage en del tid at
finde fejlen ved at genstarte programmet gang på gang. Det er i stedet muligt at
fange input data og gemme dem i på harddisken, og så senere hente %data og
%ENV hashes fra harddisken. CGI-scriptet kan så køres i en debugger men med de
samme data og environment variable, som hvis det blev kørt af en webserver.
Bemærk at det ikke køres med samme bruger og gruppe id!</para>

<para>Den følgende stump perl kode kan bruges til at debugge CGI-scripts med. Den
anvender de funktioner der er erklæret i "Et udgangspunkt for et CGI-script"
afsnittet. Køres scriptet med $debug=0 vil det indlæse webformular data fra
get eller post metoden og fortsætte, altså uden at der sker noget.</para>

<para> Køres scriptet med $debug=1 og $gemdata=1 vil det indlæse webformular data
og gemme dem i to filer. %data gemmes i en fil ved navn "grab.var", og
environment variabler %ENV i en fil med navn "grab.env", scriptet vil så
stoppe.</para>

<para>Køres scriptet bagefter med $debug=1 og $gemdata=0 vil programmet
genoprette %data og %ENV, som da scriptet kørte første gang og det vil så på
en reproducibel måde behandle data, men med den fordel at dette kan ske på
kommandolinien eller i en debugger. De to filer er formateret i en syntax der
ligner XML så det er også let at lave ændringer i datafilerne.</para>

<screen>
#!/usr/bin/perl

#filnavn: debug.cgi
#koden til URLdekrypt og HentPostData funktionerne er den samme som i echo.cgi

my %data;

#debug kode ------------------------------------------------

#basefilenavn
my $filename="grab";

#0 for at modtage data fra webserveren og bearbejde dem.
#1 for at slå debugging til

my $isDebug = 1;    

#0 for at afspille data fra fil.
#1 for at gemme data

my $grabdata = 0;   

sub Fejl
#udskriver fejl til browser og error_log
{
  print "Content-Type: text/plain\r\n\r\n";
  print "Fejl! $!";
  die "Fejl! $!";
}

sub GemHash
#Gemmer en hash til en fil i et XML lignende format.
{
   my ($hashref,$filnavn)=@_;
   my $tag,$streng;

   open OUT, $filnavn or die Fejl;
   while (($tag,$streng)=each %$hashref)
      {
#For at afkodning skal være entydig må '&lt;' og '>' escapes.
         $streng =~ s/&amp;/&amp;amp;/g;
         $streng =~ s/&lt;/&amp;lt;/g;
         $streng =~ s/>/&amp;gt;/g;

         print OUT "&lt;$tag>$streng&lt;/$tag>\n";
      }
   close OUT;  
}

sub HentHash
#Henter en hash fra en fil.
{
   my ($hashref,$filnavn)=@_;
   my $content;

#backup af record separatoren.
   my $tmp=$/; 

#indlæs hele filen på en gang
   open IN, $filnavn or die Fejl;
   $/=undef;
   $content=&lt;IN>;

#loop gennem alle &lt;tag>data&lt;/tag>'s.
   while ($content =~ /&lt;(.*?)>([^&lt;]*)&lt;\/\1>/gc) { tohash($hashref,$1,$2); }

   $/=$tmp;
}

sub tohash
#addere hash data efter at escaped karaktere er fixet
{
  my ($hashref,$key,$str)=(@_);

#Fix escaped karaktere.
  $str =~ s/&amp;lt;/&lt;/g;
  $str =~ s/&amp;gt;/>/g;
  $str =~ s/&amp;amp;/&amp;/g;

  $$hashref{$key}=$str;
}

if (not $isDebug or $isDebug and $grabdata)
   {
#hvis ikke i debug mode skal inddata fortolkes.
#hvis i debug mode og grabdata så skal inddata også fortolkes.

        if ($ENV{'REQUEST_METHOD'} eq "POST") 
          {
             %data= URLdekrypt(HentPostData());          #Post data
          }
         else
          {
             %data= URLdekrypt($ENV{'QUERY_STRING'});    #Get Data
          }
   }

if ($isDebug)
{
  if ($grabdata)
     {
#Gem environment variable og data hash.
        GemHash(\%ENV, ">".$filename.".env");
        GemHash(\%data,">".$filename.".var");

#udskriv og stop scriptet når data er gemt.
        print "Content-Type: text/plain\r\n\r\n";
        print "Data er opsamlet og gemt i \"$filename.*\".";
        print "Sæt \$grabdata=0 og kør scriptet i en debugger\n";
        die;
     }
  else
     {     
#Slet alle environment variable
        %ENV=();

#hent environment og data hash fra filer.
        HentHash(\%ENV,  $filename.".env");
        HentHash(\%data, $filename.".var");

#fortsæt cgi programmet.
     }
}


#Her behandles webformular data.
</screen>

<para>Hvis scriptet er skrevet i C eller C++ har man den mulighed at man kan
debugge script processen mens det kører. Dette gøres ved at oversætte
programmet med en option "-ggdb" for inkludere debug information, og indsætte
en sleep(30) i starten af programmet (kræver unistd.h). Før programmet kører
su'er man til webserver brugeren. Når man trykker Submit vil programmet pause
i 30 sekunder, i den tid kan man udføre "ps aux | grep script.cgi" her kan man
se scriptets process nummer og så udføre "ddd script.cgi &lt;pid>" hvor
&lt;pid> er process nummeret man fik fra ps kommandoen. Man kan så single
steppe scriptet som det modtager, bearbejder og udskriver data. Dette trick
virker desværre ikke med Java, Pyton og Perl programmer da disse jdb, pydb og
perl debuggere ikke kan debugge en kørende process. Og det kræver at man har
nok rettigheder til at kunne attache til webserverens process.</para>

</sect2>

<sect2 id="cgi-sikkerhed">
<title>Sikkerhedsaspekter</title>

<para>CGI-scripts modtager data fra en tvivelsom kilde, og kan bruge disse data
som basis for hvilken som helst operation. I eksemplet der modtog data vha.
post metoden blev problematikken omkring meget store datamængder omtalt, og
koden der blev vist kan automatisk begrænse mængden af data scriptet vil
acceptere.</para>

<para>Og i afsnittet de data der var tilgængelig til et script blev skjulte
variable præsenteret som en sikker måde at overføre skjult information i en
webformular, men enhver kan i HTML-koden se at der er skjulte variable, og det
er en let sag at ændre de skjulte variable (gem HTML-koden, ret i de skjulte
variable, åben HTML-koden, indtast data, og submit dem). Er det vigtigt at de
skjulte variable ikke forfalskes må man bruge en eller anden checksums
algoritme. Ligeledes kan en ondskabsfuld person returnere helt andre variable
end dem der står i webformularen, man kan altså ikke stole på at fordi man har
et name="navn" felt i formularen, at det URLenkrypteret svar vil indeholde det
tilsvarende navn=.. felt. I perl vil dette svare til %data{'navn'} hvor "navn"
ikke findes i hashen og den returnere "", så det er ikke noget stort
problem.</para>

<para>En typisk problem kan være at data fra en webformular kan bruges som
filnavn til at gemme information, og derfor overskrive filer der ikke burde
overskrives, det bør derfor altid checkes om filen findes i forvejen, og hvad
der så skal ske. Istedet for et filnavn kan scriptet måske snydes til at
anvende en pipe istedet "|program", det betyder at det programmet tror at det
gemmer i en fil bliver brugt som input i en pipe til at udføre en arbitrær
kommando.</para>

<para>Det kan også være farligt at udskrive for meget information om den server
som scriptet kører på, siden at den type information kan misbruges af hackere.
Det følgende kode stump indeholder to sikkerhedsfejl:</para>

<screen>
#$filnavn er navnet på en fil og er indtastet i en webformular.

my $fil = "/www/filer/$filnavn";

#Indlæs og udskriv filen
</screen>

<para>Indtastes nu <filename>../../etc/passwd</filename> som filnavn i webformularen,
så vil scriptet vise alle brugere på serveren og deres deres enkrypterede
passwords (med mindre shadow password bruges), og den information er
tilgængelig for enhver på nettet. En hacker kunne så på sin egen computer lave
et brute force angreb ved at  prøve en masse passwords igennem, indtil at han
rammer et password der giver det enkrypteret password, som det i password
filen. Han kan så logge ind på serveren hvor CGI-scriptet udføres. Moralen er
at alle filnavne skal checkes for at sikre sig at de ikke indeholder katalog
information. En anden fejl er at scriptet selv udskriver siden, det betyder at
webserverens adgangskontrol til sider bliver tilside sat. Den følgende kode
stump checker om filnavnet indeholder '/' og istedet for at udskrive filen
udskrives en Location til filen. På den måde virker Apaches adgangskontrol og
ikke mindst adgangsbegrænsning stadig</para>

<screen>
#$filnavn er navnet på filen og kommer fra et en web formular.

die "Suspekt filnavn!\n" if  $filename =~ /\//;
my $fil = "/filer/$filnavn";

#udskriv en Location til filen.
</screen>

<para>Specielt farlige er de tre perl kommandoer eval, exec og system der gør det
muligt at udføre programmer, der kører med samme rettigheder som Apache
webserveren. System ved at der startes en shell (/bin/sh) og at denne modtager
en streng af kommandoer, der skal udføres. Følgende script udskriver hvilke
processer en bestemt bruger køre og indeholder en bagdør til webserver
kontoen.</para>

<screen>
#$user er et bruger navn fra en webformular.

print "Content-Type: text/plain\r\n\r\n";
system("ps aux | grep $user");
</screen>

<para>En bruger kan nu indtaste root og se alle de services der kører på
serveren, det giver en ide om hvilke sikkerhedshuller der kan anvendes på
serveren. Men som om det ikke var nok så kan enhver indtaste "<command>daisy ; r,
-rf /</command>" i webformularen.</para>

<para>Sker dette vil scriptet udfører "<command>ps aux | grep daisy ; rm -rf
/</command>", hviket betyder at scriptet efter at havde udskrivet alle daisy's
processer vil fortsætter med at rekursivt slette alle filer på filsystemet.
Typisk vil webdeamonen kun have adgang til at slette alle webfiler, og de data
som andre CGI-scripts har gemt. Men det kan være slemt nok hvis serveren er en
dedikeret webserver for et firma. Alternativt kunne en indtastning
"<command>daisy ; ls -la /home/</command>" udskrive alle hjemmekataloger og deres
adgangsrettigheder. Hvis der er et hjemmekatalog, der er læsbart for
webserveren kan hackeren læse alle filer, som den bruger har, og skrive til
alle de filer, der er skrivebare for alle brugere, hvis der findes en .rhosts
fil og hackeren kan skrive til den, vil han kunne logge ind som den bruger
uden password fra en vilkårlig server i verden. Hackeren ville også kunne
udsende emails, der tilsyneladende kommer fra webserveren.</para>

<para>Men det er stadig kun småting en hacker kan med dette simple script oploade
en terminal server (for eksempel netcat), oversætte den og køre den, således at han
kunne logge ind på webserveren med samme rettigheder som webserveren og uden
noget password. Og når en hacker har adgang til at køre vilkårlige kommandoer
kunne han checker versionsnumre på alle deamons og sammenligne disse med
kendte sikkerhedsfejl indtil han finder en bagdør til root kontoen.</para>

<para>Derfor bør man i et CGI-script altid undgå exec og system kommandoer. Med
eval kan ethvert perl udtryk udføres, dvs. ethvert perl udtryk der åbner
filer, sletter filer, udfører system eller exec. Det er derfor umuligt at
checke at et eval udtryk ikke indeholder farlige kommandoer.</para>

<sect3 id="cgi-tainted">
<title>Tainted variable</title>

<para>Perl har indbygget en smart funktion der gør det muligt at mærke variable,
der kommer fra farlige kilder (en farlig variabel kaldes "tainted" der betyder
noget i retning af mærket/beskidt/usikker), en environment strenge, input, og
output som andre programmer laver er automatisk tainted. Bruges en tainted
variabel som filnavn eller som argument i exec eller system kald, vil perl
automatisk stoppe med en fejl. Tainted variable slås til ved at kalde perl som
"#/usr/bin/perl -T" og de slås automatisk til hvis scriptet er setuid dvs.
"<command>chmod ug+s script.cgi</command>", således at scriptet kan køres af
webserveren med dine rettigheder.</para>

<para>Hvis man tager en delstreng ud af en tainted streng vil delstrengen også
være tainted, og konkateneres en tainted og en normal streng bliver resultatet
også tainted. Man kan derfor være rimelig sikker på at der opstår en fejl,
hvis man forsøger at bruge usikker information i en farlig operation. Den
eneste måde at untainte en streng på er ved at ekstrahere den fra et regulært
udtryk, for eksempel et der fjerner forbudte karakterer som ';','|' og '/'. Se "man
perlsec" for mere information om tainted variable.</para>

<para>Det følgende eksempel bruger tainted variable, og viser hvordan det
untaintes.</para>

<screen>
#!/usr/bin/perl -T

#hent variable fra webformularen.
#$user er et brugernavn indtastet i webformularen.
#det er derfor automatisk tainted.

if ($user =~ /^(\w+)$/)
 {
   $user = $1;

#$user er nu untainted og kan kun indeholde
#følgende karaktere A-Z,a-z,0-9, samt '_'
 }
else 
 {
   die "Suspekt brugernavn!\n";
 }

die "Fy! fingerene væk!" if ($user =~ /root/);

print "Content-Type: text/plain\r\n\r\n";
system("ps aux | grep $user");
#da $user er untainted generere dette ikke en fejl.
</screen>

<para>Hvis flere bruger skal have adgang til at køre scripts på den samme
webserver, så kan det være praktisk at anvende suEXEC (Swich User for Exec).
suEXEC er et add-on til Apache, der tillader CGI-scripts at køre med samme
rettigheder som den individuelle bruger, der har lavet scriptet istedet for
som webserveren. Det er langt sikrere end at setuid'e scriptet med
"<command>chmod ug+s script.cgi</command>", men kræver også at det bliver korrekt
konfigureret for at undgå sikkerhedshuller og Apache genoversættes, det er
derfor ikke inkluderet i den Apache version der normalt distribueres.
Dokumentation hvordan Apache genoversættes med suEXEC indbygget er inkluderet i
Apache dokumentationen og kan findes i /home/httpd/html/manual/suexec.html.
suEXEC giver også mulighed for at hver bruger har sin egen fejllog,
hvilket letter debugging af scripts.</para>

</sect3>
</sect2>

<sect2 id="cgi-fast">
<title>FastCGI</title>

<para>En ulempe ved perl CGI-scripts er at hver gang de køres så skal perl
fortolkeren starte og den skal fortolke den samme perl kode igen og igen, og
det tager en del tid hvilket kan være upraktisk hvis skriptet skal køres mange
gange i sekunded.</para>

<para>Bedre ville det være hvis CGI-scriptet kørte hele tiden, og kunne modtage
mange data uden at skulle genstartes. Dette er hvad fastCGI gør muligt ved at
definere en protokol for hvordan en process kan kommunikere med webserveren's
cgi modul.</para>

<sect3 id="cgi-fast-inst">
<title>Installation af FastCGI</title>

<para>Installer apache-devel program pakken (indeholde apxs programmet).</para>

<para>Download koden til FastCGI apache-modulet fra <ulink url="http://www.fastcgi.com">http://www.FastCGI.com</ulink></para>

<para>Oversæt koden med:</para>

<screen>
apxs -c -o mod_fastcgi.so *.c
</screen>

<para>Installer apache modulet med:</para>

<screen>
apxs -i -a -n fastcgi mod_fastcgi.so
</screen>

<para>Check at mod_fastcgi er inkluderet i httpd.conf og at path til det
dynamiske bibliotek er korrekt.</para>

<para>Adder følgende linie til srm.conf</para>
<screen>AddHandler fastcgi-script fcg fcgi fpl</screen>

<para>Restart apache</para>

<screen>
/etc/rc.d/init.d/httpd restart
</screen>

<para>Apache webserveren understøtter nu fastCGI protokollen.</para>

<para>På <ulink url="http://www.cpan.org">http://www.cpan.org</ulink> kan man downloade
et FCGI modul der tillader perl programmer at anvende fastCGI modulet. Perl
modulet som andre perl moduler med:</para>

<screen>
tar -zxvf FCGI-0.53.tar.gz
cd FCGI-0.53
perl Makefile.PL
make
make install
</screen>

</sect3>

<sect3 id="cgi-fast-use">
<title>Brug af FastCGI</title>

<para>Gem følgende script som fastcgi_test.fcgi og kør det flere gange i
browseren.</para>

<screen>
#!/usr/bin/perl
use FCGI;

#filnavn: fastcgi_test.fcgi
my $count=0;

my $request = FCGI::Request();

while($request::accept() >= 0) 
{
   print "Content-Type: text/html\r\n\r\n";
   print "&lt;h1&gt;FastCGI test&lt;/h1&gt;\n";
   print "&lt;p&gt;Antal af forbindelser for dette script: ++$count&lt;/p&gt;\n";

#her kan resten af cgi scriptet udføres.
}
</screen>

<para>Det specielle ved FastCGI scripts er at de kan huske tidligere
forbindelser. $count i eksemplet tælles op for hver gang scriptet modtager en
forbindelse. Efter at fcgi scriptet er udført kan man med "ps aux | grep perl"
se at det venter på næste gang det skal modtage data. En forskel på FastCGI og
normale perl scripts er at perl scripts løbende udskriver print bufferen til
webserveren, mens FastCGI scripts kun returnere data når de afsluttes, eller
hvis bufferen flushes med $request->Flush().</para>

<para>Hvis man ændrer perl koden, og prøver scriptet igen skal man være opmærksom
på at man kan fælde et antal af gamle fcgi scripts, der må dræbes manuelt med
"kill &lt;pid>". FastCGI scripts kan også laves i C og Tcl se <ulink url="http://www.fastcgi.com">http://www.fastcgi.com</ulink> for mere
dokumentation om protokollen og hvordan den anvendes.</para>

</sect3>
</sect2>
</sect1>

