<chapter id="remote-login">
 <title>Remote login og netværksaflytning</title>

 <indexterm>
  <primary>remote login</primary>
 </indexterm>

 <indexterm>
  <primary>netværksaflytning</primary>
 </indexterm>

 <para>
  En af de store styrker ved et Linux-system (eller et andet Unix-system)
  er, at man kan administrere den fra en anden maskine via netværk. For at være
kompatibel med alle andre UNIX varianter følger de gode gamle værktøjer 
<command>telnet</command> og ftp med i Linux-distributionerne, og de er meget anvendte 
til fjernadministration. Vi vil i dette kapitel se på, hvorfor 
værktøjer som <command>telnet</command> og ftp ikke bør anvendes, hvis maskinen er koblet til 
internettet eller et andet usikkert netværk. Vi skal se på, hvordan 
netværkstrafik kan aflyttes. Derefter skal vi se nærmere på alternativer 
til <command>telnet</command> og ftp, hvor datastrømmen bliver krypteret. Specielt 
fokuserer vi på OpenSsh (den frie version af secure shell) og 
viser installation og anvendelse.
Meget af det, der beskrives i artiklen, gælder ikke blot for Linux, men
også for andre UNIX'er.
</para>

 <sect1 id="usikker-nettrafik">
  <title>Nem men usikker netværkstrafik</title>

  <para>
   Fra en Linux-maskine kan man nemt logge ind på en anden Linux-maskine
   og køre programmer, endog grafiske programmer. Dermed kan man køre
tunge programmer på en stærk server og få vist resultater på en anden 
(måske langsommere) maskine. 
</para>

<para>
Antag, at vi har et lokalnet bestående af tre maskiner. Vi anvender
maskinen "hven" (IP-adresse 192.168.0.1) med brugernavnet tyge, men vi
vil køre programmer fra maskinen "bohr" (192.168.0.2). I netværket 
finder vi desuden maskinen "nottingham" (192.168.0.3), som vi leger er 
en ondsindet maskine, der ønsker at bryde vores sikkerhed. I praksis 
kunne det være tre maskiner på internettet, hvor netværkstrafik mellem 
"hven" og "bohr" tilfældigvis også kommer forbi "nottingham".
</para>

<para>
Resten af kapitlet vil handle om programmer til remote login, som <command>telnet</command>, 
<command>rlogin</command> og ssh, samt programmer til filoverførsel (ftp og scp). Men hvad
bruges det til? Med remote login kan man udføre tekstkommandoer på den
maskine, man er logget ind på, men man kan også køre X-programmer over
nettet.
</para>

<sect2 id="telnet-og-xhost">
<title>telnet og xhost</title>
<indexterm><primary>telnet</primary><secondary>sikkerhed</secondary></indexterm>
<indexterm><primary>xhost</primary><secondary>sikkerhed</secondary></indexterm>

<para>
Hvis du på hven kører en X-baseret grafisk brugergrænseflade, og
du vil køre X-programmer (grafiske programmer) fra maskinen "bohr",
skal du starte med at fortælle maskinen "hven", at det er i orden, at
maskinen "bohr" benytter dens display.  Dette gøres ved at føje "bohr" til
listen med godkendte X-klienter med kommandoen <command>xhost</command>:

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>xhost +bohr</userinput>
bohr being added to access control list 
</screen>
</para>

<para>Dermed vil grafiske programmer fra "bohr" blive accepteret af
"hven". Udelades maskinnavnet, betyder det, at alle maskiner kan vise
grafik på din skærm. Lad være med det, da det sikkerhedsmæssigt er
en ekstremt dårlig ide. 
</para>

<para>
Lad os nu logge ind på "bohr" med <command>telnet</command>,
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>telnet bohr</userinput>
Trying 192.168.0.2...
Connected to bohr.herne.dk.
Escape character is '^]'.
Debian GNU/Linux 2.1 bohr.herne.dk

bohr login: tyge
Password:
</screen>

<para>
Efter at have skrevet brugernavn og adgangskode på bohr-maskinen får
du en kommandolinje, og du kan udføre programmer på maskinen, som om du
var logget ind lokalt. 
</para>

<para>
For at kunne få de grafiske programmer, du starter på bohr, til at
vise sig på hvens skærm er det nødvendigt at sætte systemvariablen
<literal>DISPLAY</literal>:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>export display=hven:0.0</userinput>
</screen>

<para>
Mange X-programmer kan dog også kaldes med "-display" som option. 
</para>

<para>
Nu kan du køre dit X-program, f.eks. "xload", som om du sad på 
bohr. Programmet kører på bohr, men
alt grafik vises på hven, og programmet styres fra hven. 
</para>

<screen>
<prompt>[tyge@bohr tyge]$ </prompt><userinput>xload -display hven:0.0 -geometry 60x60 -nolabel &amp;</userinput>
</screen>

<figure id="xload-fig" float="1">
<title>xload</title>
<graphic fileref="xload.&magic;"  scale="40"></graphic>
</figure>  

<para>
Problemet er ikke at du nu kan kalde grafik op på en anden skærm end
din egen. Problemet er, at den adgang du har etableret med <command>xhost</command> så at
sige går begge veje. I og med du har lavet <command>xhost +bohr</command> har alle brugere på bohr adgang til at læse og
skrive fra og til dit dislay på "hven". Er bohr et
multibrugersystem, og har en cracker, eller blot en nysgerrig kollega
konto på maskinen, kan vedkommende køre kommandoen <command>xwd -display
hven:0.0 -root -out hven.dump</command> efterfulgt af <command>xwud -in
hven.dump</command>. Den første giver vedkommende et skærmdump af hven, den
næste viser dette billede lokalt (på bohr). Alt hvad du kan se på
skærmen på hven kan enhver på bohr tage et dump af.
</para>

<para>
Selv hvis hven har <command>xhost -</command> kan en bruger, der har
lokal shell-adgang på hven, i visse tilfælde stadigvæk køre
xwd-kommandoen! Vedkommende skal så blot være logget ind på hven, når
kommandoen udføres - det kan ikke ske over nettet som beskrevet
ovenfor.
</para>

<para>
Det bliver værre: Med <command>xlswins</command> kan man vise hvilke
vinduer (xterm, netscape osv.) der er åbne på den anden maskine, og så
dump disse enkeltvis med <command>xwatchwin</command>. Begge
programmer er enten med i standard X, eller fås kvit og frit på
internettet.
</para>

<para>
Og værre: Programmet <command>xscan</command> skal efter sigende kunne
lave et tilsvarende trick, men med tastetryk. Direkte til en logfil,
alt hvad der tastes på maskinen, der har <command>xhost</command>: brugernavne,
adgangskoder, pgp-koder.
</para>

<para>
<command>xhost</command> er generelt en meget dårlig ide, og bør i
alle tilfælde erstattes med SSH, der automatisk og transparent sørger
for at sætte display og X rettigheder, så man hele tiden "har sit
display med sig".
</para>
</sect2>

<sect2 id="sende-passwords-over-net">
<title>Pas på adgangskoder sendt over netværk</title>
<indexterm><primary>password</primary><secondary>Sendt over netværk</secondary></indexterm>
<indexterm><primary>adgangskode</primary><secondary>Sendt over netværk</secondary></indexterm>
<indexterm><primary>sniffit</primary></indexterm>

<para>
For at aflytte netværkstrafikken kan man hente programmet sniffit
til Linux. Når det startes op vises alle kommunikationslinjer,
såsom telnet- og ftp-forbindelser, mellem maskinerne på netværket. Det
kommer an på opsætning af routere, firewalls, switche og hubs,
hvor meget man reelt får at se.  Sniffit kan hentes fra 
<ulink url="http://reptile.rug.ac.be/~coder/sniffit/sniffit.html">http://reptile.rug.ac.be/~coder/sniffit/sniffit.html</ulink>. 
</para>

<para>
Det er en udbredt misforståelse at man ikke kan aflytte switchede
netværk - men kun netværk med hubs. Dette er forkert og
aflytningen kan typisk foretages ved hjælp af ARP spoofing -
eksempelvis med arpspoof programmet der følger med dsniff. Link:
<ulink url="http://www.monkey.org/~dugsong/dsniff/">
http://www.monkey.org/~dugsong/dsniff/</ulink>.
Dsniff kan opsamle og afkode traffik fra mange usikre protokoller.  
Sniffit og dsniff skal køres som root.
</para>

<para>
Lad os antage, at den ondsindede "nottingham" (192.168.0.3) lytter med på, 
hvad vi laver mellem "hven" (192.168.0.1) og "bohr" (192.168.0.2).
Programmet sniffit startes i interaktiv tilstand med angivelse af
hvilket netværks-interface, der skal lyttes på: 
</para>

<screen>
<prompt>[root@nottingham root]# </prompt><userinput> sniffit -F eth0 -i</userinput> 
</screen>

<para>
hvor eth0 betyder første ethernet kort i maskinen, og i betyder
interaktiv tilstand. Ud kommer nedenstående billede, hvor man ser, at
maskinen med netværksadresse 192.168.0.1 (hven) har oprettet en
forbindelse til port 23 på maskinen med netværksadresse 192.168.0.2
(bohr). Port 23 er den port, telnet lytter på. Port 3211, som man
sender fra, er valgt blandt maskinens ledige porte, dvs. de porte, der
ikke er nogen service, der lytter på.  Der er valgt et portnummer, som
er større end 1024, dvs. en ikke priviligeret port.
</para>

<para>
Trykkes return på en linje vil den blive markeret med "*LOGGED*",
og det mindre vindue mod højre vil vise trafikken på den forbindelse. 
Først kommer login navn: "tyge", og efter to punktummer kommer adgangskoden
i klar tekst: "qwe123". Der skal ikke stor fantasi til at forestille sig, 
at dette program nemt kan sættes til at dumpe samhørende brugernavne og 
adgangskoder ned i en fil over en periode, indtil der er gevinst. 
</para>

<figure id="sniffit2-fig" float="1">
<title>Sniffit</title>
<graphic fileref="sniffit2.&magic;"  scale="40"></graphic>
</figure>  


<para>
Vi har vist, at man ikke skal bruge <command>telnet</command> til at kommunikere mellem
to maskiner, hvis der er risiko for, at nogen lytter med, og slet ikke
hvis man skal logge ind som root på maskinen. Det er simpelthen for
nemt at lede efter loginnavn root og derefter få adgangskoden. Derfor
har mange Linux-distributioner per default forhindret, at root logger
ind via netværket. Red Hat 6.0, Debian 1.3 og SuSE 6.2 har filen
"/etc/securetty", der indeholder de konsoller, hvor root må logge ind.
Dette kan være "tty1" til "tty6", som er de tekst login konsoller, der
normalt er på selve Linux-maskinen - dvs. ikke via netværket. Hvis man
absolut vil tillade root login via netværk, kan man tilføje "0", "1"
og opefter (for Linux-kerne 2.2.X) svarende til hvor mange logins, du
forventer på maskinen fra netværket. Normalt er det
<emphasis>ikke</emphasis> klogt at tillade direkte root login via
netværk.
</para>
</sect2>

<sect2 id="ftp-sniffit">

<title>ftp</title>
<indexterm><primary>ftp</primary><secondary>sikkerhed</secondary></indexterm>
<para>
Hvis vi vil overføre filer fra "hven" (192.168.0.1) til
"bohr" (192.168.0.2), er ftp et af de gennemprøvede og gamle 
værktøjer. Også her er der sikkerhedsproblemer.
Vi sætter igen "nottingham" (192.168.0.3) til at køre sniffit som vist 
nedenfor. Denne gang sætter vi sniffit op til at vise alle pakker som 
ankommer til "bohr" (192.168.0.2), og man kan nemt se, 
hvad der sker.
</para>

<screen>
<prompt>[root@nottingham root]# </prompt><userinput> sniffit -t192.168.0.2 -a -F eth0</userinput>
</screen>

<programlisting>
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1299-192.168.0.2.21
 E . . 4 . . @ . @ . . . . . . . . . . . . . . . . . b . . . . . P . } x i !
 . . U S E R   r o b i n . .

Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1299-192.168.0.2.21
 E . . ( . . @ . @ . . . . . . . . . . . . . . . . . b ( . . . . P . } x . .
 . .

Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1299-192.168.0.2.21
 E . . 5 . . @ . @ . . . . . . . . . . . . . . . . . b ( . . . . P . } x N D
 . . P A S S   q w e 1 2 3 . .
</programlisting>

<para>
På den første af de tre data-linjer kan man se login navn (tyge), og som 
vist på den sidste data-linje, vil man direkte kunne læse adgangskoden (qwe123). 
Ser man lidt nøjere efter, vises også ftp-porten, port 21. Port 
1299 er ligesom ved <command>telnet</command> en ledig port, der vælges til denne session.
</para>

<para>
Som vi ser, er ftp også et meget usikkert program, hvor andre kan lytte med.
Så brug det med omtanke.
For en systemadministrator er paranoia ikke en sygdom, men en kvalifikation...
</para>

<para>
Det skal nævnes, at også resten af den nettrafik, du laver med <command>telnet</command> og
ftp, kan læses i klar tekst via f.eks. sniffit. Starter du andre
programmer, kan man se det. Laver du "su - root" og skriver "root"s adgangskode, 
er sikkerheden på den maskine væk, for "root"s adgangskode er ude, hvis du
bliver aflyttet.
</para>
</sect2>

<sect2 id="remote-shell">
<title>Remote login, remote shell og remote copy</title>
<indexterm><primary>Remote login</primary></indexterm>
<indexterm><primary>Remote shell</primary></indexterm>
<indexterm><primary>Remote copy</primary></indexterm>
<indexterm><primary>rcp</primary></indexterm>
<indexterm><primary>rsh</primary></indexterm>

<para>
To andre velkendte programmer i samme kategori er "<command>rlogin</command>" og "rsh".
Programmerne virker næsten ens. Begge 
giver interaktivt login på maskinen, men rsh kan udføre en kommando 
samtidig med, at man logger ind. F.eks. vil den følgende kommando logge 
ind direkte fra hven til bohr og køre kommandoen "df" (som viser 
hvor fyldte dine diske er).
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>rsh bohr df</userinput>
</screen>

<para>
Nu prøver vi at køre sniffit på en <command>rlogin</command> session for at se, hvad man kan se.
På maskinen "nottingham" kører vi sniffit:
</para>

<screen>
<prompt>[root@nottingham root]# </prompt><userinput>sniffit -x -s192.168.0.1 -a -F eth0</userinput>
</screen>

<para>
Vi logger ind fra hven til bohr med kommandoen:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>rlogin bohr</userinput>
Password: qwe123
$ 
</screen>

<para>
hvor adgangskoden naturligvis ikke kan ses på skærmen, når man taster den ind.
Udklip fra sniffit's output:
</para>

<programlisting>
TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA41   ACK (hex): 105DA03F
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ? s . @ . @ . F Q . . . . . . . . . . . . . . . A . ] . ? P . } x C .
 . . r o b i n . r o b i n . x t e r m / 9 6 0 0 .     


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA58   ACK (hex): 105DA040
   FLAGS: -A----   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ( s . @ . @ . F g . . . . . . . . . . . . . . . X . ] . @ P . } x } A
 . .


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA58   ACK (hex): 105DA041
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . 4 s . @ . @ . F J . . . . . . . . . . . . . . . X . ] . A P . } x . .
 . . . . s s . . . P . . . l


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA64   ACK (hex): 105DA04B
   FLAGS: -A----   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ( s . @ . @ . F U . . . . . . . . . . . . . . . d . ] . K P . } x } *
 . .


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA64   ACK (hex): 105DA04B
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ) s . @ . @ . F S . . . . . . . . . . . . . . . d . ] . K P . } x . !
 . . q


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA65   ACK (hex): 105DA04B
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ) s . @ . @ . F R . . . . . . . . . . . . . . . e . ] . K P . } x .
 . . w


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA66   ACK (hex): 105DA04B
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ) s . @ . @ . F Q . . . . . . . . . . . . . . . f . ] . K P . } x . .
 . . e


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA67   ACK (hex): 105DA04B
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ) s . @ . @ . F P . . . . . . . . . . . . . . . g . ] . K P . } x L .
 . . 1


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA68   ACK (hex): 105DA04B
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ) s . @ . @ . F O . . . . . . . . . . . . . . . h . ] . K P . } x K .
 . . 2


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA69   ACK (hex): 105DA04B
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ) s . @ . @ . F N . . . . . . . . . . . . . . . i . ] . K P . } x J .
 . . 3
</programlisting>

<para>
Igen ser man tydeligt brugernavn og adgangskode blive sendt ukrypteret
over nettet (se sidste tegn på hver linje).  Man kan se, at <command>rlogin</command> på
bohr bruger port 513, og at der på hven sendes fra port 1023.
</para>

<para>
Skal du kopiere filer mellem to maskiner, så er ftp som tidligere
skrevet meget anvendt. Alternativt kan remote copy
<command>rcp</command> anvendes.  Skal du kopiere filen
<filename>.emacs</filename> fra hven til bohr, sker dette med
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>rcp .emacs bohr:</userinput>
</screen>

<para>
Sikkerhedsmæssigt er <command>rcp</command> på linje med
<command>rlogin</command> og <command>rsh</command>. Vi skal senere i
artiklen vende tilbage til et fuldt krypteret alternativ til
<command>rcp</command>.
</para>

<para>
Med <command>rlogin</command>, rsh og rcp kan man vælge, at login kan ske uden
adgangskode. Dette gøres ved at sætte sit hostnavn og evt. brugernavn ind
i filen <filename>~/.rhosts</filename> i sit hjemmekatalog på den
maskine, der skal logges ind på. Hvis du gerne vil kunne logge ind fra
hven til bohr uden adgangskode, som brugeren tyge, kan
<filename>.rhosts</filename>-filen i dit hjemmekatalog på bohr se
sådan ud:
</para>

<programlisting>
hven tyge
</programlisting>

<para>
Der kan godt stå mange flere linjer med andre hostnavne. Brugernavnet
kan udelades, idet brugeren sættes til den, hvis hjemmekatalog filen
ligger i.  Hvis filen er læsbar for alle, er det kun en bruger med
samme brugernavn som sit eget, der kan logge ind fra en anden
maskine. Er filen ikke læsbar for andre, kan man anføre linjer i
<filename>.rhosts</filename>-filen med først maskinnavn og dernæst det
brugernavn, som anvendes på den anden maskine. For at "peter" skal
logge på ind på "hven" som "tyge", kan man således bruge
<command>rlogin hven -l tyge</command>.
</para>

<para>
Den viste <filename>.rhosts</filename>-fil vil betyde, at du fra
maskinen "hven" som brugeren "tyge", godt må komme ind på bohr
som "tyge", uden adgangskode. Det kræver, at brugeren findes på begge
maskiner, og ".rhosts" filen skal ligge i brugerens hjemmekatalog på
den maskine, man prøver at logge ind på. Det er nemt og giver
lynhurtig adgang til, at man hopper fra maskine til maskine og laver
meget effektive arbejdsgange. Det lyder smart, men medaljen har en
bagside. En med root-adgang på maskinen "nottingham" (eller andre
maskiner i netværket) kan aflytte rsh/rlogin netværkstrafik et stykke
tid, og derved finde ud af fra hvilken maskine og med hvilket bruger
navn, man kan logge ind direkte.  Derefter kan man med lidt snilde
sætte maskinen "nottingham" lidt anderledes op, så "bohr" tror, at
den er "hven".
</para>

<para>
Der kan imidlertid være situationer, hvor det kan virke mere sikkert
at lade en bruger logge ind uden adgangskode fra en kendt host end at
lade brugeren have en adgangskode. Har man tillid til sit interne
netværk, og er det nødvendigt, at nogle brugere kan logge på en udsat
maskine, kan man vælge, at disse brugere ikke har nogen adgangskode på
den udsatte maskine.  I stedet får de en stjerne ("*") i
<filename>/etc/passwd</filename>, der hvor adgangskoden normalt ville
stå.  Dette vil forhindre dem i at logge ind fra andre maskiner end
dem, der er angivet i deres <filename>~/.rhosts</filename> fil i deres
hjemmekatalog på den udsatte maskine. Når en bruger ikke har en
adgangskode, kan man ikke bryde ind på den udefra ved at gætte eller
knække adgangskoden. Men kan kun logge ind som denne bruger, hvis man
kan overbevise maskinen om, at man logger ind fra en betroet
maskine. Der kan i øvrigt læses mere om adgangskodebeskyttelse og
håndtering i <xref linkend="root-access"/>.
</para>

<para>
Hvis man ikke tillader <filename>.rhosts</filename>-filer, vil der ved
hver login sendes adgangskoder i klar tekst over nettet. Hvis der er
<filename>.rhosts</filename>-filer, bliver der slet ikke sendt
adgangskoder over nettet - i stedet for at give sin adgangskode skal man
logge ind fra en betroet host. Ingen kan nu opsnappe adgangskoder - til
gengæld kan de udgive sig for at være den betroede host.  Stoler man
ikke på sit interne netværk, eller er nogen <emphasis>sluppet
ind</emphasis>, er begge dele nok lige dårligt.
</para>

<para>
Vi vil anbefale, at man i stedet for <command>rlogin</command> bruger et program, der 
krypterer login såvel som selve dataoverførslen, som f.eks. SSH giver
mulighed for.
</para>

<para>
Som systemadministrator kan du se om dine brugere har
<filename>.rhosts</filename> filer, og hvis det ikke er ønsket, kan du
slette dem (og skælde brugeren ud).  Hvis brugerne har hjemmekataloger
under <filename>/home/</filename>, så kan dette gøres med
</para>

<screen>
<prompt>[root@hven root]# </prompt><userinput>find /home/* -maxdepth 1 -name <filename>.rhosts</filename> -print;</userinput>
</screen>

<para>
Hvis man samtidigt vil slette de fundne .rhosts filer kan man anvende
</para>

<screen>
<prompt>[root@hven root]# </prompt><userinput>find /home/* -maxdepth 1 -name <filename>.rhosts</filename> -print -exec rm {} \;</userinput>
</screen>


<para>
Det er enklere at disable brugernes egne
<filename>.rhosts</filename>-filer ved, at man tilføjer parameteren
<filename>-l</filename> efter <filename>in.rshd</filename> i filen
<filename>/etc/inetd.conf</filename> og genstarter inetd-dæmonen. 
</para>

<para>
Et andet argument imod at tillade ".rhosts"-filer er, at brugeren kan
komme til at køre et program, som skriver til en fil uden hans viden.
Filen kunne "~/.rhosts" og dermed give adgang til en
ekstern bruger, som ikke behøver at have en konto på maskinen.
</para>


<para>
Et alternativ til "~/.rhosts" metoden er "hosts level
equivalence" via filen "/etc/hosts.equiv". Dine brugere har
ikke adgang til denne fil, og kun root kan rette i den. Root kan
vælge at sætte en række hostnavne ind i denne fil eller evt. bare et
plus. Det betyder, at disse hosts (+ betyder alle maskiner)
har adgang til at udføre <command>rlogin</command> og rsh kommandoer uden adgangskode. Dette
gælder alle brugere (dog ikke root) - brugeren skal dog findes på
begge maskiner. Filen "/etc/hosts.equiv" kan være en bekvem løsning,
men den er en bombe under systemsikkerheden - find en anden løsning,
hvis du har et åbent eller halvåbent netværk.
</para>

<para>
Her i <ulink url="http://www.userfriendly.org/cartoons/archives/97dec/19971212.html">User Friendly fra den 12. december 1997</ulink> kan Greg fra Columbia Internet 
aflytte netværkstrafikken i forsvarsministeriet...
</para>

<figure id="uf16x122-fig" float="1">
<title>User Friendly</title>
<graphic fileref="uf16x122.&magic;"  scale="40"></graphic>
</figure>  

<para>
Fortsættelsen kan findes på <ulink url="http://www.userfriendly.org/cartoons/archives/97dec/19971216.html">http://www.userfriendly.org/cartoons/archives/97dec/19971216.html</ulink> :-)
</para>
</sect2>
</sect1>

<sect1 id="sikker-net-trafik">
<title>Nem og sikker netværkstrafik</title>
<indexterm><primary>SSH</primary></indexterm>
<indexterm><primary>OpenSSH</primary></indexterm>
<indexterm><primary>Secure Shell</primary></indexterm>
<indexterm><primary>Kommunikation over netværk</primary><secondary>sikkert</secondary></indexterm>


<para>
Hvis der er risiko for, at andre lytter med på netværkstrafikken,
er der behov for erstatningsprogrammer for <command>telnet</command>,
ftp og <command>rlogin</command>. Samtidig ønsker vi stadig at kunne afvikle programmer fra en
maskine og se resultater på en anden, naturligvis også de grafiske
programmer. Med andre ord ønsker vi samme funktionalitet - men med sikkerheden
i orden.
</para>

<para>
Der findes flere sikre alternativer til de gamle, ukrypterede protokoller.
Vi vil mest beskæftige os med SSH, men der findes også andre muligheder.
Et alternativ til <command>telnet</command> er stelnet, som står for secure telnet. Programmet 
baserer sig på SSL (Secure Sockets Layer), som er en måde at lave 
krypterering af datatrafikken. Kombinationen af stelnet og SSL er ikke så 
udbredt som SSH, og det er ikke så nemt at sætte op som SSH. 
Programmet stelnet kan findes på 
<ulink url="http://www.crufty.net/ftp/pub/sjg/">
http://www.crufty.net/ftp/pub/sjg/</ulink>
og selve krypteringslaget SSL til Linux kan findes på <ulink
url="http://www.psy.uq.oz.au/~ftp/Crypto/">
http://www.psy.uq.oz.au/~ftp/Crypto/</ulink>.
Denne sidste URL har også en hel del dokumentation.
</para>

<para>
Forhistorien er, at den gamle U.S. version af <command>telnet</command>
allerede supporterede TELOPT_AUTHENTICATION og TELOPT_ENCRYPTION,
men alle spor af krypteringskoden er fjernet fra den
internationalt udbredte og anvendte <command>telnet</command>-kode.
</para>

<para>
Et andet alternativ til <command>telnet</command> og ftp, som er på vej, er SRP. Se mere
om SRP på 
<ulink url="http://srp.stanford.edu/">
http://srp.stanford.edu/</ulink>.
</para>

<para>
Det, der umiddelbart i dag er det bedste valg som erstatning for
<command>telnet</command> og <command>rlogin</command>, er SSH (Secure SHell). Programmet er oprindeligt
lavet af et finsk firma med navn SSH Communications Security med
hjemmesiden <ulink url="http://www.ssh.fi">http://www.ssh.fi</ulink>.
SSH har bl.a. den store fordel fremfor stelnet, at grafiske vinduer
(XWindow) kan sendes over kryptererede linjer.
</para>

<para>
Det er et reelt problem, at den oprindelige kommercielle SSH ikke er
<ulink url="http://www.opensource.org/">Open Source</ulink>, og derfor er
der startet et GNU-projekt under navnet PSST for at genskrive koden.
Du kan finde mere information om dette på <ulink
url="http://www.net.lut.ac.uk/psst">http://www.net.lut.ac.uk/psst</ulink>.
PSST's hjemmeside bør følges fra tid til anden, men status i øjeblikket
(April 2003) er en fungerende version 1.5.1, og den siges at
fungere sammen med OpenSSH. LSH kører kun ssh-protokol version 2,
men roser sig af at have god kryptering og bedre random-generator
for maskiner uden /dev/random. For at køre sammen med ssh kræves
nogle scripts, fordi filformater for nøglefiler ikke er det
samme.
</para>

<para>
En anden implementation af SSH-protokollen er OpenSSH,
som er fri og er lavet af OpenBSD-folkene. Et separat hold
programmører sørger for at lave en version for andre platforme,
den portable version.  OpenSSH er allerede lagt ind i
OpenBSD-distributionen, der har ry for at være særdeles
sikker. OpenSSH er ligeledes at finde i de fleste
Linux-distributioner.  Hjemmesiden for OpenSSH er 
<ulink url="http://www.openssh.com/">http://www.openssh.com/</ulink>.
OpenSSH er baseret på OpenSSL, som skal oversættes først (hvis
man vil bygge sin egen) Læs den medfølgende dokumentation, da der
er nogle options for library generation, som ikke er helt
trivielle. Den kan hentes under "support" samme
sted, som OpenSSH findes, eller direkte fra <ulink
url="http://www.openssl.org/">http://www.openssl.org/</ulink>.
Man kan enten oversætte programmerne selv eller installere de
allerede oversatte RPM-pakker.  
</para>

<para>
OpenSSH er en godt projekt. Den omfatter en server, en klient og
omfattende dokumentation af opsætningen. Den kan køre
protokol version 2 og version 1. Hvis den er konfigureret til
det, kan den endda starte rsh op, hvis alt andet fejler.
Der er glimrende support fra OpenBSD teamet og det virker.
Der er versioner af OpenSSH til alle Unix varianter også Linux, så i
praksis er der ingen grund til at vælge den kommercielle SSH længere i
forhold til OpenSSH.
</para>

<para>
Har du problemer med SSH, så læs 
<ulink url="http://sysadmin.oreilly.com/news/sshtips_0101.html">http://sysadmin.oreilly.com/news/sshtips_0101.html</ulink>. Der er et par gode råd.
</para>

  <sect2 id="installation-af-openssh">
   <title>Installation af OpenSSH</title>

   <indexterm>
    <primary>OpenSSH</primary>
    <secondary>installation</secondary>
   </indexterm>

   <para>
    Hvis dit system ikke kommer med SSH-server- og -klientprogrammer, kan du
    hente kildeteksten til OpenSSH kan hentes fra <ulink
    url="http://www.openssh.com/">http://www.openssh.com/</ulink>.  Bemærk at
    OpenSSH-udgaver før 3.4 og OpenSSL-udgaver før 0.9.6g har kendte
    sikkerhedsfejl.
    <footnote>
     <para>
      Hvis din distribution kører med ældre udgaver af OpenSSH og/eller OpenSSL
      er det muligt at de selv har lukket sikkerhedshullerne.
     </para>
    </footnote>
    Her installationen vist med openssh-3.4 og det fungerer på samme måde med
    nyeste version.
   </para>

<para>
Du kan hente tar-filer, som du selv kan
oversætte, eller du kan få OpenSSH som RPM-filer. Som RPM-filer, skal
du bruge openssh-*.i386.rpm, openssh-clients-*.i386.rpm og
openssh-server-*.i386.rpm, hvor * betyder et versionsnummer, såsom
3.4.0. Du skal også bruge zlib, som sikkert allerede er installeret på
din Linux-maskine. Er dette ikke tilfældet (se om du får fejl), så kan dette bibliotek hentes fra 
<ulink url="http://www.freesoftware.com/pub/infozip/zlib/">http://www.freesoftware.com/pub/infozip/zlib/</ulink>. Igen kan du vælge mellem tar-filer og RPM.
</para>

<indexterm><primary>OpenSSH</primary><secondary>OpenSSL</secondary></indexterm>
<indexterm><primary>OpenSSL</primary><secondary>OpenSSH</secondary></indexterm>

<para> 
OpenSSH anvender OpenSSL - et værktøj der implementerer Secure
Socket Layer (SSL) til at lave stærk kryptering af transportlaget. 
</para>

<para>
Fra RedHat-7.0 og senere er ssh en del af normal installation; det samme
gælder de fleste andre Linux distributioner.
</para>

<screen>
<prompt>[tyge@hven ~]# </prompt><userinput>su</userinput>
<prompt>[root@hven /home/tyge]# </prompt><userinput>rpm -ivh zlib-1.1.3-i386.rpm</userinput>
<prompt>[root@hven /home/tyge]# </prompt><userinput>rpm -ivh openssl-0.9.6g-i386.rpm</userinput>
<prompt>[root@hven /home/tyge]# </prompt><userinput>rpm -ivh openssh-3.4-1.i386.rpm</userinput>
<prompt>[root@hven /home/tyge]# </prompt><userinput>rpm -ivh openssh-clients-3.4-1.i386.rpm</userinput>
<prompt>[root@hven /home/tyge]# </prompt><userinput>rpm -ivh openssh-server-3.4-1.i386.rpm</userinput>
</screen>

<para>
For at undgå de vanvittig lange indtastninger bruger man
selvfølgelig tabulator tasten, når man har tastet de første par
tegn ind, idet shell'en selv kan finde resten af filnavnet. Hvis
der er flere filnavne der ligner, så taster man lidt flere tegn,
og så igen tabulator.
</para>

<para>
Installerede du på denne måde, kan du springe det næste over og gå
direkte frem til at generere bruger-nøgler med <command>ssh-keygen</command>.
Vil du installere via tar-filer, så er det ret nemt, men der er et par
skridt du skal igennem.
</para>

<para>
Først "zlib", hvis dette ikke er installeret (tjek om
<filename>/usr/lib/libz.so</filename> findes).
</para>

<screen>
<prompt>[tyge@hven ~]# </prompt><userinput>su</userinput>
<prompt>[root@hven /home/tyge]# </prompt><userinput>tar xzvf zlib-1.1.3.tar.gz</userinput>
<prompt>[root@hven /home/tyge]# </prompt><userinput>cd zlib-1.1.3</userinput>
<prompt>[root@hven zlib-1.3]# </prompt><userinput>./configure</userinput>
<prompt>[root@hven zlib-1.3]# </prompt><userinput>make</userinput>
<prompt>[root@hven zlib-1.3]# </prompt><userinput>make install</userinput>
</screen>

<para>
Dernæst skal OpenSSL installeres. Den har en variant af
configure. Den er bl.a. god til at kryds-kompilere.  Det nemmeste
er at bruge kommandoen <command>./config </command> idet den
foretager bestemmelse af maskintype og system, og derefter
starter ./Configure.
</para>


<screen>
<prompt>[tyge@hven ~]# </prompt><userinput>su</userinput>
<prompt>[root@hven /home/tyge]# </prompt><userinput>tar xzvf openssl-0.9.6g.tar.gz</userinput>
<prompt>[root@hven /home/tyge]# </prompt><userinput>cd openssl-0.9.6g</userinput>
<prompt>[root@hven openssl-0.9.6g]# </prompt><userinput>./config</userinput>
<prompt>[root@hven openssl-0.9.6g]# </prompt><userinput>make</userinput>
<prompt>[root@hven openssl-0.9.6g]# </prompt><userinput>make install</userinput>
</screen>

<para>
Og slutteligt skal OpenSSH oversættes og installeres
</para>

<screen>
<prompt>[tyge@hven ~]# </prompt><userinput>su</userinput>
<prompt>[root@hven /home/tyge]# </prompt><userinput>tar xzvf openssh-3.4.tar.gz</userinput>
<prompt>[root@hven /home/tyge]# </prompt><userinput>cd openssh-3.4</userinput>
<prompt>[root@hven openssh-3.4]# </prompt><userinput>./configure --sysconfdir=/etc/ssh</userinput>
<prompt>[root@hven openssh-3.4]# </prompt><userinput>make</userinput>
<prompt>[root@hven openssh-3.4]# </prompt><userinput>make install</userinput>
<prompt>[root@hven openssh-3.4]# </prompt><userinput>make host-key</userinput>
</screen>

<para>
Det er normalt at OpenSSH vil installere opsætning i
<filename>/usr/local/etc</filename>, men Linux-folk vil oftest gemme
opsætning til SSH i <filename>/etc/ssh</filename> - dette gøres
med option <command>sysconfdir</command> (og to minusser foran).
</para>

<para>
Kommandoen <command>make host-key</command> installerer RSA og DSA
nøgler for din maskine. RSA anvendes af SSH version 1, mens DSA er en
nyere version, der anvendes i SSH2 protokollen. 
</para>

<para>
Vi mangler stadig få ting, hvis du har oversat SSH selv (ikke ved
RPM). Mange Linux-systemer anvender PAM til at styre login på
maskinen. For Red Hat og SuSE skal du kopiere den generelle PAM-ssh fil til
/etc/pam.d under navnet sshd. Samme idé anvendes nok af de andre store
Linux-distributioner.
</para>

<screen>
<prompt>[tyge@hven ~]# </prompt><userinput>su</userinput>
<prompt>[root@hven /home/tyge]# </prompt><userinput>cp contrib/sshd.pam.generic /etc/pam.d/sshd</userinput>
</screen>

<para>
Har du oversat OpenSSH selv, mangler du stadig et start/stop
script, som kan starte OpenSSH efter reboot. Som regel finder man
et af de simple start/stop scripts i /etc/init.d og kopierer,
retter til. I OpenSSH distributionen er der nogle eksempler på
start/stop-scripts. Du kan for SuSE kopiere
</para>

<screen>
<prompt>[root@hven openssh-3.4]# </prompt><userinput>cp contrib/rc.config.sshd /etc/rc.config.d/sshd.rc.config</userinput>
</screen>


<para>
og for Red Hat
</para>

<screen>
<prompt>[root@hven openssh-3.4]# </prompt><userinput>cp contrib/rc.config.sshd /etc/init.d/sshd</userinput>
<prompt>[root@hven openssh-3.4]# </prompt><userinput>chkconfig --level 234 sshd on</userinput>
<prompt>[root@hven openssh-3.4]# </prompt><userinput> # eller bare </userinput>
<prompt>[root@hven openssh-3.4]# </prompt><userinput>chkconfig sshd on</userinput>
</screen>


<para>
For SuSE skal du nok rette i filen en sti fra
<filename>/usr/sbin</filename> over til
<filename>/usr/local/sbin</filename>.
</para>

<para>
Nu skal vi prøve at start SSH dæmonen "sshd", så man kan logge ind på
maskinen udefra. For Red Hat køres 
</para>

<screen>
<prompt>[root@hven openssh-3.4]# </prompt><userinput>/etc/init.d/sshd start</userinput>
</screen>

<para>
eller
</para>

<screen>
<prompt>[root@hven openssh-3.4]# </prompt><userinput>service sshd start</userinput>
</screen>

<para>
og tilsvarende for SuSE køres
</para>

<screen>
<prompt>[root@hven openssh-3.4]# </prompt><userinput>/sbin/init.d/sshd start</userinput>
</screen>

<para>
Tjek at SSH dæmonen (dvs. serveren) kører ved at skrive
<command>telnet localhost 22</command>
</para>

<programlisting>
Trying 127.0.0.1... 
Connected to localhost. 
Escape character is '^]'.
SSH-1.99-OpenSSH_3.4
</programlisting>
</sect2>

<sect2 id="Opsaetning-af-openssh">
<title>Brugeropsætning af OpenSSH</title>
<indexterm><primary>OpenSSH</primary><secondary>Opsætning</secondary></indexterm>

<para>
Hver bruger skal have sit eget sæt af privat/offentlig nøgle. Den
private må aldrig sendes via netværk, idet den kan dekryptere
datatrafik. Den offentlige nøgle anvendes til at kryptere data med, og
den kan man så distribuere til andre maskiner, man skal kunne logge
ind på.
</para>

<para>
Den fjerne maskine (remote-maskinen) kan nu kryptere trafikken på
en måde, så kun os, der udleverede den offentlige nøgle, kan
afkryptere datastrømmen. Dertil bruger vi naturligvis den private
nøgle. Det er derfor, denne privat-nøgle ikke må gå over nettet.
</para>

<para>
Brugeren kan selv generere nøgler til login med løsen i
stedet for at bruge en almindelig adgangskode til at logge ind. Det anses
for mere sikkert, fordi man ikke kan logge ind på hvilken som
helst konto selv om man skulle have skaffet sig den tilhørende
adgangskode.
</para>

<para>
Man kører <command>ssh-keygen</command> som generer en identitetsnøgle, og
undervejs kan man hertil selv vælge et løsen &ndash; svarende
til en adganskode, men et, som kan være meget langt.  Lav det
tilpas kryptisk, dog på en måde, så du har nemt ved at huske det.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ssh-keygen -d</userinput> 
Generating DSA parameter and key.
Enter file in which to save the key (/home/tyge/.ssh/id_dsa):
Enter passphrase (empty for no passphrase): <userinput>V1 hANDLER me spaghett1</userinput>
Enter same passphrase again: <userinput>V1 hANDLER me spaghett1</userinput>
Your identification has been saved in /home/tyge/.ssh/id_dsa.
Your public key has been saved in /home/tyge/.ssh/id_dsa.pub.
The key fingerprint is:
ea:20:20:ae:b3:39:6f:d9:1b:a2:ef:02:0c:05:c5:fb tyge@hven
</screen>


<para> 
Når du kører
<command>ssh-keygen</command> spørges du om du vil gemme i default
stedet <filename>/home/tyge/.ssh/id_dsa</filename>. Dette giver dig
mulighed for at have mere end et sæt nøgler. Din private nøgle gemmes
i <filename>$HOME/.ssh/id_dsa</filename> (for DSA nøglen). Tilsvarende
er den offentlige nøgle gemt med samme filnavn med et ".pub" tilføjet.
</para>

<para>
Lad os først se på et par af de filer, der blev installeret. Der er
kommet filer tre steder. (1) /etc/ssh, (2) /etc/init.d/, (3)
/usr/sbin/sshd og så også i hjemmekataloget, ~/.ssh  .
</para>



<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ls -al /etc/ssh/*</userinput>
-rw-r--r-- 1 root root  932 okt  6 00:09 ssh_config
-rw------- 1 root root  668 okt 11 01:33 ssh_host_dsa_key
-rw-r--r-- 1 root root  604 okt 11 01:33 ssh_host_dsa_key.pub
-rw------- 1 root root  529 okt 11 01:33 ssh_host_key
-rw-r--r-- 1 root root  333 okt 11 01:33 ssh_host_key.pub
-rw------- 1 root root 1194 okt  6 00:09 sshd_config      
</screen>

<para>
Filerne <filename>/etc/ssh/*</filename> er opsætningsfiler, der styrer
ssh opsætningen. Det er kun <filename>/etc/ssh/sshd_config</filename>,
du evt. skal rette i. <footnote><para>Hvis du har installeret fra
source-tar-balls er disse filer default lagt i
/usr/local/etc</para></footnote>
F.eks. kan du ændre "PermitRootLogin yes"
til "PermitRootLogin no", hvis du mener, at root ikke må logge ind via
ssh. Det kan være en god idé at forbyde root remote login i det hele taget.
Tilsvarende kan du forbyde tomme adgangskoder ved at ændre
"PermitEmptyPasswords yes" til "PermitEmptyPasswords no" - vent lige
med at lave disse ændringer til du har fået ssh til at virke.
</para>


<para>
Vi skal også lige nævne, at ssh forbindelser normalt ikke styres via
inetd-systemet, som du i øvrigt kan finde beskrevet tidligere i 
<xref linkend="services"/>. Grunden er, at det ville være for langsomt, idet
der ved opstart af sshd skal genereres en server-nøgle. Dette kan
tage flere sekunder for hver opstart.
</para>
</sect2>

<sect2 id="brug-af-ssh">
<title>Brug af SSH</title>
<indexterm><primary>OpenSSH</primary><secondary>Brug af</secondary></indexterm>
<para>
Hvis sshd er startet op, er alt klar til at kommunikere sikkert, 
også over usikre netværk. Start med at skrive
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ssh bohr</userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)?          
</screen>

<para>
Første gang du kobler til en fremmed maskine, der ligeledes har fået
installeret ssh, skal ssh acceptere at udveksle nøgler med en
ukendt maskine. Dette spørgsmål skal du således acceptere, og næste
gang du anvender samme fremmede maskine, skal du ikke igennem dette
spørgsmål. Efter at have svaret "yes" skal du aflevere din
almindelige adgangskode, og du er så logget ind på maskinen. Dette kan du
fortsætte med, men hvis du vil højne sikkerheden yderligere, bør du
gemme din offentlige nøgle på fjernmaskinen. Har du denne nøgle gemt, 
kan man ikke logge ind med din adgangskode, men kun med dit lange og 
kryptiske løsen.
</para>

<para>
Hvis du ikke fik adgang til maskinen, så kan der være flere grunde.
Enten kan det skyldes, at du bruger den forkerte protokol. Nyere versioner
af OpenSSH kan både køre SSH version 1 og 2. Version 2 og DSA-nøglen hænger
sammen som nævnt ovenfor. 
</para>

<indexterm><primary>OpenSSH</primary><secondary>Version 2</secondary></indexterm>
<indexterm><primary>ssh</primary><secondary>-2</secondary></indexterm>
<indexterm><primary>ssh</primary><secondary>~/.ssh/config</secondary></indexterm>
<indexterm><primary>ssh</primary><secondary>config-fil</secondary></indexterm>


<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ssh -2 tuck@bohr</userinput>
</screen>

<para>
I dette eksempel tvinges OpenSSH til at anvende SSH version 2, og 
brugeren tyge prøver at logge ind på maskinen bohr med brugernavn tuck.
</para>

<para>
<emphasis>Tip:</emphasis> Du bør udelukkende anvende SSH2 (SSH
version 2); skriv følgende ind i din
<filename>~/.ssh/config</filename>
</para>

<programlisting>
# Tillad også grafiske programmer gennem SSH-forbindelse
ForwardX11 yes
# Anvend SSH2-identitet
IdentityFile ~/.ssh/id_dsa
# Anvend SSH2-protokol
Protocol 2
# Komprimer forbindelsen
compression yes
</programlisting>

<para>
Log ud ved at skrive exit (eller trykke Ctrl-D) for at komme tilbage
til din egen maskine. Kopier nu din public key fra din egen maskine
(hven) til fjernmaskinen og gem den under
<filename>~/.ssh/authorized_keys</filename> (for SSH1, dvs. RSA
nøglen) og <filename>~/.ssh/authorized_keys2</filename> (for SSH2,
dvs. DSA nøglen). Ingen andre end dig skal kunne læse den fil du
laver. Denne kopiering laver vi med en ny kommando "scp" (secure
copy) eller beder systemadministratoren at lægge filen ind hvis du
ikke kan få adgang.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>cd ~/.ssh</userinput>
<prompt>[tyge@hven .ssh]$ </prompt><userinput>scp id_dsa.pub bohr:authorized_keys2</userinput>
</screen>

<para>
Nu skal du lave den sidste opsætning på bohr. Du laver kataloget
<filename>~/.ssh</filename>, hvor du gemmer din offentlige nøgle, og
sikrer, at andre ikke kan læse denne. Dit hjemmekatalog skal andre
heller ikke have lov til at skrive i - denne foranstaltning er altid
klog, men det er også nødvendig for at din offentlige nøgle
"id_dsa2.pub" virker efter, at den er kopieret til fjernmaskinens
"authorized_keys2". Det er en egenskab ved ssh.
</para>


<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ssh bohr</userinput>
<prompt>[tyge@bohr tyge]$ </prompt><userinput>mkdir ~/.ssh</userinput>
<prompt>[tyge@bohr tyge]$ </prompt><userinput>mv authorized_keys ~/.ssh</userinput>
<prompt>[tyge@bohr tyge]$ </prompt><userinput>chmod go-w ~</userinput>
<prompt>[tyge@bohr tyge]$ </prompt><userinput>chmod -R go-rwx .ssh</userinput>
<prompt>[tyge@bohr tyge]$ </prompt><userinput>exit</userinput>
</screen>
</sect2>

<sect2 id="krypteret-data">
<title>Krypteret dataoverførsel</title>
<para>
Nu kan du slappe af. Alt er sat op, og du kan uden at skulle
frygte for netværkssikkerheden logge ind på bohr. F.eks. kan du
starte et grafik program såsom "xload" ved at skrive
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ssh bohr xload</userinput>
Enter passphrase for RSA key 'tyge@bohr': V1 hANDLER me spaghett1
</screen>

<para>
Du blev nu mødt af noget nyt igen, idet du skulle skrive dit
løsen og ikke din adgangskode. Bemærk, at i virkeligheden vises dit
løsen naturligvis ikke på skærmen.
<command>xload</command> vil nu køre fra bohr og vises på din egen maskine (hven). 
Skal du logge ind på bohr, så skriver du blot "ssh bohr", og skal 
du have udført et program derfra, tilføjer du blot programnavnet til denne
ordre. 
</para>


<para>
Skal du kopiere en fil fra hven til bohr, skriver du
</para>

<indexterm>
  <primary>ssh</primary>
  <secondary>scp</secondary>
</indexterm>
<indexterm><primary>scp</primary></indexterm>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>scp LOKALT_FILNAVN bohr:FJERN_FILNAVN</userinput>
</screen>

<indexterm><primary>sftp</primary></indexterm>
<indexterm><primary>scp</primary></indexterm>
<indexterm><primary>rcp</primary></indexterm>
<indexterm><primary>ftp</primary><secondary>sikker erstatning</secondary></indexterm>

<para>
Tilsvarende erstattes ftp med <command>sftp</command>, og scp erstatter rcp
(remote copy), som arbejder med samme syntaks.
</para>


<para>
Hvis du ikke frygter, hvem der kan tilgå din egen maskine, kan du
få endnu nemmere adgang til de andre maskiner ved, at du en
gang for alle i den X session, du har igang, giver dit løsen.
</para>

<indexterm>
  <primary>SSH-nøgler</primary>
  <secondary>huske</secondary>
</indexterm>

<indexterm>
  <primary>huske SSH-nøgler</primary>
</indexterm>

<indexterm>
 <primary>ssh-add</primary>
</indexterm>

<indexterm>
 <primary>ssh-agent</primary>
</indexterm>

<indexterm>
  <primary>ssh</primary>
  <secondary>ssh-agent</secondary>
</indexterm>

<indexterm>
  <primary>ssh</primary>
  <secondary>ssh-add</secondary>
</indexterm>


<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ssh-agent bash</userinput>
<prompt>[tyge@hven ~]$ </prompt><userinput>ssh-add ~/.ssh/id_dsa</userinput>
Enter passphrase for /home/pto/.ssh/id_dsa:
</screen>

<para>
Derefter kan du med ssh fra den terminal logge ind og ud af "bohr" 
og andre ssh maskiner uden at skulle bruge løsen. Vil du
have at alle terminal-vinduer skal kunne dette, skal du rette i din 
"~/.xsessionrc", "~/.xinitrc" eller
lignende, hvor din window manager startes op. Er det f.eks. KDE,
skal du ændre "startkde" til "ssh-agent startkde" og kun en
enkelt gang køre "ssh-add". Derefter kan du slippe for at indtaste dit 
løsen i resten af den X session. Brug "ssh-agent" med omtanke.
</para>

<para>
Tip: Det anbefales at du flytter SSH til en anden port end port
22 - hvis det kun er dig som benytter denne. Den valgte port kan
på klienten skrives ind i ~/.ssh/config således at det stadig er
nemt at logge ind. Eksempel:
</para>

<programlisting>

~/.ssh/config:

host tyge
     port 22123

host steno
     port 955

</programlisting>

<indexterm><primary>xauth</primary></indexterm>
<indexterm><primary>SSH</primary><secondary>grafiske programmer gennem sikker tunnel</secondary></indexterm>
<indexterm><primary>OpenSSH</primary><secondary>grafiske programmer gennem sikker tunnel</secondary></indexterm>
<para>
En af de (mange) meget elegante ting man kan med SSH (og OpenSSH) er
at lave en sikker krypteret tunnel gennem en firewall og endda kunne
transmittere grafiske programmer (X-programmer). Skal man administere
servere (evt. via grafiske programmer) på et lukket netværk er en
SSH-server i firewallen yderside en god måde at give adgang til
netværket hjemmefra (husk dog at følge sikkerhedslisten for den
SSH-variant der installeres). For at grafiske programmer kan
transmitteres fra en maskine til en anden via SSH, kræves at man har
programmet <command>xauth</command> installeret. 
</para>


<para>
Anvender du ssh, kan andre med sniffit se, at der laves kommunikation
på port 22, men prøver de at følge netværkstrafikken, kommer der
ikke login navne, adgangskoder, eller efterfølgende kommandoer i klar
tekst - alt er krypteret. Den lille boks i sniffit, som for <command>telnet</command>
viste login sekvensen med adgangskoder osv., vil med ssh være fyldt med en
bunke tilfældige tegn uden sammenhæng - kun de to SSH-programmer der har etableret forbindelsen kan i praksis
afkode kommunikationen. 
</para>

<para>
Lad os vende tilbage til sniffit og se, hvad der med ssh kommer over
netværket under login via ssh. På næste billede kan vi se, at port 22
på bohr modtager tekst, der er krypteret og dermed ikke læseligt
for andre. Igen er det "sniffit -F eth0 -i", som køres. Derefter
har vi valgt at følge den linje fra 192.168.0.1, som kommer
ind via port 22 til 192.168.0.2. I det lille vindue kan du se resultatet
af vilkårlige og almindelige Linux-kommandoer - i dette tilfælde "ls
-al /home".
</para>

<figure id="sniffit3-fig" float="1">
<title>Sniffit</title>
<graphic fileref="sniffit3.&magic;"  scale="40"></graphic>
</figure>  

<para>
Endelig kan det nævnes at følgende link giver en god gennemgang af
SSH <ulink url="http://www.redhat.com/docs/manuals/linux/RHL-8.0-Manual/custom-guide/s1-openssh-client-config.html">http://www.redhat.com/docs/manuals/linux/RHL-8.0-Manual/custom-guide/s1-openssh-client-config.html</ulink>.
</para>

</sect2>
<!--
<sect2 id="tunnel-med-ssh">
<title>Tunnel med SSH</title>
<indexterm><primary>Tunnel</primary></indexterm>
<indexterm><primary>SSH</primary><secondary>Tunnel</secondary></indexterm>

<para>
Jeg har et mindre problem med hensyn til X. Da vi gerne vil have
muligheden for at brug X fra nogle af vores kunder så har vi brug for at
kunne bruge X over SSH. Vores problem et at vores netværk på kontoret er
bag en firewall, og at denne firewall ikke har X.
</para>

<screen>
[X klient hjemme]&ndash;&ndash;&ndash;[Firewall med SSH adgang uden X]&ndash;&ndash;&ndash;[X server internt net]
</screen>


firewall#> ssh login@kunde.dk -g -L 10022:127.0.0.1:22

arbejdsstation#> ssh -p 10022 -X login@firewall

kunde#> xclock  (xclock fra kundes pc på min computer)

Jeg gætter du skal gøre:



#kunde> ssh login@hjem.dk -g -L 10022:arbejdstation_lokal_ip:22

#kunde> ssh -p 10022 -X login@localhost

#arbejdstation> xclock (xclock fra din computer på kundes pc)

ssh er sejt!

mvh. Jakob Hilmer

</sect2>
-->


<sect2 id="sikkerhed-user-sr">
<title>Brugervenlighed</title>
<indexterm><primary>fish</primary></indexterm>
<indexterm><primary>scp (nem i KDE)</primary></indexterm>
<para>
Som det er beskrevet ovenfor så bør kommunikation mellem maskiner
ske over SSH-protokollen hvor det er muligt. Det er et tekst-baseret program
hvor man kan logge ind på en fjernmaskine og udføre kommandoer - men
det er ikke hele historien. Man kan også sætte OpenSSH op til at køre
grafiske programmer eller få andre programmer til at bruge OpenSSH til 
at danne en krypteret kanal mellem maskinerne og mellem maskinerne køre
alle programmer transparent. Med Konqueror til KDE kan man f.eks. installere
en lille udvidelse med navn <literal>fish</literal> 
<ulink url="http://ich.bin.kein.hoschi.de/fish/">http://ich.bin.kein.hoschi.de/fish/</ulink>. Normalt angiver man i URL-feltet til Konqueror at man vil
ser filerne i <filename>/usr/</filename> som <filename>file:/usr/</filename>.

 Vil man se filerne i kataloget "<filename>/usr/</filename>" på maskinen
 "<literal>hven.sslug.dk</literal>" med brugernavnet "<literal>tyge</literal>"
 skriver man i URL-feltet <filename>fish://tyge@hven.sslug.dk/usr</filename>.
 Har man SSH-adgang til maskinen vil filoversigten blive vist som om det var
 på egen maskine med fuld mulighed for træk-og-slip-kopiering, -flytning mv.
</para>
<indexterm><primary>KDE</primary><secondary>fish</secondary></indexterm>
<indexterm><primary>scp</primary><secondary>GUI - grafisk brugerflade</secondary></indexterm>
<indexterm><primary>ssh</primary><secondary>kopier fil med grafisk brugerflade</secondary></indexterm>
<indexterm><primary>fish</primary><secondary>KDE</secondary></indexterm>
<indexterm><primary>krypteret kanel</primary><secondary>Konqueror</secondary></indexterm>

<figure id="fish-fig" float="1">
<title>fish giver direkte adgang til filer på andre maskiner via sikker ssh-krypteret tunnel</title>
<graphic fileref="fish.&magic;" scale="60"></graphic>
</figure>


</sect2>

<sect2 id="epilog2">
<title>Epilog</title>
<para>
Der er mange forskellige smarte features i
ssh, såsom at maskinerne skal acceptere hinandens identitet, brugeres
skal accepteres via et løsen, og en gang hver time vil maskiner
endda skifte nøgler, så en eventuel ondsindet person, som vil lytte
med skal begynde forfra i dekodning af krypterings-nøgler.
</para>

<para>
Vi skal også nævne, at ssh kan anvendes til at lave VPN løsninger
(Virtual Private network) mellem to lokale netværk, der forbindes via
et usikkert net. Skal man køre revisionssystemer på Linux, kan vi
anbefale CVS, som drager nytte af ssh til at skabe krypteret tilgang
til ens server. Det er kun en systemvariabel (sæt $CVS_rsh=ssh), så
kører det. Tilsvarende kan rsync kobles med ssh (sæt $RSYNC_rsh=ssh)
for at lave synkroniseret data mellem flere maskiner, hvor
dataudveksling sker med secure shell.
</para>

<para>
Ud over Linux (UNIX) server og klient programmer, som er
indeholdt i ssh-pakken, så kan du måske også have glæde af klienter
til Windows.  
</para>

<para>
Med en af disse kan du fra en Windows-maskine logge sikkert ind på
din Linux-maskine. Du kan på hhv.
<ulink url="http://www.chiark.greenend.org.uk/~sgtatham/putty/">http://www.chiark.greenend.org.uk/~sgtatham/putty/</ulink>,
<ulink url="http://www.mindbright.se/mindterm">http://www.mindbright.se/mindterm</ulink>.
Der findes også en kommerciel Windows ssh-version, som kan købes fra 
<ulink url="http://www.datafellows.com">http://www.datafellows.com</ulink>.
</para>

<!-- snort http://networking.earthweb.com/netsecur/article/0,,12084_1381371,00.html -->

</sect2>
</sect1>

</chapter>

