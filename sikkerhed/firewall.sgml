<!-- $Id$ -->
<chapter id="Linux-firewalling">
 <title>Firewall på Linux</title>

 <sect1 id="hvad-er-firewall">
  <title>Hvad er en firewall?</title>

  <indexterm>
   <primary>dørvogter</primary>
  </indexterm>

  <indexterm>
   <primary>firewall</primary>
  </indexterm>

<para>
At forbinde sin virksomheds eller sit kollegiums lokale
computernetværk direkte til internettet kan være en risikabel
ting at gøre, for man åbner jo for trafik begge veje, altså også
for trafik ind på det lokale netværk. Hvis man uden videre
forbinder sit lokale netværk til internettet, kan man blive man
udsat for, at andre trænger ind på firmaets eller kollegiets
interne computere, læser og ændrer følsomme data, får servere til
at gå i stå osv.  Ønsker man at give adgang for beboere og
medarbejdere til e-post og den store mængde information, man kan
finde på internettet uden at åbne for trafik den anden vej,
kræver det en firewall.
</para>

<para>
Firewall er det engelske ord for en brandvæg eller en brandmur. I
bygninger bruges en brandmur til at dele en bygning i sektioner.
Hvis der opstår en brand i den ene sektion, kan brandmuren
forhindre at branden breder sig (hurtigt) til andre sektioner.
</para>

<para>
En computer som firewall bruges til på lignende vis at opdele et
netværk i sektioner, typisk i det, der er udenfor lokalnetværket,
og det, som er indenfor. Firewallen er først og fremmest et
pakkefilter, som forhindrer pakker af bestemte typer i at slippe
igennem fra det ene til det andet netværk. Linux firewallen kan
imidlertid meget mere end det, og i denne sammenhæng er det
vigtigt, at den kan lade trafik, som har oprindelse på
lokalnettet, gå til nettet udenfor, det offentlige net, og vel at
mærke tillade svarpakkerne at passere på tilbagevejen.
</para>

<para>
Man kan opnå en fremragende sikkerhed med en Linux box som
firewall, men det er imidlertid bedst at kombinere firewallen med de
forholdsregler for sikker opsætning af en computer, som er omtalt
tidligere i bogen.
</para>

<para>
En firewall kan selvfølgelig også bruges til at adskille to
eller flere lokalnetværk fra hinanden.
</para>

<para>
Der findes forskellige måder at opbygge en firewall, næste afsnit
lister de vigtigste.
</para>

<sect2><title>Firewall typer</title>

<itemizedlist mark="bullet">
  <listitem><para>Pakkefiltrering</para></listitem>
  <listitem><para>Proxy, en applikation som optræder som
  mellemmand</para></listitem>
  <listitem><para>Stateful Multi-Layer Inspection, SMLI, en kombination af pakkefilter, tilstands-betingelser og indholds-filtrering</para></listitem>
</itemizedlist>
<indexterm><primary>SMLI</primary></indexterm>

<para>
Et pakkefilter ser på pakkens IP-adresse, den protokol-type, som
den hører til og eventuelt flere ting.
</para>

<para>
En proxy, som egentlig blot betyder en stedfortræder, var
oprindeligt et program på en gateway, som man inde på lokalnettet
henvendte sig til, og så kunne dette program sende forespørgsler
videre, som om de kom fra proxy-maskinen. Det er en meget sikker
men også ret besværlig måde at skille lokalnet fra offentlige
net, og det kræver en proxy for hver protokol, man ønsker at åbne
for, http, ftp, ssh og hvad det nu kunne være.
</para>

<para>
En mere moderne proxy kan fungere uden at man henvender sig
specielt til den. Det kaldes en transparent proxy. Den lytter
efter al trafik og videresender de pakker, som er tilladte,
ligesom et pakkefilter, men i modsætning til pakkefilteret kan
proxyen altså sende dem videre, som om de kom fra den selv, og
desuden inspicere dem på indholdsniveau eller applikationslag;
man taler om netværkslag, som fx. den forsimplede Department of
Defence model, DoD 4-lags modellen her: 


<itemizedlist mark="bullet">

<listitem><para>
Fysisk link-lag, d.v.s. ethernetkort og ledninger (der er
egentlig også et par abstraktionslag her);
</para></listitem>

<listitem><para>
netværkslaget, her finder man IP-numre, ping programmet og ICMP;
</para></listitem>

<listitem><para>
transportlaget TCP 
</para></listitem>

<listitem><para>
applikationslaget, fx. FTP og HTTP.
</para></listitem>
</itemizedlist>

En proxy kan inspicere på applikationslaget. Den kan derfor kan
kaldes for et censur-program, netværks-barnepige eller spion.
</para>

<para>
Stateful Multi Layer Inspection er den mest avancerede form for
firewall. Det er faktisk muligt at lave den slags filtrering
med Linux kernen. Linux kernens indbyggede pakkefilter har
mulighed for at holde styr på det, man kalder en forbindelse
(connection), d.v.s. en session, hvor man indleder en
konversation med en server, udveksler data og ender med at sige
"nu er jeg færdig".
</para>

<para>
TCP benytter sådanne connection meddelelser, Linuxkernen kan
holde styr på status for en forbindelse. Derfor kaldes Linux
Netfilter for et State Packet Filter, SPF.
</para>

<para>
Linuxkernen kan endvidere sende udvalgte pakker til en
applikation i user space, som kan gøre med dem, hvad den vil (fx.
sende dem videre efter at have ændret på dem). Derved kan man
bygge en SMLI firewall baseret på Linux Netfilter. En
user-applikation kan inkorporeres i kernen (for at effektivisere
den), så man kan skam bygge tip top professionelle SMLI-firewalls
på basis af Linux.
</para>
</sect2>

<sect2 id="sikkerhed-grundlaeggende-pakkefilter">
<title>Grundlæggende pakkefiltrering eller politiske
overvejelser</title>

<para>
Opsætningen af en firewall kan enten bygge på den grundlæggende
antagelse, at alt, hvad der kommer udefra, er mistænkeligt og bør
stoppes - eller, omvendt, at vi tror på det gode i netværket og
kun spærrer af for de ting, som notorisk er nemme at misbruge.
</para>


<sect3 id="sikkerhed-luk-alt">
<title>Luk alt</title>
<para>
Hvis man lukker for alt, er det selvfølgelig overflødigt med en
netforbindelse ud af huset. Men det er nu alligevel den bedste
måde at sikre systemet på (;-) For at få lidt glæde af
netforbindelsen kan man så åbne for web-protokollen HTTP. En
TCP/IP pakke har ud over IP nummeret et port-nummer med sig, som
blot er et tal (16 bit) i TCP-pakkens header. På modtagermaskinen
ser TCP-softwaren i kernen efter, hvilket portnummer der er, og
om der er noget program, som har meldt sig som interesseret i
pakker til dette portnummer. Det kalder man, at et program har
registreret på den pågældende port. Et program, som lytter efter
indkommende forbindelser, kaldes en server (eller somme tider et
serverprogram.)
</para>

<para>
HTTP protokollen er karakteristisk ved, at serveren som regel
lytter på port 80. D.v.s. at vi kunne lave en firewall regel, som
siger, at al trafik, som er til eller fra port 80 på en computer
<emphasis>udenfor lokalnetværket</emphasis> skal have lov at
passere. Det er en løsning, men, som vi senere skal se, en fattig
løsning, idet man kommer til at mangle name servicen, DNS, og
endvidere kommer til at lide under, at nogle web-sites forventer,
at man kan bruge FTP til download, eller ligefrem flytter
brugerens forespørgsel til en server på et andet portnummer.
</para>
</sect3>

<sect3 id="sikkerhed-aaben-alt"><title>Lad alt være åbent -
undtagen de farlige ting</title>

<para>
For at undgå problemer kunne man så beslutte, at man lader det
meste stå åbent og - selvfølgelig - lukker for de farlige
services som fx. telnet, remote shell og så videre.
</para>

<para>
Et eksempel kunne være, at man lokalt gerne må bruge telnet, men
at det er sket at folk udefra har forsøgt at få forbindelse via
telnet. Derfor kan det se ud som en løsning at lukke for port 23.
Den løsning er dog heller ikke særlig god. Intrusion på en
computer kan sagtens benytte sig af andre portnumre (og andre
protokoller) og ved snedige, ulovlige datapakker forsøge at sætte
en kæp i hjulet på de programmer, der lytter. Hvis vi var
flittige og lappede alle hullerne i serverprogrammerne og i
øvrigt overvågede maskinen døgnet rundt, så ville denne løsning
være god nok, men den er dyr i arbejdstimer.
</para>
</sect3>
</sect2>

<sect2>
<title>Den lukkede model bør vælges som udgangspunkt</title>

<para>
Hverken den åbne eller helt lukkede model er særligt nyttige. Der
skal mere til. Som udgangspunkt er den lukkede model imidlertid
den sikreste, men den skal kombineres med connection-tracking.
</para>

<para>
Forhåbentlig fremgår det af ovenstående, at en firewall egentlig
er et ret kompliceret stykke software. Man skal nu ikke lade sig
skræmme væk af den grund. Det er i grunden ret nemt at skrive de
nødvendige kommandoer og så blot kontrollere en gang i mellem, at
det kører som det skal.
</para>

<para>
Man bruger iptables kommandoen til at opsætte firewall
reglerne i kernen. Men man behøver ikke at kunne iptables
kommando syntaksen, idet SuSE, RedHat og andre lavet
GUI-administration af firewall reglerne. Så hvis man holder sig
til de gode, kendte distributioner eller på anden måde sørger
for, at de nødvendige ting er tilstede, så kan man blot krydse
af, hvilke servere andre udefra skal have lov at bruge, om nogen.
Er man af gør det selv typen, følger her en opskrift på, hvordan
man kan lave en lille komplet firewall opsætning.
</para>


<sect3 id="sikkerhed-really-quick-guide">
<title>Lynkursus</title>

<para>
Senere bliver kommandoerne til en firewall beskrevet og forklaret
grundigt, men for den utålmodige, som bare vil i gang, kan vi
lige vise "Rusty's Really Quick Guide To Packet Filtering" fra
packet-filtering-HOWTO:
</para>

<programlisting>


  ## Insert connection-tracking modules (not needed if built into kernel).
  # insmod ip_conntrack
  # insmod ip_conntrack_ftp

  ## Create chain which blocks new connections, except if coming from inside.
  # iptables -N block
  # iptables -A block -m state --state ESTABLISHED,RELATED -j ACCEPT
  # iptables -A block -m state --state NEW -i ! ppp0 -j ACCEPT
  # iptables -A block -j DROP

  ## Jump to that chain from INPUT and FORWARD chains.
  # iptables -A INPUT -j block
  # iptables -A FORWARD -j block

</programlisting>

<para>
De første kommandoer er nødvendige med de fleste
distributionskerner. Det er ikke spor svært at lave sin egen
superkerne, hvis man interesserer sig for, hvad en kerne er, og
man har lært noget om, hvordan et operativsystem fungerer. Har
man en kerne hvor alt er kompileret ind i kernen, vil systemet
være en anelse hurtigere<footnote><para>På min gamle 75Mhz maskine kunne jeg
tydeligt mærke forskel!</para></footnote>.
</para>

<para>
<command>iptables -N block</command> laver en kæde (en skuffe
eller hylde) for et regelsæt. Regelsættene kaldes chains, fordi
man bruger reglerne i den rækkefølge, de er sat ind i kæden.
Kæden her hedder "block", blokér.
</para>

<para>
<command> iptables -A block -m state --state ESTABLISHED,RELATED
-j ACCEPT</command>
</para>

<para>
<command>-A block</command> indsætter en regel i block-kæden, som
siger, at man skal bruge tilstands-modulet, <command> -m state
</command>, og undersøge, om pakken tilhører en forbindelse
(connection), som allerede er startet eller som er i slægt med en
connection <command>--state ESTABLISHED,RELATED</command>, hvis
det er tilfældet, skal pakken accepteres, d.v.s. regelfortolkeren
jumper (-j) hopper til feltet for videresendelse af pakker,
"ACCEPT".
</para>

<para>
Næste linie siger, at alle pakker, som <emphasis>ikke</emphasis>
kommer udefra (i dette tilfælde fra et modem som bruger
Point-to-Point-Protokollen, PPP), skal have lov at passere.
</para>

<para>
Alt andet smides simpelt hen væk! DROP!
</para>

<para>
En nærmere forklaring af syntaksen og mulighederne med netfilter
kommer senere i kapitlet.
</para>


<!-- dax 2003-10-19 hertil /-->


<para>
Det er vigtigt at forstå, at en firewall ikke er spor sikker, hvis den
er sat forkert op. Når firewallen er sat op, bør man grundigt teste,
at den nu også gør, som man forventer. En vigtig del af sikkerheden
omkring en firewall er desuden, at man registrerer og overvåger den trafik,
der passerer igennem den. Hvis man glemmer at holde øje med de
log-filer, firewallen genererer, er ens sikkerhed reelt væk (Se også
<xref linkend="filcheck"/>). Man kan så risikere, at man ikke opdager,
at der har været indbrud. En firewall er aldrig helt sikker, og man
bør kun sætte en firewall op, hvis man har i sinde at vedligeholde
den.
</para>

<para>
En forkert opsat firewall eller en firewall, ingen holder øje med,
kan være værre end ingen firewall! Tilstedeværelsen af en firewall
giver let en falsk fornemmelse af tryghed, så man ikke er omhyggelig
nok med at beskytte hver enkelt computer. Det er også meget vigtigt,
at man holder sig ajour med nyheder om fejl i den
software, der anvendes på firewallen 
(Se <xref linkend="sikkerhedsreferencer"/>).
</para>

<para>
Selvom man har sat en firewall op for at beskytte et netværk imod
folk på internettet, bør man stadig være omhyggelig med sikkerheden i det
lokale netværk. For det første kan det være, at nogen bryder igennem
ens firewall, og dermed er der kun lokalnetværkets sikkerhed tilbage. For det
andet beskytter en firewall ikke imod internt misbrug af ens netværk. 
I en virksomhed eller på et kollegium e. lign. kan man ikke altid stole
på de lokale brugere. Opgørelser fra IBM peger på, at der ca. er 
ligeså mange interne netværksindbrud som eksterne.
</para>

<para>
Et andet problem indenfor firewallen er lokale modems. Hvis en
bruger har et modem, hvormed han kobler sig direkte til sin
hjemmearbejdsplads, der ikke er sikret, så er der via denne
hjemmeopkobling fri bane til virksomhedens net. Der er mange
variationer på dette sikkerhedshul, fx. også at nogen medbringer
en transportabel maskine og sætter den på kollegiets eller
virksomhedens net. På Linux/GNU/BSD platforme sikrer man den
enkelte maskine bedst ved at den er firewall for sig selv.
</para>

<para>
Så det er vigtigt at bemærke, at en firewall ikke er en universalløsning på
sikkerhed, som mange tror i dag. Den er god at have, hvis
man er indstillet på at gøre det ordentligt. Men den er ikke en
erstatning for alle de andre sikkerhedsforanstaltninger på et netværk.
</para>

<para>
Man er aldrig helt sikker, selv med en firewall...
</para>

<figure id="uf000784-fig" float="1">
<title>User Friendly</title>
<graphic fileref="uf000784.&magic;"  scale="40"></graphic>
</figure>
</sect3>
</sect2>
</sect1>

<sect1 id="firewall-links">

<title>Links</title>
<indexterm><primary>Links på nettet</primary></indexterm>
<para>
I dette kapitel henvises der til en række HOWTO's og andre dokumenter rundt 
om i teksten. Her er en hurtig oversigt:
</para>

<para>
HOWTO's:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
    Linux IPCHAINS-HOWTO <ulink url="http://sunsite.dk/ldp/HOWTO/IPCHAINS-HOWTO.html">http://sunsite.dk/ldp/HOWTO/IPCHAINS-HOWTO.html</ulink>
  </para></listitem> 
  <listitem><para>
    Firewall and Proxy Server HOWTO <ulink url="http://sunsite.dk/ldp/HOWTO/Firewall-HOWTO.html">http://sunsite.dk/ldp/HOWTO/Firewall-HOWTO.html</ulink>
  </para></listitem>
  <listitem><para>
    Transparent Proxy with Squid mini-HOWTO <ulink url="http://sunsite.dk/ldp/HOWTO/mini/TransparentProxy.html">http://sunsite.dk/ldp/HOWTO/mini/TransparentProxy.html</ulink>
  </para></listitem>
  <listitem><para> Linux 2.4 Packet Filtering HOWTO:
<ulink url="http://www.netfilter.org/unreliable-guides/packet-filtering-HOWTO/packet-filtering-HOWTO.linuxdoc.html">
http://www.netfilter.org/unreliable-guides/packet-filtering-HOWTO/packet-filtering-HOWTO.linuxdoc.html</ulink>
  </para></listitem>
  <listitem><para>
    Linux 2.4 NAT HOWTO <ulink url="http://netfilter.samba.org/unreliable-guides/NAT-HOWTO/index.html">http://netfilter.samba.org/unreliable-guides/NAT-HOWTO/index.html</ulink>
  </para></listitem>
  <listitem><para>
    (Linux IP Masquerade HOWTO <ulink url="http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO.html">http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO.html</ulink>
  </para></listitem>
</itemizedlist>

<para>
Andet:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
    Sikkerhed på Linux <ulink url="http://www.sslug.dk/artikler/Linux_sikkerhed/">http://www.sslug.dk/artikler/Linux_sikkerhed/</ulink>
  </para></listitem>
  <listitem><para>
    Linux - Friheden til at vælge <ulink url="http://&linuxbogurl;/bog/">&linuxbogurl;/bog/</ulink>
  </para></listitem>
  <listitem><para>
    IPChains i Linux 2.2 <ulink url="http://www.sslug.dk/sikkerhed/ipchains.html">http://www.sslug.dk/sikkerhed/ipchains.html</ulink>
  </para></listitem>
  <listitem><para>
    Netfilter i Linux 2.4 <ulink url="http://www.sslug.dk/sikkerhed/netfilter.html">http://www.sslug.dk/sikkerhed/netfilter.html</ulink>
  </para></listitem>
  <listitem><para>
    The Netfilter Project HomePage <ulink url="http://netfilter.samba.org/">http://netfilter.samba.org/</ulink>
  </para></listitem>
  <listitem><para>
    Squid Web Proxy Cache <ulink url="http://www.squid-cache.org/">http://www.squid-cache.org/</ulink>
  </para></listitem>
</itemizedlist>
</sect1>



<sect1 id="firewall-funktion">
<title>Firewallens funktioner</title>

<para>
Linux firewallen vil på et mindre lokalnet som regel have flere
funktioner. Den skal kontrollere, hvilken trafik, der kan
tillades, den skal sikre os mod angreb, og endelig kan den
overvåge trafikmængder og for eksempel fortælle os, om et eller
andet program begynder at udspy pakker på internettet. Det sker
somme tider. Og måske er man bare almindeligt nysgerrig og ønsker
at se, hvad der sker på maskinen.
</para>

<sect2 id="firewall-pakkefiltrering">
<title>Kontrol af trafik-typer.</title>
<indexterm><primary>pakkefiltering</primary></indexterm>
<indexterm><primary>kontrol af trafik</primary></indexterm>

<para>
Data sendes igennem et netværk i form af datapakker. På
internettet bruges IP-pakker. En IP-pakke består af en header med
information om, hvor den skal hen, hvor den kommer fra, hvad den
er for en slags samt eventuelt nogle data.  Ved pakkefiltrering
kigger man på informationen i headeren og bestemmer, hvad der
skal ske med pakken: Om den skal afvises eller slippes igennem.
</para>

<para>
Ideen er så, at en firewall stopper alle de pakker, som man ikke
har "inviteret". Kører man fx. en web-server, slipper man kun
web-pakker igennem. En privat maskine med internetadgang kan godt
stoppe alle udefra kommende forespørgseler samtidigt med, at alle
de netværks-sessions, der startes af brugeren får lov til at køre
som normalt, d.v.s. at <emphasis>svar-pakker</emphasis> fra det
externe net får lov at komme igennem.
</para>

<para>
Man bør blokere:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
      Pakker fra services, der ikke skal bruges. Hvis en server f.eks. ikke
      tilbyder ftp er det klogt at afvise alle forsøg på at
      etablere en ftp-forbindelse med det samme.
  </para></listitem>
  <listitem><para>
      Pakker med mistænkelige bits sat som IP source routing (kan bruges til
      spoofing, hvilket betyder at udgive pakkerne for at komme fra
      et andet sted, end de egentlig kommer fra).
  </para></listitem>
  <listitem><para>
      Pakker, der er til en lokal host, som ikke burde modtage 
      pakker udefra. Det vil sige pakker, som er direkte addreseret til en
      maskine, som ikke har lov til at snakke med fremmede maskiner på
      internettet.
  </para></listitem>
</itemizedlist>

 <indexterm>
  <primary>netværkssikkerhed</primary>
  <secondary>spoofing</secondary>
 </indexterm>

<para>
For mere information om IP, TCP og netværk generelt se 
f.eks. "Introduktion til Netværk" af Geir Steen-Olsen &
Arne Stalheim (IDG-bog til 69 kr.) eller "Linux - Friheden til 
til systemadministration" på <ulink url="http://&linuxbogurl;/">&linuxbogurl;</ulink>.
</para>

<para>
Pakkefiltrering kan sættes op på en maskine, som pakkerne skal
igennem for at komme videre. Det er typisk en maskine med to
netkort. En sådan maskine eller enhed kaldes en router, det
udtales på engelsk rauter, man danskere har for vane at sige
ruter, (hvilket er ok). En router forbinder to eller flere
netværk med hinanden. Det ene netkort går til lokalnettet, det
andet til det offentlige net eller noget lignende. Det kan være
lokalnetværk, eller det kan være større netværk - pakkerne skal
igennem routeren for at kunne komme videre<footnote><para>Der
findes bokse med et stik, som leverandøren kalder router. Den
foretager kun "NATting", men er nødvendig for videresendelse af
pakker fra et såkaldt "privat netværk".</para></footnote>
</para>

<para>
Ordet <emphasis>inter-net</emphasis> betyder netop, at man
forbinder flere lokale netværk og har en måde at gøre det på,
denne måde kaldes Internet Protokollen (IP).
</para>

</sect2>


<sect2 id="sikkerhed-nat">
<title>Netværks Adresse Translation, NAT</title>

<para>
En router for et lokalnetværk har som regel flere opgaver end at
sende pakker videre og stoppe uvedkommende pakker. Den skal
omsætte de interne IP adresser til den rigtige IP adresse, som
man har fået af sin Internet Udbyder, Internet Service Provider, ISP.
Man kan for eksempel bruge adresserne 192.168.1.1-255 som lokale
adresser, denne nummerserie er reserveret. Det er en del af de
såkaldt "private adresser", som ikke bliver sendt rundt på det
offentlige net. De er reserverede for at gøre det lettere at
etablere et lokalnet uden at skulle søge og betale for "rigtige
IP-adresser".
</para>

<para>
Det er så routerens opgave at foretage en omskrivning af pakkerne
og sende dem videre som om de kom fra routerens eksterne,
offentligt synlige IP-adresse. Lige så vigtigt er det, at den kan
identificere svar-pakkerne, og sende dem til den rigtige maskine.
Dertil bruges portnumrene som en forlængelse af IP adressen.
Denne funktion kaldes <emphasis>N</emphasis>etwork
<emphasis>A</emphasis>ddress <emphasis>T</emphasis>ranslation
eller NAT. En router, som kan det, kaldes somme tider en NATting
router. (se nedenfor<!-- TODO xref linkend="si-NATting" /-->)
</para>

<para>
Som sagt kan en Linux-PC fungere som router, men en router kan
også være en dedikeret, flad boks, som egentlig er et diskløst
system, der kan fjernstyres fra en anden computer.  Der fås
billige routere til mindre virksomheder og private net, og der
fås også store routere med mange stik, som kan håndtere meget
store trafikmængder. Der er en Linux-kerne inde i mange af den
slags dedikerede routere.
</para>

<para>
En Linux/GNU maskine kan sættes op til at fungere som både
NATting router og pakkefilter - og yderligere til at måle
trafikmængder, fordele trafikken ligeligt mellem forskellige
brugere og/eller protokoller, fordele belastningen over flere
parallelle opkoblinger og meget, meget mere.
</para>

<para>
En af de vigtigste ting for en firewall til et privat netværk er,
at man kan tillade brugerne indenfor at have FTP, web, ssh,
mail og sågar telnet og så videre udadtil, selv om man lukker for
alle, der udefra forsøger at komme ind på systemet. Hvis man
forestiller at hver enkelt maskine på et lokalnet var sikret på
denne måde mod uvedkommende, så kan man forstå, hvorfor
Linux/GNU/BSD af fagfolk anses for at være bedre og sikrere
systemer.
</para>

</sect2>


<sect2 id="kontrol-af-forbindelser">
<title>Kontrol med oprettelse af forbindelser</title>

<para>
Hvis man lukker for al adgang med den undtagelse, at pakker, som
skal til port 80 på eksterne computere, skal have lov at passere,
så taler vi om filtrering på transportlaget eller på pakkeniveau.
</para>

<para>
Hvad vil der så ske, hvis en web-side indeholder et link eller et
billede fra fx.
<ulink url="http://www.e-bannerx.com:8888/adrevolver/ui">
"http://www.e-bannerx.com:8888/adrevolver/ui"</ulink>?
Vi vil ikke få forbindelse, for vi requester port 8888 fra en
remote host, og vi må kun få fat i port 80!
</para>

<para>
Vi vil med andre ord gerne åbne for al trafik indefra, men spærre
for uvedkommende udefra.
</para>

<para>
At åbne for alle forbindelser, som startes indefra, kræver, at
firewallen holder styr på, hvilke forbindelser, der er oprettet;
for at gøre det, skal firewallen have inkluderet et modul, der
kaldes "connection tracking". Derved kan Linux kernen styre
hvilke forbindelser, der må oprettes imellem de to adskilte
netværk. Den kan også logge, hvad der sker på disse forbindelser.
</para>

<para>
Det kalder man filtrering på session- eller forbindelses - niveau.
</para>

</sect2>



<sect2 id="Ftp-problemet">
<title>Ftp-problemet</title>
<indexterm><primary>FTP og sikkerhed</primary></indexterm>

<para>
Traditionel FTP, også kaldet aktiv FTP, er lidt et problem i
forbindelse med en firewall, da det laver indgående forbindelser.
Ikke alene laver det 
indgående forbindelser, men det er ikke muligt på forhånd at vide hvilken
port, forbindelsen laves på. Det vil sige, at for at tillade sine brugere at
benytte aktiv FTP, er man
nødt til at lade en masse porte stå åbne. Lad os se, hvad der sker,
når man bruger traditionel FTP:
</para>

<programlisting>
Aktiv FTP 

  Klient                  Server
                     command  data
57726 57724               21   20
  @    @                  @    @
  |    |1__               |    |
  |    |   \__port 57726__|    |
  |    |                  |    |
  |    |              ___2|    |
  |    |____ok__ ____/    |    |
  |    |                  |    |
  |____|_                 |    |
  |    | \_data channel___|___3|
  |    |                  |    |
  |    |                __|____|
  |4___|________ ok___ /  |    |
  |    |                  |    |
  |    |                  |    |

</programlisting>

<itemizedlist mark="bullet">

<listitem><para>1) Først oprettes en forbindelse fra klienten på en 
tilfældig port (her port 57724) til port 21, FTP kommando porten, 
på serveren. Klienten overfører et portnummer, som den vil benytte 
til dataoverførslen (her port 57726).</para></listitem>

<listitem><para>2) Serveren siger ok</para></listitem>

<listitem><para>3) Serveren opretter en dataforbindelse fra sin
FTP
dataport - port 20 - til den angivne port på klienten
(57726).</para></listitem>

<listitem><para>4) Klienten siger ok</para></listitem>

</itemizedlist>

<para>
Man kan se, at serveren opretter en forbindelse til klienten på port
57726.  Da man ikke på forhånd kan vide hvilken port, der vil blive
brugt på klienten - FTP-programmet vælger bare en ledig port - er det
nødvendigt at lade et portinterval på klienten stå åbent for FTP
forbindelser, så FTP klienten kan virke.
</para>

<para>
Problemet kan løses med nyere udgaver af FTP,
som kan køre "passiv FTP" i stedet for. Ved passiv FTP er det kun klienten,
der starter forbindelser op. 
</para>

<indexterm><primary>passiv FTP</primary></indexterm>

<example id="passiv-FTP">
<title>Passiv FTP</title>
<programlisting>
Passiv FTP 

  Klient                  Server
                     command      data
57726 57724               21       20
  @    @                  @  58734   @
  |    |1__               |    @    |
  |    |   \_PASV_________|    |    |
  |    |                  |    |    |
  |    |______ok_58734___2|    |    |
  |    |                  |    |    |
  |3___|__                |    |    |
  |    |  \__data_channel_|____|    |
  |    |                  |    |    |
  |____|_______ok_________|___4|    |
  |    |                  |    |    |
  |    |                  |    |    |
  |    |                  |    |    |
  |    |                  |    |    |
</programlisting>
</example>

<itemizedlist mark="bullet">
<listitem><para>1) Først oprettes en forbindelse fra klienten på en 
tilfældig port (57724) til port 21, ftp kommando porten, på serveren. 
Klienten overfører en kommando, der fortæller serveren, at der skal 
bruges passiv ftp.</para></listitem>

<listitem><para>2) Serveren siger ok og fortæller hvilket portnummer,
den vil have, at klienten connecter til.</para></listitem>

<listitem><para>3) Klienten opretter en dataforbindelse fra sin
ønskede dataport - her port 57726 - til den angivne port på serveren
(58734).</para></listitem>

<listitem><para>4) Serveren siger ok</para></listitem>
</itemizedlist>

<para>
Lad os se på, hvad der er vundet. Hvis man vedligeholder en firewall
bag hvilken, der er klienter, der gerne vil hente via
ftp, er man ved traditionel ftp nødt til at lade et portinterval stå
åbent til indgående forbindelser, som de forskellige ftp-servere, folk
henter fra, skal oprette. Bruges der derimod passiv ftp, skal man
kun tillade udgående forbindelser - man behøver ikke længere lade et
portinterval stå åbent til de indgående forbindelser fra diverse ftp
servere.
</para>

<para>
Ftp serveren skal til gengæld lade en port stå åben til data, men den 
bestemmer selv hvilken. Den oplysning sender den med over, før 
dataforbindelsen oprettes. Alligevel betragtes det nogle steder som 
et problem på serversiden. Selvom de fleste ftp-programmer - herunder
web-browsere - understøtter passiv ftp, er det derfor ikke alle ftp-servere, 
der understøtter det.
</para>

</sect2>
</sect1>

<sect1 id="Linux-som-firewall">
<title>Linux som firewall</title>

<indexterm><primary>firewall</primary></indexterm>
<indexterm><primary>dørvogter</primary></indexterm>

<para>
I dette afsnit ser vi på Linux kernens netfilter modul og hvad 
man kan gøre med det.
</para>

<para>
Desuden vil vi kigge nærmere på proxy opsætning med squid, samt
snuse lidt til Network Address Translation.
</para>


<sect2 id="pakkefiltrering">
<title>Pakkefiltrering</title>

<sect3 id="ipchains">
<title>Iptables - kommandoen, som installerer filterregler</title>

<indexterm><primary>iptables</primary></indexterm>

<para>
&lt;!-- (KOMMENTAR)
NOTABENE!!! Vi bytter om på afsnittene. Her skal omtales
iptables, hvad er en table, hvad er en chain, hvad er en default
policy, hvordan lister/ændrer man default policy, hvordan laver
man en kæde af regler, hvilke targets har man og hvordan bruger
man dem, hvordan sætter man en almindelig firewall op? Hvorfor
kan man ikke angive fx. ftp som --protocol parameter? men kun -p
tcp eller -p udp eller evt. icmp? og hvordan bruger man mest
fornuftigt --source og --destination parametre? endelig også
hooks til traffic control tc kommandoen m.v. (Har jeg glemt
noget?)
/--&gt;
</para>

<para>
Det program, som man anvender i dag og også i nærmeste fremtid på
kerne 2.6, hedder iptables og henvender sig til et kernemodul,
som hedder netfilter. Netfilter kan optimeres efter behov, og man
skal generere sin egen kerne, hvis man vil have alle features med
(i hvert fald så vidt angår RedHat 9.x++).
</para>

<para>
I kerne 2.2, hed firewallværktøjet ipchains. Ipchains er en
omskrivning af ipfwadm, som man anvendte i kerne 2.0. 
</para>

<para>
En mere grundig introduktion til ipchains kan findes i IPCHAINS-HOWTO
<ulink url="http://sunsite.dk/ldp/HOWTO/IPCHAINS-HOWTO.html">http://sunsite.dk/ldp/HOWTO/IPCHAINS-HOWTO.html</ulink>.
</para>

<sect4 id="har-jeg-ipchains">
<title>Er iptables/netfilter installeret på min maskine?</title>

<para>
Netfilter er en del af selve Linux kernen. Man skal altså bruge en kerne, der
er oversat med netfilter. Undersøg om kernen er oversat med understøttelse af
ipchains: 
</para>

<para>
PAS PÅ - næste er gammel ipchains text!
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ls /proc/net/ip_fwchains</userinput>
</screen>

<para>
Hvis filen eksisterer, er ipchains understøttet i den kerne, der er
installeret. Hvis den ikke gør, skal der oversættes
en ny kerne. Vi vil ikke her komme ind på, hvordan man
oversætter en ny kerne. Der findes en del beskrivelser på internettet om
dette, f.eks. <ulink url="http://&linuxbogurl;/admin/bog/kerne.html">&linuxbogurl;/admin/bog/kerne.html</ulink>. Man skal
under konfiguration af den nye kerne vælge "Network Firewalls" og "IP 
firewalling" under "network options". Hvis maskinen også skal bruge IP
masquerading, så vælg dette med ind i kernen med det samme - se
<xref linkend="Masquerading-med-ipchains"/>.
</para>
</sect4>


<sect4 id="rules">
<title>Opsætning af regler</title>

<indexterm><primary>rules</primary></indexterm>


<para>
Pakkefiltreringen styres af en række regler (rules), som 
systemadministratoren selv sætter op.  Disse regler styrer, hvilke
pakker, der slippes ind og ud, baseret på afsender, modtager og
typeinformation i pakke-headeren.
</para>

<para>
En regel kan f.eks. være:
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -A input -s 127.0.0.1 -p icmp -j DENY</userinput>
</screen>

<para>
som betyder, at ICMP pakker, der kommer fra 127.0.0.1 (loopback
interfacet) skal afvises. Dette er nok ikke en god regel at køre med
til daglig, da det betyder, at man ikke kan pinge sin localhost, men
den er glimrende som eksempel.
</para>

<para>
Vi kommer nærmere ind på de forskellige dele af den ovenstående kommando 
i resten af dette afsnit.
</para>

<para>
<emphasis>Kæder</emphasis>
<indexterm><primary>Kæder</primary></indexterm>


Regler puttes ind i kæder (chains). Pakkerne passerer igennem disse kæder, 
og checkes imod hver regel, der er i kæden. Der er tre indbyggede kæder:
</para>

<itemizedlist mark="bullet">
<listitem><para>

<emphasis>input</emphasis>: Input-kæden bruges på alt, hvad der kommer ind til
maskinen udefra, lige når det kommer ind. Det kan være pakker, der
kommer på netkortet (ethx), modemet (pppx) eller loopback (lo)
interfacet. </para></listitem> 

<listitem><para><emphasis>output</emphasis>: Output-kæden bruges lige
inden, en pakke forlader maskinen.
</para></listitem>

<listitem><para><emphasis>forward</emphasis>: Forward-kæden benyttes
på pakker, der kommer ind, som har en anden maskine som
destination. Dvs. pakker der skal videresendes. De har dog først
været igennem input kæden, og ryger igennem output kæden før de
forlader maskinen.</para></listitem>

</itemizedlist>

<para>
I eksemplet ovenfor er det input kæden, vi arbejder med.
</para>

<para>
Kæderelaterede options til ipchains:
</para>

<itemizedlist mark="bullet">
<listitem><para>-N Opret ny kæde</para></listitem> 
<listitem><para>-X Slet tom kæde </para></listitem>
<listitem><para>-F Flush (tøm) kæde</para></listitem>
<listitem><para>-L Vis de regler, der er i en kæde</para></listitem>
<listitem><para>-Z Nulstil (zero) pakke- og byte-tællere på alle regler i en kæde</para></listitem>
</itemizedlist>

<para>
Pakke- og byte-tælleren på en regel tæller hvor mange pakker hhv
bytes, der har været forbi, som har "opfyldt" den regel.
</para>

<para>
<emphasis>Private kæder</emphasis>:
<indexterm><primary>Private kæder</primary></indexterm>
Ud over de tre indbyggede kæder kan man lave sine egne. Det kan være smart, 
da det bl.a gør ens firewall-regler mere overskuelige.</para>

<para>
Hvis man f.eks. har et system, hvor ppp0 (modemet) er det interface, der er
forbundet til internet, vil man nok gerne sætte en masse firewallregler op
i input-kæden for ppp0-interfacet. Disse kan samles i en hjemmelavet kæde. 
</para>

<para>
Lad os kalde vores hjemmelavede kæde for
ppp0-rules. Vi sætter så en regel op i input-kæden, der kalder ppp0-rules
kæden, hvis en pakke kommer ind på ppp0. På den måde undgår man dels, at
input-kæden bliver uoverskuelig pga. alt for mange regler, dels opnår man,
at reglerne for ppp0 kun gennemløbes, hvis pakken rent faktisk er kommet 
ind på ppp0.
</para>

<programlisting>
                  __________
                _|ppp0-rules|__> ppp0 rule 1 __> ppp0 rule 2 ..._
               ^ |__________|                                    |
              _|_____                                            |
             /if ppp0\                                           |
            |  else   |                                          |
             \_______/ _    _____________________________________|
               ^        |  |
   ______      |        v  v
__|input |__> rule 1    rule 2 __> rule 3
  |______|  
   ______
__|output|
  |______| 
   _______
__|forward|
  |_______|
</programlisting>

<para>
En kæde oprettes med kommandoen:
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -N ppp0-rules</userinput>
</screen>

<para>
og kan slettes igen med
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -X ppp0-rules</userinput>
</screen>

<para>
Man kan kun slette en tom kæde. En kæde kan flushes (tømmes) med en 
"-F" option til ipchains kommandoen. Det betyder, at alle regler i 
kæden slettes.
</para>

<para>
<indexterm><primary>targets</primary></indexterm>

<emphasis>Targets</emphasis>: 
En regel har et target (mål), som fortæller hvad der
skal ske med pakken. Logikken i navnet "target" kan diskuteres, men
sådan hedder det. Pakkens skæbne kan være
</para>

<itemizedlist mark="bullet">
<listitem>
<indexterm><primary>ACCEPT</primary></indexterm>

<para>ACCEPT betyder, at pakken accepteres.</para></listitem> 

<listitem>
<indexterm><primary>REJECT</primary></indexterm>
<para>REJECT betyder, at pakken afvises, og at 
afsenderen orienteres om dette.</para></listitem> 


<listitem>
<indexterm><primary>DENY</primary></indexterm>
<para>DENY betyder at pakken afvises, uden at 
afsenderen får det at vide.</para></listitem>  


<listitem>
<indexterm><primary>MASQ</primary></indexterm>
<para>MASQ er relateret til masquerading og 
bruges kun i forward kæden. Se om masquerading senere i artiklen
</para></listitem>  
<!-- HUSK -->

<listitem><para>REDIRECT betyder, at pakken sendes til en lokal port i
stedet for at gå videre til destinationsmaskinen. REDIRECT kan kun
bruges i input kæden og kun med pakker til UPD eller TCP
protokollerne.</para></listitem>

<listitem><para>RETURN betyder, at man straks springer
til enden af kæden.</para></listitem> 
</itemizedlist>

<para>
I eksemplet
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -A input -s 127.0.0.1 -p icmp -j DENY</userinput>
</screen>

<para>
er target sat til DENY. Option "-j", som bruges til at definere target,
kan huskes ved at tænke "jump to", 
hvilket måske siger mere om betydningen end "target" gør.
</para>

<para>
<emphasis>Default policy</emphasis> 
er det, der sker, hvis en pakke når enden af en af de tre 
standardkæder uden at være blevet afvist eller accepteret. Default policy 
kan være et af de fire første targets: ACCEPT, REJECT, DENY eller MASQ - 
MASQ bruges dog stadig kun i forward kæden.
</para>

<para>
Default policy for en kæde sættes med en "-P" option til ipchains:
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -P input ACCEPT</userinput>
</screen>

<para>
En regel behøver ikke at have et target. En pakke, som matcher en regel, der
ikke har noget target, går bare videre til næste regel. En regel uden target
kan f.eks. bruges til at tælle antallet af pakker, der opfylder bestemte
kriterier.
</para>

<para>
<emphasis>Regler</emphasis>
Rule relaterede options til ipchains:
</para>
<itemizedlist mark="bullet">
<listitem><para>-A Tilføj (append) regel</para></listitem> 
<listitem><para>-D Slet (delete) regel</para></listitem>
<listitem><para>-R Erstat (replace) regel</para></listitem>
<listitem><para>-I Indsæt (insert) regel</para></listitem>
</itemizedlist>



<para>
Lad os beholde vores eksempel fra ovenfor.
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -A input -s 127.0.0.1 -p icmp -j DENY</userinput>
</screen>

<para>
"-A" betyder at vi tilføjer en regel (append). 
</para>

<para>
En regel kan indeholde forskellige betingelser, som gør, at pakkerne matcher
eller ikke matcher.
</para>

<para>
<emphasis>Betingelser</emphasis>
</para>

<itemizedlist mark="bullet">
<listitem><para>-p Protokol</para></listitem>
<listitem><para>-s Source IP-adresse</para></listitem>
<listitem><para>-d Destination IP-adresse</para></listitem>
<listitem><para>-i Interface</para></listitem>
<listitem><para>-y SYN pakker (kun TCP)</para></listitem>
<listitem><para>-f Fragmenter af en pakke</para></listitem>
</itemizedlist>

<para>Desuden kan der ved TCP eller UPD specificeres en port eller et
portinterval efter source eller destination IP-adresse. Ved ICMP kan
der specificeres en ICMP type og kode efter source eller destination
adressen. 
</para>

<para>
En oversigt over protokollerne findes i
<filename>/etc/protocols</filename>. ICMP typerne kan ses med
kommandoen
<indexterm><primary>/etc/protocols</primary></indexterm>
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -h icmp | more</userinput>
</screen>

<para>
Lad os prøve at lave nogle regler i praksis. Vi ser igen på vores eksempel 
fra tidligere:
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -A input -s 127.0.0.1 -p icmp -j DENY</userinput> 
</screen>

<para>
Den betyder, at der ikke må komme ICMP pakker ind på lo (loopback interfacet), 
og derfor kan man ikke kan pinge sin localhost:
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ping -c 1 localhost</userinput>
PING localhost (127.0.0.1): 56 data bytes 
</screen>

<para>
Før eller siden vil man få timeout på sin ping kommando. For at fjerne
den nye regel igen skrives
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -D input -s 127.0.0.1 -p icmp -j DENY</userinput>
</screen>

<para>
og prøv at pinge localhost igen:
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ping -c 1 localhost</userinput>
PING localhost (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=0.1 ms

--- localhost ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 0.1/0.1/0.1 ms
</screen>

<para>
En regel kan også fjernes ved blot at angive dens nummer i stedet for hele i
dens indhold. Da vores regel fra før havde nummer 1, kunne den være fjernet med
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -D input 1</userinput>
</screen> 

<para>
Regler får nummer i den rækkefølge, man laver dem: Næste regel vi laver, får
nummer 2. 
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -A input -s 127.0.0.1 -p icmp -j DENY</userinput>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -A input -s 192.168.1.1</userinput>
</screen>

<para>
Den første kommando danner regel nummer et, den næste regel nummer 2. Slettes 
nummer et, rykker nummer 2 frem og bliver nummer 1.
</para>

<para>
Man kan dog indsætte regler inde i en kæde med -I optionen.
Dette gøres ved at angive det ønskede regelnummer:
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -A input -s 127.0.0.1 -p icmp -j DENY</userinput> 
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains -I input 1 -s 192.168.1.1</userinput>
</screen>

<para>
Her vil den sidste regel blive nummer 1, pga -I optionen og ettallet, i
der er angivet efter kædenavnet (input).
</para>
</sect4>

<sect4 id="eksempel-hjemmebruger">
<title>Eksempel:  hjemmebruger</title>
<para>
Nu har vi lært lidt om at oprette og slette regler. Lad os kigge på hvilken
opsætning af kæder og regler, man kunne ønske sig i virkeligheden.
</para>

<para>
Det eksempel, vi skal se på, er en hjemmebruger, der har en eller
flere computere og en opkobling til internettet. Vores hjemmebruger
kører sin egen webserver. Han kører også en auth server til validering 
af hvilken bruger, der kører en bestemt service. 
</para>

<para>
Desuden bruger han en
række klienter, der kræver forbindelser (connections): ftp, DNS og Real Audio. 
</para>

<para>
Figuren viser et netværk der består af to computere, en på det lokale
LAN og en, der skal fungere som firewall. Der kunne selvfølgelig godt være
mange flere maskiner indenfor firewallen. Men selv hvis man kun har én
computer, kan det godt give mening at installere ipchains på den
alligevel, for at sortere i, hvilke pakker der skal slippe igennem
til maskinens egne lokale services.
</para>


<figure id="netfirewall-fig" float="1">
<title>Firewall</title>
<graphic fileref="netfirewall.&magic;"  scale="40"></graphic>
</figure>  

<para>
Først skal vi sætte vores default policy op. I input og output kæden kan 
man vælge ACCEPT, DENY eller REJECT. Vælger man ACCEPT, skal man sætte
regler op for at spærre for alt det, der ikke må komme igennem. Vælger man
DENY eller REJECT, skal man sætte regler op for alt det, der gerne må komme
igennem. Det er nemt at regne ud, at det sidste er det mest sikre. Især på
input kæden kan det frarådes at køre ACCEPT som default policy, med mindre
man er helt sikker på, at man ved, hvad man gør, eller sikkerheden ikke er så
vigtig i det pågældende netværk I forward kæden kan man desuden vælge MASQ, 
dette kommer vi ind på i afsnittet om
masquerading.
</para>

<!-- HUSK -->

<para>
Vores hjemmebruger bag firewallen ønsker adgang til internettet
igennem firewallen. Derimod vil han gerne skærme sit lokale netværk
imod de indgående forbindelser fra fremmede maskiner.
</para>

<para>
Først sætter vi "default policies" op.
<indexterm><primary>default policy</primary></indexterm>
</para>

<programlisting>
ipchains -P input DENY
ipchains -P output ACCEPT
ipchains -P forward DENY
</programlisting>
</sect4>

<sect4 id="eksempel-for-vores-hjemmebruger">
<title>Regler for vores hjemmebruger</title>
<para>
Tillad alt på loopback interfacet
</para>

<programlisting>
ipchains -A input -p all -j ACCEPT -i lo
</programlisting>

<para>
Tillad alt på LAN
</para>

<programlisting>
ipchains -A input -p all -j ACCEPT -i eth0
</programlisting>

<para>
Nu er der kun indgående trafik fra internettet (ppp0) tilbage.  Først
spærrer vi for at der kan komme spoofede pakker fra "interne
ip-adresser" fra det eksterne interface. Hvis vores interne net er
192.168.0.0/255.255.255.0, hedder det:
</para>

<programlisting>
ipchains -A input -p all -s 192.168.0.0/255.255.255.0 -j DENY -i ppp0
</programlisting>

<para>
Lad os nu kigge på TCP pakker. Tillad alt, hvad der <emphasis>ikke</emphasis>
forsøger at oprette en forbindelse, det vil sige alt, hvad der ikke
har SYN bitten sat:
</para>

<programlisting>
ipchains -A input -p tcp -j ACCEPT \! -y
</programlisting>

<para>
Tillad forbindelser til vores http, https og auth server:
</para>

<programlisting>
ipchains -A input -p tcp -j ACCEPT -s 0/0 -d 0/0 http -y
ipchains -A input -p tcp -j ACCEPT -s 0/0 -d 0/0 https -y
ipchains -A input -p tcp -j ACCEPT -s 0/0 -d 0/0 auth -y
</programlisting>

<para>
Tillad FTP-dataforbindelser (når vores hjemmebruger vil hente filer over
FTP og se indholdet af FTP-servere ude i verden):

<programlisting>
ipchains -A input -p tcp -j ACCEPT -s 0/0 ftp-data -d 0/0 56000:65096 -y
</programlisting>
</para>

<para>
UDP pakker: Tillad svar på DNS-opslag:

<programlisting>
ipchains -A input -p udp -j ACCEPT -s 0/0 domain -d 0/0 56000:65096
</programlisting>
</para>

<para>
Tillad Real Audio / Real video i bedste kvalitet:
</para>

<programlisting>
ipchains -A input -p udp -j ACCEPT -d 0/0 32768:37769
</programlisting>

<para>
ICMP
</para>

<para>
Tillad ikke redirect (kan principielt bruges til at manipulere
routing)
</para>

<programlisting>
ipchains -A input -p icmp -s 0/0 redirect -j DENY --log
ipchains -A input -p icmp -s 0/0 timestamp-request -j DENY --log
ipchains -A input -p icmp -s 0/0 address-mask-request -j DENY --log
ipchains -A input -p icmp -j ACCEPT
</programlisting>

<para>
Log resten
</para>

<programlisting>
ipchains -A input --log
</programlisting>


<para>
Alt, hvad der kommer på inputkæden, og som ikke er blevet accepteret af 
en af de andre regler, matcher denne sidste regel. Reglen gør, at der
logges information om disse pakker i kerne-logfilen (ofte
<filename>/var/log/messages</filename>).
<indexterm><primary>/var/log/messages</primary></indexterm>

</para>

<para>
En log entry kan f.eks. se sådan ud:
</para>

<programlisting>
input - ppp0 proto=17 4.3.2.1:4000 1.2.3.4:1872 l=53 s=0x00      
i=60456 f=4000 t=240 (#14)
</programlisting>

<para>
hvor <emphasis>1.2.3.4</emphasis> er vores hjemmebrugers egen
ip-adresse på ppp0. Man kan se, at det er kommet ind på
<emphasis>input</emphasis>kæden, interface <emphasis>ppp0</emphasis>.
<emphasis>proto=17</emphasis> betyder, at det er udp (se
<filename>/etc/protocols</filename>).
</para>

<para>
<emphasis>4.3.2.1:4000</emphasis> er afsender-adressen, port
4000. Pakken er forsøgt sendt til port <emphasis>1872</emphasis> hos
vores bruger. <emphasis>l=53</emphasis> betyder, at pakken var 53
bytes lang. <emphasis>S</emphasis> betyder type of
service. <emphasis>I</emphasis> betyder IP ID, <emphasis>F</emphasis>
betyder fragment offset, og <emphasis>T</emphasis> betyder Time to
live. <emphasis>#14</emphasis> betyder, at det var vores regel nummer
14, der loggede pakken. Se
<ulink url="http://sunsite.dk/ldp/HOWTO/IPCHAINS-HOWTO.html">
ipchains HOWTO'en</ulink> for yderligere detaljer.
</para>

<para>
Hvis ftp ikke virker med det angivne portinterval (56000:65096), er det fordi,
maskinen er sat op til at bruge nogle andre porte til at oprette 
forbindelser på. Det kan systemadministratoren selv sætte med kommandoen
</para>

<programlisting>
echo "56000 60999" >/proc/sys/net/ipv4/ip_local_port_range
</programlisting>

<para>
Se i øvrigt et glimerende eksempel på ipchains opsætning på
<ulink url="http://www.sslug.dk/sikkerhed/ipchains.html">http://www.sslug.dk/sikkerhed/ipchains.html</ulink>
</para>
</sect4>

<sect4 id="aktivere-rules">
<title>At aktivere sine regler ved opstart</title>

<para>
Ipchains styres af en række regler. Selve pakkefiltreringen
sker i kernen, så det eneste, man skal gøre, er, at fortælle kernen om sine
ipchain regler.
</para>

<para>
Da regler gemmes i kernen, går de imidlertid tabt ved reboot. Derfor er
det en god ide at gemme dem i en fil. Man kan så lave et startup
script, som læser filen og sætter kernen op til at bruge de regler ved
genstart af maskinen. Ipchains regler gemmes i en fil med følgende
kommando:
</para>

<screen>
<prompt>[root@sherwood /root]#</prompt> <userinput>ipchains-save > /etc/ipchains.rules</userinput>
</screen>

<para>
Hvis du anvender en ældre Red Hat version, så er nedenstående
interessant, men for nyere Red Hat versioner - f.eks. 7.1 eller senere
så er der allerede i <filename>/etc/init.d/ipchains</filename> er
script til at starte og stoppe ipchains. Den tager sin konfiguration
fra <filename>/etc/sysconfig/ipchains</filename>, og denne fil har
samme funktion som <filename>/etc/ipchains.rules</filename> og man kan
evt.  sym-linke de to filer eller anvende
<filename>/etc/sysconfig/ipchains</filename>i stedet for
<filename>/etc/ipchains.rules</filename>.
</para>

<para>
Det følgende startup script kan hvert fald bruges med Red Hat, SuSE og
Debian:
</para>

<programlisting>
#!/bin/sh
#ipchains startup script
#To be run before starting network on startup
#and to be shut down after network on shutdown 

# If no rules, do nothing.
[ -f /etc/ipchains.rules ] || exit 0

case "$1" in
    start)
        echo -n "Turning on packet filtering:"
        /sbin/ipchains-restore &lt; /etc/ipchains.rules || exit 1
        echo 1 &gt; /proc/sys/net/ipv4/ip_forward
        echo "."
        ;;
    stop)
        echo -n "Turning off packet filtering:"
        echo 0 &gt; /proc/sys/net/ipv4/ip_forward
        /sbin/ipchains -X
        /sbin/ipchains -F
        /sbin/ipchains -P input ACCEPT
        /sbin/ipchains -P output ACCEPT
        /sbin/ipchains -P forward ACCEPT
        echo "."
        ;;
    *)                        
        echo "Usage: /etc/init.d/packetfilter {start|stop}"
        exit 1
        ;;
esac                
</programlisting>

<para>
Lav et symlink til det i <filename>/etc/rc.d/rc</filename><emphasis>N</emphasis><filename>.d</filename> (n=runlevel) 
directory'erne (Red Hat) eller 
<filename>/etcrc</filename><emphasis>N</emphasis><filename>.d</filename>
(Debian/SuSE), så det bliver startet op før
netværket. Hvis netværket f.eks. startes op med et symlink, der hedder
<filename>S10network</filename>, skal ipchains symlinket hedde et lavere
tal. F.eks. <filename>S9ipchainsrules</filename>.  
Så er ipchains altid kørende før
netværket startes op. Ligeledes bør netværket lukkes ned før ipchains
lukkes ned. Selvom der er grænser for, hvor meget skade en cracker kan
nå at gøre på systemet, før det når at lukke ned.  Det skal specielt
bemærkes, at hvis man med det viste script anvender stop-kommandoen,
efterlader man sit system i en særdeles usikker tilstand med alt
nettraffik tilladt. Lad være med at gøre det, mens systemet er i
drift. Man lukker simpelthen ned for firewallen.
</para>

<para>
Se i øvrigt en udemærket HOWTO på <ulink url="http://sunsite.dk/ldp/HOWTO/IPCHAINS-HOWTO.html">http://sunsite.dk/ldp/HOWTO/IPCHAINS-HOWTO.html</ulink>.
</para>
</sect4>
</sect3>

<sect3 id="netfilter">
<title>Iptables (Netfilter) - kerne 2.4</title>
<indexterm><primary>Iptables</primary></indexterm>
<indexterm><primary>Netfilter</primary></indexterm>

<para>
Kerne 2.4 er den nyeste stabile gren af Linuxkernen. Den er fra
januar 2001.  I skrivende stund er kerne 2.6 på vej.
</para>

<para>
I kerne 2.4 er firewallsystemet ændret og forbedret. Systemet
kaldes <command>netfilter</command> og styres af "The Netfilter
Core Team".
</para>

<para>
Kommandoen, der før hed ipchains, hedder nu iptables, fordi den
arbejder med tre tabeller, en for pakkefiltrering, en for NAT
(<emphasis>N</emphasis>etwork <emphasis>A</emphasis>ddress
<emphasis>T</emphasis>ranslation), og en for pakke-mangling, som
bruges til specialiserede ændringer af pakker, fx. kan man ændre
feltet Type Of Service, TOS. 
</para>

<para>
De tre tabeller er data i kernens netfilter del, og iptables gør
ikke andet end at lægge nogle data ind i disse tabelstrukturer.
Hver tabel har nogle kæder af regler (chains), og det minder jo
om den gamle ipchains kommando fra kerne 2.2.
</para>

<para>
Kommandoerne og navnene ligner næsten sig selv fra ipchains. Man
skal dog ikke lade sig narre - iptables kan meget mere.
</para>

<sect4 id="hvad-skal-jeg-bruge">
<title>Hvad skal jeg bruge?</title>
<para>
For at komme igang med netfilter skal man bruge en 2.4 kerne
oversat med netfilter aktiveret, CONFIG_NETFILTER, samt user
space-værktøjet iptables. Begge dele er med i alle nyere Linux
distributioner efter RedHat 7.0.  Den nyeste version kan hentes
fra Netfilter hjemmesiden: <ulink
url="http://netfilter.samba.org/">http://netfilter.samba.org/</ulink>
</para>

<para>
De fleste Linux-distributører har endog et GUI-apparat til at
indsætte de vigtigste regler. RedHat har endog en
installations-mulighed for opsætning af en fornuftig firewall.
Hvis man vælger den, kan man kun komme ind på maskinen ved hjælp
af secure shell, et <emphasis>meget</emphasis> fornuftigt valg.
</para>

<para>
Kommer man fra ipchains er det ikke svært at følge med i
kommandoerne til iptables.
</para>
</sect4>

<sect4 id="chains">
<title>Kæder</title>
<para>
Først ser vi på tabellen for filtrering af pakker på basis af
protokol, portnumre og netkort, tabellen vælges med option
<command>-t filter</command>, men det behøver man ikke at skrive.
Det er default - tabellen. En kommando, som fx. lukker for alt
input fra netkort nummer to (eth1) kunne se sådan ud:
</para>


<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>iptables -A INPUT -i eth1 -j DROP
# eller som nedenstående:
</userinput>
<prompt>[tyge@hven ~]$ </prompt> <userinput>iptables -t filter -A INPUT -i eth1 -j DROP
</userinput>
</screen>

<para>
Det læses således: iptables kommandoen skal i tabellen "filter"
tilføje (addere, -A) en regel om, at alt input fra ethernet kort
eth1 skal smides væk (DROP).
</para>

<para>
Hvis du sidder og eksperimenterer med kommandoerne mens du læser
(hvilket er en god ide) så skal du sidde ved maskinens
indbyggede tastatur (hvis den har et) og i øvrigt passe lidt på,
hvis andre bruger den. Du kan fjerne alle regler, flushe, med
flg. kommando:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>iptables -F 
# eller:
</userinput>
<prompt>[tyge@hven ~]$ </prompt> <userinput>iptables -t filter -F
</userinput>
</screen>

<para>
Flush kommandoen (-F) ændrer dog ikke på default policy, så hvis
man har ændret den, skal den også "normaliseres", mere herom
senere.
</para>

<para>
På linje med ipchains har filter-tabellen 3 indbyggede kæder: INPUT, OUTPUT
og FORWARD. Kæderelaterede options til iptables er uændret fra ipchains.
Der er dog den gennemgribende arkitekturforskel at pakker til FORWARD
kæden ikke længere kommer igennem INPUT kæden først og OUTPUT kæden 
bagefter, men alene igennem FORWARD kæden. Og så er mange ting case sensitive
i iptables - bl.a skal navnene på de indbyggede kæder skrives med stort.
</para>
</sect4>

<sect4 id="targets">
<title>Targets</title>

<para>De indbyggede targets er flg.: </para>
<itemizedlist mark="bullet">
<listitem><para>DROP betyder, at pakken smides væk</para></listitem>
<listitem><para>ACCEPT betyder, at pakken accepteres</para></listitem>
<listitem><para>RETURN betyder, "gå til enden af kæden" og tilbage, hvor vi kom fra</para></listitem>
<listitem><para>QUEUE betyder, at pakken skal sættes i kø til brugerniveauprocessering</para></listitem>
</itemizedlist>

<para>
Muligheden for at sende pakker over til bruger-niveau og så tygge
dem igennem der er ny. Den skal anvendes med forsigtighed, for
det er noget, der virkelig koster i tid. Men det er en stor
fordel for eksperimenter med TCP/IP.
</para>

<para>
Når vi sammenligner med ipchains, kan vi se, at REJECT er forsvundet.
Den findes dog som modul (extension), d.v.s. at man ved
kernegenerering skal huske at tage det med, ellers kan man ikke
lade iptables kommandoen bruge REJECT<footnote><para>Det er af
optimeringshensyn, at alt, hvad der sløver en kerne ned, skal
vælges separat.</para></footnote>. Der er to extensions, som
følger med iptables og kerne 2.4.x:
</para>

<itemizedlist mark="bullet">
<listitem><para>REJECT</para></listitem>
<listitem><para>LOG</para></listitem>
</itemizedlist>

<para>
Det er muligt at skrive sine egne extension og derved lave andre
"targets".
</para>
</sect4>

<sect4 id="default-policy">
<title>Default policy</title>
<para>
Default policy er som i ipchains, alt accepteres. Man kan liste
filter tabellen med kommandoerne:
</para>


<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>iptables -L
# eller som nedenstående:
</userinput>
<prompt>[tyge@hven ~]$ </prompt> <userinput>iptables -L -v
</userinput>
</screen>

<para>
og tilsvarende, hvis man har installeret <command>nat</command>
og <command>mangle</command> i kernen:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>iptables -t nat -L
# eller som nedenstående:
</userinput>
<prompt>[tyge@hven ~]$ </prompt> <userinput>iptables -t mangle -L
</userinput>
</screen>

</sect4>

<sect4 id="chains-rules">
<title>Regler</title>
<para>
Når en pakke er lagt på dissektionsbordet, undersøger kerne-koden
pakken ud fra de regler, som er blevet sat op (som data) i kernen
ved hjælp af iptables kommandoen. Der skal udstedes en iptables
kommando for hver regel. En regel består af en betingelse og en
beslutning, som kan være at hoppe til en anden kæde eller til et
af de indbyggede targets, DROP, ACCEPT, REJECT, SNAT o.s.v.
</para>
</sect4>

<sect4 id="betingelser">
<title>Betingelser</title>
<para>
En regel kan indeholde flere betingelser. Hvis alle betingelserne
er opfyldt, siger man at pakken matcher den betingelse. Hvis en
pakke matcher, ser kernekoden efter, hvilket target den så skal gå
til, eller sagt på en anden måde, når vi har inspiceret en
egenskab ved pakken kan vi enten droppe pakken, acceptere den
eller gå videre med en anden inspektion.
</para>

<para>
<emphasis>Betingelser</emphasis>
</para>

<itemizedlist mark="bullet">
<listitem><para>-p Protokol</para></listitem>
<listitem><para>-s Source IP-adresse</para></listitem>
<listitem><para>-d Destination IP-adresse</para></listitem>
<listitem><para>-i Input interface</para></listitem>
<listitem><para>-o Output interface</para></listitem>
<listitem><para>-f Fragmenter af en pakke</para></listitem>
</itemizedlist>

<para>
Vi ser at <emphasis>-i</emphasis> nu ikke betyder interface, men input
interface, og <emphasis>-o</emphasis> er kommet til for output
interface.  Desuden er <emphasis>-y</emphasis> (SYN) forsvundet, men
bare rolig, den kommer om lidt.
</para>

<para>
Ud over standardbetingelserne er der en del protokolspecifikke udvidelser:
</para>

<para>
<emphasis>TCP</emphasis>
</para>

<itemizedlist mark="bullet">
<listitem><para>--tcp-flags (SYN,ACK,FIN,RST,URG,PSH)</para></listitem>
<listitem><para>--syn (SYN,RST,ACK SYN)</para></listitem>
<listitem><para>--source-port </para></listitem>
<listitem><para>--destination-port </para></listitem>
<listitem><para>--tcp-option </para></listitem>
</itemizedlist>

<para>
<emphasis>UDP</emphasis>
</para>

<itemizedlist mark="bullet">
<listitem><para>--source-port </para></listitem>
<listitem><para>--destination-port </para></listitem>
</itemizedlist>

<para>
<emphasis>ICMP</emphasis>
</para>

<itemizedlist mark="bullet">
<listitem><para>--icmp-type</para></listitem>
</itemizedlist>

<para>
Desuden er der skrevet en række extensions, som følger med iptables:
</para>

<para>
<emphasis>Andre extensions</emphasis>
</para>

<itemizedlist mark="bullet">
<listitem><para>mac</para>
  <itemizedlist mark="bullet">
  <listitem><para>--mac-source</para></listitem>
  </itemizedlist>
</listitem>
<listitem><para>limit</para>
  <itemizedlist mark="bullet">
  <listitem><para>--limit</para></listitem>
  <listitem><para>--limit-burst</para></listitem>
  </itemizedlist>
</listitem>
<listitem><para>owner</para>
  <itemizedlist mark="bullet">
  <listitem><para>--uid-owner userid</para></listitem>
  <listitem><para>--uid-owner groupid</para></listitem>
  <listitem><para>--pid-owner processid</para></listitem>
  <listitem><para>--sid-owner processid</para></listitem>
  </itemizedlist>
</listitem>
<listitem><para>unclean</para></listitem>
<listitem><para>state</para>
  <itemizedlist mark="bullet">
  <listitem><para>NEW</para></listitem>
  <listitem><para>ESTABLISHED</para></listitem>
  <listitem><para>RELATED</para></listitem>
  <listitem><para>INVALID</para></listitem>
  </itemizedlist>
</listitem>
</itemizedlist>

<para>Udvidelsesmodulerne indlæses med <emphasis>-m</emphasis>, f.eks.</para>
<programlisting># iptables -A INPUT -m mac --mac-source 192.168.0.1</programlisting>
<para>Det er også muligt selv at skrive udvidelser til <literal>iptables</literal>.</para>
</sect4>

<sect4 id="state">
<title>State</title>
<para>
State er værd at kigge lidt nærmere på, da det bruges til at checke 
på connection tracking. Det vil sige, at man kan sortere på, om en pakke er en 
del af en eksisterende forbindelse (ESTABLISHED), om den vil etablere en ny 
forbindelse (NEW), om den er relateret til en eksisterende forbindelse, 
f.eks. en ICMP fejl (RELATED), eller om den ikke kan genkendes (INVALID).
</para>
</sect4>

<sect4 id="mere-ipchains">
<title>Læs selv videre</title>
<para>
For mere information om iptables og netfilter anbefaler vi at læse 
Linux 2.4 Packet Filtering HOWTO:
<ulink url=
"http://www.netfilter.org/unreliable-guides/packet-filtering-HOWTO/packet-filtering-HOWTO.linuxdoc.html">
http://www.netfilter.org/unreliable-guides/packet-filtering-HOWTO/packet-filtering-HOWTO.linuxdoc.html</ulink>
</para>
</sect4>
</sect3>
</sect2>

<sect2 id="proxy-server">
<title>Linux som proxy server</title>

<itemizedlist mark="bullet">
<listitem><para>Squid</para></listitem>
<listitem><para>Masquerading med ipchains</para></listitem>
<listitem><para>Network Address Translation med iptables (Netfilter)
i kerne 2.4</para></listitem>
</itemizedlist>

<sect3 id="proxy-squid">
<title>Proxy med Squid</title>

<para>
Squid er en god proxy server bl.a. til Linux, der kan findes på 
<ulink url="http://www.squid-cache.org/">http://www.squid-cache.org/</ulink>. Squid
er en agent, der henter de hjemmesider, brugeren beder om, og
videresender resultatet til brugeren. Samtidig kan Squid fungere som
proxy-cache - den gemmer hjemmesiden i cache, og er der nu en anden
bruger, der vil se den samme hjemmeside, hentes den direkte fra den
lokale hukommelses- eller disk-cache på proxy-maskinen - det vil sige,
uden at man skal via internettet. Squid tester, om en hjemmeside på
nettet er nyere end den i cachen, og kun hvis cachen er forældet, vil
en ny version blive hentet. Fordelen ved en proxy-cache er således, at
man ofte kan spare måske 50% på båndbredden.
</para>

<para>
Det er naturligvis ikke alt, som kan gemmes i en cache, f.eks.
skal cgi-kald netop ikke køre fra cache. Disse hindringer
håndterer Squid dog transparent. Ud over hjemmesider (HTTP) er FTP,
GOPHER, SSL og WAIS protokollen understøttet. Squid kan dog ikke klare
POP-mail, NNTP (News grupper) og RealAudio.
</para>
</sect3>

<sect3 id="installation-squid">
<title>Installation af Squid-serveren</title>


<indexterm><primary>Squid</primary><secondary>installation</secondary></indexterm>
<para>
Man bør ikke installere Squid, så den kører som root. Ofte vælger man
at lade Squid køre som brugeren <command>squid</command> i sin egen gruppe
<command>squid</command>, og kun med få rettigheder.
</para>

<para>
Vi har installeret <filename>squid-2.2.STABLE5-1.i386.rpm</filename>,
som kan hentes fra <ulink
url="http://www.squid-cache.org/">http://www.squid-cache.org/</ulink>. Squid
startes op via <filename>/etc/rc.d/init.d/squid</filename>. Squids
opsætningsfil hedder <filename>/etc/squid/squid.conf</filename>. Der er
<emphasis>mange</emphasis> konfigurationsmuligheder. Basalt set skal
man fjerne kommentartegnene fra nogle linjer i
<filename>/etc/squid/squid.conf</filename> og udkommentere andre, og
så starte Squid.  Den originale
<filename>/etc/squid/squid.conf</filename> er stor, og vi vil nu se
nærmere på en simpel opsætning af squid.
</para>

<sect4 id="basal-squid-conf">
<title>Basal opsætning af squid.conf</title>

<indexterm><primary>squid.conf</primary></indexterm>
<para>
Man kan i <filename>/usr/doc/squid-2.2.STABLE5/QUICKSTART</filename>
finde en minimal beskrivelse af parametre for
<filename>squid.conf</filename>. En meget bedre gennemgang fås ved at
læse brugermanualen til Squid, som kan findes på 
<ulink url="http://www.squid-cache.org/Doc/Users-Guide/">http://www.squid-cache.org/Doc/Users-Guide/</ulink>.
En anden god start er også at læse (og gemme) den originale
<filename>/etc/squid/squid.conf</filename>, som fulgte med RPM-pakken.
</para>

<para>
Vi skal nu vise en kort <filename>squid.conf</filename>, hvor vi lader squid køre som 
brugeren <filename>squid</filename>.
</para>

<programlisting>
#squid.conf -  Basal opsætning

#Laveste niveau af logging
debug_options ALL,1

#Gruppe af IP numre, som kan tilgå Squid (Access Control List) 
#Vil man kun give access til netværket 192.168.0.0/255.255.255.0
#så brug følgende linje
acl all src 192.168.0.0/255.255.255.0

#Skal alle kunne bruge Squid så udkommenter følgende linje.
#acl all src 0.0.0.0/0.0.0.0

#Port, man anvender til konfiguration af Netscape klienter
http_port 3128

#Lad alle i ACL bruge Squid til HTTP
http_access allow  all

#test følgende sites for at checke, om maskinen er koblet til internettet
dns_testnames internic.net usc.edu cs.colorado.edu mit.edu yale.edu

#Kør som effektiv bruger squid og gruppe squid
cache_effective_user squid squid

# Squid vil oftest bruge to-tre gange denne RAM størrelse. Vil man max
# bruge 24 Mb RAM til Squid, så sæt cache_ram til 8 Mb. 
# Jo mere cache_mem desto hurtige er cachen (mindre diskaccess).
cache_mem  8 MB

#Maximal størrelse på object i cache
maximum_object_size 4096 KB

# Næste parameter-opsætning er disk cache struktur. Parametre er
#  Dirname - hvor på disken er disk cache dvs. spool dir
#  Mbytes under spool dir - hvor mange Mb må gemmes i disk cache.
#  Level-1 dir antal - Antal underkataloger under Dirname
#  Level2 dir antal - Antal underkataloger for hver Level-1 kataloger
# Sæt ikke produktet mellem de to sidste vildt højt!
cache_dir /var/spool/squid 100 16 256
</programlisting>


<para>
Lad os se nærmere på, hvad der installeres, og hvordan squid
kører. Installer squid med 
</para>

<programlisting>
#rpm -ivh squid-2.2.STABLE5-1.i386.rpm
</programlisting>

<para>
Ret <filename>/etc/squid/squid.conf</filename> til som vist ovenfor. Husk dog at gemme 
den originale <filename>/etc/squid/squid.conf</filename> før ovenstående eksempel anvendes.
</para>

<itemizedlist mark="bullet">

<listitem><para><filename>/etc/squid/</filename> indeholder konfigurationsfiler - specielt er
<filename>/etc/squid/squid.conf</filename> vigtig.</para></listitem> 

<listitem><para><filename>/var/spool/squid</filename> indeholder den dynamiske database. (se
parameteren <filename>cache_dir</filename> i <filename>squid.conf</filename>). Over 4000 filer laves med
ovenstående opsætning.</para></listitem>

<listitem><para><filename>/var/log/squid</filename> indeholder log-filer.
</para></listitem>
<listitem>
  <itemizedlist mark="bullet">
    <listitem><para><filename>access.log</filename> - Hvad blev hentet
    fra  nettet. 
    Her kan systemadministratoren overvåge trafik.</para></listitem>
  <listitem><para><filename>cache.log</filename> - Opstartsmeddelelser.</para></listitem>
<listitem><para><filename>store.log</filename> - Oversigt over, hvad der findes i proxy-cache nu.</para></listitem>
  </itemizedlist>
</listitem>

</itemizedlist>

<para>
Med installation af squid blev <filename>squid</filename> brugeren og
tilsvarende gruppe oprettet. Kataloget
<filename>/var/spool/squid</filename> er tomt men ejet af brugeren
squid. Selve databasestrukturen skal man en gang for alle sætte op -
hertil bruges parameteren <filename>cache_dir</filename>.
</para>

<screen>
<prompt>[root@sherwood root]#</prompt> <userinput>/usr/sbin/squid -z</userinput>
</screen>

<para>
Anvender man 16 og 256 som de sidste to parametre til <filename>cache_dir</filename>, skal
man ikke blive bange, når man initialiserer databasen. Der køres hårdt på
harddisken, og det tager måske flere minutter - databasen bliver stor!
</para>
</sect4>

<sect4 id="squid-bruger">
<title>Brugerens opsætning</title>

<indexterm><primary>Proxy klient</primary></indexterm>
<para>
For at man kan få squid til at virke sammen med lynx og wget, kan man
sætte følgende environment variable 
(her hedder vores proxy-server "proxy.herne.dk")
</para>

<programlisting>
% setenv http_proxy http://proxy.herne.dk:3128/
% setenv gopher_proxy http://proxy.herne.dk:3128/
% setenv ftp_proxy http://proxy.herne.dk:3128/ 
</programlisting>

<para>
I Netscape skal brugerne under
<filename>Edit->Preferences->Advanced->Proxies</filename> vælge
<filename>Manual proxy configuration</filename> og tryk på
<filename>View</filename>. Som det kan ses på det næste billede, skal
man skive navnet på proxy maskinen (her anvender vi
<filename>proxy.herne.dk</filename>), og port 3128 svarer til
parameteren "http_port" i <filename>squid.conf</filename>.
</para>

<figure id="proxy-fig" float="1">
<title>Proxy opsætning i Netscape</title>
<graphic fileref="proxy.&magic;"  scale="40"></graphic>
</figure>  



<para>
Squid er i dagligdagen et meget driftsikkert program og kan anbefales.
Vi skal dog lige huske at nævne, at hvis der ikke er blokeret for det
via en firewall, så kan brugeren af Netscape faktisk godt køre
forbi proxy cachen ved enten at udelade proxy-opsætningen eller 
at holde SHIFT nede, før der trykkes på et
link. Derfor skal firewallopsætningen være lavet, så
proxy-programmet godt kan hente data fra internettet, men at brugere
ikke kan - hvis man virkelig ønsker, at folk skal bruge
proxy-serveren.
</para>
</sect4>
</sect3>

<sect3 id="transparent-proxy">
<title>Transparent proxy med squid</title>

<indexterm><primary>transparent proxy</primary></indexterm>

<para>
Man kan lave noget transparent proxy med squid sammen med ipchains. 
Kernen skal være oversat med "Transparent proxying". Vi vil ikke
beskrive det her, men der findes en mini-HOWTO på
<ulink url="http://sunsite.dk/ldp/HOWTO/mini/TransparentProxy.html ">http://sunsite.dk/ldp/HOWTO/mini/TransparentProxy.html </ulink>.
</para>
</sect3>

<sect3 id="Masquerading-med-ipchains">
<title>Masquerading med ipchains (kerne 2.2)</title>

<indexterm><primary>Masquerading</primary></indexterm>

<para>
Masquerading er ikke proxying men en speciel form for NAT
(<emphasis>N</emphasis>etwork <emphasis>A</emphasis>ddress
<emphasis>T</emphasis>ranslation). Det giver delvis samme
funktionalitet som proxying, - at man kan få sit lokalnetværk på
internettet med kun een gyldig IP-adresse - men det giver ikke den
samme sikkerhed som proxying.  Linux-kernen understøtter masquerading
som en del af ipchains.
</para>

<para><emphasis>Bemærk at masquerading ikke er særlig sikkert. Der er
fundet flere sikkerhedshuller. Bl.a et som går ud på, at man kan
omskrive portnummeret på udp svarpakkerne til en masqueraded maskine,
og derved kan få adgang til selv at sende pakker til en host inde
bagved masqueraring.</emphasis> </para>

<para>
Med IP masquerading opnås, at mange forskellige maskiner kan komme på internet
med kun én IP-adresse - såkaldt "Source NAT" (SNAT). Man sætter en masquerading 
server op, og alle 
maskinerne bagved skal bruge den som default gateway. Masquerading serveren 
omskriver så alle pakkerne, der kommer forbi, til at have dens egen IP-adresse
som afsender. Den "husker" så hvilke pakker, der har været sendt ud, og bruger 
denne information til at genkende svaret, så den kan sørge for, at svaret 
kommer til den maskine, der sendte forespørgslen ud.
</para>

<para>
I sagens natur skal forwarding være slået til her, og der
<emphasis>er</emphasis> oprettet direkte forbindelse imellem den
lokale maskine og en maskine ude på internettet.  Fællestrækket ved proxy
og masquerading er, at man kan sætte mange maskiner på internettet ved
hjælp af kun én "ægte" ip-adresse. En fordel ved masquerading fremfor
proxying er, at med masquerading kan man alt - der er ting, man ikke
kan få igennem en proxy.  Men det er på bekostning af sikkerheden:
Masquerading giver ikke den samme beskyttelse som en proxy. Man kan
dog beskytte sig en del ved at sætte firewallregler op i kernen. Se
afsnittet om pakkefiltrering tidligere i artiklen.
</para>

<para>
Vi skal nu til at sætte forwardkæden op - den kan ud over de tre 
almindelige policies også sættes til MASQ.
</para>

<para>
Den simple og hurtige måde at sætte IP masquerading op på er:
</para>

<screen>
<prompt>[root@myhost /root]#</prompt> <userinput>ipchains -A forward -i ppp0 -j MASQ</userinput>
<prompt>[root@myhost /root]#</prompt> <userinput>ipchains -A forward -s 0.0.0.0/0 -d 0.0.0.0/0 -l -j REJECT</userinput>
<prompt>[root@myhost /root]#</prompt> <userinput>echo 1 > /proc/sys/net/ipv4/ip_forward</userinput>
</screen>

<para>
hvor ppp0 er det interface, der peger ud imod verden, imod internettet, imod 
det net, man vil give sine maskiner adgang til via masquerading.
</para>

<para>
Det kan også give mening at sætte timeouts for masquerading forbindelserne:
</para>

<screen>
<prompt>[root@myhost /root]#</prompt> <userinput>ipchains -M -S 7200 10 160</userinput>
</screen>

<para>
Det første tal er timeout for en tcp forbindelse, det næste er hvor
længe en tcp forbindelse skal kunne eksistere efter modtagelsen af en
FIN pakke, og det sidste er timeout for UDP. Timeout tiderne er i
sekunder. Default timeout er 15 minutter, og det kan være lidt kort
for en tcp session.
</para>

<para>
Nu sættes de andre maskiner i lokalnetværket til at bruge myhost som
default gateway, og voila! Man kan komme på internettet fra de andre
maskiner. 
</para>

<sect4 id="ipchains-moduler">
<title>Moduler til ipchains</title>

<para>
Og dog. Http mm virker nu, men der er et par protokoller, der kræver særlige 
hensyn. Det er bla. ftp, realaudio, irc og forskellige spil.
</para>

<para>
For at kunne bruge ftp, real audio, irc, spille quake mm via
masquerading, er vi nødt til gøre det lidt mere indviklet. Der findes
moduler til ipchains, der kan håndtere en del forskellige
applikationer: ip_masq_ftp, ip_masq_raudio, ip_masq_irc, ip_masq_quake
etc. For at kunne bruge disse moduler, skal de være oversat med, da
man lavede kernen. Det er inde under networking options, hvor man skal
slå "IP masquerading special module support" og "ipportfw masq
support" til. I kerne 2.2.12 er det nødvendigt at slå "prompt for
development and/or incomplete code/drivers" til for at få lov til at
vælge ipportfw.
</para>

<para>
Modulerne indlæses nu med:

<screen>
<prompt>[root@myhost /root]#</prompt> <userinput>/sbin/modprobe ip_masq_ftp</userinput>
<prompt>[root@myhost /root]#</prompt> <userinput>/sbin/modprobe ip_masq_raudio</userinput>
</screen>
</para>

<para>
Nu virker ftp og realaudio fra de andre maskiner. Gør det samme med
de andre moduler, der skal bruges. Der findes også et værktøj, der hedder 
IPMASQADM, man kan bruge. 
Der findes en slags beskrivelse af emnet i IP-Masquerade-HOWTO'en på
<ulink url="http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO-6.html#ss6.8">http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO-6.html#ss6.8</ulink>
</para>
</sect4>

<sect4 id="opsaetning-andre-maskiner">
<title>Opsætning af de andre maskiner i nettet</title>
<para>
Default gateway sættes med kommandoen <command>route</command>:
</para>

<programlisting>
route add default gw myhost
</programlisting>

<para>
Hvis det skal være permanent, er der lidt forskel på distributionerne.
Nogle har et fint konfigurationsværktøj, det vil vi ikke komme ind på
her. I SuSE er det en <filename>/etc/route.conf</filename>, man kan
sætte det ind i.  I debian er det direkte i
<filename>/etc/init.d/</filename> i et netværks startup script.  I
RedHat er det filen <filename>/etc/sysconfig/network</filename>, man
sætter sin default gateway ind i.
</para>

<para>
For yderligere information om IP masquerading kan man læse
IP-Masquerade-HOWTO'en
<ulink url="http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO">http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO</ulink> .
HOWTO'en indeholder også referencer til en række gode ressourcer.
</para>
</sect4>
</sect3>

<sect3 id="NAT">
<title>Network Address Translation med iptables (Netfilter) i kerne 2.4</title>

<indexterm><primary>NAT</primary></indexterm>
<para>
I kerne 2.4 er ipchains erstattet af iptables, som er en del af
netfilter. Ipchains understøtter en bestemt form for NAT kaldet
ip-masquerading. Iptables kan meget mere indenfor NAT. Ud over NAT
bruges iptables også til pakkefiltrering, som er beskrevet tidligere i
kapitlet.  For at kunne afbilde alle svarene på NAT pakkerne rigtigt,
benytter iptable sig af connection tracking - den holder styr på de
oprettede forbindelser.  Dette kan man checke på i sit pakkefilter -
en meget spændende ny feature.  Se afsnittet om
"state" under Iptables (Netfilter) - kerne 2.4.
<!-- UPS -->
</para>

<sect4 id="source-NAT">
<title>Source NAT</title>
<indexterm><primary>Source NAT</primary></indexterm>

<para>
NAT går ud på at man kan afbilde IP-adresser. F.eks. kan man afbilde en 
række lokale IP-adresser til en begrænset pulje af rigtige 
internet-IP-adresser. IP masquerading er et særtilfælde af dette, hvor 
man afbilder alle sine lokale IP-adresser til kun een gyldig internet-IP-adresse.
I ovenstående tilfælde er det source adressen, man manipulerer - Source NAT.
</para>
</sect4>

<sect4 id="Desination-NAT">
<title>Destination NAT</title>
<para>
Man kan også afbilde destinationsadressen - Destination NAT - så folks 
forespørgsler f.eks. bliver redirigeret hen til den lokale webserver eller 
til en server pool. 
</para>

<para>
For TCP og UDP kan man lave portmapping med iptables, hvor man skifter
destinationsporten ud. F.eks. kan en klient oprette en forbindelse til
en web-server på port 80, og NAT-serveren kan afbilde pakkerne til sin
egen port 3128, hvor der kører en squid. Dette kaldes redirect,
men er også en form for destination NAT. Resultatet er transparent proxying.
</para>
</sect4>

<sect4 id="hvordan-NAT">
<title>Hvordan</title>
<para>
For at bruge NAT skal modulet <filename>iptables_nat</filename> være indlæst.
NAT med iptables laves med "-t nat" option til iptables.
<emphasis>-t</emphasis> fortæller iptables, at det er NAT-tabellen den skal bruge.
Til pakkefiltrering bruges filter-tabellen.</para>

<para><emphasis>Kæder:</emphasis> 
NAT har tre kæder, hvor man kan sætte regler op for pakkerne:</para>
<itemizedlist mark="bullet">
  <listitem><para>PREROUTING - Destination NAT</para></listitem>
  <listitem><para>POSTROUTING - Source NAT</para></listitem>
  <listitem><para>OUTPUT - Destination NAT fra lokale porte</para></listitem>
</itemizedlist>

<para>
<emphasis>Targets:</emphasis> 
</para>
<itemizedlist mark="bullet">
  <listitem><para>SNAT -source NAT</para></listitem>
  <listitem><para>DNAT - destination NAT</para></listitem>
  <listitem><para>MASQUERADING - Masquerading på dial-up interface</para></listitem>
  <listitem><para>REDIRECT - destination NAT til lokal port</para></listitem>
</itemizedlist>

<para>
Man kan angive <filename>-p protokol</filename>, og for tcp og udp kan
man også angive portnummer eller port range. <filename>--to</filename>
angiver den/de ip-adresse(r) der skal NAT'es til.
</para>
</sect4>

<sect4 id="eksempel-masq">
<title>Eksempler</title>
<para>Opsætning af IP masquerading med iptables:</para>

<para>Med fast ip-adresse:</para>

<programlisting>
# iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to 1.2.3.4
</programlisting>

<para>Med dynamisk ip-adresse:</para>
<programlisting>
# iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE
</programlisting>

<para>
MASQUERADING target er specielt til masquerading med en dynamisk
tildelt ip-adresse, som en dial-up forbindelse har. Den finder 
selv ud af det, når ip-adressen på ppp0 skifter. 
</para>
<para>Lav destination NAT til ip 1.2.3.4, 1.2.3.5 eller 1.2.3.6</para>
<programlisting>
# iptables -t nat -A PREROUTING -i eth1 -j DNAT --to 1.2.3.4-1.2.3.6
</programlisting>

<para>Lav destinations NAT fra port 80 til den lokale port 3128, hvor squid kører</para>
<programlisting>
# iptables -t nat -A PREROUTING -i eth1 -p tcp --dport 80 \ 
-j REDIRECT --to-port 3128
</programlisting>

<para>
Eksemplerne er taget mere eller mindre direkte fra Linux 2.4 NAT HOWTO, og
er blot ment som illustration af, hvad man kan med iptables NAT.
</para>

<para>
For nærmere beskrivelse, se Linux 2.4 NAT HOWTO på <ulink
url="http://netfilter.samba.org/unreliable-guides/packet-filtering-HOWTO/index.html">http://netfilter.samba.org/unreliable-guides/packet-filtering-HOWTO/index.html</ulink>
Se desuden man-siden for iptables.
</para>

</sect4>
</sect3>
</sect2>
</sect1>

<sect1 id="firewall-test">
<title>Afprøvning af en firewall</title>
 <indexterm>
  <primary>firewall</primary>
  <secondary>afprøvning</secondary>
 </indexterm>
 <indexterm>
  <primary>afprøvning af en firewall</primary>
 </indexterm>
<indexterm><primary>Firewall</primary><secondary>test</secondary></indexterm>
<indexterm><primary>Test af firewall</primary></indexterm>
<para>
Når man har sat sin firewall op, skal man altid undersøge, 
at den virker som forventet.</para>

<itemizedlist mark="bullet">

<listitem><para>
  <emphasis>Funktionalitet: </emphasis>Test at de services, der skal
  kunne benyttes, virker. Både indefra og udefra. Der er dog stor
  chance for, at brugerne nok skal fortælle meget hurtigt, hvis det
  ikke er tilfældet.
</para></listitem>

<listitem><para>
  <emphasis>Sikkerhed: </emphasis>Test at firewallen rent faktisk
  lukker for de ting, den burde. Prøv at bruge services, der skulle
  være lukket for, ved at prøve at oprette forbindelser
  udefra. Portscan firewallen for at se, hvad folk kan få at vide om
  den udefra. Der findes også mere omfattende tests. Man kan forsøge
  sig med diverse cracker-programmer, eller man kan betale andre for
  at teste firewallen.
</para></listitem>

<listitem><para>
  <emphasis>Vedligeholdelse: </emphasis> Hold altid softwaren på
  firewallen opdateret med de nyeste sikkerhedsrettelser. Læs altid
  logfiler.
</para></listitem>
</itemizedlist>

</sect1>

<sect1 id="epilog4">
<title>Epilog</title>

<para>
Firewallløsninger kan ikke beskrives fuldstændigt her. Vi
har taget en del af Linux-mulighederne, men der er meget, vi ikke har dækket:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
    Trusted Information Systems Firewall Toolkit (FWTK): Se 
    <ulink url="http://www.fwtk.org/fwtk/">http://www.fwtk.org/fwtk/</ulink>
  </para></listitem>
  <listitem><para>
    T.REX: Open Source firewall: Se <ulink url="http://www.opensourcefirewall.com/">http://www.opensourcefirewall.com/</ulink> 
  </para></listitem>
  <listitem><para>
    En side med mange links om firewalle: Se <ulink url="http://www.linux-firewall-tools.com/linux/">http://www.linux-firewall-tools.com/linux/</ulink>
  </para></listitem>
  <listitem><para>
    Firewall-1 er en fuld kommerciel firewall: 
    Se <ulink url="http://www.checkpoint.com/products/firewall-1/">http://www.checkpoint.com/products/firewall-1/</ulink>
  </para></listitem>
  <listitem><para>
    Socks5 er en proxy server, der anvendes mange steder. 
    Se <ulink url="http://www.socks.nec.com">http://www.socks.nec.com</ulink>
  </para></listitem>
  <listitem><para>
    Mange gode netværkssikkerhedsværktøjer og ressourcer findes på
    <ulink url="http://www.freefire.org">http://www.freefire.org</ulink>
  </para></listitem>
  <listitem><para>
    En opskrift på test af firewall kan læses på <ulink url="http://linuxtoday.com/news_story.php3?ltsn=2001-05-04-015-20-SC">http://linuxtoday.com/news_story.php3?ltsn=2001-05-04-015-20-SC</ulink>.
  </para></listitem>
</itemizedlist>
</sect1>
</chapter>
