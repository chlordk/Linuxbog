<!-- $Id$ -->
<chapter id="Linux-firewalling">
 <title>Firewall på Linux</title>

 <sect1 id="hvad-er-firewall">
  <title>Hvad er en firewall?</title>

  <indexterm>
   <primary>dørvogter</primary>
  </indexterm>

  <indexterm>
   <primary>firewall</primary>
  </indexterm>

<para>
At forbinde sin virksomheds eller sit kollegiums lokale
computernetværk direkte til internettet kan være en risikabel
ting at gøre, for man åbner jo for trafik begge veje, altså også
for trafik ind på det lokale netværk. Hvis man uden videre
forbinder sit lokale netværk til internettet, kan man blive 
udsat for, at andre trænger ind på firmaets eller kollegiets
interne computere, læser og ændrer følsomme data, får servere til
at gå i stå osv.  Ønsker man at give adgang for beboere og
medarbejdere til e-post og den store mængde information, man kan
finde på internettet uden at åbne for trafik den anden vej,
kræver det en firewall.
</para>

<para>
Firewall er det engelske ord for en brandvæg eller en brandmur. I
bygninger bruges en brandmur til at dele en bygning i sektioner.
Hvis der opstår en brand i den ene sektion, kan brandmuren
forhindre at branden breder sig (hurtigt) til andre sektioner.
</para>

<para>
En computer som firewall bruges til på lignende vis at opdele et
netværk i sektioner, typisk i det, der er uden for lokalnetværket,
og det, som er indenfor. Firewallen er først og fremmest et
pakkefilter, som forhindrer pakker af bestemte typer i at slippe
igennem fra det ene til det andet netværk. Linux firewallen kan
imidlertid meget mere end det, og i denne sammenhæng er det
vigtigt, at den kan lade trafik, som har oprindelse på
lokalnettet, gå til nettet udenfor, det offentlige net, og vel at
mærke tillade svarpakkerne at passere på tilbagevejen.
</para>

<para>
Man kan opnå en fremragende sikkerhed med en Linux box som
firewall, men det er imidlertid bedst at kombinere firewallen med de
forholdsregler for sikker opsætning af en computer, som er omtalt
tidligere i bogen.
</para>

<para>
En firewall kan selvfølgelig også bruges til at adskille to
eller flere lokalnetværk fra hinanden.
</para>

<para>
Der findes forskellige måder at opbygge en firewall, næste afsnit
lister de vigtigste.
</para>

<sect2 id="sikkerhed-firewall-typer">
<title>Firewall typer</title>

<itemizedlist mark="bullet">
  <listitem><para>Pakkefiltrering</para></listitem>
  <listitem><para>Proxy, en applikation som optræder som
     mellemmand</para></listitem>
  <listitem><para>Stateful Multi-Layer Inspection, SMLI, en
     kombination af pakkefilter, tilstands-betingelser og
     indholds-filtrering</para></listitem>
</itemizedlist>
<indexterm><primary>SMLI</primary></indexterm>

<para>
Et pakkefilter ser på pakkens IP-adresse, den protokol-type, som
den hører til, og eventuelt flere ting.
</para>

<para>
En proxy, som egentlig blot betyder en stedfortræder, var
oprindeligt et program på en gateway, som man inde på lokalnettet
henvendte sig til, og så kunne dette program sende forespørgsler
videre, som om de kom fra proxy-maskinen. Det er en meget sikker,
men også ret besværlig måde at skille lokalnet fra offentlige
net, og det kræver en proxy for hver protokol, man ønsker at åbne
for, http, ftp, ssh, og hvad det nu kunne være.
</para>

<para>
En mere moderne proxy kan fungere uden at man henvender sig
specielt til den. Det kaldes en transparent proxy. Den lytter
efter al trafik og videresender de pakker, som er tilladte,
ligesom et pakkefilter, men i modsætning til pakkefilteret kan
proxyen altså sende dem videre, som om de kom fra den selv, og
desuden inspicere dem på indholdsniveau eller applikationslag.
</para>

<para>
I forbindelse med firewalls taler man ofte om netværkslag, fordi
det gør det muligt at beskrive mere præcist, hvad der sker.
Den forsimplede Department of Defence-model, DoD 4-lags modellen,
er en god hjælp til de fleste formål: 
</para>



<sect3 id="sikkerhed-layer">
<title>Netværks-lag</title>

<programlisting>

                           Netværks-lag

                        +---------------------+
                        | Applikations-laget  |
                        +---------------------+
                        | Transport eller     |
                        | validering/flow     |
                        +---------------------+
                        | Globale adresser    |
                        +---------------------+
                        | Ethernet, backbone  |
                        | tranceiver logik    |
                        +---------------------+

</programlisting>

<para>
Nogle vil måske foretrække at få en forklaring på, hvorfor man i
det hele taget har lag, og så er det bedst at tage forklaringerne
fra ledningerne, det fysiske netværk og opefter.
</para>

<itemizedlist mark="bullet" id="sikkerhed-network-layer">

<listitem><para>
Fysisk link-lag, det vil sige ethernetkort og ledninger (der er
egentlig også et par abstraktionslag her); ofte kaldes det for
det nederste lag; det skyldes måske, at ledningerne som regel
liger på gulvet og føres ud gennem kælderen - hvis man stadig
brugte telefonstolper, ville man nok kalde det for det øverste
lag;-))
</para></listitem>

<listitem><para>
netværkslaget, her finder man IP-numre, ping programmet og ICMP;
dette lag har ansvaret for at en pakke kan komme fra Jylland til
Australien, det vil sige ansvaret for at forbinde forskellige net
med hinanden, herunder også fragmentering af pakker, som er for
store til det underliggende fysiske net;
</para></listitem>

<listitem><para>
transportlaget, TCP, som er forskelligt fra IP-laget derved at
det sørger for at data er valide, det vil sige at der oprettes
handshake; nyere TCP implementationer kan også håndtere
flow-kontrol: parametre på fysisk niveau kan styres indirekte af
TCP oplysninger om, hvor meget modtageren kan klare, førend man
får data galt i halsen; man kunne også kalde TCP laget for
validerings- og flow control lag;
</para></listitem>

<listitem><para>
applikationslaget, higher level, for eksempel FTP og HTTP.
</para></listitem>
</itemizedlist>

</sect3>

<sect3 id="sikkerhed-proxy-applikationslag">
<title>Filtrering på applikationslag</title>

<para>
En proxy kan inspicere på applikationslaget. Den kan derfor
kaldes for et censur-program, netværks-barnepige eller spion.
</para>

<para>
Stateful Multi Layer Inspection (SMLI) er den mest avancerede
form for firewall. Det er faktisk muligt at lave den slags
filtrering med Linux-kernen. Udvalgte pakker kan med iptables
kommandoen sendes til et program, som inspicerer dem og som kan
afgøre, om de skal sendes videre eller ej. En forudsætning for
det er, at Linux' indbyggede pakkefilter har mulighed for at
holde styr på det, man kalder en forbindelse (connection), det
vil sige en session, hvor man indleder en konversation med en
server, udveksler data og ender med at sige "nu er jeg færdig".
</para>

<para>
TCP benytter sådanne connection-meddelelser. Linux-kernen kan
holde styr på status for en forbindelse. Derfor kaldes Linux
Netfilter for et State Packet Filter, SPF.
</para>

<para>
Derved kan man bygge en SMLI firewall baseret på Linux Netfilter.
Endvidere kan en user-applikation inkorporeres i kernen (for at
effektivisere den), så man kan skam bygge tiptop professionelle
SMLI-firewalls på basis af Linux.
</para>
</sect3>
</sect2>

<sect2 id="sikkerhed-grundlaeggende-pakkefilter">
<title>Grundlæggende pakkefiltrering eller politiske
overvejelser</title>

<para>
Opsætningen af en firewall kan enten bygge på den grundlæggende
antagelse, at alt, hvad der kommer udefra, er mistænkeligt og bør
stoppes - eller, omvendt, at vi tror på det gode i netværket og
kun spærrer af for de ting, som notorisk er nemme at misbruge.
</para>


<sect3 id="sikkerhed-luk-alt">
<title>Luk alt</title>
<para>
Hvis man lukker for alt, er det selvfølgelig overflødigt med en
netforbindelse ud af huset. Men det er nu alligevel den bedste
måde at sikre systemet på (;-) For at få lidt glæde af
netforbindelsen kan man så åbne for web-protokollen HTTP. En
TCP/IP-pakke har ud over IP-nummeret et port-nummer med sig, som
blot er et tal (16 bit) i TCP-pakkens header. På modtagermaskinen
ser TCP-softwaren i kernen efter, hvilket portnummer der er, og
om der er noget program, som har meldt sig som interesseret i
pakker til dette portnummer. Det kalder man, at et program har
registreret på den pågældende port. Et program, som lytter efter
indkommende forbindelser, kaldes en server (eller somme tider et
serverprogram.)
</para>

<para>
HTTP-protokollen er karakteristisk ved, at serveren som regel
lytter på port 80. Vi kan derfor lave en firewall regel, som
siger, at al trafik, som er til eller fra port 80 på en computer
<emphasis>udenfor lokalnetværket</emphasis> skal have lov at
passere. Det er en løsning, men en fattig løsning, idet man
kommer til at mangle Domain Name Service, DNS, og endvidere
kommer til at lide under, at nogle web-sites forventer, at man
kan bruge FTP til download, eller ligefrem flytter brugerens
forespørgsel til en server på et andet portnummer.
</para>

<para>
En netværksforbindelse mellem to applikationer defineres af
IP-adresse plus portnummer. En sådan identificeret forbindelse
kaldes en socket.
</para>

<programlisting>

SOCKET-illustration

Afsender (browser)                      Modtager (http-server)

IP-adresse  + portnummer                IP-adresse   + portnummer

201.2.3.4     51001          &lt;----->    193.88.44.22   80

En anden afsender (wget)                Modtager (samme http-server)

201.2.3.4     47011          &lt;----->    193.88.44.22   80


En socket definerer en forbindelse,
typisk fra applikation til applikation.

</programlisting>

</sect3>

<sect3 id="sikkerhed-aaben-alt"><title>Lad alt være åbent -
undtagen de farlige ting</title>

<para>
For at undgå problemer kunne man så beslutte, at man lader det
meste stå åbent og - selvfølgelig - lukker for de farlige
services som telnet, remote shell og så videre.
</para>

<para>
Et eksempel kunne være, at man lokalt gerne må bruge telnet, men
at det er sket at folk udefra har forsøgt at få forbindelse via
telnet. Derfor kan det se ud som en løsning at lukke for port 23.
Den løsning er dog heller ikke særlig god. Intrusion på en
computer kan sagtens benytte sig af andre portnumre (og andre
protokoller) og ved snedige, ulovlige datapakker forsøge at sætte
en kæp i hjulet på de programmer, der lytter. Hvis vi var
flittige og lappede alle hullerne i serverprogrammerne og i
øvrigt overvågede maskinen døgnet rundt, så ville denne løsning
være god nok, men den er dyr i arbejdstimer.
</para>
</sect3>
</sect2>

<sect2>
<title>Den lukkede model bør vælges som udgangspunkt</title>

<para>
Hverken den åbne eller helt lukkede model er særligt nyttige. Der
skal mere til. Som udgangspunkt er den lukkede model imidlertid
den sikreste, men den skal kombineres med connection-tracking.
</para>

<para>
Forhåbentlig fremgår det af ovenstående, at en firewall egentlig
er et ret kompliceret stykke software. Man skal nu ikke lade sig
skræmme væk af den grund. Det er i grunden ret nemt at skrive de
nødvendige kommandoer og så blot kontrollere en gang i mellem, at
det kører som det skal.
</para>

<para>
Man bruger <command> iptables </command> kommandoen til at
opsætte firewall reglerne i kernen. Men man behøver ikke at kunne
<command> iptables </command> kommando syntaksen, idet SuSE,
RedHat og andre lavet GUI-administration af firewall reglerne. Så
hvis man holder sig til de gode, kendte distributioner eller på
anden måde sørger for, at de nødvendige ting er til stede, så kan
man blot krydse af, hvilke servere andre udefra skal have lov at
bruge, om nogen.  Er man af gør det selv typen, følger her en
opskrift på, hvordan man kan lave en lille komplet
firewall-opsætning.
</para>


<sect3 id="sikkerhed-really-quick-guide">
<title>Lynkursus</title>

<para>
Senere bliver kommandoerne til en firewall beskrevet og forklaret
grundigt, men for den utålmodige, som bare vil i gang, kan vi
lige vise "Rusty's Really Quick Guide To Packet Filtering" fra
packet-filtering-HOWTO. Vi antager, at maskinen har en
modemforbindelse til en ISP og ikke ønsker, at man skal kunne
tilgå maskinen udefra:
</para>

<programlisting>

  ## Insert connection-tracking modules (not needed if built into kernel).
  # insmod ip_conntrack
  # insmod ip_conntrack_ftp

  ## Create chain which blocks new connections, except if coming from inside.
  # iptables -N block
  # iptables -A block -m state --state ESTABLISHED,RELATED -j ACCEPT
  # iptables -A block -m state --state NEW -i ! ppp0 -j ACCEPT
  # iptables -A block -j DROP

  ## Jump to that chain from INPUT and FORWARD chains.
  # iptables -A INPUT -j block
  # iptables -A FORWARD -j block

</programlisting>

<para>
De første kommandoer er nødvendige med de fleste
distributionskerner. Det er ikke spor svært at lave sin egen
superkerne, hvis man interesserer sig for, hvad en kerne er, og
man har lært noget om, hvordan et operativsystem fungerer. Har
man en kerne hvor alt er kompileret ind i kernen, vil systemet
være en anelse hurtigere<footnote><para>På min gamle 75 Mhz
maskine kunne jeg tydeligt mærke forskel!</para></footnote>.
</para>

<para>
<command>iptables -N block</command> laver en kæde (en skuffe
eller hylde) for et regelsæt. Regelsættene kaldes chains, fordi
man bruger reglerne i den rækkefølge, de er sat ind i kæden.
Kæden her hedder "block", blokér.
</para>

<para>
<command> iptables -A block -m state --state ESTABLISHED,RELATED
-j ACCEPT</command>
</para>

<para>
<command>-A block</command> indsætter en regel i block-kæden, som
siger, at man skal bruge tilstands-modulet, <command> -m state
</command>, og undersøge, om pakken tilhører en forbindelse
(connection), som allerede er startet, eller som er i slægt med en
connection <command>--state ESTABLISHED,RELATED</command>, hvis
det er tilfældet, skal pakken accepteres, d.v.s. regelfortolkeren
jumper (-j) hopper til feltet for videresendelse af pakker,
"ACCEPT".
</para>

<para>
Næste linje siger, at alle pakker, som <emphasis>ikke</emphasis>
kommer udefra (i dette tilfælde fra et modem som bruger
Point-to-Point-Protokollen, PPP), skal have lov at passere.
</para>

<para>
Alt andet smides simpelt hen væk! DROP!
</para>

<para>
Og de sidste par linjer bevirker, som kommentaren siger, at både
pakker, som er INPUT og pakker og FORWARD pakker kommer igennem
den regelkæde, som vi har dannet. Dette er, som nævnt, et
eksempel for den utålmodige, men for den tålmodige er der en
nærmere forklaring af kommandoen og mulighederne med netfilter
i <xref linkend="sikkerhed-iptables-cmd"/>.
</para>


<!-- dax 2003-10-19 hertil, næste paragraffer stort set uændrede /-->


<para>
Det er vigtigt at forstå, at en firewall ikke er spor sikker, hvis den
er sat forkert op. Når firewallen er sat op, bør man grundigt teste,
at den nu også gør, som man forventer. En vigtig del af sikkerheden
omkring en firewall er desuden, at man registrerer og overvåger den trafik,
der passerer igennem den. Hvis man glemmer at holde øje med de
log-filer, firewallen genererer, er ens sikkerhed reelt væk (Se også
<xref linkend="filtjek"/>). Man kan så risikere, at man ikke opdager,
at der har været indbrud. En firewall er aldrig helt sikker, og man
bør kun sætte en firewall op, hvis man har i sinde at vedligeholde
den.
</para>

<para>
En forkert opsat firewall eller en firewall, ingen holder øje med,
kan være værre end ingen firewall! Tilstedeværelsen af en firewall
giver let en falsk fornemmelse af tryghed, så man ikke er omhyggelig
nok med at beskytte hver enkelt computer. Det er også meget vigtigt,
at man holder sig ajour med nyheder om fejl i den
software, der anvendes på firewallen 
(Se <xref linkend="sikkerhedsreferencer"/>).
</para>

<para>
Selvom man har sat en firewall op for at beskytte et netværk imod
folk på internettet, bør man stadig være omhyggelig med sikkerheden i det
lokale netværk. For det første kan det være, at nogen bryder igennem
ens firewall, og dermed er der kun lokalnetværkets sikkerhed tilbage. For det
andet beskytter en firewall ikke imod internt misbrug af ens netværk. 
I en virksomhed eller på et kollegium eller lignende kan man ikke
altid stole på de lokale brugere. Opgørelser fra IBM peger på, at
der ca. er ligeså mange interne netværksindbrud som eksterne.
</para>

<para>
Et andet problem inden for firewallen er lokale modems. Hvis en
bruger har et modem, hvormed han kobler sig direkte til sin
hjemmearbejdsplads, der ikke er sikret, så er der via denne
hjemmeopkobling fri bane til virksomhedens net. Der er mange
variationer på dette sikkerhedshul, for eksempel også at nogen
medbringer en transportabel maskine og sætter den på kollegiets
eller virksomhedens net. På Linux/GNU/BSD platforme sikrer man
den enkelte maskine bedst ved at den er firewall for sig selv.
</para>

<para>
Så det er vigtigt at bemærke, at en firewall ikke er en universalløsning på
sikkerhed, som mange tror i dag. Den er god at have, hvis
man er indstillet på at gøre det ordentligt. Men den er ikke en
erstatning for alle de andre sikkerhedsforanstaltninger på et netværk.
</para>

<para>
Man er aldrig helt sikker, selv med en firewall ...
</para>

<figure id="uf000784-fig" float="1">
<title>User Friendly</title>
<graphic fileref="uf000784.&magic;"  scale="40"></graphic>
</figure>
</sect3>
</sect2>
</sect1>

<sect1 id="firewall-links">

<title>Links</title>
<indexterm><primary>Links på nettet</primary></indexterm>
<para>
I dette kapitel henvises der til en række HOWTO's og andre dokumenter rundt 
om i teksten. Her er en hurtig oversigt:
</para>

<para>
HOWTO's:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
    Linux IPCHAINS-HOWTO <ulink url="http://sunsite.dk/ldp/HOWTO/IPCHAINS-HOWTO.html">http://sunsite.dk/ldp/HOWTO/IPCHAINS-HOWTO.html</ulink>
  </para></listitem> 
  <listitem><para>
    Firewall and Proxy Server HOWTO <ulink url="http://sunsite.dk/ldp/HOWTO/Firewall-HOWTO.html">http://sunsite.dk/ldp/HOWTO/Firewall-HOWTO.html</ulink>
  </para></listitem>
  <listitem><para>
    Transparent Proxy with Squid mini-HOWTO <ulink url="http://sunsite.dk/ldp/HOWTO/mini/TransparentProxy.html">http://sunsite.dk/ldp/HOWTO/mini/TransparentProxy.html</ulink>
  </para></listitem>
  <listitem><para> Linux 2.4 Packet Filtering HOWTO:
<ulink url="http://www.netfilter.org/unreliable-guides/packet-filtering-HOWTO/packet-filtering-HOWTO.linuxdoc.html">
http://www.netfilter.org/unreliable-guides/packet-filtering-HOWTO/packet-filtering-HOWTO.linuxdoc.html</ulink>
  </para></listitem>
  <listitem><para>
    Linux 2.4 NAT HOWTO <ulink url="http://netfilter.samba.org/unreliable-guides/NAT-HOWTO/index.html">http://netfilter.samba.org/unreliable-guides/NAT-HOWTO/index.html</ulink>
  </para></listitem>
  <listitem><para>
    (Linux IP Masquerade HOWTO <ulink url="http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO.html">http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO.html</ulink>
  </para></listitem>
</itemizedlist>

<para>
Andet:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
    Sikkerhed på Linux <ulink url="http://www.sslug.dk/artikler/Linux_sikkerhed/">http://www.sslug.dk/artikler/Linux_sikkerhed/</ulink>
  </para></listitem>
  <listitem><para>
    Linux - Friheden til at vælge <ulink url="http://&linuxbogurl;/bog/">&linuxbogurl;/bog/</ulink>
  </para></listitem>
  <listitem><para>
    IPChains i Linux 2.2 <ulink url="http://www.sslug.dk/sikkerhed/ipchains.html">http://www.sslug.dk/sikkerhed/ipchains.html</ulink>
  </para></listitem>
  <listitem><para>
    Netfilter i Linux 2.4 <ulink url="http://www.sslug.dk/sikkerhed/netfilter.html">http://www.sslug.dk/sikkerhed/netfilter.html</ulink>
  </para></listitem>
  <listitem><para>
    The Netfilter Project HomePage <ulink url="http://netfilter.samba.org/">http://netfilter.samba.org/</ulink>
  </para></listitem>
  <listitem><para>
    Squid Web Proxy Cache <ulink url="http://www.squid-cache.org/">http://www.squid-cache.org/</ulink>
  </para></listitem>
</itemizedlist>
</sect1>



<sect1 id="firewall-funktion">
<title>Firewallens funktioner</title>

<indexterm><primary>firewall</primary>
           <secondary>grundlæggende funktioner</secondary>
</indexterm>


<para>
Linux firewallen vil på et mindre lokalnet som regel have flere
funktioner. Den skal kontrollere, hvilken trafik, der kan
tillades, den skal sikre os mod angreb, og endelig kan den
overvåge trafikmængder og for eksempel fortælle os, om et eller
andet program begynder at udspy pakker på internettet. Det sker
somme tider. Og måske er man bare almindeligt nysgerrig og ønsker
at se, hvad der sker på maskinen. Endvidere vil vi også gerne
kunne servicere maskiner, som ikke har et offentligt IP-nummer.
</para>

<itemizedlist mark="bullet" id="sikkerhed-fw-funx">
<listitem><para>Kontrol af trafik-typer</para></listitem>
<listitem><para>Sikring mod indtrængen</para></listitem>
<listitem><para>Overvågning, logning</para></listitem>
<listitem><para>Servicering af maskiner uden offentligt IP-nummer</para></listitem>
</itemizedlist>

<sect2 id="firewall-pakkefiltrering">
<title>Kontrol af trafik-typer.</title>
<indexterm><primary>pakkefiltering</primary></indexterm>
<indexterm><primary>kontrol af trafik</primary></indexterm>

<para>
Data sendes igennem et netværk i form af datapakker. På
internettet bruges IP-pakker. En IP-pakke består af en header med
information om, hvor den skal hen, hvor den kommer fra, hvad den
er for en slags samt eventuelt nogle data.  Ved pakkefiltrering
kigger man på informationen i headeren og bestemmer, hvad der
skal ske med pakken: Om den skal afvises eller slippes igennem.
</para>

<para>
Ideen er så, at en firewall stopper alle de pakker, som man ikke
har "inviteret". Kører man f. eks. en web-server, slipper man kun
web-pakker igennem. En privat maskine med internetadgang kan godt
stoppe alle udefra kommende forespørgsler samtidigt med, at alle
de netværks-sessions, der startes af brugeren får lov til at køre
som normalt, d.v.s. at <emphasis>svar-pakker</emphasis> fra det
eksterne net får lov at komme igennem.
</para>

<para>
Man bør blokere:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
      Pakker fra services, der ikke skal bruges. Hvis en server f.eks. ikke
      tilbyder FTP, er det klogt at afvise alle forsøg på at
      etablere en FTP-forbindelse med det samme.
  </para></listitem>
  <listitem><para>
      Pakker med mistænkelige bits sat som IP source routing (kan bruges til
      spoofing, hvilket betyder at udgive pakkerne for at komme fra
      et andet sted, end de egentlig kommer fra).
  </para></listitem>
  <listitem><para>
      Pakker, der er til en lokal host, som ikke burde modtage 
      pakker udefra. Det vil sige pakker, som er direkte addreseret til en
      maskine, som ikke har lov til at snakke med fremmede maskiner på
      internettet.
  </para></listitem>
</itemizedlist>

 <indexterm>
  <primary>netværkssikkerhed</primary>
  <secondary>spoofing</secondary>
 </indexterm>

<para>
Hvis for eksempel Boligforeningen Xyzzy-42 ikke ønsker, at der
skal være adgang til FTP-serveren fra maskiner udefra, men gerne
vil se, hvor mange, der prøver at komme i forbindelse med
serveren, så kan nedenstående kommando bruges.
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -A INPUT -p tcp --destination-port 21 -j DROP</userinput>
</screen>

<para>
For mere information om IP, TCP og netværk generelt se f.eks.
"Introduktion til Netværk" af Geir Steen-Olsen & Arne Stalheim
(IDG-bog til 69 kr.) eller "Linux - Friheden til til
systemadministration" på <ulink
url="http://&linuxbogurl;/">&linuxbogurl;</ulink>.  Den grundige
gennemgang af IPtables begynder <xref linkend="sikkerhed-netfilter"/>
</para>
</sect2>


<sect2 id="sikkerhed-indtraengen">
<title>Sikring mod indtrængen</title>
<para>
Firewallens vigtigste opgave er selvfølgelig at hindre
uvedkommende at trænge ind på systemet. Det bedste er at spærre
for alt og åbne for en positivliste, som kan bestå af de tilladte
brugeres IP-numre. Hvis man derimod vil tillade bruger XYZ at
komme ind gennem vores firewall, uanset hvilken maskine XYZ
benytter, ses (let) at det ikke kan lade sig gøre ved hjælp af
firewall-regler. Man kan ikke på netværksniveau eller
transportniveau åbne for en bestemt loginkonto, men her kommer
SSH, secure shell, protokollen heldigvis til undsætning og løser
problemet elegant og sikkert på session-niveau.
</para>
</sect2>


<sect2 id="sikkerhed-logning">
<title>Overvågning og logning</title>
<para>
Når man installerer en regel i kernens pakkefilter, holder kernen
automatisk øje med, hvor mange pakker der falder ind under denne
regel, og med -L (list) kommandoen få iptables til at vise
tællerne (counters).
</para>

<para>
Et eksempel:
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -L INPUT -v</userinput>

</screen>

</sect2>


<sect2 id="sikkerhed-NAT">
<title>Servicering af maskiner uden offentligt IP-nummer</title>

<para>
En router for et lokalnetværk har som regel flere opgaver end at
sende pakker videre og stoppe uvedkommende pakker. I de fleste
netværk bruger man adresser, som er reserveret til testformål, de
såkaldte private adresser. De skal ompakkes til en rigtig
IP-adresse, og hertil bruger routeren NAT, Network Address
Translation.
</para>

<para>
NAT er en teknik, som minder om en transparent
proxy. NAT-ing har vist sig at være en halv løsning på mangelen
på IP-numre. IP-numre er 32 bit.  Hvis man kunne udnytte alle
4,294,967,295 numre (4 mia.), så ville det stadig ikke være nok
til at dække behovet. Der er ca. 0.5 mia adresser, som bliver
brugt til specielle formål, men selv hvis man kunne inddrage dem
til "almindelige" adresser, så ville der ikke være nok numre til
at dække behovet for at hvert menneske havde et IP-nummer, for
slet ikke at tale om, hvis vi skulle have IP-numre til arbejde og
hjem, køleskab, cykel og fjernsyn.
</para>

<para>
Hvis to maskiner på et net udgiver sig for at have samme
IP-nummer, så vil kommunikationen blive upålidelig for begge
maskiner. <!-- TODO: Illustration /-->
</para>

<para>
Da man jo ikke behøver at koble et lokalnet på det globale
internet, behøver man heller ikke at få en adresse på det
globale net fra InterNIC eller deres lokale repræsentant.
Man kunne sådan set godt bruge de numre, man synes så pænest ud.
Imidlertid viser det sig ofte, at folk alligevel gerne vil
have deres separate TCP/IP-net tilsluttet det globale Internet
på et eller andet tidspunkt, og derfor indskærpes det overfor
netværksadministratorer, at man skal bruge de "private adresser",
selv om man ikke lige nu har tænkt sig at slutte maskinerne
til det offentlige net. De private adresser får ikke lov til
at passere en router, det er indbygget i routeren.  På den måde
kan man undgå uskyldige fejltagelser, hvor en maskine har fået
et IP-nummer, som tilhører en anden.
</para>

<para>
De mest benyttede private adresser er intervallet
192.168.1.0 - 192.168.255.255. Man kan også bruge alle adresser,
som begynder med 10, og adresser, som begynder med 172.16
</para>

<para>
Det er så routerens opgave at foretage en omskrivning af pakkerne
og sende dem videre, som om de kom fra routerens eksterne,
offentligt synlige IP-adresse. Lige så vigtigt er det, at den kan
identificere svar-pakkerne, og sende dem til den rigtige maskine.
Dertil bruges portnumrene som en forlængelse af IP-adressen.
Denne funktion kaldes <emphasis>N</emphasis>etwork
<emphasis>A</emphasis>ddress <emphasis>T</emphasis>ranslation
eller NAT. En router, som kan det, kaldes somme tider en NATting
router.
</para>

<para>
Den utålmodige læser kan nu springe frem til 
<xref linkend="sikkerhed-netfilter"/>,
mens den grundige læser i de næste afsnit kan få meget mere at
vide om, hvordan Linux fungerer.
</para>

</sect2>
</sect1>


<sect1 id="sikkerhed-virkemaader">
<title>Firewallens virkemåder</title>

<para>
Som sagt kan en Linux-pc <!-- Den stavemaade er jeg ikke glad
for, men jeg kan ikke faa verificeret en kapitaliseret version
lige nu/--> fungere som firewall og router. En firewall-router er
dog ofte en dedikeret, flad boks, som egentlig er et diskløst
system, der kan fjernstyres fra en anden computer.  Der fås
billige routere til mindre virksomheder og private net, og der
fås også store routere med mange stik, som kan håndtere meget
store trafikmængder. Der er en Linux-kerne inde i mange af den
slags dedikerede routere. TODO: eksempler, billede.
</para>

<para>
Inde i firewallen inspiceres pakkerne. Hvordan man gør, og hvor
meget det koster i tid, og hvilke problemer, der kan opstå, er
emnet for dette afsnit.
</para>

<para>
Netværksmodellen (<xref linkend="sikkerhed-layer"/>) viser to
ting. Dels viser den abstraktionslagene, som giver de elektriske
signaler mening. Dels viser modellen, at en applikation, som
ønsker at sende data (typisk tekst) til en anden applikation på
en remote værtsmaskine, skal sende sin pakke gennem adskillige
instanser (lag svarer her til programafsnit eller
kernefunktioner). Hver gang pakken passerer et lag, bliver det
hele lagt i en slags "konvolut". Først sendes applikationens
information til transportlaget, og her lægges TCP-oplysninger ind
i nogle felter forrest i pakken. Pakken (eller rettere en pointer
til den) sendes videre til IP-laget, som forsyner den med en 
IP-header, "konvolut", foran. 
</para>


<programlisting>

   &lt;-IP-header----|--TCP-header----|----FTP-header-|-FTP-data----|->
   |                                                               |
   &lt;-----------------------IP-pakke-------------------------------->
                  |                                                |
                  &lt;--------------TCP-segment-eller-pakke----------->
                                   |                               |
                                   |                               |
                                   &lt;-------------FTP-pakke--------->


   Skematisk opstilling af IP-pakke som konvolut for en TCP-pakke

</programlisting>


<para>
Hver konvolut svarer til et lag i netværksmodellen. Uden om
IP-pakken er der på et ethernet en ethernet pakke. Det er en god
ide at se på den slags pakker med programmet ethereal. Når
ethernet-headeren er selected i mellemste rude, så er de
tilsvarende bytes highlighted i hexdump-ruden nederst.  
</para>

<graphic fileref="ethereal-display1.&magic;"  scale="40"></graphic>


<para>
Lagene fra den simple DoD model med kommentarer ses her:
</para>

<programlisting>

                           Protocol Layering

                        +---------------------+
                        |     higher-level    |
                        | applikations-laget  |
                        +---------------------+
                        |        TCP          |
                        +---------------------+
                        |  internet protocol  |
                        +---------------------+
                        |communication network|
                        +---------------------+


</programlisting>


<itemizedlist>
<listitem><para>
Applikationslaget, f.eks. FTP og HTTP. Applikationen kan selv lave
nogle regler for, hvordan pakkerne skal håndteres og se ud. Der
er <emphasis> mange </emphasis> forskellige
applikationsprotokoller, og det er let at lave nogle selv eller
afprøve teknikken ved at lave f.eks. en <command>finger</command>
klient (TODO: Reference til gawk-finger-server).
</para></listitem>

<listitem><para>
Transportlaget, TCP står for Transport Control Protocol. Her
tilføjes TCP-portnummer, TCP-type, tjeksum m.v.
</para></listitem>

<listitem><para>
Netværkslaget, her arbejdes med IP-numre, SNMP, ICMP og
router-protokoller; IP, eller Inter Net Protokollen, er reglerne
for, hvordan man kommer fra ét lokalnet til et andet.
</para></listitem>

<listitem><para>
Fysisk link-lag, d.v.s. MAC-adresser, ethernetkort og ledninger.
Mac-adresser er knyttet til ethernet-pakker. Der er egentlig også
et par abstraktionslag her.
</para></listitem>
</itemizedlist>

<para>
<emphasis>Et par forklaringer: </emphasis>
Finger protokollen er en af de simplere, morsomme protokoller.
Det er nemt at prøve fingerprotokollen: <command>finger
quake@geophys.washington.edu</command>
</para>

<para>
SNMP, Simple Network Management Protocol, bruges til fjernkontrol
af netværks enheder som f.eks routere. ICMP, Internet Control
Message Protocol, er den, som ping programmet benytter, og den,
som gør det muligt at sende en besked om, at vores maskine ikke
har tænkt sig at svare på fx. ftp. MAC-adresser kan listes med
<command> arp -a </command> programmet og er et tal, som er brændt
ind i netkortets ROM, så hardwaren altid kan skelne to netkort
fra hinanden.
</para>

<para>
Disse netværkslag er defineret med henblik på at kunne
transportere så meget som muligt så hurtigt som muligt. Derfor
behøver IP-laget ikke at interessere sig for, om data er korrekte
eller om der lyttes på modtagerens portnummer, og heller ikke for
applikationens datakodning og så videre.
</para>

<para>
Det er derfor meget enkelt og "billigt", målt i tid, at filtrere
indkommende pakker på netværkslaget. Bare se efter, om de er til
vores maskine, og om de kommer inde- eller udefra.
</para>

<para>
Hvis firewallen imidlertid er nødt til også at udpakke
transportpakken (d.v.s. se i TCP-konvolutten for at få fat i
portnummeret) så kræver det selvfølgelig lidt mere tid. Hvis
pakken yderligere skal om-adresseres og en ny tjeksum skal
beregnes, så bliver det rigtig dyrt. Som tidligere nævnt er det
for primitivt kun at filtrere på netværkslaget.
</para>

<para>
De omtalte netværkslag svarer i kernen til programafsnit, som
bearbejder henholdsvis IP-adresse, TCP-oplysninger og, i sidste
instans, flytter pakken til den applikation, som skal bruge data.
</para>



<sect2 id="sikkerhed-nat">
<title>NAT-ing giver også mere sikkerhed</title>

<para>
Som tidligere nævnt skal en NAT-ing router omsætte de interne
eller private IP-adresser til den offentlige (lovligt købte)
IP-adresse, som man har fået af sin Internet Udbyder, Internet
Service Provider, ISP.  Man kan for eksempel bruge adresserne
192.168.1.1-255 som lokale adresser, denne nummerserie er
reserveret. Det er en del af de såkaldt "private adresser", som
ikke bliver sendt rundt på det offentlige net. De er reserverede
for at gøre det lettere at etablere et lokalnet uden at skulle
søge og betale for "rigtige IP-adresser".
</para>

<para>
NAT-teknikken er med til at gøre firewallen mere
uigennemtrængelig. Det ses, hvis man forestiller sig hvad der
sker, hvis man prøver at "snakke" med en maskine med et
192.168.x.y - nummer? Pakkerne kommer ingen vegne. Hvis nogen
prøver at trænge igennem en firewall ved at bryde ind i en
kommunkations sekvens (trediemandsprincippet, spoofing) så skal
pakkerne kunne snyde firewallen *og* modtagemaskinen inden for
muren. Det er svært, og det sker heldigvis meget sjældent.
</para>

</sect2>


<!--dax 2003-10-22 nogenlunde ok hertil, mangler ekstern korrektur/-->

<sect2 id="kontrol-af-forbindelser">
<title>Kontrol med oprettelse af forbindelser</title>

<para>
At åbne for alle forbindelser, som startes indefra, kræver, at
firewallen holder styr på, hvilke forbindelser der er oprettet;
for at gøre det, skal firewallen have inkluderet et modul, der
kaldes "connection tracking". Derved kan Linux-kernen styre
hvilke forbindelser, der må oprettes imellem de to adskilte
netværk. Den kan også logge, hvad der sker på disse forbindelser.
</para>

<para>
Der er her tale om filtrering på session- eller forbindelses-niveau 
(se <xref linkend="sikkerhed-layer" />). FTP er en protokol
oven på TCP-laget, og når denne applikation går i gang, opretter
den mange "forbindelser". Det giver en ekstra vanskelighed for en
firewall. Man skal huske, at FTP protokollen kom til verden i en
tid, hvor der ikke var noget, der hed firewalls.
</para>

</sect2>


<!-- dax 2003-10-23 god forklaring, belyser virkemåde, fredet! /-->

<sect2 id="Ftp-problemet">
<title>Ftp-problemet</title>
<indexterm><primary>FTP og sikkerhed</primary></indexterm>

<para>
Traditionel FTP, også kaldet aktiv FTP, er lidt et problem i
forbindelse med en firewall, da det laver indgående forbindelser.
Ikke alene laver det 
indgående forbindelser, men det er ikke muligt på forhånd at vide hvilken
port, forbindelsen laves på. Det vil sige, at for at tillade sine brugere at
benytte aktiv FTP, er man
nødt til at lade en masse porte stå åbne. Lad os se, hvad der sker,
når man bruger traditionel FTP:
</para>

<programlisting>
Aktiv FTP 

  Klient                  Server
                     command  data
57726 57724               21   20
  @    @                  @    @
  |    |1__               |    |
  |    |   \__port 57726__|    |
  |    |                  |    |
  |    |              ___2|    |
  |    |____ok__ ____/    |    |
  |    |                  |    |
  |____|_                 |    |
  |    | \_data channel___|___3|
  |    |                  |    |
  |    |                __|____|
  |4___|________ ok___ /  |    |
  |    |                  |    |
  |    |                  |    |

</programlisting>

<itemizedlist mark="bullet">

<listitem><para>1) Først oprettes en forbindelse fra klienten på en 
tilfældig port (her port 57724) til port 21, FTP-kommandoporten, 
på serveren. Klienten overfører et portnummer, som den vil benytte 
til dataoverførslen (her port 57726).</para></listitem>

<listitem><para>2) Serveren siger ok</para></listitem>

<listitem><para>3) Serveren opretter en dataforbindelse fra sin
FTP-dataport - port 20 - til den angivne port på klienten
(57726).</para></listitem>

<listitem><para>4) Klienten siger ok</para></listitem>

</itemizedlist>

<para>
Man kan se, at serveren opretter en forbindelse til klienten på port
57726.  Da man ikke på forhånd kan vide hvilken port, der vil blive
brugt på klienten - FTP-programmet vælger bare en ledig port - er det
nødvendigt at lade et portinterval på klienten stå åbent for
FTP-forbindelser, så FTP-klienten kan virke.
</para>

<para>
Problemet kan løses med nyere udgaver af FTP,
som kan køre "passiv FTP" i stedet for. Ved passiv FTP er det kun klienten,
der starter forbindelser op. 
</para>

<indexterm><primary>passiv FTP</primary></indexterm>

<example id="passiv-FTP">
<title>Passiv FTP</title>
<programlisting>
Passiv FTP 

  Klient                  Server
                     command      data
57726 57724               21       20
  @    @                  @  58734   @
  |    |1__               |    @    |
  |    |   \_PASV_________|    |    |
  |    |                  |    |    |
  |    |______ok_58734___2|    |    |
  |    |                  |    |    |
  |3___|__                |    |    |
  |    |  \__data_channel_|____|    |
  |    |                  |    |    |
  |____|_______ok_________|___4|    |
  |    |                  |    |    |
  |    |                  |    |    |
  |    |                  |    |    |
  |    |                  |    |    |
</programlisting>
</example>

<itemizedlist mark="bullet">
<listitem><para>1) Først oprettes en forbindelse fra klienten på en 
tilfældig port (57724) til port 21, ftp-kommandoporten, på serveren. 
Klienten overfører en kommando, der fortæller serveren, at der skal 
bruges passiv ftp.</para></listitem>

<listitem><para>2) Serveren siger ok og fortæller hvilket portnummer,
den vil have, at klienten connecter til.</para></listitem>

<listitem><para>3) Klienten opretter en dataforbindelse fra sin
ønskede dataport - her port 57726 - til den angivne port på serveren
(58734).</para></listitem>

<listitem><para>4) Serveren siger ok</para></listitem>
</itemizedlist>

<para>
Lad os se på, hvad der er vundet. Hvis man vedligeholder en firewall
bag hvilken, der er klienter, der gerne vil hente via
ftp, er man ved traditionel ftp nødt til at lade et portinterval stå
åbent til indgående forbindelser, som de forskellige ftp-servere, folk
henter fra, skal oprette. Bruges der derimod passiv ftp, skal man
kun tillade udgående forbindelser - man behøver ikke længere lade et
portinterval stå åbent til de indgående forbindelser fra diverse
ftp-servere.
</para>

<para>
Ftp-serveren skal til gengæld lade en port stå åben til data, men den 
bestemmer selv hvilken. Den oplysning sender den med over, før 
dataforbindelsen oprettes. Alligevel betragtes det nogle steder som 
et problem på serversiden. Selvom de fleste ftp-programmer - herunder
web-browsere - understøtter passiv ftp, er det derfor ikke alle ftp-servere, 
der understøtter det.
</para>

</sect2>
</sect1>

<sect1 id="Linux-som-firewall">
<title>Linux som firewall</title>

<indexterm><primary>firewall</primary></indexterm>
<indexterm><primary>dørvogter</primary></indexterm>

<para>
I dette afsnit ser vi på Linux-kernens netfilter modul og hvad 
man kan gøre med det. Det er en forudsætning, at man kender til
begreberne IP-adresse, netværksadresse, netmaske, routing og DNS.
Hvis du ikke gør, så læs i det mindste indledningen til denne
bog, eller se på <ulink
url="http://www.netfilter.org/documentation/index.html#HOWTO">
http://www.netfilter.org/documentation/index.html#HOWTO</ulink>
efter Networking Concepts HOWTO.  </para>

<para>
De mere avancerede anvendelser af Network Address Translation,
NAT, omtales sidst i denne del (<xref
linkend="sikkerhed-grundig-NAT" />).  Derefter omtales proxy
opsætning med squid.
</para>


<!-- dax 2003-10-23 Hertil. Har slettet resten og starter forfra HUSK /-->


<sect2 id="sikkerhed-netfilter">
<title>Iptables og netfilter i kerne 2.4 og 2.6</title>
<indexterm><primary>Iptables</primary></indexterm>
<indexterm><primary>Netfilter</primary></indexterm>

<para>
I Linux er pakkefiltrering i en avanceret version indbygget i
kernen; kernedelen kaldes netfilter, og programmet <command>
iptables </command> kommunikerer vores ønsker om hvad kernen skal
foretage sig fra user-space til kerne-space.
</para>

<para>
For at kunne bruge kernens netfilter og <command> iptables
</command> kommandoen, skal kernen være bygget med netfilter, og,
hvis man planlægger at sikre en maskine, må det stærkt anbefales
at man også inkluderer connection tracking. Det koster lidt
belastning, men giver mange fordele.  De fleste standard kerner
fra distributioner med kerne 2.4.18 og frem har den slags. Det
kan kontrolleres med <command>ls -l /proc/net/ip_conntrack
</command>
</para>

<figure>
<title>Firestarter giver ikke ligefrem indtryk af at være en
sikker firewall, tværtimod står den vildt udseende pingvin med en
tændstik her. Men det *er* linux-humor og ikke en trussel!
</title>
<graphic fileref="fs00.&magic;"  scale="40"/>
</figure>

<para>
Der mange gode front ends til iptables kommandoen. Hvis man er
utryg ved anvendelse af kommandolinien, bør man først og fremmest
under installationen læse vejledningen grundigt og indsætte et
firewall filter af medium styrke allerede under installtionen.
Desuden kan man begynde med en GUI som fx. RedHats
system-konfigurations tool, <command> setup </command> eller
<command> /usr/sbin/lokkit </command>. Disse nemme programmer er
front-ends til den bagvedliggende mekanisme og fungerer bravt. De
er til stede efter en normal installation. Firestarter kan man
selv hente i forskellige grydeklare versioner, så den er bestemt
også nem at komme igang med.
</para>

<para>
Hvis man vil noget særligt eller bare vil prøve kommandoerne
direkte, så står der mere om det i de efterfølgende afsnit, som
beskriver <command> iptables </command>
anvendelse<footnote>
  <para>
  Der kan være mange grunde til, at man selv vil skrive iptables
  kommandoerne. Ved afprøvningen af Firestarter konstatererede
  jeg, at den laver om på filer i /etc/ uden at aflevere en liste
  over hvilke filer, den har ændret. Firestarter kan ikke save
  sine resultat filer, firewall scriptet, uden at køre iptables
  kommandoen.  Derfor kan man ikke "se den over skulderen" inden
  man vælger at acceptere den. Jeg kørte den i en 'chroot'ed
  partition og den stoppede min firewall uden at spørge.
  </para>
  <para>
  For en begynder er det nok en fordel, at den opfører sig så
  håndfast uden at spørge.
  </para>
  <para>
  Ældre versioner af Red Hats firewall-config bruger ipchains
  og forventer, at man har en modulariseret (distributions)kerne.
  Det gør ikke så meget, at den råber FEJL når man kører med
  optimeret non-modul kerne, hvis den i øvrigt bare fungerer.
  Den kan heller ikke vise, hvad den vil gøre <emphasis> uden
  </emphasis> at gøre det.
  </para>
  <para>
  I de senere afsnit vises, hvordan man skriver et script med
  sine egne firewall regler, og hvis man har gjort det, så kan
  man jo tage en komplet kopi af /etc til fx /etc-bkup og på den
  måde sikre sine ændringer mod overskrivning.
  </para>
  <para>
  RedHats setup er et xterm - menuprogram, og starter
  forskellige subprogrammer til opsætning og konfiguration.
  Bortset fra små problemer med samtidig konfiguration fra det
  ene/andet GUI er jeg glad for RedHat setup. Dens firewall
  configurator hedder /usr/sbin/lokkit og fungerer. Det er også
  den, som bruges under installation af RedHat, og den fås også
  som GUI version, /usr/sbin/redhat-config-network.
  </para>
</footnote>.
</para>

<para>
Firestarter er en generel front-end, som er meget nem at bruge,
fordi den ligesom RedHats installations program har nogle meget
fornuftige default værdier, hvis man bruger troldmand/hjælpe
systemet til opsætning af sin første firewall.
</para>

<para>
Grafikken er rigtig pæn, og let at læse.  I første vindue står en
pingvin med en tændstik, og sådan noget kan godt gøre mig lidt
urolog. Pingvinen ser dog ikke umiddelbart ud til at være i gang
med ildspåsættelse!
</para>

<para>
I andet vindue skal man fortælle, hvilke netkort (d.v.s.
interfaces) reglerne skal gælde for. De kan også gælde for modem
opkobling med Point-to-Point Protocol (PPP), hvilket også er
forklaret. Man lades ikke i stikken!
</para>

<graphic fileref="fs01.&magic;"  scale="40"></graphic>

<para>
Det er meget fine forklaringer, også på det næste skærmbillede,
hvor man rådes til i første omgang at lukke for alle "offentlige"
services (disable public access to all services), så intet er
tilgængeligt udefra. Så kan man åbne for dem senere, hvis man får
brug for dem. Der burde stå, at man ikke bør åbne for telnet, men
derimod kan klare de fleste opgaver med ssh.
</para>

<figure>
<title>Man kan åbne for de services, man har brug for</title>
<graphic fileref="fs02.&magic;"  scale="40"/>
</figure>

<para>
Der er et par skærmbilleder mere, som på en overskuelig måde
tilbyder at justere på trafikken af forskellige typer. Denne form
for justering vil blive meget mere almindelig i fremtiden, fordi
mange typer service kræver en jævn datastrøm, men som
udgangspunkt kan man blot acceptere default indstillingerne.
</para>

<para>
Ønsker man dansk tekst i sin GUI er guarddog (GPL) det klare valg.
Gunner Poulsen har oversat til dansk, og man kan hente denne fra
<ulink
url="http://www.simonzone.com/software/guarddog/#download">
http://www.simonzone.com/software/guarddog/#download</ulink>
Guarddog kan skelne mellem lokalnet og <emphasis>
demilitariseret zone, </emphasis> som er et område udenfor
lokalnettet, hvor man har anbragt sine servere - tilbørligt
sikrede, men der skal jo være en åben dør, for at folk kan komme
ind og se på éns dejlige web-sider. Man kan selv definere flere
zoner og zonetyper.
</para>

<graphic fileref="guarddog2_protocol.&magic;"  scale="40"></graphic>

<para>
Læg mærke til, at guarddog styrer protokollerne pr. zone. Det vil
sige, at man kan lukke for alt fra fx. externe numre og åbne for
sine lokale 4 maskiner. Man kan have flere zoner, fx. kan en
anden afdeling huset få adgang til noget specielt, som de har
brug for.
</para>

<para>
Et andet fremragende GUI firewall-protection program er lokkit,
som er bruges ved installation af RedHat og ved kørsel af setup
programmet.
</para>

<graphic fileref="gl06.&magic;"  scale="40"></graphic>

<para>
Her skal man blot angive fx. maximum sikkerhed og så åbne for den
eller de services, som skal være tilgængelige udefra. (De skal jo
så være sikret på anden måde, pas især på CGI scripting i Apache
hvis den kører som root.)
</para>

<para>
Hvis du selv vil opdatere din kerne med source fra <ulink
url="http://www.kernel.org/">www.kernel.org</ulink> så kommer
nedenfor nogle screenshots som svarer til <command> make xconfig
</command>. Her kan du se, hvor i menuerne du skal klikke; husk
at læse help teksterne, det er gode forklaringer.
</para>

<figure>
<title>make xconfig, vælg network packet filtering</title>
<graphic fileref="kconf-netfilt.&magic;"  scale="40"/>
</figure>

<figure>
<title>Længere nede vælges sub-menu for netfilter
configuration</title>
<graphic fileref="kconf-netfilt-2.&magic;"  scale="40"/>
</figure>

<figure>
<title>Den engelske hjælpetekst er meget fyldestgørende, se
appendix <xref linkend="sikkerhed-xconf-netfilt-help"/></title>
<graphic fileref="kconf-netfilt-hlp.&magic;"  scale="40"/>
</figure>

<para>
iptables kommandoen skal bygges, så den passer til den kerne, man
bruger, eller rettere, så den passer til den version af
netfilter, som er i kernen. Også det er gjort i alle
distributioner.
</para>

<para>
iptables indsætter som nævnt regler i kernens netfilter
tabeller, hvilket betyder, at reglerne går tabt ved reboot. Du
kan prøve at bruge kommandoerne iptables-save og
iptables-restore.
</para>

<para>
Alternativt sætter man alle iptables kommandoerne ind i et
start/stop script, som køres af rc kommandoen ved opstart. Man
skal i så fald huske at få den til at foretage sig noget
fornuftigt, hvis en af iptables kommandoerne fejler; normalt vil
det være at starte <command> /sbin/sulogin </command>
</para>



<sect3 id="sikkerhed-traverse">
<title>Hvordan pakker rejser igennem filtrene</title>

<para>
Navnet iptables hentyder til, at kernen har tre tabeller:
</para>

<itemizedlist mark="bullet" id="sikkerhed-list-iptables">
<listitem><para>
Filter tabellen, som bruges, hvis man udelukkende skal stoppe
uvedkommende trafik.
</para></listitem>
<listitem><para>
NAT-tabellen, som bruges, hvis man skal foretage mapning /
spejling af interne adresser, obligatorisk, hvis der er tale om
private adresser som fx. 192.168.x.x.
</para></listitem>
<listitem><para>
Mangle-tabellen, som bruges, hvis man vil pille ved bits i
pakkerne for at kunne klare vanskelige situationer.
</para></listitem>
</itemizedlist>

<para>
Kernen begynder med at have 3 lister med regler i "filter"
tabellen. Disse lister kaldes firewall kæder eller blot kæder,
chains. De tre kæder kaldes INPUT, OUTPUT og FORWARD (pakker-ind,
pakker-ud og pakker-til-videresendelse).<!-- Af hensyn til Jacobs
læsere/-->
</para>

<para>
Her er en ASCII-kunstnerisk gengivelse af kædernes organisation
(med tak til Rusty Russell's packet-filtering-HOWTO).  Det er
væsentligt forskelligt fra arrangementet i kerne 2.0 og 2.2.
</para>

<programlisting>
                            _____
  Incoming                 /     \         Outgoing
         -->[Routing ]--->|FORWARD|------->
            [Decision]     \_____/        ^
                 |                        |
                 v                       ____
                ___                     /    \
               /   \                   |OUTPUT|
              |INPUT|                   \____/
               \___/                      ^
                 |                        |
                  ----> Local Process ----
</programlisting>

<para>
Det ses, at en pakke kan komme fra to principielt forskellige
kilder. Enten kommer pakkerne fra et netkort (rettere interface -
men prøv at oversætte det til dansk) eller også kommer de fra et
program, en lokal proces.
</para>

<para>
De tre "cirkler" repræsenterer de tre kæder nævnt ovenfor. Når en
pakke ankommer til en cirkel i diagrammet, undersøges reglerne i
denne kæde for at afgøre pakkens skæbne. Hvis kæden siger DROP
pakken bliver den elimineret på stedet, men hvis kæden siger
ACCEPT vil den fortsætte sin rejse gennem diagrammet.
</para>

<para>
En kæde er en tjekliste med regler. Hver regel siger "hvis
pakke-headeren ser ud på denne-hersens-måde, så se her hvad der
skal gøres med pakken".  Hvis en regels pakke-beskrivelse passer
på pakken, kalder man det et match. Det svarer selvfølgelig til
en masse betingelser, som er opfyldt. Hvis pakken ikke matcher
reglen fortsætter man til næste regel. Endelig når vi til et
punkt, hvor der ikke er flere regler at undersøge. Nu ser kernen
på kæde-policy for at afgøre, hvad der skal ske. I et
sikkerheds-bevidst system siger denne policy som regel at kernen
skal DROPpe pakken.
</para>

<para>
1. Når en pakke kommer ind, lad os sige fra ethernet-kortet ser
kernen på pakkens destination: Dette kaldes routing (rutning
eller bedre, ruting?)
</para>

<para>
2. Hvis den er til denne box bliver pakken sendt videre ned i
diagrammet til INPUT kæden. Hvis den passerer denne, så vil alle
processer, som venter på denne pakke, få den.
</para>

<para>
3. I modsat fald, hvis kernen ikke har videresendelse aktiveret,
eller den ikke ved, hvordan pakken skal sendes videre, vil pakken
blive droppet. Hvis videresendelse er aktiveret, og pakken er
tiltænkt til et andet netværks-interface (hvis du har sådan et),
så vil pakken gå fremad til FORWARD kæden. Hvis den accepteres
her, bliver den sendt ud.
</para>

<para>
4. Sluttelig kan et program, som kører på boxen, sende
netværkspakker. Disse passerer gennem OUTPUT kæden straks: Hvis
den siger ACCEPT, så fortsætter pakken til hvad nu end det måtte
være for et interface, som den er bestemt for.
</para>

</sect3>

</sect2>
<sect2 id="sikkerhed-iptables-cmd">
<title>Anvendelse af <command>iptables</command> kommandoen</title>

<para>
<command> iptables </command> kommandoen har en ret detailleret
manual side (<command> man iptables </command>) hvis du har brug
for oplysninger om specielle ting.
</para>

<para>
Der er mange ting, man kan gøre med <command> iptables </command>
kommandoen. Man begynder med at have de tre indbyggede kæder,
INPUT, FORWARD og OUTPUT, som man ikke kan slette. Lad os først
se på hvordan man administrerer hele kæder.
</para>


<itemizedlist mark="bullet">
<listitem><para>
<command> -N </command>: Opretter en ny kæde.
</para></listitem>
<listitem><para>
<command> -X </command>: Sletter en tom kæde.
</para></listitem>
<listitem><para>
<command> -P </command>: Ændrer policy for en kæde.
</para></listitem>
<listitem><para>
<command> -L </command>: Lister regler i en kæde.
</para></listitem>
<listitem><para>
<command> -F </command>: Flusher, sletter reglerne i en kæde.
</para></listitem>
<listitem><para>
<command> -Z </command>: Nulstiller tællerne for en kæde.
</para></listitem>
</itemizedlist>


<para>
Brugerdefinerede kæder bruges til at strukturere filtreringen og
demonstreres senere. Her er et simpelt eksempel på en
kæde-kommando, som nulstiller tællerne i INPUT kæden. Prøv at
liste før og efter med <command> iptables -L INPUT -v </command>:
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -Z INPUT</userinput>
</screen>

<para>
Der er fire kommandoer til at manipulere reglerne i en kæde:
</para>

<itemizedlist mark="bullet">
<listitem><para><command> -A &lt;kæde&gt; </command> Tilføj (append) regel</para></listitem>
<listitem><para><command> -D &lt;kæde&gt; [nummer] </command> Slet (delete) regel</para></listitem>
<listitem><para><command> -R &lt;kæde&gt; [nummer] </command> Erstat (replace) regel</para></listitem>
<listitem><para><command> -I &lt;kæde&gt; [nummer] </command> Indsæt (insert) regel</para></listitem>
</itemizedlist>


<para>
En regel er en beskrivelse plus en handling. 
</para>

<para>
Beskrivelsen er et match-udtryk og kan være sammensat af mange
del-udtryk: <emphasis>Hvis pakken kommer fra adresse 44.55.66.77
og skal videre gennem interface eth1 ... </emphasis> Det ville
man skrive sådan: <command> --source 44.55.66.77 --out-interface
eth1 </command>. 
</para>

<para>
En handling er et "jump", og det svarer til at tage en
bestemmelse om, hvad der skal ske med pakken. Det, man hopper
til, kaldes et mål eller target, og to af de indbyggede targes
er de samme som de policy, vi tidligere har set, DROP, ACCEPT.
At tage beslutning om at droppe en pakke skrives <command> -j
DROP </command>
</para>

<para>
Man kan sætte flere match udtryk sammen.  Nedenfor ses efter
pakker, som kommer fra host 44.55.66.77 og som skal ud gennem
interface eth1. Alle pakker, som har de to egenskaber, droppes:
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -A OUTPUT --source 44.55.66.77 --out-interface eth1 -j DROP </userinput>
</screen>

<para>
Endvidere kan man hoppe til en anden, brugeroprettet kæde,
eller man kan returnere fra en kæde (med <command> -j RETURN
</command>). Der er et REJECT target, som dog kræver at
kernen er kompileret med support for det. Der er andre inbyggede
targets, som kræver tilvalg i kernen: QUEUE beder kernen om at
sende pakkerne til en pseudo-device, som et program i userspace
kan lytte på, og så er der bl.a. også REDIRECT, SNAT, DNAT og LOG
targets. (Lad være med at studere listen i detailler! Bladr frem.)
</para>

<orderedlist>
<listitem><para>ACCEPT</para>
          <para>Pakken sendes videre uden yderligere
          test og dermed uden yderligere tidsforbrug.</para></listitem>
<listitem><para>DROP</para>
          <para>Pakken ignoreres ("smides væk").
          </para></listitem>
<listitem><para>RETURN</para>
          <para>Der hoppes tilbage til den kæde, man kom fra
          eller for indbyggede kæder til default policy.
          </para></listitem>
<listitem><para>REJECT</para>
          <para>Pakken droppes men der sendes en ICMP pakke til
          modtageren med besked.
          </para></listitem>
<listitem><para>QUEUE</para>
          <para>Pakken lægges i kø til pseudodevice der tillader
          data at blive hentet til userspace.
          </para></listitem>
<listitem><para>REDIRECT</para>
          <para>En -t nat funktion. Modtageradressen ændres, så
          pakken sendes til maskinen selv (lokalhost); for tcp/udp 
          kan portnummer ændres. Bruges til proxy-funktionalitet.
          </para></listitem>
<listitem><para>SNAT</para>
          <para>Kun for nat-tabellen, POSTROUTING kæden,
          specificerer at afsenderadresse skal ændres for denne
          og alle fremtidige pakker i denne forbindelse.
          </para></listitem>
<listitem><para>DNAT</para>
          <para>Modtager adressen ændres for denne og følgende
          pakker i samme forbindelse.
          </para></listitem>
<listitem><para>LOG</para>
          <para>Begynd kernel-logging for matchende pakker.
          Reglen behøver ikke at have noget target. Netfilter
          fortsætter med næste regel. Bruges til at analysere.
          </para></listitem>
<listitem><para>MARK</para>
          <para>Bruges i mangle tabellen i forbindelse med iproute2.
          </para></listitem>
<listitem><para>MASQUERADE</para>
          <para>Bruges til NAT-ing med dynamiske adresser.
          </para></listitem>
<listitem><para>TCPMSS</para>
          <para>En speciel funktionalitet for fragmentering af
          ICMP pakker, som ens ISP ellers kasserer.
          </para></listitem>
<listitem><para>TOS</para>
          <para>For mangle tabellen, ændring af Type Of Service (TOS)
          feltet i TCP headeren.
          </para></listitem>
<listitem><para>ULOG</para>
          <para>Pakken multicastes til userspace for logging/analyse.
          </para></listitem>
<listitem><para>DSCP</para>
          <para>Nyere version TOS mangling.
          </para></listitem>
<listitem><para>ECN</para>
          <para>For løsning af problem med Explicit Congestion
          Notification.
          </para></listitem>
<listitem><para>MIRROR</para>
          <para>Kun for forsøg, bytter om på afsender/modtager adresserne.
          </para></listitem>
</orderedlist>

<para>
Listen er ordnet efter hvad jeg synes er vigtigst. Se manual page
for nærmere detailler om targets. Lige nu er de vigtigste ACCEPT,
DROP og SNAT, som kun kan bruges i nat-tabellens POSTROUTING chain.
</para>

<para>
</para>

<para>
Opsummerende kan vi sige, at en regel består af består af en
eller flere kommandoparametre, som beskriver en egenskab ved en
netværkspakke, samt (som regel) en besked om, hvad der skal ske
med pakker, som beskrivelsen passer på. Hvis en beskrivelse
passer, siger man at pakken matcher.
</para>

<para>
De vigtigste kommandoparametre til match er
</para>

<itemizedlist mark="bullet">
<listitem>
<para>
<command> --protocol [icmp|tcp|udp|all] </command> 
</para>
<para>
Man kan også bruge et navn fra <filename> /etc/protocols
</filename>. Hvis man ønsker at matche alle pakker, som ikke
tilhører en bestemt protokol, negeres med udråbstegn. Fx.
<command> iptables -A INPUT --protocol ! tcp -j ACCEPT</command>
accepterer alt undtagen TCP-pakker.  Kan forkortes til -p.
</para>
</listitem>
<listitem>
<para>
<command> --source [!] adresse[/netmaske] </command>
</para>
<para>
Angiver oprindelsesadressen. Kan forkortes til -s. Eksempel:
<command> iptables -A INPUT --source 123.45.67.89 -j ACCEPT
</command> vil bevirke at vi accepterer alt, hvad der kommer fra
123.45.67.89 - og formentlig dropper alt andet.
</para>
</listitem>
<listitem>
<para>
<command> --destination [!] address[/mask] </command>
</para>
<para>
matcher på slutadressen, destinationen. Forkortes -d.
</para>

</listitem>
<listitem>
<para>
<command> -i, --in-interface [!] name </command>
</para>
<para>
hvor <emphasis>name</emphasis> kan være eth0, eth1, ppp0 m.v. kan
bruges til at selektere alle pakker, som kommer fra ydersiden eller
indersiden af firewallen.
</para>
</listitem>

<listitem>
<para>
<command> -o, --out-interface [!] name </command>
</para>
<para>
som -i, bruges til at selektere på alle pakker, der skal sendes
ud via et bestemt interface.
</para>
</listitem>

<listitem>
<para>
<command> -m state </command>
</para>
<para>
bruges til at fortælle kernen at tilstandsmodulet (connection
tracking) skal bruges. Derefter kan man specificere, at pakker,
som er ESTABLISHED eller RELATED til en forbindelse, som er i
gang, skal have lov at passere. Det er den måde, man åbner for al
trafik indefra.
</para>
</listitem>
</itemizedlist>

<para>
Næsten alle options har en kort form, for eksempel -s i stedet for
--source.
</para>

<para>
Adresser til --source og --destination kan
specificeres på fire måder:
</para>

<itemizedlist>
<listitem><para>
Som domaine-navn, www.kernel.org, linuxbog.dk, www.netfilter.org
</para></listitem>
<listitem><para>
Som IP-adresse: 127.0.0.1, 193.88.44.22
</para></listitem>
<listitem><para>
Som netværksadresse med skråstreg + antal signifikante bits:
10.11.128.0/17
</para></listitem>
<listitem><para>
Netværksadresse med skråstreg+bitmaske, 10.11.128.0/255.255.128.0
</para></listitem>
</itemizedlist>

<para>
Man kan selektere alle pakker, som <emphasis>ikke</emphasis>
kommer fra en adresse ved at negere adresse udtrykket, hertil
bruges et udråbstegn, som skal have space før og efter: <command>
-s ! localhost </command> vil matche alle pakker, som ikke kommer
fra localhost.
</para>



<sect3 id="sikkerhed-iptables-handson">
<title>Nogle praktiske eksempler</title>

<para>
Nu til hands on! Vi antager, at vi har fem maskiner i huset og et
en ADSL forbindelse på en af maskinerne. ADSL er på et separat
netkort, som har betegnelsen eth1. De andre maskiner er forbundet
via eth0 og vil gerne have lov at få del i ADSL forbindelsen.
</para>

<para>
Lad os lave en kæde af regler, som skal inspicere al trafik, der
kommer ind på vores box, men kun, hvis det er fra ADSL
interfacet, altså eth1.
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -N udefra </userinput>
</screen>

<para>
Man kan liste den nye kæde sammen med de andre: <command>
iptables -L </command> Kæden er ikke taget i brug, så der står "0
references". For at bruge den til noget må vi instruere kernen
yderligere med en jump kommando. Vi laver en regel 1 for INPUT
kæden.
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -A INPUT -i eth1 -j udefra </userinput>
</screen>


<programlisting>
                  __________
                _|  udefra  |--> regel 1 --> regel 2 ... 
               ^ |__________|                                    
              _|_____                                            
             /if eth1\                                           
            |  else   |                                          
             \_______/ _                                         
               ^        |   
   ______      |        v   
__|input |--> regel 1   regel 2 --> regel 3
  |______|
   ______
__|output|
  |______|
   _______
__|forward|
  |_______|
</programlisting>

<para>
Det svarer til en if-sætning. Vi tester for om det var
fra eth1 og hvis det er det, så fortsæt med regelkæden
<emphasis>udefra</emphasis>.
</para>

<programlisting>

   if (pakke_source == device_eth1) {
       tjek_reglerne_i_kaede_eth1();
   }
   else {
       fortsaet_med rule2();
   }

</programlisting>


<para>
Lad os inspicere pakkerne udefra for, om de er til vores http
server. Hvis de er det, så slip dem igennem, ellers skal de
droppes.
</para>


<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -A udefra -p tcp --dport 80 -j ACCEPT </userinput>
</screen>

<para>
Når man specificerer -p tcp (eller --protocol tcp) så loader
iptables et extension modul, og vi kan nu kigge ind i
tcp-headeren, hvis vi vil - og det vil vi, vi undersøger, om
pakkerne er bestemt for port 80, den velkendte port, som benyttes
af http serveren. Alle pakker til serveren accepteres. Der er
forskellige protocol extensions, som tillader avancerede ting:
Læs manual-page hvis du vil vide mere. <!-- TODO: Skal vi have et
appendix med en dansk version af alle de tekniske
specifikationer? senere, måske! /-->
</para>


<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -A udefra -j DROP </userinput>
</screen>

<para>
Derefter appender vi med <command> -A </command> endnu en regel,
som siger, at alt andet skal droppes.
Svarpakker til brugerne inde på lokalnettet vil imidlertid også
blive stoppet af denne stop-regel, så nu vil vi benytte
connection tracking og indsætte en regel, som siger, at alle
pakker, som er beslægtede med en forbindelse, som allerede er
oprettet, skal accepteres.
</para>


<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -I udefra -m state --state ESTABLISHED,RELATED -j ACCEPT </userinput>
</screen>

<para>
Denne regel bliver nu nummer 1, og de andre rykker ned som 2 og
tre. Hvis vi hellere vil sætte denne regel ind som nummer 2, skal
kommandoen bruge <command> -I udefra 2 </command> ; det er en
meget bedre løsning, for connection tracking koster trods alt
mere tid, så man bør acceptere så mange pakker som muligt med
simple regler inden man bruger connection-regler.
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -I udefra 2 -m state --state ESTABLISHED,RELATED -j ACCEPT </userinput>
</screen>

<para>
<command> -m state </command> fortæller kernen, at den skal
benytte tilstandsmodulet, ip_conntrack. Derefter er det
nødvendigt at bruge --state parameteren til at fortælle, hvilke
tilstande, der skal accepteres. Ud over ESTABLISHED og RELATED er
der bl.a. NEW og INVALID, som betyder at en pakke ikke tilhører
nogen kendt forbindelse.
</para>

<para>
Læg mærke til, at der ikke er mellemrum efter kommaet mellem de
to tilstande, det må der ikke være.
</para>

<programlisting>
     +-----------------------------------------------------------
    _|  udefra  ---> udefra-regel1 --> udefra-regel2 ---->regel3
   ^ |  kæden        PORT 80?          RELATED?           DROP!
   | +------------   ACCEPT            ACCEPT
  _|_____               |                 |
 /if eth1\              |                 |
|  else   |             |                 |
 \_______/------------> +-----------------+----------> Sendes videre
   |     
   |        
INPUT-chain

Lidt forsimplet af pladshensyn, man skal spørge både på
ESTABLISHED og RELATED i regel 1 i <emphasis> "udefra" </emphasis> regel kæden.
</programlisting>

<para>
Lad os nu antage, at vi slet ikke kan lide telnet protokollen,
heller ikke internt på det lille net, og derfor vil blokere for
al telnet. Nu er telnet jo så en applikationsprotokol, så vi kan
ikke bruge <command> --protocol </command> optionen, idet den kun
kender protokollerne tcp, udp, icmp eller "all", eller også et
nummer fra filen <filename> /etc/protocols </filename>.  Med
andre ord, telnet står ikke i <filename> /etc/protocols
</filename> og derfor må vi "sigte efter telnet" på en anden
måde, fx. ved at stoppe al trafik, som har destination port 23.
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -I INPUT -p tcp --dport 23 -j DROP </userinput>
</screen>

<para>
Der benyttes -I, insert, fordi reglen skal komme før
eth1-reglerne, hvis det skal nytte noget. Der står jo en accept
inde i eth1-reglerne, som kunne forstyrre billedet (lidt).
Nyere versioner af iptables vil kunne matche generelt på --ports
23, så det både er afsender/modtager pakker, som stoppes.
</para>

<para>
Eksemplet er ikke fuldkomment endnu, hvis maskinerne på
lokalnettet har "private IP-adresser" - så næste opgave går ud på
at opsætte NAT for lokalmaskiner.
</para>
</sect3>

</sect2>

<sect2 id="sikkerhed-start-nat">
<title>Opsætning af NAT</title>

<para>
NAT og Masquerading sker i nat-tabellens FORWARD kæde, når en
datapakke skal til at forlade maskinen. Det kan kun ske her.
Source adressen, som skal NATtes, er den interne eller private
adresse, men man kan også angive netværket ved at skrive 0 for
den sidste byte i en almindelig 192.168 - adresse og også angive
netmaske, typisk 192.168.1.0/24, så vil alle de lokale adresser
blive NAT-ede.
</para>

<para>
<command> iptables </command> har mange måder at angive adresser
på, navne, numre, netværk, og for NAT også intervaller m.v., så
hvis der opstår specielle behov, så kig lige en gang ekstra på
manual page for iptables. Det er bedre at nøjes med én regel, som
dækker flere adresser, end at have flere regler med hver deres
adresse.
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -t nat -A POSTROUTING --src 192.168.1.0/24  -o eth1 -j SNAT --to x.y.w.z   </userinput>
</screen>

<para>
Hvis man får en dynamisk IP adresse fra sin internet leverandør,
skal kommandoen se lidt anderledes ud, og så bruger man
betegnelsen <emphasis> masquerading </emphasis> om metoden.
Dynamiske adresser benyttes typisk med modemforbindelser, eller
når man har en Point-to-Point Protocol (PPP) forbindelse til sin
ISP. Man får en ny adresse hver gang. Linux kan tage denne
adresse og bruge som den officielle adresse for NAT-ing af
interne maskiner.  Masquerading er oftest dynamisk NAT,
med kun en ekstern adresse.
</para>

<para>
MASQUERADE target er kun muligt i <emphasis> nat </emphasis>
tabellen, og kun i POSTROUTING kæden. Dette target bør kun
benyttes med dynamiske IP-adresser.
</para>

<programlisting>
# Eksempel på anvendelse af MASQUERADE target:

       # Masquerade out ppp0
       iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE

       # Disallow NEW and INVALID incoming or forwarded packets from ppp0.
       iptables -A INPUT -i ppp0 -m state --state NEW,INVALID -j DROP
       iptables -A FORWARD -i ppp0 -m state --state NEW,INVALID -j DROP

       # Turn on IP forwarding
       echo 1 > /proc/sys/net/ipv4/ip_forward

</programlisting>

<para>
Man kan godt bestemme, hvilken port-range, som må bruges til
<emphasis> nat </emphasis> tabellen. Hvorfor skulle man gøre det?
I nogle tilfælde laver man huller i firewallen for at sikre folk
adgang til en bestemt protokol. Det er klart, at dette er en
sikkerhedsfaktor, men hvis man skal have glæde af en server, så
må der jo åbnes. Det kan evt. aftales med kendte brugere, at man
kun holder et mindre port-interval åbent for bestemte protokoller.
</para>

<para>
DNS forespørgsler kan bruges som eksempel.  Vi vil sætte en
intern DNS server op, en hjælpeserver, som husker nyligt brugte
adresser, så alle maskinerne på vores lille netværk ikke behøver
at spørge igen og igen ud over det overbelastede ISP link. Alle
på det interne net kan spørge denne maskine, men den skal være
fuldstændig lukket udadtil, bortset fra, at den skal kunne spørge
en remote DNS server. Det kaldes en DNS caching server. Til DNS
benyttes User Datagram Protokol, UDP, som let kan udsættes for
spoofing. Det ønsker vi at gøre alt for at forhindre. Det
forbedrer selvfølgelig sikkerheden at køre en DNS caching server
på en maskine for sig selv. 
</para>

<para>
Når hjælpeserveren skal foretage en forespørgsel, bruger den som
afsenderport et nummer som den får tildelt lidt tilfældigt, men
det vil ligge i intervallet 1024 - 65535. Det kaldes de
ikke-priviligerede porte. Netfilter skelner mellem 1-511, som er
såkaldt privilegerede, velkendte portnumre, som kun kræver root
privilegier, og som typisk bruges af specielle serverprogrammer
som fx. httpd, 512-1023, som også er priviligerede, og så 1024 -
65535, der kan anvendes til alt. Netfilter mapper ikke portnumre
fra en gruppe til en anden. (At mappe = at spejle eller sige a
svarer til X, b svarer til Y, c svarer til Z og så fremdeles, en
af de få ting, en computer er god til.) Man vil kunne begrænse
DNS-klienten til at bruge ganske få portnumre for forespørgsler,
og derved yderligere skærpe sikkerheden, men det er ikke
netfilters område. 
</para>

<para>
De eksterne DNS servere sender svar til det portnummer, som 
klienten brugte til at spørge.
</para>

<para>
Her kommer kommandoen, som tillader alle remote DNS servere at
svare til vores maskines eksterne netkort på en ikke-priviligeret
port:
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput> iptables -A INPUT -p udp -s 0/0 --source-port 53 -d 66.14.136.144/32 --destination-port 1024:65535 </userinput>
</screen>

<para>
Det ville være væsentligt bedre, hvis vi kun brugte en enkelt
server udenfor firewallen, men så begynder det at blive et stort
setup. Med den foreslåede lokale caching server kan anvendelsen
af udp på alle lokale maskiner begrænses til, at de kun må lave
UDP til denne specifikke IP-adresse. Her kommer kommandoerne, som
kan gøre det, idet vi antager, at caching serveren har
lokalnummeret 192.168.1.2:
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput> iptables -A INPUT -p udp -s 192.168.0.0/16 --destination-port 53 -d 192.168.136.144 -j ACCEPT</userinput>
<prompt>[root@hven /]#</prompt> <userinput> iptables -A INPUT -p udp -s 192.168.1.2/16 --source-port 53 -d 192.168.0.0/16 1024:65535 -j ACCEPT</userinput>
<prompt>[root@hven /]#</prompt> <userinput> iptables -A INPUT -p udp -j DROP</userinput>
</screen>

<para>
Som man kan se er det lidt mere besværligt at kontrollere UDP,
fordi man ikke kan regne med connections - alle pakker er som en
enkeltstående begivenhed. Det er en statusløs protokol.
Rækkefølgen er kritisk. Det ville være en god ide at bruge -i for
interface specifikation, så firewallen styrer på IP nummer og
hardware.
</para>

<para>
Ligesom for tcp protokollen loades der et extension modul, når vi
specificerer -p udp. De ekstra kriterier, som dette modul giver
mulighed for, er dog kun portnumre for hhv. source og
destination. Det ovenstående eksempel specificerer, at alle
inputporte over 1023 må bruges.  Det ville være meget bedre at
sige til DNS-forwarder programmet at det kun må bruge fx. port
32109. Ved at bruge fast portnummer for hjælpeserverens udgående
trafik kan antallet af åbne porte begrænses meget.
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput> iptables -A INPUT -p tcp ! --syn --source-port 20 --destination-port 1024:65535 -j ACCEPT </userinput>
</screen>

<para>
Her vises en måde at åbne for alle FTP-pakker udefra, som ikke
forsøger at indlede en konversation. Optionen --syn betyder, at
pakker, som ikkehar syn-flaget (synkroniserings-request) sat,
skal have lov at passere. Det er en anden måde at specificere, at
maskiner indenfor firewallen skal have lov til at gøre alt, men
alligevel beskyttes de såkaldt priviligerede porte i intervallet
1 - 1024. En angriber kan godt sende en pakke, som ikke har syn
flaget sat, men det er jo sværere at komme igennem til noget
sårbart, når man nu ikke kan sende til portnumre under 1024.
</para>

<para>
En måske mere avanceret anvendelse af port-ranges er at åbne for et
mindre område ved source NAT-ing; man reserverer et interval til
et bestemt formål og kan på remote maskinen filtrere alle andre
afsenderporte fra. Mange netværksprogrammer har en mulighed for
at brugeren specificerer, hvilke porte, der må bruges.
</para>


<screen>
<prompt>[root@hven /]#</prompt> <userinput> iptables -t nat -A
POSTROUTING -j SNAT --to 129.142.141.140:47000-49000
</userinput>
</screen>

<para>
Et eksempel på anvendelse af multiport extension, hvor der åbnes
for (kendte) serverporte i et hug (mere effektivt, mindre load på
firewall):
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput> iptables -A INPUT -p tcp -m mulitport --dport 21,25,80,110,143,443 -j ACCEPT </userinput>
</screen>

<para>
I det efterfølgende eksempel bliver port specifikationer brugt
til at omdirigere trafikken, en stærk feature, når man vil lave
en HTML proxy.
</para>

</sect2>



<sect2 id="sikkerhed-grundig-NAT">
<title>Source/Destination NAT og omdirigering</title>

<indexterm><primary>NAT</primary></indexterm>
<para>
I det følgende ses på henholdsvis source NAT og destination NAT.
I source NAT er det afsenderens adresse+port, som oversættes til
gateway-adresse + en anden port. I Destination NAT sendes pakker,
som egentlig er til a.b.c.d i stedet til x.y.z.q, hvilket jo
strengt taget blot er en omdirigering.
</para>

<para>
Destination NAT rummer imidlertid mange muligheder, og er
nødvendigt, når fx. 1000 klienter i sekundet spørger på Google,
der i snit måske er 1/100 sekund om at svare. Man kan hurtigt
regne ud, at de har mange servere kørende!
</para>

<sect3 id="source-NAT">
<title>Source NAT</title>
<indexterm><primary>Source NAT</primary></indexterm>

<para>
Source NAT er det almindeligste, og er det, som vi hidtil har set
på <!--TODO reference/--> i forbindelse med i192.168-numre
klienter bag en firewall. Man kan sige, at vi spejler, (mapper,
afbilder) source adressen plus portnummer som en global
(offentlig) IP adresse med et andet portnummer.  Derved kan mange
lokale maskiner deles om et enkelt IP nummer. Teoretisk set kan
man løbe tør for portnumre på NAT maskinen, og det er der skam
også taget højde for, idet maskinen simpelthen dropper alle
pakker som ikke kan mappes til dens range af IP-numre+portnumre.
</para>
</sect3>

<sect3 id="destination-nat">
<title>Destination NAT</title>

<indexterm><primary>Destination NAT</primary></indexterm>

<para>
Man kan også mappe (afbilde) destinationsadressen - Destination
NAT - så folks forespørgsler f.eks. bliver omdirigeret hen til
den lokale webserver eller til en server ud af en server pool. 
</para>

<para>
For TCP og UDP kan man lave portmapping med iptables, hvor man skifter
destinationsporten ud. F.eks. kan en klient oprette en forbindelse til
en web-server på port 80, og NAT-serveren kan afbilde pakkerne til sin
egen port 3128, hvor der kører en squid. Dette kaldes redirect,
men er også en form for destination NAT. Resultatet er transparent proxying.
</para>

<para>Lav destination NAT til ip 1.2.3.4, 1.2.3.5 eller 1.2.3.6</para>
<programlisting>
# iptables -t nat -A PREROUTING -i eth1 -j DNAT --to 1.2.3.4-1.2.3.6
</programlisting>

<para>
Fordelingen til serverne nr. 4 - 6 sker efter tur. Det kaldes
ofte round-robin princippet. Derved kan man få fordelt
belastningen til flere servere. Det egner sig ikke til CGI eller
.php løsninger, hvor man skal fastholde en klient, hertil kræves
en router, som kan holde styr på connections og samtidig lave
round robin.
</para>

<para>Lav destinations NAT fra port 80 til den lokale port 3128, hvor squid kører</para>
<programlisting>
# iptables -t nat -A PREROUTING -i eth1 -p tcp --dport 80 \ 
-j REDIRECT --to-port 3128
</programlisting>

<para>
Eksemplerne er taget mere eller mindre direkte fra Linux 2.4 NAT HOWTO, og
er blot ment som illustration af, hvad man kan med iptables NAT.
</para>

<para>
For nærmere beskrivelse, se Linux 2.4 NAT HOWTO på <ulink
url="http://www.netfilter.org/unreliable-guides/NAT-HOWTO/index.html">
http://www.netfilter.org/unreliable-guides/NAT-HOWTO/index.html</ulink>
Se desuden man-siden for iptables.
</para>

</sect3>
</sect2>

<sect2 id="sikkerhed-komplet-firewall">
<title>En komplet firewall</title>

<para>
Selv om der allerede er givet eksempler på en firewall <xref
linkend="sikkerhed-really-quick-guide" /> så vises her en lidt
større konfiguration af en firewall. Eksemplet er valgt 
ud fra det kriterium, at det skal være en opsætning,
som har fungeret og har vist sig at være stabil.
</para>

<para>
Setuppet er, at vi har en maskine, som har forbindelse til vores
ISP med fast (eller næsten fast) adresse, 130.3.2.99. Den skal
være gateway og firewall. Desuden står der et antal maskiner i
vores lille computerworkshop, og de må gerne snakke med
internettet gennem vores gateway/firewall, men da de ikke har
"private adresser" må vi også sørge for, at firewallen laver NAT.
Desuden vil vi gerne have, at firewallen er web-server. Dette er
ikke realistisk for en virksomhed, som ønsker high-speed,
ultimativ sikkerhed, her ville man sørge for at fordele
belastningen på flere maskiner, men realistisk nok for at
demonstrere mange pointer.  </para>

<para>
Firewall maskinen har 2 netkort, eth0 og eth1. På eth0 er den
forbundet til en hub på det interne net, og på eth1 er der hul
til ISP'ens gateway, der har nummer 130.3.2.1, en såkaldt klasse
B adresse, som har netmaske 255.255.255.0 så den fungerer som en
klasse A adresse, med max 255 maskiner i netværket.
</para>

<para>
Det interne net har adresser i området 192.168.67.0 - 255. Det er
for at være lidt på tværs, at jeg altid anbefaler andet end
192.168.1.1-254 om ikke andet, så kan de værste root-kit til
intrusion på lokalnet herved vanskeligere få adgang ved spoofing.
</para>

<para>
Vi starter med at konstatere, at man ikke kan lave en default
policy som kun gælder for det ene netkort. Derfor adskilles
trafikken, således at alt input fra eth1 ledes igennem en kæde,
som kaldes door1.
</para>

<para>
Door1 skal ende med at droppe al trafik, som vi ikke ønsker ind i
vores netværk. De ting, som vi gerne vil have med, skal
accepteres med en kommando -j ACCEPT.
</para>

<para>
Det aller første, scriptet gør, er at sikre, at netfilter delen i
kernen er i en kendt tilstand, d.v.s. vi flusher alle regler i
alle kæder og sætter alle default policies. Hvis man prøver at
optimere ved kun at foretage de nødvendige ting for ens opsætning
efter et boot, så skal man lige sørge for at have en version
liggende, som kan klare <emphasis> alle </emphasis> situationer.
</para>

<para>
Det næste, der sker, er at kæden door1 slettes. Det sker
selvfølgelig for at sikre, at der ikke ligger rester af andre
regler i door1.
</para>

<para>
Det kan gøres på mange mange andre måder, men denne her metode er
valgt efter lidt eksperimenteren. Man får også nulstillet
tællerne for door1, og fejlene er ikke nogen, som får systemet
til at hænge, hvilket vistnok har kunnet forekomme med nogle af
de iptables options, som giver fejl, hvis man kører dem
selv om de ikke er nødvendige. Læseren kan eksperimentere med at
flushe kæden door1 i stedet for (også hvis den ikke findes).
</para>

<para>
Næste skridt er så at oprette kæden door1. Nu er den tom - ingen
regler, ingen forbindelse med andre kæder. Lister man med -L
kommandoen, får man at vide "no references", svarende til død
kode eller ubrugt variabel.
</para>

<para>
Nu installeres regel efter regel i firewallen. De vigtigste er
stadig dem, som tillader brugere indefra at kommunikere frit, men
man skal lige huske, at denne trafik altid starter med input fra
eth0, som vi slet ikke ser i denne door1 kæde. Indtil videre er
der fri passage indefra og ud. Det er først til sidst, at der
etableres en regel som siger, at al indadgående trafik fra eth1
skal via door1. Det kunne lige så godt have været først, og under
alle omstændigheder må man kun aktivere eth1, når alle reglerne i
firewallen er opsat. Man kan godt opsætte regler for et
interface, som er "down", <command> ifconfig eth1 down
</command>.
</para>

<para>
Der åbnes for al trafik til ssh-porten, både den indefra-ud og
udefra-ind.  Ligeledes åbnes der for al trafik til http porten.
</para>

<para>
Næste regel åbner for indkommende trafik, der stammer fra port
53, nameservere.
</para>

<para>
Nu kommer en regel, som kun skal benyttes, hvis ISP benytter DHCP
til kontrol af IP, nameservices og routing. Det er en god ting
og forhindrer slet ikke, at man selv styrer konfigurationen.
</para>

<para>
Der åbnes også for ping. Det er ikke et krav for en firewall, men
er ok at gøre på en maskine, der står udenfor en firewall men
inden en gateway. I eksemplet her er gateway og firewall den
samme, men det er ok at åbne for ping/ICMP, hvis man holder øje
med trafikken.
</para>

<para>
Endelig kommer de spændende linier, hvor der åbnes for indgang
for alt, hvad der er svar på forbindelser etableret indefra.
</para>

<para>
Dernæst er der kun opsætning af NAT-ing og aktivering af
forwarding.
</para>

<programlisting>

#/bin/ksh

iptables -t filter -F
iptables -t nat    -F
iptables -t mangle -F
iptables -X door1 2> /dev/null 1>&2
iptables -N door1

iptables -A door1 -m state --state INVALID -j DROP
# åbne for al ssh og http
iptables -A door1 -p tcp --sport ssh  -j ACCEPT
iptables -A door1 -p tcp --dport ssh  -j ACCEPT
iptables -A door1 -p tcp --sport http -j ACCEPT
iptables -A door1 -p tcp --dport http -j ACCEPT
# åbne for svar fra nameserere, DNS.
iptables -A door1 -p udp --sport 53   -j ACCEPT
# der åbnes for konversation med dhcp serveren på gatewayen.
iptables -A door1 -p udp --source 130.3.2.1 --dport bootps -j ACCEPT
# åbne for ping (mange vil foretrække at lukke i stedet!)
iptables -A door1 -p icmp             -j ACCEPT
# Alt, hvad der er etableret indefra, accepteres.
iptables -A door1 -m state --state ESTABLISHED,RELATED  -j ACCEPT
# alt andet smides væk.
iptables -A door1 -j DROP

# Hop til door1 hvis input er fra eth1
iptables -A INPUT -i eth1 -j door1

# NAT-ing sættes op, så alt, hvad der kommer fra lokalnettet,
# bliver videresendt som om det kommer fra firewallen.
iptables -t nat -A POSTROUTING --src 192.168.67.0/24 \
         -o eth1 -j SNAT --to 130.3.2.99

# for at det skal fungere, må vi aktivere forwarding:
echo 1 >> /proc/sys/net/ipv4/ip_forward

</programlisting>

<para>
Der er mange andre ting, man kan foretage sig, for at maskinen
bliver sikret: <ulink url="http://www.bastille-linux.org/">
http://www.bastille-linux.org/</ulink>. Det kaldes også
"hardening", hærdning, af et system. For eksempel anbefales det
på udsatte systemer at fjerne de tools, som en
systemadministrator bruger til sletning, kopiering og omdøbning
af filer, mount, diskformatering, oprettelse af filsystemer mv.
Hvis en cracker opnår root-privilegier, vil aktionsmulighederne
derved være begrænset. Men det vil for de fleste private medføre
irritationsmomenter i det daglige arbejde.  Man kunne
selvfølgelig have en supplements-server stående, som man lige
kunne hooke op når man havde brug for det ...
</para>

<para>
Sådan er der så mange ting, man kunne gøre. De fleste af disse
tiltag beskrives i sidste afsnit <!--TODO xref linkend="" /-->
</para>

<para>
Kommentarer til ovenstående firewall er velkomne, særligt hvis
der er konkrete ting, som er afprøvet, men også kommentarer, som
bevæger sig i yderkanten af emnet.
</para>

<para>
</para>

</sect2>



<sect2 id="proxy-server">
<title>Linux som proxy server</title>

<para>
I det følgende beskrives den situation, at en virksomhed med 40
ihærdige brugere på en 2 Megabit forbindelse ønsker at forbedre
browser-response, således, at når en person har hentet en
web-side, så kan de andre hente den samme web-information lokalt
fra en server med buffer, en såkaldt caching proxy.
</para>

<sect3 id="proxy-squid">
<title>Proxy med Squid</title>

<para>
Squid er en god proxy server bl.a. til Linux, der kan findes på 
<ulink url="http://www.squid-cache.org/">http://www.squid-cache.org/</ulink>. Squid
er en agent, der henter de hjemmesider, brugeren beder om, og
videresender resultatet til brugeren. Samtidig kan Squid fungere som
proxy-cache - den gemmer hjemmesiden i cache, og er der nu en anden
bruger, der vil se den samme hjemmeside, hentes den direkte fra den
lokale hukommelses- eller disk-cache på proxy-maskinen - det vil sige,
uden at man skal via internettet. Squid tester, om en hjemmeside på
nettet er nyere end den i cachen, og kun hvis cachen er forældet, vil
en ny version blive hentet. Fordelen ved en proxy-cache er således, at
man ofte kan spare måske 50% på båndbredden.
</para>

<para>
Det er naturligvis ikke alt, som kan gemmes i en cache, f.eks.
skal cgi-kald netop ikke køre fra cache. Disse hindringer
håndterer Squid dog transparent. Ud over hjemmesider (HTTP) er FTP,
GOPHER, SSL og WAIS protokollen understøttet. Squid kan dog ikke klare
POP-mail, NNTP (News grupper) og RealAudio.
</para>
</sect3>

<sect3 id="installation-squid">
<title>Installation af Squid-serveren</title>


<indexterm><primary>Squid</primary><secondary>installation</secondary></indexterm>
<para>
Man bør ikke installere Squid, så den kører som root. Ofte vælger man
at lade Squid køre som brugeren <command>squid</command> i sin egen gruppe
<command>squid</command>, og kun med få rettigheder.
</para>

<para>
Vi har installeret <filename>squid-2.2.STABLE5-1.i386.rpm</filename>,
som kan hentes fra <ulink
url="http://www.squid-cache.org/">http://www.squid-cache.org/</ulink>. Squid
startes op via <filename>/etc/rc.d/init.d/squid</filename>. Squids
opsætningsfil hedder <filename>/etc/squid/squid.conf</filename>. Der er
<emphasis>mange</emphasis> konfigurationsmuligheder. Basalt set skal
man fjerne kommentartegnene fra nogle linjer i
<filename>/etc/squid/squid.conf</filename> og udkommentere andre, og
så starte Squid.  Den originale
<filename>/etc/squid/squid.conf</filename> er stor, og vi vil nu se
nærmere på en simpel opsætning af squid.
</para>

<sect4 id="basal-squid-conf">
<title>Basal opsætning af squid.conf</title>

<indexterm><primary>squid.conf</primary></indexterm>
<para>
Man kan i <filename>/usr/doc/squid-2.2.STABLE5/QUICKSTART</filename>
finde en minimal beskrivelse af parametre for
<filename>squid.conf</filename>. En meget bedre gennemgang fås ved at
læse brugermanualen til Squid, som kan findes på 
<ulink url="http://www.squid-cache.org/Doc/Users-Guide/">http://www.squid-cache.org/Doc/Users-Guide/</ulink>.
En anden god start er også at læse (og gemme) den originale
<filename>/etc/squid/squid.conf</filename>, som fulgte med RPM-pakken.
</para>

<para>
Vi skal nu vise en kort <filename>squid.conf</filename>, hvor vi lader squid køre som 
brugeren <filename>squid</filename>.
</para>

<programlisting>
#squid.conf -  Basal opsætning

#Laveste niveau af logging
debug_options ALL,1

#Gruppe af IP numre, som kan tilgå Squid (Access Control List) 
#Vil man kun give access til netværket 192.168.0.0/255.255.255.0
#så brug følgende linje
acl all src 192.168.0.0/255.255.255.0

#Skal alle kunne bruge Squid så udkommenter følgende linje.
#acl all src 0.0.0.0/0.0.0.0

#Port, man anvender til konfiguration af Netscape klienter
http_port 3128

#Lad alle i ACL bruge Squid til HTTP
http_access allow  all

#test følgende sites for at tjeke, om maskinen er koblet til internettet
dns_testnames internic.net usc.edu cs.colorado.edu mit.edu yale.edu

#Kør som effektiv bruger squid og gruppe squid
cache_effective_user squid squid

# Squid vil oftest bruge to-tre gange denne RAM størrelse. Vil man max
# bruge 24 Mb RAM til Squid, så sæt cache_ram til 8 Mb. 
# Jo mere cache_mem desto hurtige er cachen (mindre diskaccess).
cache_mem  8 MB

#Maximal størrelse på object i cache
maximum_object_size 4096 KB

# Næste parameter-opsætning er disk cache struktur. Parametre er
#  Dirname - hvor på disken er disk cache, dvs. spool dir
#  Mbytes under spool dir - hvor mange Mb må gemmes i disk cache.
#  Level-1 dir antal - Antal underkataloger under Dirname
#  Level2 dir antal - Antal underkataloger for hver Level-1 kataloger
# Sæt ikke produktet mellem de to sidste vildt højt!
cache_dir /var/spool/squid 100 16 256
</programlisting>


<para>
Lad os se nærmere på, hvad der installeres, og hvordan squid
kører. Installer squid med 
</para>

<programlisting>
#rpm -ivh squid-2.2.STABLE5-1.i386.rpm
</programlisting>

<para>
Ret <filename>/etc/squid/squid.conf</filename> til som vist ovenfor. Husk dog at gemme 
den originale <filename>/etc/squid/squid.conf</filename> før ovenstående eksempel anvendes.
</para>

<itemizedlist mark="bullet">

<listitem><para><filename>/etc/squid/</filename> indeholder konfigurationsfiler - specielt er
<filename>/etc/squid/squid.conf</filename> vigtig.</para></listitem> 

<listitem><para><filename>/var/spool/squid</filename> indeholder den dynamiske database. (se
parameteren <filename>cache_dir</filename> i <filename>squid.conf</filename>). Over 4000 filer laves med
ovenstående opsætning.</para></listitem>

<listitem><para><filename>/var/log/squid</filename> indeholder log-filer.
</para></listitem>
<listitem>
  <itemizedlist mark="bullet">
    <listitem><para><filename>access.log</filename> - Hvad blev hentet
    fra  nettet. 
    Her kan systemadministratoren overvåge trafik.</para></listitem>
  <listitem><para><filename>cache.log</filename> - Opstartsmeddelelser.</para></listitem>
<listitem><para><filename>store.log</filename> - Oversigt over, hvad der findes i proxy-cache nu.</para></listitem>
  </itemizedlist>
</listitem>

</itemizedlist>

<para>
Med installation af squid blev <filename>squid</filename> brugeren og
tilsvarende gruppe oprettet. Kataloget
<filename>/var/spool/squid</filename> er tomt men ejet af brugeren
squid. Selve databasestrukturen skal man en gang for alle sætte op -
hertil bruges parameteren <filename>cache_dir</filename>.
</para>

<screen>
<prompt>[root@sherwood root]#</prompt> <userinput>/usr/sbin/squid -z</userinput>
</screen>

<para>
Anvender man 16 og 256 som de sidste to parametre til <filename>cache_dir</filename>, skal
man ikke blive bange, når man initialiserer databasen. Der køres hårdt på
harddisken, og det tager måske flere minutter - databasen bliver stor!
</para>
</sect4>

<sect4 id="squid-bruger">
<title>Brugerens opsætning</title>

<indexterm><primary>Proxy klient</primary></indexterm>
<para>
For at man kan få squid til at virke sammen med lynx og wget, kan man
sætte følgende environment variable 
(her hedder vores proxy-server "proxy.herne.dk")
</para>

<programlisting>
% setenv http_proxy http://proxy.herne.dk:3128/
% setenv gopher_proxy http://proxy.herne.dk:3128/
% setenv ftp_proxy http://proxy.herne.dk:3128/ 
</programlisting>

<para>
I Netscape skal brugerne under
<filename>Edit->Preferences->Advanced->Proxies</filename> vælge
<filename>Manual proxy configuration</filename> og tryk på
<filename>View</filename>. Som det kan ses på det næste billede, skal
man skive navnet på proxy maskinen (her anvender vi
<filename>proxy.herne.dk</filename>), og port 3128 svarer til
parameteren "http_port" i <filename>squid.conf</filename>.
</para>

<figure id="proxy-fig" float="1">
<title>Proxy opsætning i Netscape</title>
<graphic fileref="proxy.&magic;"  scale="40"></graphic>
</figure>  



<para>
Squid er i dagligdagen et meget driftsikkert program og kan anbefales.
Vi skal dog lige huske at nævne, at hvis der ikke er blokeret for det
via en firewall, så kan brugeren af Netscape faktisk godt køre
forbi proxy cachen ved enten at udelade proxy-opsætningen eller 
at holde SHIFT nede, før der trykkes på et
link. Derfor skal firewallopsætningen være lavet, så
proxy-programmet godt kan hente data fra internettet, men at brugere
ikke kan - hvis man virkelig ønsker, at folk skal bruge
proxy-serveren.
</para>

<!--TODO Her skal man forklare om redirection med iptables /-->

</sect4>
</sect3>

<sect3 id="transparent-proxy">
<title>Transparent proxy med squid</title>

<indexterm><primary>transparent proxy</primary></indexterm>

<para>
Man kan lave transparent proxy med squid sammen med iptables.
Kernen skal være oversat med "Transparent proxying". Se
<xref linkend="destination-nat"/>
</para>

<para>
Der findes også en mini-HOWTO på <ulink
url="http://sunsite.dk/ldp/HOWTO/mini/TransparentProxy.html
">http://sunsite.dk/ldp/HOWTO/mini/TransparentProxy.html
</ulink>.
</para>
</sect3>
</sect2>

<sect2 id="masquerading-med-ipchains">
<title>Masquerading med ipchains (kerne 2.2)</title>

<indexterm><primary>Masquerading</primary></indexterm>

<para>
I Linux-kerne 2.2 hedder firewall kommandoen <command> ipchains </command>, og denne
kommando bruges også til opsætning af masquerading.
</para>

<para>
Forwardkæden sættes op med en default target MASQ eller, hvis
default politik (policy). Den kan stadig væk smide væk, men i
<command> ipchains </command> hedder det DENY.
</para>

<para>
Den simple og hurtige måde at sætte IP masquerading op på er:
</para>

<screen>
<prompt>[root@myhost /root]#</prompt> <userinput>ipchains -A forward -i ppp0 -j MASQ</userinput>
<prompt>[root@myhost /root]#</prompt> <userinput>ipchains -A forward -s 0.0.0.0/0 -d 0.0.0.0/0 -l -j REJECT</userinput>
<prompt>[root@myhost /root]#</prompt> <userinput>echo 1 > /proc/sys/net/ipv4/ip_forward</userinput>
</screen>

<para>
hvor ppp0 er det interface, der peger ud imod verden, imod internettet, imod 
det net, man vil give sine maskiner adgang til via masquerading.
</para>

<para>
Det kan også give mening at sætte timeouts for masquerading forbindelserne:
</para>

<screen>
<prompt>[root@myhost /root]#</prompt> <userinput>ipchains -M -S 7200 10 160</userinput>
</screen>

<para>
Det første tal er timeout for en tcp forbindelse, det næste er hvor
længe en tcp forbindelse skal kunne eksistere efter modtagelsen af en
FIN pakke, og det sidste er timeout for UDP. Timeout tiderne er i
sekunder. Default timeout er 15 minutter, og det kan være lidt kort
for en tcp session.
</para>

<para>
Nu sættes de andre maskiner i lokalnetværket til at bruge myhost som
default gateway, og voila! Man kan komme på internettet fra de andre
maskiner. 
</para>

<sect3 id="ipchains-moduler">
<title>Moduler til ipchains</title>

<para>
Og dog. Http mm virker nu, men der er et par protokoller, der kræver særlige 
hensyn. Det er bla. ftp, realaudio, irc og forskellige spil.
</para>

<para>
For at kunne bruge ftp, real audio, irc, spille quake mm via
masquerading, er vi nødt til gøre det lidt mere indviklet. Der findes
moduler til <command> ipchains </command>, der kan håndtere en del forskellige
applikationer: ip_masq_ftp, ip_masq_raudio, ip_masq_irc, ip_masq_quake
etc. For at kunne bruge disse moduler, skal de være oversat med, da
man lavede kernen. Det er inde under networking options, hvor man skal
slå "IP masquerading special module support" og "ipportfw masq
support" til. I kerne 2.2.12 er det nødvendigt at slå "prompt for
development and/or incomplete code/drivers" til for at få lov til at
vælge ipportfw.
</para>

<para>
Modulerne indlæses nu med:

<screen>
<prompt>[root@myhost /root]#</prompt> <userinput>/sbin/modprobe ip_masq_ftp</userinput>
<prompt>[root@myhost /root]#</prompt> <userinput>/sbin/modprobe ip_masq_raudio</userinput>
</screen>
</para>

<para>
Nu virker ftp og realaudio fra de andre maskiner. Gør det samme med
de andre moduler, der skal bruges. Der findes også et værktøj, der hedder 
IPMASQADM, man kan bruge. 
Der findes en slags beskrivelse af emnet i IP-Masquerade-HOWTO'en på
<ulink url="http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO-6.html#ss6.8">http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO-6.html#ss6.8</ulink>
</para>
</sect3>

<sect3 id="opsaetning-andre-maskiner">
<title>Opsætning af de andre maskiner i nettet</title>
<para>
Default gateway sættes med kommandoen <command>route</command>:
</para>

<programlisting>
route add default gw myhost
</programlisting>

<para>
Hvis det skal være permanent, er der lidt forskel på distributionerne.
Nogle har et fint konfigurationsværktøj, det vil vi ikke komme ind på
her. I SuSE er det en <filename>/etc/route.conf</filename>, man kan
sætte det ind i.  I debian er det direkte i
<filename>/etc/init.d/</filename> i et netværks startup script.  I
RedHat er det filen <filename>/etc/sysconfig/network</filename>, man
sætter sin default gateway ind i.
</para>

<para>
For yderligere information om IP masquerading kan man læse
IP-Masquerade-HOWTO'en
<ulink url="http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO">http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO</ulink> .
HOWTO'en indeholder også referencer til en række gode ressourcer.
</para>

</sect3>
</sect2>
</sect1>



<sect1 id="firewall-test">
<title>Afprøvning af en firewall</title>
 <indexterm>
  <primary>firewall</primary>
  <secondary>afprøvning</secondary>
 </indexterm>
 <indexterm>
  <primary>afprøvning af en firewall</primary>
 </indexterm>
<indexterm><primary>Firewall</primary><secondary>test</secondary></indexterm>
<indexterm><primary>Test af firewall</primary></indexterm>
<para>
Når man har sat sin firewall op, skal man altid undersøge, 
at den virker som forventet.</para>

<itemizedlist mark="bullet">

<listitem><para>
  <emphasis>Funktionalitet: </emphasis>Test at de services, der skal
  kunne benyttes, virker. Både indefra og udefra. Der er dog stor
  chance for, at brugerne nok skal fortælle meget hurtigt, hvis det
  ikke er tilfældet.
</para></listitem>

<listitem><para>
  <emphasis>Sikkerhed: </emphasis>Test at firewallen rent faktisk
  lukker for de ting, den burde. Prøv at bruge services, der skulle
  være lukket for, ved at prøve at oprette forbindelser
  udefra. Portscan firewallen for at se, hvad folk kan få at vide om
  den udefra. Der findes også mere omfattende tests. Man kan forsøge
  sig med diverse cracker-programmer, eller man kan betale andre for
  at teste firewallen.
</para></listitem>

<listitem><para>
  <emphasis>Vedligeholdelse: </emphasis> Hold altid softwaren på
  firewallen opdateret med de nyeste sikkerhedsrettelser. Læs altid
  logfiler.
</para></listitem>
</itemizedlist>

</sect1>

<sect1 id="epilog4">
<title>Epilog</title>

<para>
Firewallløsninger kan ikke beskrives fuldstændigt her. Vi
har taget en del af Linux-mulighederne, men der er meget, vi ikke har dækket:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
    Trusted Information Systems Firewall Toolkit (FWTK): Se 
    <ulink url="http://www.fwtk.org/fwtk/">http://www.fwtk.org/fwtk/</ulink>
  </para></listitem>
  <listitem><para>
    T.REX: Open Source firewall: Se <ulink url="http://www.opensourcefirewall.com/">http://www.opensourcefirewall.com/</ulink> 
  </para></listitem>
  <listitem><para>
    En side med mange links om firewalle: Se <ulink url="http://www.linux-firewall-tools.com/linux/">http://www.linux-firewall-tools.com/linux/</ulink>
  </para></listitem>
  <listitem><para>
    Firewall-1 er en fuld kommerciel firewall: 
    Se <ulink url="http://www.checkpoint.com/products/firewall-1/">http://www.checkpoint.com/products/firewall-1/</ulink>
  </para></listitem>
  <listitem><para>
    Socks5 er en proxy server, der anvendes mange steder. 
    Se <ulink url="http://www.socks.nec.com">http://www.socks.nec.com</ulink>
  </para></listitem>
  <listitem><para>
    Mange gode netværkssikkerhedsværktøjer og ressourcer findes på
    <ulink url="http://www.freefire.org">http://www.freefire.org</ulink>
  </para></listitem>
  <listitem><para>
    En opskrift på test af firewall kan læses på <ulink url="http://linuxtoday.com/news_story.php3?ltsn=2001-05-04-015-20-SC">http://linuxtoday.com/news_story.php3?ltsn=2001-05-04-015-20-SC</ulink>.
  </para></listitem>
</itemizedlist>


</sect1>

<!-- TODO: Dette afsnit kan måske komme i et appendix eller hvad?
 /-->

<sect1 id="sikkerhed-xconf-netfilt-help">
<title>Oversættelse af xconfig netfilter configuration help
tekst.</title>

<para>
Netfilter er en række faciliteter til at filtrere og berarbejde
de pakker, som kommer igennem din Linux box.
</para>

<para>
Den mest almindelige anvendelse af netfilter er at bruge din
Linux box som firewall, der beskytter et lokalt netværk mod
Internettet. Den type firewall, som denne kerne supporterer,
kaldes et pakkefilter, hvilket betyder, at den kan afvise
individuelle pakker baseret på type, afsenderadresse, modtager
etc. Den anden slags firewall er "proxy-baseret", den er mere
sikker men mere besværlig at sætte op. Den inspicerer
netværkstrafikken meget mere i detailler, modificerer den og har
viden om de højere protokol-lag, som et pakkefilter ikke ved
noget om. Endvidere kræver proxy'er ofte ændringer i de
programmer, som kører på den lokale klient. Proxy baserede
firewalls har ikke brug for support i kernen, men de er ofte
kombineret med et pakkefilter, som kun virker, hvis du siger Y
(Yes, ja) her.
</para>

<para>
Du bør sige Y her, hvis du har tænkt dig at bruge Linux som en
gateway til Internettet for et lokalt netværk af maskiner uden
globalt gyldige IP-adresser. Dette kaldes masquerading: Hvis en
af dine lokale maskiner ønsker at sende noget til verden udenfor,
kan din box "forklæde sig" (maskere sig) som den maskine, d.v.s.
den videresender pakkerne til den angivne ydre destination, men
modificerer pakkerne, så de ser ud, som om de kommer fra
firewall-boxen selv. Det fungerer begge veje: Hvis hosten udenfor
svarer, vil linuxboxen uden yderligere kommentarer sende pakkerne
videre til den rigtige lokale computer. På denne måde er
maskinerne på indersiden af firewallen fuldstændig usynlige for
verden udenfor, selv om de kan nå udenfor og får svar. Det er
endog muligt at køre globalt synlige servere inde fra et
masqueraded lokal netværk ved at anvende en mekanisme, som kaldes
port-forwarding. Masquerading kaldes også ofte NAT (Network
Address Translation)<footnote>
<para>
NAT bruges dog oftest om en gateway, som har flere IP adresser,
som den kan bruge for mapning af de lokale maskiner. Det er som
regel nok med 2 - 3 stykker, idet man sjældent løber tør for
portnumre som jo er en 16-bit størrelse. Masquerading har
yderligere den egenskab, at det oftest kan sættes op til at ske
automatisk på et dynamisk tildelt IP-nummer for en klient, som
fx. benytter PPP på en modem-linje.
</para>
</footnote>.
</para>

<para>
En anden anvendelse er transparent proxy-ing. Hvis en maskine på
lokalnettet prøver at få skabe forbindelse til en maskine
udenfor, kan Linux-boxen uden at det mærkes sende pakkerne til en
lokal host, som typisk vil være en caching server.
</para>

<para>
Der er forskellige moduler, som erstatter tidligere masquerading
(ipmasquadm), packet filtering, transparent proxying og
portforwarding mekanismer. Se venligst ~kernel/Documentation/Changes
for placeringen af af disse pakker.
</para>

<para>
Vær sikker på at svare N til "Fast switching" nedenfor, hvis du
siger ja til netfilter her, eftersom "Fast switching" i den
aktuelle version laver bypass på netfilter.
</para>

<para>
Du bør nok sige Y her, hvis du oversætter en kerne, som skal
fungere som router, og N, hvis det er til en almindelig host.
Hvis du er usikker, så svar Y.
</para>

<para>
[Oversætterens anmærkning: Det er i dag bedst at sige Y til
netfilter, idet man også på et lokalnet kan have fordel af at
kunne spærre af for uønskede pakker udefra. De store
distributioner har det altid med.]
</para>

</sect1>


<sect1 id="sikkerhed-hardening">
<title>System hærdning</title>

<para>
Hærdning af kernen er relevant på en firewall. Man kan for
eksempel tilføje flg. til sit firewall script:
</para>

<programlisting>
# Svar ikke på ping
/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all

# undgå at være med til smurf angreb
/bin/echo "0" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
# Tillad ikke source routing
/bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route
/bin/echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects
/bin/echo "1" > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses
for i in /proc/sys/net/ipv4/conf/*; do
    /bin/echo "1" > $i/rp_filter
done
# Log forsøg på source routing samt redirect
/bin/echo "1" > /proc/sys/net/ipv4/conf/all/log_martians
/bin/echo "0" > /proc/sys/net/ipv4/ip_forward

</programlisting>

<para>
Det kræver en speciel kerne, hvor de forskellige nødvendige
features er aktiveret. Man kan fx. godt køre en firewall på en
kerne, som ikke har logging af fremmede (spoofede) pakker, også
kaldet mars-boere, "Martians".
</para>

</sect1>
</chapter>




