<!-- $Id$ -->
<chapter id="Linux-firewalling">
 <title>Firewall på Linux</title>

 <sect1 id="hvad-er-firewall">
  <title>Hvad er en firewall?</title>

  <indexterm>
   <primary>dørvogter</primary>
  </indexterm>

  <indexterm>
   <primary>firewall</primary>
  </indexterm>

<para>
At forbinde sin virksomheds eller sit kollegiums lokale
computernetværk direkte til internettet kan være en risikabel
ting at gøre, for man åbner jo for trafik begge veje, altså også
for trafik ind på det lokale netværk. Hvis man uden videre
forbinder sit lokale netværk til internettet, kan man blive man
udsat for, at andre trænger ind på firmaets eller kollegiets
interne computere, læser og ændrer følsomme data, får servere til
at gå i stå osv.  Ønsker man at give adgang for beboere og
medarbejdere til e-post og den store mængde information, man kan
finde på internettet uden at åbne for trafik den anden vej,
kræver det en firewall.
</para>

<para>
Firewall er det engelske ord for en brandvæg eller en brandmur. I
bygninger bruges en brandmur til at dele en bygning i sektioner.
Hvis der opstår en brand i den ene sektion, kan brandmuren
forhindre at branden breder sig (hurtigt) til andre sektioner.
</para>

<para>
En computer som firewall bruges til på lignende vis at opdele et
netværk i sektioner, typisk i det, der er udenfor lokalnetværket,
og det, som er indenfor. Firewallen er først og fremmest et
pakkefilter, som forhindrer pakker af bestemte typer i at slippe
igennem fra det ene til det andet netværk. Linux firewallen kan
imidlertid meget mere end det, og i denne sammenhæng er det
vigtigt, at den kan lade trafik, som har oprindelse på
lokalnettet, gå til nettet udenfor, det offentlige net, og vel at
mærke tillade svarpakkerne at passere på tilbagevejen.
</para>

<para>
Man kan opnå en fremragende sikkerhed med en Linux box som
firewall, men det er imidlertid bedst at kombinere firewallen med de
forholdsregler for sikker opsætning af en computer, som er omtalt
tidligere i bogen.
</para>

<para>
En firewall kan selvfølgelig også bruges til at adskille to
eller flere lokalnetværk fra hinanden.
</para>

<para>
Der findes forskellige måder at opbygge en firewall, næste afsnit
lister de vigtigste.
</para>

<sect2 id="sikkerhed-firewall-typer">
<title>Firewall typer</title>

<itemizedlist mark="bullet">
  <listitem><para>Pakkefiltrering</para></listitem>
  <listitem><para>Proxy, en applikation som optræder som
     mellemmand</para></listitem>
  <listitem><para>Stateful Multi-Layer Inspection, SMLI, en
     kombination af pakkefilter, tilstands-betingelser og
     indholds-filtrering</para></listitem>
</itemizedlist>
<indexterm><primary>SMLI</primary></indexterm>

<para>
Et pakkefilter ser på pakkens IP-adresse, den protokol-type, som
den hører til og eventuelt flere ting.
</para>

<para>
En proxy, som egentlig blot betyder en stedfortræder, var
oprindeligt et program på en gateway, som man inde på lokalnettet
henvendte sig til, og så kunne dette program sende forespørgsler
videre, som om de kom fra proxy-maskinen. Det er en meget sikker
men også ret besværlig måde at skille lokalnet fra offentlige
net, og det kræver en proxy for hver protokol, man ønsker at åbne
for, http, ftp, ssh og hvad det nu kunne være.
</para>

<para>
En mere moderne proxy kan fungere uden at man henvender sig
specielt til den. Det kaldes en transparent proxy. Den lytter
efter al trafik og videresender de pakker, som er tilladte,
ligesom et pakkefilter, men i modsætning til pakkefilteret kan
proxyen altså sende dem videre, som om de kom fra den selv, og
desuden inspicere dem på indholdsniveau eller applikationslag;
man taler om netværkslag, som fx. den forsimplede Department of
Defence model, DoD 4-lags modellen her: 
</para>



<sect3 id="sikkerhed-layer">
<title>Netværks-lag</title>

<itemizedlist mark="bullet" id="sikkerhed-network-layer">

<listitem><para>
Fysisk link-lag, d.v.s. ethernetkort og ledninger (der er
egentlig også et par abstraktionslag her);
</para></listitem>

<listitem><para>
netværkslaget, her finder man IP-numre, ping programmet og ICMP;
</para></listitem>

<listitem><para>
transportlaget, TCP;
</para></listitem>

<listitem><para>
applikationslaget, higher level, fx. FTP og HTTP.
</para></listitem>
</itemizedlist>

</sect3>

<sect3 id="sikkerhed-proxy-applikationslag">
<title>Filtrering på applikationslag</title>

<para>
En proxy kan inspicere på applikationslaget. Den kan derfor kan
kaldes for et censur-program, netværks-barnepige eller spion.
</para>

<para>
Stateful Multi Layer Inspection er den mest avancerede form for
firewall. Det er faktisk muligt at lave den slags filtrering
med Linux kernen. Linux kernens indbyggede pakkefilter har
mulighed for at holde styr på det, man kalder en forbindelse
(connection), d.v.s. en session, hvor man indleder en
konversation med en server, udveksler data og ender med at sige
"nu er jeg færdig".
</para>

<para>
TCP benytter sådanne connection meddelelser, Linuxkernen kan
holde styr på status for en forbindelse. Derfor kaldes Linux
Netfilter for et State Packet Filter, SPF.
</para>

<para>
Linuxkernen kan endvidere sende udvalgte pakker til en
applikation i user space, som kan gøre med dem, hvad den vil (fx.
sende dem videre efter at have ændret på dem). Derved kan man
bygge en SMLI firewall baseret på Linux Netfilter. En
user-applikation kan inkorporeres i kernen (for at effektivisere
den), så man kan skam bygge tip top professionelle SMLI-firewalls
på basis af Linux.
</para>
</sect3>
</sect2>

<sect2 id="sikkerhed-grundlaeggende-pakkefilter">
<title>Grundlæggende pakkefiltrering eller politiske
overvejelser</title>

<para>
Opsætningen af en firewall kan enten bygge på den grundlæggende
antagelse, at alt, hvad der kommer udefra, er mistænkeligt og bør
stoppes - eller, omvendt, at vi tror på det gode i netværket og
kun spærrer af for de ting, som notorisk er nemme at misbruge.
</para>


<sect3 id="sikkerhed-luk-alt">
<title>Luk alt</title>
<para>
Hvis man lukker for alt, er det selvfølgelig overflødigt med en
netforbindelse ud af huset. Men det er nu alligevel den bedste
måde at sikre systemet på (;-) For at få lidt glæde af
netforbindelsen kan man så åbne for web-protokollen HTTP. En
TCP/IP pakke har ud over IP nummeret et port-nummer med sig, som
blot er et tal (16 bit) i TCP-pakkens header. På modtagermaskinen
ser TCP-softwaren i kernen efter, hvilket portnummer der er, og
om der er noget program, som har meldt sig som interesseret i
pakker til dette portnummer. Det kalder man, at et program har
registreret på den pågældende port. Et program, som lytter efter
indkommende forbindelser, kaldes en server (eller somme tider et
serverprogram.)
</para>

<para>
HTTP protokollen er karakteristisk ved, at serveren som regel
lytter på port 80. D.v.s. at vi kunne lave en firewall regel, som
siger, at al trafik, som er til eller fra port 80 på en computer
<emphasis>udenfor lokalnetværket</emphasis> skal have lov at
passere. Det er en løsning, men en fattig løsning, idet man
kommer til at mangle name servicen, DNS, og endvidere kommer til
at lide under, at nogle web-sites forventer, at man kan bruge FTP
til download, eller ligefrem flytter brugerens forespørgsel til
en server på et andet portnummer.
</para>

<para>
En netværksforbindelse mellem to applikationer defineres af
IP-adresse plus portnummer. En sådan identificeret forbindelse
kaldes en socket.
</para>

<programlisting>

Afsender                                Modtager (http-server)

IP-adresse  + portnummer                IP-adresse   + portnummer

201.2.3.4     51001          &lt;----->    193.88.44.22   80

</programlisting>

</sect3>

<sect3 id="sikkerhed-aaben-alt"><title>Lad alt være åbent -
undtagen de farlige ting</title>

<para>
For at undgå problemer kunne man så beslutte, at man lader det
meste stå åbent og - selvfølgelig - lukker for de farlige
services som fx. telnet, remote shell og så videre.
</para>

<para>
Et eksempel kunne være, at man lokalt gerne må bruge telnet, men
at det er sket at folk udefra har forsøgt at få forbindelse via
telnet. Derfor kan det se ud som en løsning at lukke for port 23.
Den løsning er dog heller ikke særlig god. Intrusion på en
computer kan sagtens benytte sig af andre portnumre (og andre
protokoller) og ved snedige, ulovlige datapakker forsøge at sætte
en kæp i hjulet på de programmer, der lytter. Hvis vi var
flittige og lappede alle hullerne i serverprogrammerne og i
øvrigt overvågede maskinen døgnet rundt, så ville denne løsning
være god nok, men den er dyr i arbejdstimer.
</para>
</sect3>
</sect2>

<sect2>
<title>Den lukkede model bør vælges som udgangspunkt</title>

<para>
Hverken den åbne eller helt lukkede model er særligt nyttige. Der
skal mere til. Som udgangspunkt er den lukkede model imidlertid
den sikreste, men den skal kombineres med connection-tracking.
</para>

<para>
Forhåbentlig fremgår det af ovenstående, at en firewall egentlig
er et ret kompliceret stykke software. Man skal nu ikke lade sig
skræmme væk af den grund. Det er i grunden ret nemt at skrive de
nødvendige kommandoer og så blot kontrollere en gang i mellem, at
det kører som det skal.
</para>

<para>
Man bruger <command> iptables </command> kommandoen til at
opsætte firewall reglerne i kernen. Men man behøver ikke at kunne
<command> iptables </command> kommando syntaksen, idet SuSE,
RedHat og andre lavet GUI-administration af firewall reglerne. Så
hvis man holder sig til de gode, kendte distributioner eller på
anden måde sørger for, at de nødvendige ting er tilstede, så kan
man blot krydse af, hvilke servere andre udefra skal have lov at
bruge, om nogen.  Er man af gør det selv typen, følger her en
opskrift på, hvordan man kan lave en lille komplet firewall
opsætning.
</para>


<sect3 id="sikkerhed-really-quick-guide">
<title>Lynkursus</title>

<para>
Senere bliver kommandoerne til en firewall beskrevet og forklaret
grundigt, men for den utålmodige, som bare vil i gang, kan vi
lige vise "Rusty's Really Quick Guide To Packet Filtering" fra
packet-filtering-HOWTO. Vi antager, at maskinen har en
modemforbindelse til en ISP og ikke ønsker, at man skal kunne
tilgå maskinen udefra:
</para>

<programlisting>

  ## Insert connection-tracking modules (not needed if built into kernel).
  # insmod ip_conntrack
  # insmod ip_conntrack_ftp

  ## Create chain which blocks new connections, except if coming from inside.
  # iptables -N block
  # iptables -A block -m state --state ESTABLISHED,RELATED -j ACCEPT
  # iptables -A block -m state --state NEW -i ! ppp0 -j ACCEPT
  # iptables -A block -j DROP

  ## Jump to that chain from INPUT and FORWARD chains.
  # iptables -A INPUT -j block
  # iptables -A FORWARD -j block

</programlisting>

<para>
De første kommandoer er nødvendige med de fleste
distributionskerner. Det er ikke spor svært at lave sin egen
superkerne, hvis man interesserer sig for, hvad en kerne er, og
man har lært noget om, hvordan et operativsystem fungerer. Har
man en kerne hvor alt er kompileret ind i kernen, vil systemet
være en anelse hurtigere<footnote><para>På min gamle 75Mhz maskine kunne jeg
tydeligt mærke forskel!</para></footnote>.
</para>

<para>
<command>iptables -N block</command> laver en kæde (en skuffe
eller hylde) for et regelsæt. Regelsættene kaldes chains, fordi
man bruger reglerne i den rækkefølge, de er sat ind i kæden.
Kæden her hedder "block", blokér.
</para>

<para>
<command> iptables -A block -m state --state ESTABLISHED,RELATED
-j ACCEPT</command>
</para>

<para>
<command>-A block</command> indsætter en regel i block-kæden, som
siger, at man skal bruge tilstands-modulet, <command> -m state
</command>, og undersøge, om pakken tilhører en forbindelse
(connection), som allerede er startet eller som er i slægt med en
connection <command>--state ESTABLISHED,RELATED</command>, hvis
det er tilfældet, skal pakken accepteres, d.v.s. regelfortolkeren
jumper (-j) hopper til feltet for videresendelse af pakker,
"ACCEPT".
</para>

<para>
Næste linie siger, at alle pakker, som <emphasis>ikke</emphasis>
kommer udefra (i dette tilfælde fra et modem som bruger
Point-to-Point-Protokollen, PPP), skal have lov at passere.
</para>

<para>
Alt andet smides simpelt hen væk! DROP!
</para>

<para>
Og de sidste par linier bevirker, som kommentaren siger, at både
pakker, som er INPUT og pakker og FORWARD pakker kommer igennem
den regelkæde, som vi har dannet. Dette er, som nævnt, et
eksempel for den utålmodige, men for den tålmodige er der en
nærmere forklaring af kommandoen og mulighederne med netfilter
i <xref linkend="sikkerhed-iptables-cmd"/>.
</para>


<!-- dax 2003-10-19 hertil, næste paragraffer stort set uændrede /-->


<para>
Det er vigtigt at forstå, at en firewall ikke er spor sikker, hvis den
er sat forkert op. Når firewallen er sat op, bør man grundigt teste,
at den nu også gør, som man forventer. En vigtig del af sikkerheden
omkring en firewall er desuden, at man registrerer og overvåger den trafik,
der passerer igennem den. Hvis man glemmer at holde øje med de
log-filer, firewallen genererer, er ens sikkerhed reelt væk (Se også
<xref linkend="filcheck"/>). Man kan så risikere, at man ikke opdager,
at der har været indbrud. En firewall er aldrig helt sikker, og man
bør kun sætte en firewall op, hvis man har i sinde at vedligeholde
den.
</para>

<para>
En forkert opsat firewall eller en firewall, ingen holder øje med,
kan være værre end ingen firewall! Tilstedeværelsen af en firewall
giver let en falsk fornemmelse af tryghed, så man ikke er omhyggelig
nok med at beskytte hver enkelt computer. Det er også meget vigtigt,
at man holder sig ajour med nyheder om fejl i den
software, der anvendes på firewallen 
(Se <xref linkend="sikkerhedsreferencer"/>).
</para>

<para>
Selvom man har sat en firewall op for at beskytte et netværk imod
folk på internettet, bør man stadig være omhyggelig med sikkerheden i det
lokale netværk. For det første kan det være, at nogen bryder igennem
ens firewall, og dermed er der kun lokalnetværkets sikkerhed tilbage. For det
andet beskytter en firewall ikke imod internt misbrug af ens netværk. 
I en virksomhed eller på et kollegium e. lign. kan man ikke altid stole
på de lokale brugere. Opgørelser fra IBM peger på, at der ca. er 
ligeså mange interne netværksindbrud som eksterne.
</para>

<para>
Et andet problem indenfor firewallen er lokale modems. Hvis en
bruger har et modem, hvormed han kobler sig direkte til sin
hjemmearbejdsplads, der ikke er sikret, så er der via denne
hjemmeopkobling fri bane til virksomhedens net. Der er mange
variationer på dette sikkerhedshul, fx. også at nogen medbringer
en transportabel maskine og sætter den på kollegiets eller
virksomhedens net. På Linux/GNU/BSD platforme sikrer man den
enkelte maskine bedst ved at den er firewall for sig selv.
</para>

<para>
Så det er vigtigt at bemærke, at en firewall ikke er en universalløsning på
sikkerhed, som mange tror i dag. Den er god at have, hvis
man er indstillet på at gøre det ordentligt. Men den er ikke en
erstatning for alle de andre sikkerhedsforanstaltninger på et netværk.
</para>

<para>
Man er aldrig helt sikker, selv med en firewall...
</para>

<figure id="uf000784-fig" float="1">
<title>User Friendly</title>
<graphic fileref="uf000784.&magic;"  scale="40"></graphic>
</figure>
</sect3>
</sect2>
</sect1>

<sect1 id="firewall-links">

<title>Links</title>
<indexterm><primary>Links på nettet</primary></indexterm>
<para>
I dette kapitel henvises der til en række HOWTO's og andre dokumenter rundt 
om i teksten. Her er en hurtig oversigt:
</para>

<para>
HOWTO's:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
    Linux IPCHAINS-HOWTO <ulink url="http://sunsite.dk/ldp/HOWTO/IPCHAINS-HOWTO.html">http://sunsite.dk/ldp/HOWTO/IPCHAINS-HOWTO.html</ulink>
  </para></listitem> 
  <listitem><para>
    Firewall and Proxy Server HOWTO <ulink url="http://sunsite.dk/ldp/HOWTO/Firewall-HOWTO.html">http://sunsite.dk/ldp/HOWTO/Firewall-HOWTO.html</ulink>
  </para></listitem>
  <listitem><para>
    Transparent Proxy with Squid mini-HOWTO <ulink url="http://sunsite.dk/ldp/HOWTO/mini/TransparentProxy.html">http://sunsite.dk/ldp/HOWTO/mini/TransparentProxy.html</ulink>
  </para></listitem>
  <listitem><para> Linux 2.4 Packet Filtering HOWTO:
<ulink url="http://www.netfilter.org/unreliable-guides/packet-filtering-HOWTO/packet-filtering-HOWTO.linuxdoc.html">
http://www.netfilter.org/unreliable-guides/packet-filtering-HOWTO/packet-filtering-HOWTO.linuxdoc.html</ulink>
  </para></listitem>
  <listitem><para>
    Linux 2.4 NAT HOWTO <ulink url="http://netfilter.samba.org/unreliable-guides/NAT-HOWTO/index.html">http://netfilter.samba.org/unreliable-guides/NAT-HOWTO/index.html</ulink>
  </para></listitem>
  <listitem><para>
    (Linux IP Masquerade HOWTO <ulink url="http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO.html">http://sunsite.dk/ldp/HOWTO/IP-Masquerade-HOWTO.html</ulink>
  </para></listitem>
</itemizedlist>

<para>
Andet:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
    Sikkerhed på Linux <ulink url="http://www.sslug.dk/artikler/Linux_sikkerhed/">http://www.sslug.dk/artikler/Linux_sikkerhed/</ulink>
  </para></listitem>
  <listitem><para>
    Linux - Friheden til at vælge <ulink url="http://&linuxbogurl;/bog/">&linuxbogurl;/bog/</ulink>
  </para></listitem>
  <listitem><para>
    IPChains i Linux 2.2 <ulink url="http://www.sslug.dk/sikkerhed/ipchains.html">http://www.sslug.dk/sikkerhed/ipchains.html</ulink>
  </para></listitem>
  <listitem><para>
    Netfilter i Linux 2.4 <ulink url="http://www.sslug.dk/sikkerhed/netfilter.html">http://www.sslug.dk/sikkerhed/netfilter.html</ulink>
  </para></listitem>
  <listitem><para>
    The Netfilter Project HomePage <ulink url="http://netfilter.samba.org/">http://netfilter.samba.org/</ulink>
  </para></listitem>
  <listitem><para>
    Squid Web Proxy Cache <ulink url="http://www.squid-cache.org/">http://www.squid-cache.org/</ulink>
  </para></listitem>
</itemizedlist>
</sect1>



<sect1 id="firewall-funktion">
<title>Firewallens funktioner</title>

<indexterm><primary>firewall</primary>
           <secondary>grundlæggende funktioner</secondary>
</indexterm>


<para>
Linux firewallen vil på et mindre lokalnet som regel have flere
funktioner. Den skal kontrollere, hvilken trafik, der kan
tillades, den skal sikre os mod angreb, og endelig kan den
overvåge trafikmængder og for eksempel fortælle os, om et eller
andet program begynder at udspy pakker på internettet. Det sker
somme tider. Og måske er man bare almindeligt nysgerrig og ønsker
at se, hvad der sker på maskinen. Endvidere vil vi også gerne
kunne servicere maskiner, som ikke har et offentligt IP-nummer.
</para>

<itemizedlist mark="bullet" id="sikkerhed-fw-funx">
<listitem><para>Kontrol af trafik-typer</para></listitem>
<listitem><para>Sikring mod indtrængen</para></listitem>
<listitem><para>Overvågning, logning</para></listitem>
<listitem><para>Servicering af maskiner uden offentligt IP nummer</para></listitem>
</itemizedlist>

<sect2 id="firewall-pakkefiltrering">
<title>Kontrol af trafik-typer.</title>
<indexterm><primary>pakkefiltering</primary></indexterm>
<indexterm><primary>kontrol af trafik</primary></indexterm>

<para>
Data sendes igennem et netværk i form af datapakker. På
internettet bruges IP-pakker. En IP-pakke består af en header med
information om, hvor den skal hen, hvor den kommer fra, hvad den
er for en slags samt eventuelt nogle data.  Ved pakkefiltrering
kigger man på informationen i headeren og bestemmer, hvad der
skal ske med pakken: Om den skal afvises eller slippes igennem.
</para>

<para>
Ideen er så, at en firewall stopper alle de pakker, som man ikke
har "inviteret". Kører man fx. en web-server, slipper man kun
web-pakker igennem. En privat maskine med internetadgang kan godt
stoppe alle udefra kommende forespørgseler samtidigt med, at alle
de netværks-sessions, der startes af brugeren får lov til at køre
som normalt, d.v.s. at <emphasis>svar-pakker</emphasis> fra det
externe net får lov at komme igennem.
</para>

<para>
Man bør blokere:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
      Pakker fra services, der ikke skal bruges. Hvis en server f.eks. ikke
      tilbyder ftp er det klogt at afvise alle forsøg på at
      etablere en ftp-forbindelse med det samme.
  </para></listitem>
  <listitem><para>
      Pakker med mistænkelige bits sat som IP source routing (kan bruges til
      spoofing, hvilket betyder at udgive pakkerne for at komme fra
      et andet sted, end de egentlig kommer fra).
  </para></listitem>
  <listitem><para>
      Pakker, der er til en lokal host, som ikke burde modtage 
      pakker udefra. Det vil sige pakker, som er direkte addreseret til en
      maskine, som ikke har lov til at snakke med fremmede maskiner på
      internettet.
  </para></listitem>
</itemizedlist>

 <indexterm>
  <primary>netværkssikkerhed</primary>
  <secondary>spoofing</secondary>
 </indexterm>

<para>
Hvis for eksempel Boligforeningen Xyzzy-42 ikke ønsker, at der
skal være adgang til FTP serveren fra maskiner udefra, men gerne
vil se, hvor mange, der prøver at komme i forbindelse med
serveren, så kan nedenstående kommando bruges.
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -A INPUT -p tcp --destination-port 21 -j DROP</userinput>
</screen>

<para>
For mere information om IP, TCP og netværk generelt se f.eks.
"Introduktion til Netværk" af Geir Steen-Olsen & Arne Stalheim
(IDG-bog til 69 kr.) eller "Linux - Friheden til til
systemadministration" på <ulink
url="http://&linuxbogurl;/">&linuxbogurl;</ulink>.  Den grundige
gennemgang af IPtables begynder <xref linkend="sikkerhed-netfilter"/>
</para>
</sect2>


<sect2 id="sikkerhed-indtraengen">
<title>Sikring mod indtrængen</title>
<para>
Firewallens vigtigste opgave er selvfølgelig at hindre
uvedkommende at trænge ind på systemet. Det bedste er at spærre
for alt og åbne for en positivliste, som kan bestå af de tilladte
brugeres IP-numre. Hvis man derimod vil tillade bruger XYZ at
komme ind uanset fra hvilken maskine XYZ benytter, ses (let) at 
det ikke kan lade sig gøre. Man kan ikke på netværksniveau eller
transportniveau åbne for en bestemt loginkonto, men her kommer
SSH, secure shell, protokollen heldigvis til undsætning og løser
problemet elegant og sikkert på session-niveau.
</para>
</sect2>


<sect2 id="sikkerhed-logning">
<title>Overvågning og logning</title>
<para>
Når man installerer en regel i kernens pakkefilter, holder kernen
automatisk øje med, hvor mange pakker der falder ind under denne
regel, og med -L (list) kommandoen få iptables til at vise
tællerne (counters).
</para>

<para>
Et eksempel:
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -L INPUT -v</userinput>

</screen>

</sect2>


<sect2 id="sikkerhed-NAT">
<title>Servicering af maskiner uden offentligt IP nummer</title>

<para>
En router for et lokalnetværk har som regel flere opgaver end at
sende pakker videre og stoppe uvedkommende pakker. I de fleste
netværk bruger man adresser, som er reserveret til testformål, de
såkaldte private adresser. De skal ompakkes til en rigtig
IP-adresse, og hertil bruger routeren NAT, Network Address
Translation.
</para>

<para>
NAT er en teknik, som minder om en transparent
proxy. NAT-ing har vist sig at være en halv løsning på mangelen
på IP-numre. IP-numre er 32 bit.  Hvis man kunne udnytte alle
4,294,967,295 numre (4 mia), så ville det stadig ikke være nok
til at dække behovet. Der er ca. 0.5 mia adresser, som bliver
brugt til specielle formål, men selv hvis man kunne inddrage dem
til "almindelige" adresser, så ville der ikke være nok numre til
at dække behovet for at hvert menneske havde et IP nummer, for
slet ikke at tale om, hvis vi skulle have IP numre til arbejde og
hjem, køleskab, cykel og fjernsyn.
</para>

<para>
Hvis to maskiner på et net udgiver sig for at have samme IP
nummer, så vil kommunikationen blive upålidelig for begge
maskiner. <!-- TODO: Illustration /-->
</para>

<para>
Da man jo ikke behøver at koble et lokalnet på det globale
internet, behøver man heller ikke at få en adresse på det
globale net fra InterNIC eller deres lokale repræsentant.
Man kunne sådan set godt bruge de numre, man synes så pænest ud.
Imidlertid viser det sig ofte, at folk alligevel gerne vil
have deres separate TCP/IP net tilsluttet det globale Internet
på et eller andet tidspunkt og derfor indskærpes det overfor
netværksadministratorer, at man skal bruge de "private adresser"
selv om man ikke lige nu har tænkt sig at slutte maskinerne
til det offentlige net. De private adresser får ikke lov til
at passere en router, det er indbygget i routeren.  På den måde
kan man undgå uskyldige fejltagelser, hvor en maskine har fået
et IP-nummer, som tilhører en anden.
</para>

<para>
De mest benyttede private adresser er intervallet
192.168.1.0 - 192.168.255.255. Man kan også bruge alle adresser,
som begynder med 10, og adresser, som begynder med 172.16
</para>

<para>
Det er så routerens opgave at foretage en omskrivning af pakkerne
og sende dem videre som om de kom fra routerens eksterne,
offentligt synlige IP-adresse. Lige så vigtigt er det, at den kan
identificere svar-pakkerne, og sende dem til den rigtige maskine.
Dertil bruges portnumrene som en forlængelse af IP adressen.
Denne funktion kaldes <emphasis>N</emphasis>etwork
<emphasis>A</emphasis>ddress <emphasis>T</emphasis>ranslation
eller NAT. En router, som kan det, kaldes somme tider en NATting
router.
</para>

<para>
Den utålmodige læser kan nu springe frem til 
<xref linkend="sikkerhed-netfilter"/>
mens den grundige læser i de næste afsnit kan få meget mere at
vide om, hvordan Linux fungerer.
</para>

</sect2>
</sect1>


<sect1 id="sikkerhed-virkemaader">
<title>Firewallens virkemåder</title>

<para>
Som sagt kan en Linux-PC fungere som firewall og router. En
firewall-router er dog ofte en dedikeret, flad boks, som
egentlig er et diskløst system, der kan fjernstyres fra en anden
computer.  Der fås billige routere til mindre virksomheder og
private net, og der fås også store routere med mange stik, som
kan håndtere meget store trafikmængder. Der er en Linux-kerne
inde i mange af den slags dedikerede routere. TODO: eksempler,
billede.
</para>

<para>
Inde i firewallen inspiceres pakkerne. Hvordan man gør, og hvor
meget det koster i tid, og hvilke problemer, der kan opstå, er
emnet for dette afsnit.
</para>

<para>
Netværksmodellen (<xref linkend="sikkerhed-layer"/>) viser to
ting. Dels viser den abstraktionslagene, som giver de elektriske
signaler mening. Dels viser modellen, at en applikation, som
ønsker at sende data (typisk tekst) til en anden applikation på
en remote værtsmaskine skal sende sin pakke gennem adskillige
instanser (lag svarer her til programafsnit eller
kernefunktioner). Hver gang pakken passerer et lag, bliver det
hele lagt i en slags "konvolut". Først sendes applikationens
information til transportlaget, og her lægges TCP oplysninger ind
i nogle felter forrest i pakken. Pakken (eller rettere en pointer
til den) sendes videre til IP-laget, som forsyner den med en IP
header, "konvolut", foran. 
</para>

<programlisting>

+-------------------+-------------+
|  IP-oplysninger   | IP-pakke    |
|  IP-modtager      |             |
|  IP-afsender m.v. | header      |
+-------------------+-------------+------------+
|  TCP-header       | IP-data     | TCP-pakke  |
|  med bl.a. portnr.|             |            |
|  længde, checksum |             | header     |
+-------------------+             +------------+---------+
|  Interne headere  |             |            |         |
|  hvis der er nogen|             | TCP-data   | appli-  |
|                   |             |            | kations |
+-------------------+             |            | pakke   |
|  Applikationens   |             |            |         |
|  data             |             |            |         |
 
~                   ~
|                   |             |            |         |
+-------------------+-------------+------------+---------+

Forsøg på skematisk forklaring af konvolut-princippet.

</programlisting>


<para>
Hver konvolut svarer til et lag i netværksmodellen.
Lagene fra den simple DoD model med kommentarer ses her:
</para>

<programlisting>

                           Protocol Layering

                        +---------------------+
                        |     higher-level    |
                        | applikations-laget  |
                        +---------------------+
                        |        TCP          |
                        +---------------------+
                        |  internet protocol  |
                        +---------------------+
                        |communication network|
                        +---------------------+


</programlisting>


<itemizedlist>
<listitem><para>
Applikationslaget, fx. FTP og HTTP. Applikationen kan selv lave
nogle regler for, hvordan pakkerne skal håndteres og se ud. Der
er <emphasis> mange </emphasis> forskellige
applikationsprotokoller, og det er let at lave nogle selv. Se fx.
på <command>finger</command> kommandoen (TODO: Reference til
gawk-finger-server).
</para></listitem>

<listitem><para>
Transportlaget, TCP står for Transport Control Protocol. Her
tilføjes TCP portnummer, TCP-type, checksum m.v.
</para></listitem>

<listitem><para>
Netværkslaget, her arbejdes med IP-numre, SNMP, ICMP og router
protokoller; IP, eller Inter Net Protokollen, er reglerne for,
hvordan man kommer fra ét lokalnet til et andet.
</para></listitem>

<listitem><para>
Fysisk link-lag, d.v.s. MAC-adresser, ethernetkort og ledninger.
Mac adresser er knyttet til ethernet-pakker. Der er egentlig også
et par abstraktionslag her.
</para></listitem>
</itemizedlist>

<para>
<emphasis>Et par forklaringer: </emphasis>
Finger protokollen er en af de simplere, morsomme protokoller.
Det er nemt at prøve fingerprotokollen: <command>finger
quake@geophys.washington.edu</command>
</para>

<para>
SNMP, Simple Network Management Protocol, bruges til fjernkontrol
af netværks enheder som fx. routere. ICMP, Internet Control
Message Protocol, er den, som ping programmet benytter, og den,
som gør det muligt at sende en besked om, at vores maskine ikke
har tænkt sig at svare på fx. ftp. MAC adresser kan listes med
<command> arp -a</command> programmet og er et tal, som er brændt
ind i netkortets ROM, så hardwaren altid kan skelne to netkort
fra hinanden.
</para>

<para>
Disse netværks lag er defineret med henblik på at kunne
transportere så meget som muligt så hurtigt som muligt. Derfor
behøver IP laget ikke at interessere sig for, om data er korrekte
eller om der lyttes modtagerens portnummer, og heller ikke for
applikationens datakodning og så videre.
</para>

<para>
Det er derfor meget enkelt og "billigt", målt i tid, at filtrere
indkommende pakker på netværkslaget. Bare se efter, om de er til
vores maskine og om de kommer inde eller udefra.
</para>

<para>
Hvis firewallen imidlertid er nødt til også at udpakke transport
pakken (d.v.s. se i TCP-konvolutten for at få fat i portnummeret)
så kræver det selvfølgelig lidt mere tid. Hvis pakken yderligere
skal om-adresseres og en ny checksum skal beregnes, så bliver det
rigtig dyrt. Som tidligere nævnt er det for primitivt kun at
filtrere på netværkslaget.
</para>

<para>
De omtalte netværks lag svarer i kernen til programafsnit, som
bearbejder henholdsvis IP-adresse, TCP-oplysninger og, i sidste
instans, flytter pakken til den applikation, som skal bruge data.
</para>

<programlisting>

                           Protocol Layering

                        +---------------------+
                        |     higher-level    |
                        +---------------------+
                        |        TCP          |
                        +---------------------+
                        |  internet protocol  |
                        +---------------------+
                        |communication network|
                        +---------------------+


</programlisting>


<sect2 id="sikkerhed-nat">
<title>NAT-ing giver også mere sikkerhed</title>

<para>
Som tidligere nævnt skal en NAT-ing router omsætte de interne
eller private IP-adresser til den offentlige (lovligt købte)
IP adresse, som man har fået af sin Internet Udbyder, Internet
Service Provider, ISP.  Man kan for eksempel bruge adresserne
192.168.1.1-255 som lokale adresser, denne nummerserie er
reserveret. Det er en del af de såkaldt "private adresser", som
ikke bliver sendt rundt på det offentlige net. De er reserverede
for at gøre det lettere at etablere et lokalnet uden at skulle
søge og betale for "rigtige IP-adresser".
</para>

<para>
NAT teknikken er med til at gøre firewallen mere
uigennemtrængelig. Det ses, hvis man forestiller sig hvad der
sker, hvis man prøver at "snakke" med en maskine med et
192.168.x.y - nummer? Pakkerne kommer ingen vegne. Hvis nogen
prøver at trænge igennem en firewall ved at bryde ind i en
kommunkations sekvens (tredie-mands princippet, spoofing) så skal
pakkerne kunne snyde firewallen *og* modtagemaskinen indenfor
muren. Det er svært, og det sker heldigvis meget sjældent.
</para>

</sect2>


<!--dax 2003-10-22 nogenlunde ok hertil, mangler ekstern korrektur/-->

<sect2 id="kontrol-af-forbindelser">
<title>Kontrol med oprettelse af forbindelser</title>

<para>
At åbne for alle forbindelser, som startes indefra, kræver, at
firewallen holder styr på, hvilke forbindelser, der er oprettet;
for at gøre det, skal firewallen have inkluderet et modul, der
kaldes "connection tracking". Derved kan Linux kernen styre
hvilke forbindelser, der må oprettes imellem de to adskilte
netværk. Den kan også logge, hvad der sker på disse forbindelser.
</para>

<para>
Der er her tale om filtrering på session- eller forbindelses -
niveau (se <xref linkend="sikkerhed-layer" />). FTP er en protokol
oven på TCP-laget, og når denne applikation går i gang, opretter
den mange "forbindelser". Det giver en ekstra vanskelighed for en
firewall. Man skal huske, at FTP protokollen kom til verden i en
tid, hvor der ikke var noget, der hed firewalls.
</para>

</sect2>


<!-- dax 2003-10-23 god forklaring, belyser virkemåde, fredet! /-->

<sect2 id="Ftp-problemet">
<title>Ftp-problemet</title>
<indexterm><primary>FTP og sikkerhed</primary></indexterm>

<para>
Traditionel FTP, også kaldet aktiv FTP, er lidt et problem i
forbindelse med en firewall, da det laver indgående forbindelser.
Ikke alene laver det 
indgående forbindelser, men det er ikke muligt på forhånd at vide hvilken
port, forbindelsen laves på. Det vil sige, at for at tillade sine brugere at
benytte aktiv FTP, er man
nødt til at lade en masse porte stå åbne. Lad os se, hvad der sker,
når man bruger traditionel FTP:
</para>

<programlisting>
Aktiv FTP 

  Klient                  Server
                     command  data
57726 57724               21   20
  @    @                  @    @
  |    |1__               |    |
  |    |   \__port 57726__|    |
  |    |                  |    |
  |    |              ___2|    |
  |    |____ok__ ____/    |    |
  |    |                  |    |
  |____|_                 |    |
  |    | \_data channel___|___3|
  |    |                  |    |
  |    |                __|____|
  |4___|________ ok___ /  |    |
  |    |                  |    |
  |    |                  |    |

</programlisting>

<itemizedlist mark="bullet">

<listitem><para>1) Først oprettes en forbindelse fra klienten på en 
tilfældig port (her port 57724) til port 21, FTP kommando porten, 
på serveren. Klienten overfører et portnummer, som den vil benytte 
til dataoverførslen (her port 57726).</para></listitem>

<listitem><para>2) Serveren siger ok</para></listitem>

<listitem><para>3) Serveren opretter en dataforbindelse fra sin
FTP
dataport - port 20 - til den angivne port på klienten
(57726).</para></listitem>

<listitem><para>4) Klienten siger ok</para></listitem>

</itemizedlist>

<para>
Man kan se, at serveren opretter en forbindelse til klienten på port
57726.  Da man ikke på forhånd kan vide hvilken port, der vil blive
brugt på klienten - FTP-programmet vælger bare en ledig port - er det
nødvendigt at lade et portinterval på klienten stå åbent for FTP
forbindelser, så FTP klienten kan virke.
</para>

<para>
Problemet kan løses med nyere udgaver af FTP,
som kan køre "passiv FTP" i stedet for. Ved passiv FTP er det kun klienten,
der starter forbindelser op. 
</para>

<indexterm><primary>passiv FTP</primary></indexterm>

<example id="passiv-FTP">
<title>Passiv FTP</title>
<programlisting>
Passiv FTP 

  Klient                  Server
                     command      data
57726 57724               21       20
  @    @                  @  58734   @
  |    |1__               |    @    |
  |    |   \_PASV_________|    |    |
  |    |                  |    |    |
  |    |______ok_58734___2|    |    |
  |    |                  |    |    |
  |3___|__                |    |    |
  |    |  \__data_channel_|____|    |
  |    |                  |    |    |
  |____|_______ok_________|___4|    |
  |    |                  |    |    |
  |    |                  |    |    |
  |    |                  |    |    |
  |    |                  |    |    |
</programlisting>
</example>

<itemizedlist mark="bullet">
<listitem><para>1) Først oprettes en forbindelse fra klienten på en 
tilfældig port (57724) til port 21, ftp kommando porten, på serveren. 
Klienten overfører en kommando, der fortæller serveren, at der skal 
bruges passiv ftp.</para></listitem>

<listitem><para>2) Serveren siger ok og fortæller hvilket portnummer,
den vil have, at klienten connecter til.</para></listitem>

<listitem><para>3) Klienten opretter en dataforbindelse fra sin
ønskede dataport - her port 57726 - til den angivne port på serveren
(58734).</para></listitem>

<listitem><para>4) Serveren siger ok</para></listitem>
</itemizedlist>

<para>
Lad os se på, hvad der er vundet. Hvis man vedligeholder en firewall
bag hvilken, der er klienter, der gerne vil hente via
ftp, er man ved traditionel ftp nødt til at lade et portinterval stå
åbent til indgående forbindelser, som de forskellige ftp-servere, folk
henter fra, skal oprette. Bruges der derimod passiv ftp, skal man
kun tillade udgående forbindelser - man behøver ikke længere lade et
portinterval stå åbent til de indgående forbindelser fra diverse ftp
servere.
</para>

<para>
Ftp serveren skal til gengæld lade en port stå åben til data, men den 
bestemmer selv hvilken. Den oplysning sender den med over, før 
dataforbindelsen oprettes. Alligevel betragtes det nogle steder som 
et problem på serversiden. Selvom de fleste ftp-programmer - herunder
web-browsere - understøtter passiv ftp, er det derfor ikke alle ftp-servere, 
der understøtter det.
</para>

</sect2>
</sect1>

<sect1 id="Linux-som-firewall">
<title>Linux som firewall</title>

<indexterm><primary>firewall</primary></indexterm>
<indexterm><primary>dørvogter</primary></indexterm>

<para>
I dette afsnit ser vi på Linux kernens netfilter modul og hvad 
man kan gøre med det. Det er en forudsætning, at man er godt
kender til begreberne IP adresse, netværksadresse, netmaske,
routing og DNS. Hvis du ikke gør, så se på <ulink 
url="http://www.netfilter.org/documentation/index.html#HOWTO">
http://www.netfilter.org/documentation/index.html#HOWTO</ulink>
efter Networking Concepts HOWTO.
</para>

<para>
Desuden vil vi kigge nærmere på proxy opsætning med squid, samt
se på Network Address Translation.
</para>


<!-- dax 2003-10-23 Hertil. Har slettet resten og starter forfra HUSK /-->


<sect2 id="sikkerhed-netfilter">
<title>Iptables og netfilter i kerne 2.4 og 2.6</title>
<indexterm><primary>Iptables</primary></indexterm>
<indexterm><primary>Netfilter</primary></indexterm>

<para>
I Linux er pakkefiltrering i en avanceret version indbygget i
kernen; kernedelen kaldes netfilter, og programmet <command>
iptables </command> kommunikerer vores ønsker om hvad kernen skal
foretage sig fra user-space til kerne-space.
</para>

<para>
For at kunne bruge kernens netfilter og <command> iptables
</command> kommandoen, skal kernen være bygget med netfilter, og,
hvis man planlægger at sikre en maskine må det stærkt anbefales
at man også inkluderer connection tracking. Det koster lidt
belastning, men giver mange fordele.  De fleste standard kerner
fra distributioner med kerne 2.4.18 og frem har den slags. Det
kan kontrolleres med <command>ls -l /proc/net/ip_conntrack
</command>
</para>

<graphic fileref="kconf-netfilt.&magic;"  scale="40"></graphic>
<graphic fileref="kconf-netfilt-2.&magic;"  scale="40"></graphic>
<graphic fileref="kconf-netfilt-hlp.&magic;"  scale="40"></graphic>

<para>
iptables kommandoen skal bygges, så den passer til den kerne, man
bruger, eller rettere, så den passer til den version af
netfilter, som er i kernen. Også det er gjort i alle
distributioner.
</para>

<para>
iptables indsætter som nævnt regler i kernens pakke-filter
tabeller, hvilket betyder, at reglerne går tabt ved reboot. Du
kan prøve at bruge kommandoerne iptables-save og
iptables-restore (oprindeligt var det scripts).
</para>

<para>
Alternativt sætter man alle iptables kommandoerne ind i et
start/stop script, som køres af rc kommandoen ved opstart. Man
skal i så fald huske at få den til at foretage sig noget
fornuftigt, hvis en af iptables kommandoerne fejler; normalt vil
det være at starte <command> /sbin/sulogin </command>
</para>



<sect3 id="sikkerhed-traverse">
<title>Hvordan pakker rejser igennem filtrene</title>

<para>
Navnet iptables hentyder til, at kernen har tre tabeller:
</para>

<itemizedlist mark="bullet" id="sikkerhed-list-iptables">
<listitem><para>
Filter tabellen, som bruges, hvis man udelukkende skal stoppe
uvedkommende trafik.
</para></listitem>
<listitem><para>
NAT-tabellen, som bruges, hvis man skal foretage mapning /
spejling af interne adresser, obligatorisk, hvis der er tale om
private adresser som fx. 192.168.x.x.
</para></listitem>
<listitem><para>
Mangle-tabellen, som bruges, hvis man vil pille ved bits i
pakkerne for at kunne klare vanskelige situationer.
</para></listitem>
</itemizedlist>

<para>
Kernen begynder med at have 3 lister med regler i "filter"
tabellen. Disse lister kaldes firewall kæder eller blot kæder,
chains. De tre kæder kaldes INPUT, OUTPUT og FORWARD (pakker-ind,
pakker-ud og pakker-til-videresendelse).<!-- Af hensyn til Jacobs
læsere/-->
</para>

<para>
Her er en ASCII-kunstnerisk gengivelse af kædernes organisation
(med tak til Rusty Russell's packet-filtering-HOWTO).  Det er
væsentligt forskelligt fra arrangementet i kerne 2.0 og 2.2.
</para>

<programlisting>
                            _____
  Incoming                 /     \         Outgoing
         -->[Routing ]--->|FORWARD|------->
            [Decision]     \_____/        ^
                 |                        |
                 v                       ____
                ___                     /    \
               /   \                   |OUTPUT|
              |INPUT|                   \____/
               \___/                      ^
                 |                        |
                  ----> Local Process ----
</programlisting>

<para>
Det ses, at en pakke kan komme fra to principielt forskellige
kilder. Enten kommer pakkerne fra et netkort (rettere interface -
men prøv at oversætte det til dansk) eller også kommer de fra et
program, en lokal proces.
</para>

<para>
De tre "cirkler" repræsenterer de tre kæder nævnt ovenfor. Når en
pakke ankommer til en cirkel i diagrammet, undersøges reglerne i
denne kæde for at afgøre pakkens skæbne. Hvis kæden siger DROP
pakken bliver den elimineret på stedet, men hvis kæden siger
ACCEPT vil den fortsætte sin rejse gennem diagrammet.
</para>

<para>
En kæde er en checkliste med regler. Hver regel siger "hvis
pakke-headeren ser ud på denne-hersens-måde, så se her hvad der
skal gøres med pakken".  Hvis en regels pakke-beskrivelse passer
på pakken, kalder man det et match. Det svarer selvfølgelig til
en masse betingelser, som er opfyldt. Hvis pakken ikke matcher
reglen fortsætter man til næste regel. Endelig når vi til et
punkt, hvor der ikke er flere regler at undersøge. Nu ser kernen
på kæde-policy for at afgøre, hvad der skal ske. I et
sikkerheds-bevidst system siger denne policy som regel at kernen
skal DROPpe pakken.
</para>

<para>
1. Når en pakke kommer ind, lad os sige fra ethernet-kortet ser
kernen på pakkens destination: Dette kaldes routing (rutning
eller bedre, ruting?)
</para>

<para>
2. Hvis den er til denne box bliver pakken sendt videre ned i
diagrammet til INPUT kæden. Hvis den passerer denne, så vil alle
processer, som venter på denne pakke, få den.
</para>

<para>
3. I modsat fald, hvis kernen ikke har videresendelse aktiveret,
eller den ikke ved, hvordan pakken skal sendes videre, vil pakken
blive droppet. Hvis videresendelse er aktiveret, og pakken er
tiltænkt til et andet netværks-interface (hvis du har sådan et),
så vil pakken gå fremad til FORWARD kæden. Hvis den accepteres
her, bliver den sendt ud.
</para>

<para>
4. Sluttelig kan et program, som kører på boxen, sende
netværkspakker. Disse passerer gennem OUTPUT kæden straks: Hvis
den siger ACCEPT, så fortsætter pakken til hvad nu end det måtte
være for et interface, som den er bestemt for.
</para>

</sect3>

</sect2>
<sect2 id="sikkerhed-iptables-cmd">
<title>Anvendelse af <command>iptables</command> kommandoen</title>

<para>
<command> iptables </command> kommandoen har en ret detailleret
manual side (<command> man iptables </command>) hvis du har brug
for oplysninger om specielle ting.
</para>

<para>
Der er mange ting, man kan gøre med <command> iptables </command>
kommandoen. Man begynder med at have de tre indbyggede kæder,
INPUT, FORWARD og OUTPUT, som man ikke kan slette. Lad os først
se på hvordan man administrerer hele kæder.
</para>


<itemizedlist mark="bullet">
<listitem><para>
<command> -N </command>: Opretter en ny kæde.
</para></listitem>
<listitem><para>
<command> -X </command>: Sletter en tom kæde.
</para></listitem>
<listitem><para>
<command> -P </command>: Ændrer policy for en kæde.
</para></listitem>
<listitem><para>
<command> -L </command>: Lister regler i en kæde.
</para></listitem>
<listitem><para>
<command> -F </command>: Flusher, sletter reglerne i en kæde.
</para></listitem>
<listitem><para>
<command> -Z </command>: Nulstiller tællerne for en kæde.
</para></listitem>
</itemizedlist>


<para>
Der er været vist nogle eksempler ovenfor, her er et til, som
nulstiller tællerne i INPUT kæden. Prøv at liste før og efter med
<command> iptables -L INPUT -v </command>:
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -Z INPUT</userinput>
</screen>

<para>
Der er mange kommandoer til at manipulere reglerne i en kæde.
</para>

<itemizedlist mark="bullet">
<listitem><para>-A &lt;kæde&gt; Tilføj (append) regel</para></listitem>
<listitem><para>-D &lt;kæde&gt; [nummer] Slet (delete) regel</para></listitem>
<listitem><para>-R &lt;kæde&gt; [nummer] Erstat (replace) regel</para></listitem>
<listitem><para>-I &lt;kæde&gt; [nummer] Indsæt (insert) regel</para></listitem>
</itemizedlist>


<para>
En regel består af en eller flere kommandoparametre, som
beskriver en egenskab ved en netværkspakke, samt (som regel) en
besked om, hvad der skal ske med pakker, som beskrivelsen passer på.
Hvis en beskrivelse passer, siger man at pakken matcher.
</para>

<para>
Kommandoparameteren -j står for jump. Det, man hopper til, kaldes
mål eller target, og to af de indbyggede targes er de samme som de
policy, vi tidligere har set, DROP, ACCEPT; endvidere kan man
hoppe til en anden, brugeroprettet kæde, eller man kan returnere
fra en kæde (med RETURN). Desuden er der et REJECT target, som
dog kræver at kernen er kompileret med support for det. Der er
mange andre inbyggede targets, som kræver tilvalg i kernen: QUEUE
beder kernen om at sende pakkerne til en pseudo-device, som et
program i userspace kan lytte på, og så er der bl.a. også
REDIRECT, SNAT, DNAT og LOG targets. Se manual page for komplet
listning. Lige nu er de vigtigste ACCEPT, DROP og SNAT, som kun
kan bruges i nat-tabellens POSTROUTING chain.
</para>

<para>
De vigtigste kommandoparametre til match er
</para>

<itemizedlist mark="bullet">
<listitem>
<para>
<command> --protocol [icmp|tcp|udp|all] </command> 
</para>
<para>
Man kan også bruge et navn fra <filename> /etc/protocols
</filename>. Hvis man ønsker at matche alle pakker, som ikke
tilhører en bestemt protokol, negeres med udråbstegn. Fx.
<command> iptables -A INPUT --protocol ! tcp -j ACCEPT</command>
accepterer alt undtagen TCP-pakker.  Kan forkortes til -p.
</para>
</listitem>
<listitem>
<para>
<command> --source [!] adresse[/netmaske] </command>
</para>
<para>
Angiver oprindelsesadressen. Kan forkortes til -s. Eksempel:
<command> iptables -A INPUT --source 123.45.67.89 -j ACCEPT
</command> vil bevirke at vi accepterer alt, hvad der kommer fra
123.45.67.89 - og formentlig dropper alt andet.
</para>
</listitem>
<listitem>
<para>
<command> --destination [!] address[/mask] </command>
</para>
<para>
matcher på slutadressen, destinationen. Forkortes -d.
</para>

</listitem>
<listitem>
<para>
<command> -i, --in-interface [!] name </command>
</para>
<para>
hvor <emphasis>name</emphasis> kan være eth0, eth1, ppp0 m.v. kan
bruges til at selektere alle pakker, som kommer fra ydersiden eller
indersiden af firewallen.
</para>
</listitem>

<listitem>
<para>
<command> -o, --out-interface [!] name </command>
</para>
<para>
som -i, bruges til at selektere på alle pakker, der skal sendes
ud via et bestemt interface.
</para>
</listitem>

<listitem>
<para>
<command> -m state </command>
</para>
<para>
bruges til at fortælle kernen at tilstandsmodulet (connection
tracking) skal bruges. Derefter kan man specificere, at pakker,
som er ESTABLISHED eller RELATED til en forbindelse, som er i
gang, skal have lov at passere. Det er den måde, man åbner for al
trafik indefra.
</para>
</listitem>

</itemizedlist>


<para>
Nu til hands on! Vi antager, at vi har fem maskiner i huset og et
en ADSL forbindelse på en af maskinerne. ADSL er på et separat
netkort, som har betegnelsen eth1. De andre maskiner er forbundet
via eth0 og vil gerne have lov at få del i ADSL forbindelsen.
</para>

<para>
Lad os lave en kæde af regler, som skal inspicere al trafik, der
kommer ind på vores box, men kun, hvis det er fra ADSL
interfacet, altså eth1.
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -N eth1-rules </userinput>
</screen>

<para>
Man kan liste den nye kæde sammen med de andre: <command>
iptables -L </command> Kæden er ikke taget i brug, så der står "0
references". For at bruge den til noget må vi instruere kernen
yderligere med en jump kommando. Vi laver en regel 1 for INPUT
kæden.
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -A INPUT -i eth1 -j udefra </userinput>
</screen>


<programlisting>
                  __________
                _|eth1-rules|__> eth1 rule 1 __> eth1 rule 2 ..._
               ^ |__________|                                    |
              _|_____                                            |
             /if eth1\                                           |
            |  else   |                                          |
             \_______/ _    _____________________________________|
               ^        |  |
   ______      |        v  v
__|input |__> rule 1    rule 2 __> rule 3
  |______|
   ______
__|output|
  |______|
   _______
__|forward|
  |_______|
</programlisting>

<para>
Det svarer til en sammensat if-sætning. Vi tester for om det var
fra eth1 og hvis det er det, så undersøg også lige dit og dat.
</para>

<para>
Lad os inspicere pakkerne udefra for, om de er til vores http
server. Hvis de er det, så slip dem igennem, ellers skal de
droppes.
</para>


<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -A eth1-rules -p tcp --dport 80 -j ACCEPT </userinput>
<prompt>[root@hven /]#</prompt> <userinput>iptables -A eth1-rules -j DROP </userinput>
</screen>

<para>
Svarpakker til brugerne inde på lokalnettet vil imidlertid også
blive stoppet af denne stop-regel, så nu vil vi benytte
connection tracking og indsætte en regel, som siger, at alle
pakker, som er beslægtede med en forbindelse, som allerede er
oprettet, skal accepteres.
</para>


<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -I eth1-rules -m state --state ESTABLISHED,RELATED -j ACCEPT </userinput>
</screen>

<para>
Denne regel bliver nu nummer 1, og de andre rykker ned som 2 og
tre. Hvis vi hellere vil sætte denne regel ind som nummer 2, skal
kommandoen hedde <command> iptables -I eth1-rules 2 -m state
--state ESTABLISHED,RELATED -j ACCEPT </command> 
</para>

<para>
<command> -m state </command> fortæller kernen, at den skal
benytte tilstandsmodulet, ip_conntrack. Derefter er det
nødvendigt at bruge --state parameteren til at fortælle, hvilke
tilstande, der skal accepteres. Ud over ESTABLISHED og RELATED er
der bl.a. NEW og INVALID, som betyder at en pakke ikke tilhører
nogen kendt forbindelse.
</para>

<para>
Læg mærke til, at der ikke er mellemrum efter kommaet mellem de
to tilstande, det må der ikke være.
</para>

<para>
Lad os nu antage, at vi slet ikke kan lide telnet protokollen,
heller ikke internt på det lille net, og derfor vil blokere for
al telnet. Nu er det jo så en applikationsprotokol, så vi kan
ikke bruge --protocol. Med andre ord, telnet står ikke i
<filename> /etc/protocols </filename> og derfor må vi "sigte
efter telnet" på en anden måde, fx. ved at stoppe al trafik, som
har destination port 23.
</para>

<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -I INPUT -p tcp --dport 23 -j DROP </userinput>
</screen>

<para>
Der benyttes -I, insert, fordi reglen skal komme før
eth1-reglerne, hvis det skal nytte noget. Der står jo en accept
inde i eth1-reglerne, som kunne forstyrre billedet (lidt).
Nyere versioner af iptables vil kunne matche generelt på --ports
23, så det både er afsender/modtager pakker, som stoppes.
</para>

<para>
Eksemplet er ikke fuldkomment endnu, hvis de andre lokalnet
maskiner har "private IP-adresser" - så næste opgave går ud på at
opsætte NAT for de 4 lokalmaskiner.
</para>

</sect2>

<sect2 id="sikkerhed-start-nat">
<title>Opsætning af NAT</title>

<para>
NAT og Masquerading sker i nat-tabellens FORWARD kæde, når en
datapakke skal til at forlade maskinen. 
</para>



<screen>
<prompt>[root@hven /]#</prompt> <userinput>iptables -t nat -A POSTROUTING --src 192.168.1.0/24  -o eth1 -j SNAT --to x.y.w.z   </userinput>
</screen>

<para>
Hvis man bruger en dynamisk IP adresse, skal kommandoen se lidt
anderledes ud.
</para>




</sect2>

</sect1>
</chapter>

