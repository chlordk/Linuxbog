<chapter id="Introduktion">
<TITLE>Introduktion til sikkerhed</TITLE>

<sect1>
<title>Hvorfor er netværk usikkert?</title>
<para>
Din maskine har ofte en del netværksservices åbne på forskellige "porte",
når du har adgang til Internet. En port er ikke en fysisk port, men en 
logisk indgang til din maskine via netværksenheden (modem eller 
netværkskort). Disse "åbne porte" benyttes til at udføre 
netværkskommunikation, hvis maskinen tilbyder netværksservices som f.eks. ftp.
Men de kan også misbruges, så uautoriserede
personer kan komme ind på din computer via nettet. Dette kan ske, hvis der 
er fejl i den software der styrer netværksportene, eller hvis du lader dem 
stå helt åbne uden nogen form for adgangskontrol. Det kan også ske selvom 
du har adgangkontrol, hvis folk har mulighed for at opsnappe dit brugernavn 
og password via nettet.
Ofte kan man direkte samle brugernavne og passwords op på nettet ved at 
bruge et "sniffer" program, som lytter til trafikken på et givent sted.
</para>

<para>
Dette er bare en forsmag på de emner, vi vil komme nærmere ind på i de
kommende kapitler.
</para>

<sect2 id="linux-usikkert">
<title>Er Linux et usikkert system?</title>
<para>
Nogen har anklaget Linux for at være et meget usikkert system, idet alle 
kan læse kildeteksten. Når man kan læse kildeteksten til f.eks. 
netværksprogrammer og se hvordan, de fungerer, er det nemt finde 
eventuelle fejl.
Disse kan bruges til at lave angreb på Linuxmaskiner. Dette er delvis sandt! 
<emphasis>Men</emphasis> alligevel ikke. Vi ser på hvorfor.
</para>

<para>
For at knække sikkerheden på et UNIX system, skal man enten
<emphasis>kende</emphasis> en fejl i systemopsætningen eller
<emphasis>lede efter</emphasis> fejl.

For en kommerciel leverandør er en fejl ofte et prestigetab, og derfor er 
det måske ikke alle fejl, som bliver offentligt kendt. Hvis ingen kendte
de fejl, der er i de lukkede UNIX systemer, ville alt være godt. Men ofte
bliver fejl i lukkede UNIX systemer opdaget og kendt.
Det kan skyldes at nogen udefra opdager fejlen ved et tilfælde, eller måske 
leder de bevidst efter fejl - eller at nogen indefra lækker information  
eller taler over sig. Så ender fejlen måske på en Internethjemmeside
eller som en artikel i en avis -
og så har du problemet: Hvis den, der vil bryde 
ind, kender fejlen, og du ikke kender den og tager højde for den, kan han 
komme ind på dit system. 
</para>

<para>
Det er nok nærmest umuligt at gardere sig imod at en sikkerhedsbrist 
bliver offentligt kendt. 
</para>

<para>
Ud over kendte sikkerhedshuller kan den, der vil bryde ind, selv lede efter
fejl. I en lukket UNIX er det langt sværere at lede efter fejl end i Linux, 
fordi man ikke har kildeteksten. Men en måde at finde sikkerhedsfejl på, 
er at prøve gamle sikkerhedshuller af på nye maskinopsætninger - men med 
ændringer svarende til nye ideer. Nogle gange sker det så, at der er
bid. Et system er ikke sikkert imod crackere, bare fordi kildeteksten er 
lukket.
</para>

<para>
Erfaring viser, at nogle af de helt store firmaer er meget ringe til
at oplyse om sikkerhedsfejl - de skal helst negligeres eller
skjules. Sikkerhedsbristerne findes ofte hurtigt refereret på Internet,
mens firmaerne bruger lang tid på at lukke sikkerhedshullet
ordentligt. I al den tid er maskinerne åbne for sikkerhedsangreb.
</para> 

<para>
Linuxverdenen vender alle disse dogmer på hovedet. For det første
findes al relevant kode på Internet til offentlig beskuelse. Så nok
er der mennesker, som kan læse og bryde sikkerheden for andre, men
Linuxverdenen er indrettet, så der er en meget stor prestige i at
finde og specielt lappe sikkerhedshuller. Derfor vil folk, der
finder fejl, oftest fortælle offentligt om de fundne fejl fremfor at
gemme informationen. Det kan selvfølgelig også være, at man i stedet
vælger at udnytte informationen til at bryde ind på nogens system. Så kan
det være et af de første "ofre" der rapporterer fejlen. Da vil man 
fokusere på hvilken service, der gav sikkerhedshullet. Oftest vil Linuxverdenen
indlede en klapjagt for at få fjernet problemet og 
udgive nye versioner af de berørte programmer. Det bliver en slags "trofæ" 
at komme først med den korrekte rettelse. Normalt er man nede på dage 
eller ofte timer, fra en sikkerhedsfejl er rapporteret, til den er fundet 
og rettet, hvilket er markant mindre end på nogen af de andre systemer.
</para>

<para>
Alt dette lyder meget rosenrødt, men hvis din Linuxmaskine har en
kendt sikkerhedsbrist, og maskinen er på et usikkert netværk såsom
Internet, så er der er en pris at betale.
Du <emphasis>skal</emphasis> opdatere din maskine, når der er fundet
sikkerhedsbrister, og den tilsvarende sikkerhedsrettelse er
publiceret. Ellers har du reelt set nul sikkerhed!  Alle kan jo se
hvad, der er galt i din kode - det har været diskuteret på Internet for,
at man har kunnet lave rettelsen. På 
<ulink url="http://www.rootshell.com">http://www.rootshell.com</ulink> ligger
der oftest anvisninger af både problemets omfang, karakter, udnyttelse
og reparation.
</para>
</sect2>

<sect2 id="angrebs-typer">
<title>Hvilke angreb kan jeg blive udsat for</title>
<para>
Der er flere forskellige typer angreb, der kan ramme din maskine. Der
er forskellige metoder, en angriber kan benytte sig af, og som man kan gøre
noget for at beskytte sig imod. Der er også forskel på, hvilken type
adgang en angriber får til dit system, og hvor alvorlige konsekvenser
et vellykket angreb har for dig. 
</para>

<para>
Lad os først se på, hvordan en angriber kan bære sig ad med at få adgang
til dit system.
</para>

<itemizedlist mark="bullet">
<listitem><para>
<emphasis>Exploits</emphasis>
Det mest almindelige er at gå efter nogle netværksservice programmer, 
der er fundet fejl i. Disse fejl udnyttes ofte for at få fuld adgang
til maskinen (<ulink url="rootaccess.html">root-adgang</ulink>). Som 
tidligere nævnt skal man holde øje med annoncerede sikkerhedsfejl,
og få opdateret de anfægtede programmer. Vi vil i <xref linkend="services"> se på hvorfor og hvordan, du minimerer disse problemer.
</para></listitem>

<listitem><para>
<emphasis>Password angreb</emphasis>
Den klassiske måde at komme ind på et system på er at få fat i et
brugernavn og password (helst root passwordet). 

<itemizedlist mark="bullet">
<listitem><para>
<emphasis>Packet sniffing</emphasis>
Man kan opsnappe brugernavne og passwords, hvis disse sendes i klar, 
ukrypteret form over nettet - se "man-in-the-middle angreb" herunder. 
Vi kommer desuden tilbage til
emnet i <ulink url="netvaerk.html">Artikel
4. Remote login og netværksaflytning</ulink>.
</para></listitem>

<listitem><para>
<emphasis>Brute force</emphasis>
Man kan knække et svagt password med rå computerkraft. Se Artikel 3 
<ulink url="rootaccess.html">Root access - hvem, hvordan og hvorfor ikke?</ulink>.
</para></listitem>

<listitem><para>
<emphasis>Social engineering angreb</emphasis>
Ofte kan en angriber slutte sig til ting ud fra sin viden om menneskelig
adfærd. F.eks. at en bruger vil benytte det samme passwords til mange ting
for at slippe for at huske så mange passwords. Så har man et password fra
en telnet session, man har overvåget, kan det sikkert bruges til andre ting
også.</para></listitem>
</itemizedlist>
</para></listitem>

<listitem><para><emphasis>Man-in-the-middle angreb</emphasis>
Her er tale om at angriberen befinder sig et sted på netværket, hvor dine
data-pakker kommer forbi. F.eks. hos din Internetudbyder eller på dit 
lokalnetværk. Eller i princippet et vilkårligt sted på Internet, 
hvor dine pakker kommer forbi.
</para></listitem>

<listitem>

<itemizedlist mark="bullet">
<listitem><para><emphasis>Packet sniffing</emphasis>
Det mest almindelige man-in-the-middle angreb er, at angriberen kigger på 
dine data-pakker for at opsnappe information. Det kan f.eks.være 
brugernavne og passwords, som sendes i klar tekst over nettet, eller dine 
firmahemmeligheder, hvis du kunne finde på at sende dem ukrypteret afsted.
</para></listitem>
<listitem><para><emphasis>Session hijacking</emphasis>
En anden type man-in-the-middle angreb er, at en angriber går ind og 
overtager en igangværende session f.eks. en telnet session. Dette er
i praksis meget vanskeligt på Internet, da det enten kræver at
target-maskinen bruger forudsigelige tcp sekvens-numre, eller at man
kan aflytte trafikken. Det første er ikke muligt i Linux, og hvis man
kan det andet, er det meget nemmere blot at sniffe brugernavn og
password.
</para></listitem>
</itemizedlist>
</listitem>

<listitem><para><emphasis>IP spoofing</emphasis>
IP Spoofing går ud på at få systemet til at tro, at angriberens computer 
er en autoriseret computer, der har lovlig adgang. Dvs. at angriberens 
computer udgiver sig for at være en autoriseret host ved at bruge 
dennes IP-adresse. Dette kan bruges til at indsætte angriberens data i 
en datastrøm. Hvis angriberen ønsker at opnå tovejskommunikation, hvor 
han modtager de pakker, der er tiltænkt den, han udgiver sig for, er det 
sværere. Så skal han ind og ændre routing tabellerne. 
</para></listitem>

<listitem><para><emphasis>Trojanske heste</emphasis>
"Trojanske heste" er programmer, der indeholder skjult funktionalitet. Et 
velkendt program på dit system kan se helt uskyldigt ud og udføre sin 
normale funktion. Programmet kan imidlertid være modificeret, så det 
ud over sine normale opgaver f.eks. mailer navne og passwords til en fast 
modtager eller lader ukendte personer logge ind på maskinen uden, 
at dette skrives i systemets logfiler. 
"Trojansk heste" kan være programmer efterladt af en angriber, der har 
været inde på dit system. De kan skjule hans spor og lette hans adgang 
næste gang (<emphasis>back-doors</emphasis>). Det kan imidlertid også være programmer, 
du selv har download'ed og installeret. Du tror, du installerer et 
almindeligt program, men i virkeligheden er det en modificeret udgave, 
du har fået fat i. Heldigvis medfører traditionen med 
<ulink url="http://www.opensource.org">Open Source</ulink> 
programmer, at vi har
adgang til kildeteksten, og at man i praksis ikke kan skjule disse problemer
for os. Downloader du binære programmer (såsom RPM pakker), så bør
dette kun ske fra betroede steder, hvor du kan regne med at der bliver
holdt styr på sikkerheden - men det er altid en risiko, du må løbe. 
Ydermere findes der PGP-nøglesignaturer i alle RPM-pakker, som man
kan bruge til at checke, hvem der har lavet den enkelte pakke.
Heldigvis er problemerne i Linux verdenen meget små i forhold
til det niveau, som Windows verdenen er udsat for med virus i programmer 
og selv i Word dokumenter. Et velkendt eksempel på en trojansk hest fra i
Windows verdenen er "Back orifice". Hvis det først er installeret, giver 
det folk udefra fuld kontrol over den inficerede maskine via
Internet. 
</para></listitem>
</itemizedlist>


<para>
Vi har nu set på forskellige metoder, en angriber kan bruge til at få
adgang til dit system. Men hvad kan han bruge det til?  Lad os dele
angrebene op efter resultatet - hvad opnår vedkommende, og hvor
farligt er det for dig.
</para>

<itemizedlist mark="bullet">
<listitem>
<para><emphasis>Læseadgang</emphasis>
Angriberen kan stjæle (kopiere) dine data. Dette er alvorligt, hvis du 
har hemmelige data, som kan udnyttes af andre på en måde, der skader dig.
Læseadgang kan f.eks. opnås ved packet sniffing - hvis der er værdifuld
information i pakkerne. Man kan beskytte sig ved at kryptere sine data.
Læseadgang kan også opnås ved IP spoofing, hvis angriberen f.eks. giver 
din maskine besked om at videresende en vigtig 
email til ham. Endelig kan det opnås, hvis angriberen opnår login på
dit system f.eks. ved at have skaffet sig et brugernavn og tilhørende 
password. Har man login på maskinen, kan man naturligvis også skrive men
kun i de filer, der er adgang til for den bruger, man er logget ind som.
</para></listitem>

<listitem>
<para><emphasis>Skriveadgang</emphasis>
Ud over at dine data kan blive stjålet, kan du risikere, at de er ændret, 
og at dit system er modificeret. Dette er meget alvorligt. Dit system er
kompromitteret.
</para>

<para>
Skriveadgang kan opnås, hvis angriberen opnår login på systemet. Han kan
modificere de data, som det anvendte brugernavn har adgang til. Hvis
han er inde som root, har han fuld adgang til at ødelægge eller modificere
dit system. Root adgang kan ud over at opsnappe eller knække root passwordet
opnås ved at udnytte et sikkerhedshul i en netværksservice f.eks. sendmail.
En angriber kan også opnå skriveadgang til dit system ved IP spoofing - 
hvis man kan ændre indholdet af pakker, der bliver sendt over nettet, uden
at modtageren opdager det, så har man effektivt forfalsket data. Det kunne
også være kommandoer til systemet. Har an angriber først haft skriveadgang 
til dit system, skal du være meget forsigtig. Du ved ikke hvilke data, der er
ændret - måske er de programmer, du kontrollerer dit system med, selv 
modificeret, og du kan ikke regne med dem længere. Du ved måske ikke med 
sikkerhed, hvornår han første gang har været inde, og dine backups kan være 
inficeret et stykke tid tilbage. Vi kommer tilbage til, hvad du skal gøre 
for at opdage et indbrud i <xref linkend="filcheck">. 
Har en angriber lokket dig til at installere en trojansk hest, er det også
en slags skriveadgang - dit system er modificeret.
</para></listitem>
</itemizedlist>

<sect3>
<title>Denial of Service angreb</title>

<para>
Denial of Service (DoS) angreb har til formål at få din maskine til at
holde op med at gøre det, den er sat til. Dette er knap så alvorligt
som et reelt indbrud på systemet, men kan alligevel godt koste meget
tid og mange penge.  Eksempler på DoS angreb er <emphasis>Pentium F00F
fejlen</emphasis>, <emphasis>ping of death</emphasis> eller
<emphasis>teardrop</emphasis>, som får maskinen til at låse. Disse
fejl er rettet i nyere Linux systemer.
</para>
</sect3>

<sect3>
<title>Syn flooding og Ping flooding</title>

<para>
Ved <emphasis>SYN flooding</emphasis> og <emphasis>Ping
flooding</emphasis> udsættes maskinen for en voldsom belastning fra en
eller flere angribere med at svare på netværksforespørglser, og det er
ikke muligt at bruge andre netværksservices på grund af
overbelastning.
</para>
</sect3>

<sect3>
<title>Smurfing</title>

<para>
Ved <emphasis>smurfing</emphasis> er det netværket, der
overbelastes. Disse problemer kan der dæmmes op for ved fornuftig
router-konfiguration. Der er også angreb, hvor der uploades meget
store mængder data til en anonym ftp konto, hvor formålet er at få
diske til at løbe fulde. Disse problemer kan der dæmmes op for med
disk kvoter og/eller smart partitionering (eller at upload af filer
disables).</para>

<para>
Fra den mere muntre ende kan vi lige vise lidt om DoS angreb fra 
<ulink url="http://www.userfriendly.org/cartoons/archives/99aug/19990807.html">User Friendly strippen den 7/8 99</ulink>.
</para>

<FIGURE ID="uf000914-fig" FLOAT="1">
<TITLE>User Friendly</TITLE>
<GRAPHIC FILEREF="uf000914.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>  
</sect3>

</sect2>

</sect1>

<sect1>
<title>Har mit system sikkerhedsproblemer?</title>

<para>
Nu skal vi se på, hvor meget du udsætter din maskine for, når du 
tilslutter den til Internet. Vi tager udgangspunkt i en Linux maskine, 
som har en netværksopkobling enten via modem eller fast forbindelse. 
Det er reelt ikke så vigtigt, at det er en Linuxmaskine - alle 
systemer med netværk har samme karakteristiske træk. 
</para>

<para>
Lad os inddele verden efter  
</para>

<itemizedlist mark="bullet">
<listitem><para>"On and off" :
Opkobling sker med modem og f.eks. PPP. Der hentes emails og
surfes minimalt på Internet.
</para>

<para>Du har ikke så meget at frygte, selvom du måske ikke har styr på
din sikkerhed på maskinen.  Når du laver en modem opkobling til
Internet, får du tildelt en IP-adresse, dvs. en adresse, som alle kan
tilgå din maskine på. Men den adresse er forskellig fra gang til gang
når du laver opkobling. Derfor bliver det i praksis umuligt at checke
din maskines sikkerhedshuller fra en anden maskine, før du igen har
lukket forbindelsen. Der er dog oplagt, at den risiko, du løber,
svarer nøje til den tid du er koblet på Internet.
</para>


</listitem>

<listitem><para>"Seriøs surfing" : Opkobling sker med modem og f.eks. PPP. Der
hentes emails jævnligt, og der surfes en del. Denne situation kan
også gælde for en maskine, som via automatiske services laver
internetopkobling for et helt lokalnet. Til Linux er det
ofte "diald", som bruges til dette.
</para>
<para>
Du er tilkoblet Internet i længere tid ad gangen men stadig med 
forskellig IP-adresse hver gang, så du er ikke helt nem at finde.
Men i modsætning til "On and off" brugeren er du på så lang tid, 
at der godt kan
laves skanning på din maskine. Hvis der findes en usikker service,
kan den måske give oplysninger om svagheder i dit system, og dermed
kan din netværkssikkerhed rammes. Du bør tænke på hvilke åbninger, 
der er i dit system. Du bør lære noget om grundlæggende
netværkssikkerhed. Læs f.eks. resten af artiklerne i denne serie.
</para>

</listitem>

<listitem><para>"Fast opkobling" : Maskinen har fast opkobling til Internet via
ethernet, ISDN eller anden forbindelse.
</para>
<para>
Du kan skannes fra en enhver maskine på Internet medmindre der er
firewalls eller såkaldte proxy servere imellem. Du kan ikke
overvåge alt 24 timer i døgnet. Maskinen efterlades. Du må checke
dine log filer! Slå overflødige netværksservices fra og begræns adgangen
til dem, der er tilbage. Du bør lære noget om sikkerhed. Læs f.eks. som en
start de kommende artikler i denne serie. På Internet er der også
masser af information, og der findes gode bøger om emnet.
</para>
</listitem>
</itemizedlist>


<para>
Lad os antage, at din maskine har direkte adgang til internet uden 
firewall eller anden beskyttelse. Vi vil nu se på, hvorfor 
din maskine kan være udsat, og hvordan andre finder ud af, at du har en
maskine på nettet. At det netop er din maskine, som er udset til et
crackerangreb, kan skyldes mange ting: Tilfældigheder, at du anses
for at ligge inde med interessante data, eller at du ikke har
vedligeholdt din Linux maskine og fået lukket de kendte sikkerhedshuller. 
</para>

<para>
En angriber har flere måder at finde din maskine på. En er f.eks.
at studere headerne i dine emails. En anden er at hente listen
over hostnavnene i dit domæne vha. DNS (navneservere). En mere
direkte måde er at bruge ping.
</para>

<para>
En cracker kan derefter spørge din maskine, hvilke services den 
tilbyder, og måske finde et sikkerhedshul. Som eksempel kan vi tage ssh,
som tilbydes på port 22. Med telnet kan man logge ind på port 22 og få
versionsnummeret på ssh. I det følgende eksempel finder vi ud af, at det 
er ssh version 1.2.27, der kører. Kan crackeren f.eks. på Internet finde 
en beskrivelse af en sikkerhedsfejl i den version af ssh, kan han udnytte
dette til at angribe dit system med.
</para>

<SCREEN>
[robin@sherwood robin]$ telnet locksley 22
Trying 172.17.0.3...
Connected to locksley
Escape character is '^]'.
SSH-1.5-1.2.27                          
</SCREEN>

<para>
Normalt er det nødvendigt, at din maskine har nogle af 
de mange netværksservices kørende, da de bruges til at kommunikere med 
andre maskiner via netværk. Ofte kan de fleste af dem dog slås fra, se 
<ulink url="services.html">Artikel 2: Netværkssikkerhed - Services</ulink>.
</para>

<para>
I stedet for at en cracker manuelt skal gennemse alle dine porte for mulige
huller, kan han gøre det nemmere og meget hurtigere ved at installere 
programmer såsom nmap. Nmap kan hentes på 
<ulink url="http://www.insecure.org/nmap">http://www.insecure.org/nmap</ulink>.
Med nmap kan man dels se hvilke maskiner, der er i live,
men også hvilke porte, der er åbne. Nedenstående eksempel viser, at
maskinen "locksley" har (alt for) mange porte åbne. 
</para>

<SCREEN>
[robin@sherwood robin]$ nmap locksley
Starting nmap V. 2.12 by Fyodor (fyodor@dhp.com, www.insecure.org/nmap/)
Interesting ports on locksley.herne.dk (172.17.0.3):
Port    State       Protocol  Service
21      open        tcp        ftp
22      open        tcp        ssh
23      open        tcp        telnet
25      open        tcp        smtp
79      open        tcp        finger         
80      open        tcp        http
98      open        tcp        linuxconf
111     open        tcp        sunrpc
113     open        tcp        auth
513     open        tcp        login
514     open        tcp        shell
515     open        tcp        printer
6000    open        tcp        X11             

Nmap run completed -- 1 IP address (1 host up) scanned in 2 seconds       
</SCREEN>

<para>
Eksemplet med nmap svarer til, hvad man udefra kan se om maskinen. Har
man adgang til maskinen, så kan "netstat -a" også være interessant,
idet kommandoen viser alle de netværksforbindelser, som er etableret,
samt de ventende serverprogrammer. Et forkortet output af "netstat -a"
kan være følgende, hvor man kan se, at en telnet session fra sherwood
til locksley er igang, og serverprogrammer ssh, sendmail (smtp),
telnet og ftp er klar.
</para>

<SCREEN>
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address             Foreign Address             State      
tcp        0      0 locksley.herne.dk:telnet  sherwood.herne.dk:1074      ESTABLISHED
tcp        0      0 *:ssh                     *:*                         LISTEN      
tcp        0      0 *:smtp                    *:*                         LISTEN      
tcp        0      0 *:telnet                  *:*                         LISTEN      
tcp        0      0 *:ftp                     *:*                         LISTEN      
</SCREEN>

<para>
Man kan også have interesse i at bruge det grafiske program cheops,
som findes på
<ulink url="ftp://ftp.marko.net/pub/cheops/RPMS/">ftp://ftp.marko.net/pub/cheops/RPMS/</ulink>.
Programmet er skrevet sådan, at det grafisk viser hvilke maskiner, som er i live, 
og evt. overvåger, at de forbliver i live. Cheops er nok primært beregnet 
til at give systemadministratoren et hurtigt overblik over netværket, men 
det kan også bruges til at udse sig svage maskiner, som kan
crackes. På 
følgende billede er vist, hvordan cheops ud fra et domænenavn selv
finder ud af, at der er seks maskiner i live. Det vises grafisk hvilket 
operativsystem, der anvendes på hver af dem. Fra venstre mod højre: SGI IRIX, 
Linux, HP/UX, HP/UX, Windows og endelig en speciel maskine. 
</para> 

<FIGURE ID="cheops-fig" FLOAT="1">
<TITLE>Cheops</TITLE>
<GRAPHIC FILEREF="cheops.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>  

<para>
Flytter man musen ned på ikonet for maskinen, får man flere oplysninger
om den ofte også versionsnumre, og man kan yderligere direkte skanne
maskinen for alle oplysninger. Man kan ofte se alt for meget - især når 
folk ikke har deres sikkerhed i orden.
</para>

<FIGURE ID="cheops2-fig" FLOAT="1">
<TITLE>Cheops</TITLE>
<GRAPHIC FILEREF="cheops2.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>  

<para>
Det er altså nemt at trække informationer ud af en ubeskyttet maskine.
</para>
</sect1>

<sect1>
<title>Hvordan sikrer jeg min maskine?</title>

<para>
Hold din maskine ajour med sikkerhedsrettelser. 
Du kan følge med på diverse postlister/nyhedsgrupper om sikkerhed, 
og websider - se under <ulink url="#referencer">referencer</ulink>.  
Ofte kan man hurtigt efter en fejl er opdaget, downloade rettelsen 
fra Internet.
</para>

<para>
Når du downloader en sikkerhedsopdatering, så tænk lige på om den
kommer fra et sted, du stoler på - den kunne i princippet være
falsk. Det er den sikkert ikke, men nøjes alligevel med at downloade
fra "officielle" steder. Den første lektie, du skal lære, hvis du vil
have et sikkert computer system, er at være en lille smule paranoid.
:-) Der er intet på nettet, der er helt sikkert.
</para>
</sect1>

<sect1>
<title>Referencer</title>

<para>Gode steder at starte</para>

  <itemizedlist mark="bullet">
    <listitem><para>Linux Administrator's Security Guide (LASG) by Kurt Seifried.
        Denne bog er guld værd - og kan findes på 
        <ulink url="http://securityportal.com/lasg/">http://securityportal.com/lasg/</ulink>.
    </para></listitem>
    <listitem><para>Linux Security HOWTO - 
        <ulink url="http://sunsite.auc.dk/ldp/HOWTO/Security-HOWTO.html">http://sunsite.auc.dk/ldp/HOWTO/Security-HOWTO.html</ulink>
    </para></listitem>
  </itemizedlist>

<para>
Annonceringer af fejl i flere af de kendte Linux distributioner:
</para>

  <itemizedlist mark="bullet">

    <listitem><para><emphasis>Debian</emphasis> 
       <ulink url="http://www.debian.org/security/">http://www.debian.org/security/</ulink>
       Lister sikkerhedsrelaterede fejl i Debian.
    </para></listitem>
    <listitem><para><emphasis>SuSE</emphasis> 
       <ulink url="http://www.suse.de/security/index.html">http://www.suse.de/security/index.html</ulink>
       har liste over sikkerhedsfejl i SuSE.
    </para></listitem>
    <listitem><para><emphasis>Red Hat</emphasis> 
       <ulink url="http://www.redhat.com/support/errata">http://www.redhat.com/support/errata</ulink>
       Generel entry til fejllisterne. Du bør nok også se på den nyeste
       (pt. Red Hat 6.2)
    </para></listitem>
  </itemizedlist>

<para>Steder som ellers bør eller kan følges</para>
  <itemizedlist mark="bullet">
    <listitem><para>Bugtraq <ulink url="http://www.securityfocus.com">http://www.securityfocus.com</ulink>
      bør du følge med på for at læse om de nyeste exploits.
    </para></listitem>
    <listitem><para>Root Shell <ulink url="http://www.rootshell.com">http://www.rootshell.com</ulink>
      har alt indenfor diskussion af sikkerhed.
    </para></listitem>
    <listitem><para>Linux Today <ulink url="http://linuxtoday.com">http://linuxtoday.com</ulink> bringer
      også sikkerhedsbrister frem sammen med andre nyheder.
    </para></listitem>
    <listitem><para><ulink url="http://www.securityportal.com/">http://www.securityportal.com/</ulink>
      er et andet interessant sted, som interesserer sig for sikkerhed.
    </para></listitem>
    <listitem><para>Linux Security WWW - 
        <ulink url="http://www.aoy.net/Linux/Security">http://www.aoy.net/Linux/Security</ulink>,
        med mange  Linux-relaterede sikkerheds annonceringer, FAQ og links.
    </para></listitem>
    <listitem><para>Linux Security Home Page - 
        <ulink url="http://www.ecst.csuchico.edu/~jtmurphy/">http://www.ecst.csuchico.edu/~jtmurphy/</ulink>
    </para></listitem>
    <listitem><para>Reptile's Linux Security Page - 
        <ulink url="http://www.reptile.net/linux">http://www.reptile.net/linux</ulink>
    </para></listitem>
    <listitem><para>Infilsec Vulnerability Engine - 
        <ulink url="http://www.infilsec.com/vulnerabilities/">http://www.infilsec.com/vulnerabilities/</ulink>
        - generelt om sikkerhed.
    </para></listitem>
    <listitem><para>Munitions - <ulink url="http://munitions.polkaroo.net/">http://munitions.polkaroo.net/</ulink>
        - stor samling af viden og programmer om kryptering af data 
          og netværkstraffik til Linux.
    </para></listitem>
  </itemizedlist>
</sect1>
</chapter>



<chapter id="services">
<title>Netværkssikkerhed - Services</title>

<sect1>
<title>TCP/IP services</title>
<para>
En Linuxcomputer forventer at være på netværk. Hvis der ikke er
noget netværk, laver den bare et for sig selv. Uanset om din Linuxcomputer
er på et netværk eller ej, tilbyder den en række 
netværksservices.
</para>

<para>
Er din computer koblet til netværk, er den udsat for
misbrug udefra. Derfor er det vigtigt, at du forstår, 
hvilke services din maskine tilbyder, hvad disse services gør, hvem de 
tilbydes til, og at du i øvrigt har så få services kørende som muligt. 
Services, du ikke bruger, bør slås fra, idet de kan give andre adgang til
maskinen. Hvis din Linuxmaskine ikke er på et netværk, kan du egentlig være 
ligeglad med, hvilke services den tilbyder. Og dog - imorgen kommer den 
måske på lokalnet, og i overmorgen bliver lokalnettet sluttet til Internet. 
Denne kendsgerning kommer bag på de fleste, og det er en god ide at gøre 
sig nogle sikkerhedsovervejelser på forhånd. 
</para>

<para>
Hvad er en service? Det er et program, der kører på din computer, som
er beregnet til at andre kan koble sig til din computer og udveksle data. 
Det kan f.eks. være ftp, telnet, finger, pop-2, pop-3, rpc (herunder NFS), 
nntp og talk. Det kan også være http, smtp eller linuxconf.
</para>

</sect1>

<sect1>
<title>Netværksprotokoller og porte</title>

<para>
Før vi ser nærmere på, hvad Linuxmaskinen kan servicere for et
netværk, så lad os lige træde et skridt tilbage og se på, hvordan
systemet er bygget op. 
</para>

<para>
En Linuxmaskine vil normalt lave en masse ting samtidig, f.eks. 
håndtere emails, login brugere som kører programmer, samt have en 
web-server kørende. Derfor har man ikke bare kunnet nøjes med at 
hver enkelt computer har en IP-adresse. De forskellige services
lytter på hver sit "port"-nummer. F.eks. bruges port 21 til ftp,
port 22 til ssh (secure shell), port 23 til telnet, port 25 til 
smtp og  port 80 til http. De mest kendte 
(well-known) service portnumre, er tildelt af organisationen IANA
(Internet Assigned Numbers Authority).
I TCP/IP protokollen er det i TCP datapakkerne, man finder information 
om afsender port og modtager port, imens IP adressen på afsender og 
modtager er indeholdt i IP transportlaget. 
</para>

<para>
Porte er ikke fysiske men logiske konstruktioner, som anvendes i den måde,
man sender data over netværket. Man skelner imellem TCP og UDP porte, som 
bruges til to forskellige typer dataoverførsler. TCP er connection orienteret. 
Den sender hele tiden kvitteringer frem og tilbage (handshake), og når det 
går godt, behøver den ikke at få kvittering
for sine data så tit. Hvis en datapakke går tabt, vil den blive retransmitteret
af protokollen. Der findes også en anden type IP-pakker med betegnelsen UDP. 
UDP anvendes oftest til hurtig letvægts information, som kan accepteres at 
gå tabt i netværket såsom f.eks. NFS forespørgsler.
UDP pakker, der går tabt 
vil kun blive retransmitteret, hvis applikationen sørger for det
(typisk NFS).
</para>

<para>
Ofte tildeles en service både TCP og UDP porten med et givet nummer, 
selvom den kun bruger den ene.
</para>

<para>
User Friendly <ulink url="http://www.userfriendly.org/static">http://www.userfriendly.org/static</ulink>ser på IP-pakker...</para>

<FIGURE ID="uf000405-fig" FLOAT="1">
<TITLE>User Friendly</TITLE>
<GRAPHIC FILEREF="uf000405.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>  


<para>
Porte vælges ikke tilfældigt, men mange er standardiserede, så
maskiner kan koble sig til en given port og dermed vide hvilken
service, der kan findes. Hvis du læser filen
<FILENAME>/etc/services</FILENAME> på en vilkårlig UNIX maskine såsom
Linux, kan du se hvilke porte, der bruges til hvad. Udsnit af en
<FILENAME>/etc/services</FILENAME>:
</para>

<SCREEN>
ftp-data        20/tcp
ftp             21/tcp
telnet          23/tcp
smtp            25/tcp          mail
</SCREEN>

<para>
Først står navnet på servicen, derefter portnummeret og om det er tcp 
eller udp. Det sidste felt er til et evt. alias for denne service - i
eksemplet er <FILENAME>mail</FILENAME> et alias for <FILENAME>smtp</FILENAME>.
</para>

<para>
Portnumre under 1024 kaldes priviligerede porte, og man skal være root for
at kunne lytte på dem. Dette er lavet, så en klient, der kontakter en
fremmed maskine på en port under 1024, kan regne med at få fat i en standard 
service og ikke et eller andet tilfældigt bruger-program. Se 
<COMMAND>man services</COMMAND>.
</para>

<para>
IP (Internet Protocol) er den netværksprotokol, man bruger på Internet.
Der findes mange andre. - Apple har deres egen AppleTalk-protokol,
og Novell har IPX/SPX. UNIX maskiner bruger normalt IP, men har
historisk også gjort brug af andre protokoller, f.eks. Digital's
DECNET og Regnecentralens IMC. Linuxmaskiner kan forstå mange
af disse andre protokoller.
</para>

<sect2 id="daemons">
<title>Daemons</title>
<para>
En service kan enten køres som en selvstændig daemon, eller den kan 
styres af inetd. En daemon er en proces, som kører i baggrunden hele 
tiden, og venter på forespørgsler. Nogle services skal køre hele 
tiden og altid være klar, fordi det er nødvendigt med en hurtig responstid,
eller at de ikke må være nede. Et eksempel er named, som laver navneoplag via 
DNS, og som skal være hurtigt. Andre eksempler på daemons er lpd 
(printer daemon), syslogd (logger system events) og sendmail. 
Vi kigger nærmere på sendmail i et senere afsnit. 
En anden daemon, som vi skal se på om lidt, er inetd, der bruges til at
starte andre services efter behov.
Prøv at køre kommandoen
</para>

<SCREEN>
[robin@sherwood robin]$ ps aux |more
</SCREEN>

<para>
Denne kommando viser alle de kørende processer på systemet, og du vil
kunne genkende processer som lpd, syslogd og inetd.
</para>

</sect2>

<sect2 id="inetd">
<title>Inetd</title>
<para>
En del services har kun brug for at køre relativt sjældent. Disse 
services er i Linux styret af inetd-programmet. I stedet for at have
f.eks. in.telnetd kørende hele tiden, sættes inetd daemonen til at
lytte efter, om der er telnet forespørgsler, og starter in.telnetd 
efter behov.
</para>

<para>
Hvilke services, der skal startes, bestemmes af filen
<FILENAME>/etc/inetd.conf</FILENAME>. Eks.:
</para>

<SCREEN>
# These are standard services.
#
ftp    stream  tcp     nowait  root    /usr/sbin/tcpd  in.ftpd -l -a
telnet stream  tcp     nowait  root    /usr/sbin/tcpd  in.telnetd
gopher stream  tcp     nowait  root    /usr/sbin/tcpd  gn

...
</SCREEN>

<para>
En service kan slås fra ved at udkommentere den linie, der starter
den pågældende service.
Eks.:
</para>

<SCREEN>
ftp     stream  tcp     nowait  root    /usr/sbin/tcpd  in.ftpd -l -a
</SCREEN>

<para>
bliver efter udkommentering til
</para>

<SCREEN>
#ftp    stream  tcp     nowait  root    /usr/sbin/tcpd  in.ftpd -l -a
</SCREEN>

<para>
dvs. du indsætter et # foran den linie, der styrer den enkelte
service.  Dette gør, at denne service ikke bliver startet, og dermed
vil din maskine ikke længere stille ftp servicen til rådighed for
andre maskiner på nettet.  Når du alligevel retter i
<FILENAME>/etc/inetd.conf</FILENAME>, så udkommenter også linien med
gopher, som er en ældre service, der i dag er helt erstattet af http.
</para>

<para>
For at ændringerne i <FILENAME>/etc/inetd.conf</FILENAME> skal træde i
kraft, er det nødvendigt at genstarte inetd processen. Dette kan gøres
på flere måder.  Nogle distributioner har en struktur med startup
scripts, der bruges til dette formål. Under Red Hat og Debian ligger
de under <FILENAME>/etc/rc.d/init.d</FILENAME>
hhv. <FILENAME>/etc/init.d</FILENAME>. Så kan man bruge startup
scriptet til at genstarte inetd med.
</para>

<para>
Red Hat:
</para>

<SCREEN>
[root@sherwood robin]# /etc/rc.d/init.d/inet reload 
</SCREEN>

<para>
Debian:
</para>

<SCREEN>
[root@locksley robin]# /etc/init.d/netbase restart 
</SCREEN>

<para>
Der er dog også nogle Linux distributioner, der ikke benytter denne struktur
herunder Slackware, så vi har brug for en mere generel løsning. For en 
vilkårlig distribution kan man genstarte inetd ved at skrive:
</para>
<SCREEN>
[root@sherwood robin]# killall -1 inetd
</SCREEN>

<para>
Bemærk, at du i eksemplet kun slår din ftp-<emphasis>server</emphasis>
fra. Du kan stadig bruge ftp fra maskinen til andre maskiner. Man kan
bare ikke længere bruge ftp udefra og ind til din maskine.
</para>

<para>
Inetd har den sikring, at en service bliver lukket ned i 10 minutter, 
hvis der kommer mere end 20 forespørgsler i sekundet. For nogle services
er dette ikke acceptabelt. Det er derfor, programmer som named og syslogd
kører udenom inetd som daemons.  
</para>

<para>
Gennemgå de andre services i <FILENAME>/etc/inetd.conf</FILENAME> på
samme måde som vist ovenfor.  Undersøg, hvad der kører på din maskine,
og find ud af om det er nødvendigt at de enkelte services kører. Hvis
ikke, så slå det fra.  En gylden regel er, at du hellere må køre for
få end for mange services.  Vi kommer senere til en gennemgang af de
services, der findes i <FILENAME>/etc/inetd.conf</FILENAME>.
</para>
</sect2>

<sect2 id="TCP-wrappers">
<title>TCP wrappere</title> 
<para>
Adgangen til de services, der styres af inetd, kan på en nem
måde konfigureres, så der er kontrol over hvem, der har adgang til
at bruge de forskellige services, maskinen tilbyder.
</para>

<para>
Dette gøres ved at anvende en TCP-wrapper (tcpd), som er en
agent, der bliver eksekveret i stedet for din normale server
applikation. Den sørger for at requests om service bliver logget 
til syslogd, og den giver en stærk og fleksibel adgangskontrol.
Man kan f.eks. også få den til at sende sig en email, hvis nogen
udefra forsøger at lave en telnet til maskinen.
</para>

<para>
Tcpd virker sådan, at hver gang, der kommer en forespørgsel til
inetd om at starte en service, er det tcpd, der får lov at starte den.
Tcpd  rapporterer til syslogd, hvad der sker, så det bliver skrevet 
i logfiler, og checker, om den kaldende
host har adgang til den pågældende service. Hvis alt er i orden,
starter tcpd servicen, og afslutter sig selv. Simpelt og elegant.
Tcpd skal sættes ind i <FILENAME>/etc/inetd.conf</FILENAME>-filen i stedet 
for navnet på den service, der skal udføres. 
Navnet på serviceprogrammet gives som parameter til tcpd. I de viste linier 
fra <FILENAME>/etc/inetd.conf</FILENAME> ovenfor er tcpd allerede sat ind.
</para>
</sect2>

<sect2 id="Adgang-til-din-maskine">
<title>Adgang til din maskine</title> 
<para>
Adgangskontrol sker via filerne <FILENAME>/etc/hosts.allow</FILENAME> og 
<FILENAME>/etc/hosts.deny</FILENAME>.
</para>

<para>
Når tcpd skal finde ud af, om der er adgang til en service, checker 
den først <FILENAME>/etc/hosts.allow</FILENAME>. Hvis der her er givet explicit adgang, 
godkendes forsøget, og servicen bliver startet. Hvis der ikke står
noget om den pågældene service i <FILENAME>/etc/hosts.allow</FILENAME>,
læses nu <FILENAME>/etc/hosts.deny</FILENAME>.
Hvis <FILENAME>/etc/hosts.deny</FILENAME> ikke indeholder noget, der forbyder 
den forsøgte adgang, vil forsøget blive godkendt. Det kan altså 
være en god ide at sætte sin <FILENAME>/etc/hosts.deny</FILENAME> op til at 
slutte med at afvise alt og alle. På den måde er man sikker på, 
at hvis der er noget, man ikke explicit har givet adgang til, så 
er der ikke adgang. På den anden side må man så sikre sig, at alle 
services, der skal kunne anvendes, er sat op i <FILENAME>/etc/hosts.allow</FILENAME>.
</para>

<para>
Filerne har det følgende format. Eks. på en linie:
</para>

<SCREEN>
in.telnetd: 192.168.0.0/255.255.255.0
</SCREEN>

<para>
I <FILENAME>/etc/hosts.allow</FILENAME> ville denne linie tillade alle på lokalnettet 
192.168.0.* at benytte telnet servicen. Stod linien i <FILENAME>/etc/hosts.deny</FILENAME>,
ville det betyde, at de ikke kunne.
</para>

<para>
Eksempel på <FILENAME>/etc/hosts.allow</FILENAME> fil:
</para>

<SCREEN>
in.ftpd: 0.0.0.0/0.0.0.0
ALL: 192.168.0.2
ipop3d: 192.168.0.0/255.255.255.0
</SCREEN>

<para>
Denne <FILENAME>/etc/hosts.allow</FILENAME> vil tillade hele verden adgang til ftp, og 
giver host 192.168.0.2 lov til alt. Hosts på netværket 192.168.0.*
har desuden adgang til pop3.
</para>

<para>
Eksempel på <FILENAME>/etc/hosts.deny</FILENAME> fil:
</para>

<SCREEN>
in.telnetd: 0.0.0.0/0.0.0.0
</SCREEN>

<para>
Denne <FILENAME>/etc/hosts.deny</FILENAME> fil sørger for, at ingen har adgang til 
telnet servicen. Dette gælder dog ikke for 192.168.0.2, da den 
allerede i <FILENAME>/etc/hosts.allow</FILENAME> har fået lov til alt herunder telnet.
</para>

<para>
En mere sikker <FILENAME>/etc/hosts.deny</FILENAME> ville være denne:
</para>

<SCREEN>
ALL: 0.0.0.0/0.0.0.0
</SCREEN>

<para>
Denne linie nægter alle adgang til alt, medmindre der specifikt er
givet lov i filen <FILENAME>/etc/hosts.allow</FILENAME>. Bemærk dog,
at du kan blive overrasket over ting, der ikke virker, hvis du har sat
den restriktive <FILENAME>/etc/hosts.deny</FILENAME>-fil op.  Vær
omhyggelig med at sætte de nødvendige tilladelser op i
<FILENAME>/etc/hosts.allow</FILENAME>. Hvis du har glemt at give
adgang til noget, opdager du det sikkert, når du skal bruge det, eller
når nogen brokker sig.  Har du derimod glemt at spærre for noget,
opdager du det måske først den dag, det bliver brugt til at bryde ind
på dit system.  Med sikkerhed og paranoia i højsædet er det smart at
have ovenstående linie i sin <FILENAME>/etc/hosts.deny</FILENAME>. Så
bliver forespørgsler afvist, hvis du ikke har sat dem ind i
<FILENAME>/etc/hosts.allow</FILENAME>. HUSK at en forespørgsel bliver
godkendt, hvis du ikke har angivet andet.
</para>

<para>
Se i øvrigt <COMMAND>man tcpd</COMMAND>, og <COMMAND>man
hosts.allow</COMMAND> eller <COMMAND>man hosts.deny</COMMAND> (de to
sidste er samme fil).
</para>
</sect2>
</sect1>

<sect1 id="inetd-slaa-fra">
<title>Hvilke inetd services skal jeg slå fra?</title>
<para>
Hvilke services, der kan undværes på dit system, afhænger af hvad
det skal bruges til, og det er dig selv der må afgøre det. Men vi
vil gennemgå de mest almindelige services, hvad de gør, om de er 
usikre, og hvad de evt. kan erstattes af.  
</para>

<sect2 id="telnet">
<title>Telnet</title>
<para>
Telnet (telnetd) er en service der gør, at folk kan logge ind på maskinen
ved hjælp af en telnet-klient. For at det er muligt at logge ind,
skal man have et brugernavn og tilhørende password, som findes på
maskinen. Når man er logget ind, kan man så udføre de tekstkommandoer, 
man plejer at kunne udføre, når man sidder foran maskinen. Telnet
kører normalt på port 23, men kan sættes op til en anden port.
</para>

<para>
Telnet er en gammel sag, fra dengang i begyndelsen af Internets 
historie, hvor der kun var venner og ingen fjender på nettet. Det var 
mest forskere på universiteter, der havde adgang, og de ville ikke 
hinanden noget ondt. Alle kendte mere eller mindre hinanden, så hvis 
man lavede ballade var man hurtigt upopulær blandt ligesindede. 
Den slags moral kan vi ikke regne med mere.
</para>

<para>
Mange af de "gamle" services er usikre i dag, fordi de slet ikke er 
designet med sikkerhed i tankerne men alene stabilitet og fornuftig ydelse.
</para>

<para>
Telnet er først og fremmest usikker, fordi den sender brugernavn og 
password som klar ukrypteret tekst over nettet. Dvs., at det er lige til
at læse for enhver, der måtte sidde og kigge på nettrafikken et sted
imellem dig selv og den maskine, du logger ind på. Det er særdeles 
risikabelt at bruge telnet over Internet, hvor alle i princippet kan
sidde og lytte med. 
</para>

<para>
På en maskine, der har adgang til Internet, bør telnet slås fra, og 
<ulink url="netvaerk.html#ssh">erstattes med ssh</ulink>. En grund til at beholde 
telnet kan dog være, at der findes telnet-klienter til stort set alle
systemer. Hvis man har brug for at logge ind fra et system, hvortil der
ikke findes en ssh-klient, kan det være nødvendigt at bruge telnet. Men 
det er risikabelt at lade en telnet service køre, hvis maskinen er på
Internet. Så overvej, om der ikke er andre muligheder for at løse dine behov.
</para>

<para>
Hvis telnet skal køre, kan man sikre sig bedre med adgangskontrol
(<FILENAME>/etc/hosts.allow</FILENAME>), ved at skifte password hver gang og
ved ikke at have det samme password på andre maskiner i lokalnettet, 
så skaden ved indbrud trods alt begrænses.
</para>
</sect2>

<sect2 id="ftp">
<title>Ftp</title>
<para>
FTP (File Transfer Protocol) bruges, når man vil kopiere filer fra
en maskine til en anden.
FTP er ligesom telnet en af de gamle services, som er meget
stabil men slet ikke sikker, idet login navn og password
sendes i klar tekst. FTP er imidlertid ofte mindre farlig end
telnet, da det meste ftp-trafik foregår som "anonymous ftp".
</para>

<para>
Når man skal ftp'e til en maskine, skriver man ftp maskinnavn 
(evt portnavn). 
F.eks.:
</para>

<SCREEN>
ftp locksley 37067
</SCREEN>

<para>
Ovenstående kommando vil forsøge at åbne en ftp forbindelse til
host "locksley" port 37067. Så bliver man spurgt om loginnavn og derefter
password. Går det godt, er man inde, og man kan downloade filer med
kommandoen "get" og uploade med "put". Man kan desuden vælge, om det
skal være binær eller ascii overførsel, skrive "ls" for at se
indhold af katalog eller skifte katalog med "cd" mm.
</para>

<para>
Har man en rigtig bruger konto på maskinen, og er ftp sat op til det, 
kan man logge ind med sit normale brugernavn og password.
Dette kan være relevant på f.eks. et lokalnet, hvor brugerne har behov 
for at flytte filer. Faren er her den samme som ved brug af telnet, nemlig at 
brugernavn og password sendes i klar tekst over nettet. Foregår dette over det
usikre Internet, må vi bestemt anbefale at man bruger scp
(<ulink url="netvaerk.html#ssh">secure copy fra ssh-pakken</ulink>), 
hvis det er muligt. Alternativet er en speciel
krypteret udgave af ftp, men dette kræver, at klienten kan
tale samme sprog. Ftp kører normalt på port 20 (data) og 21
(kommandoer).
</para>

<para>
Det er imidlertid meget almindeligt, at en ftp server er sat op til at i
acceptere brugernavnet "anonymous" eller "ftp". En del ftp servere er 
beregnet til kun
at understøtte denne type login. Det kaldes anonymous ftp, og bruges
ved "offentlige" ftp servere, hvor enhver kan hente de filer der er 
lagt frem. Her bruger man sin email adresse som password. Ved 
anonymous ftp kan alle logge ind, og det lyder måske farligt, men det er 
det kun, hvis man har sat sin ftp server forkert op. 
</para>

<para>
Der sendes ikke brugernavne og passwords over nettet. Der sendes kun 
brugernavnet "anonymous", samt en email adresse, og det gør ingenting for
serverens sikkerhed, at det bliver opsnappet.
</para>

<para>
Ved anonymous ftp har folk ikke brug for at kunne ret meget.  De har
brug for at kunne downloade og måske uploade. Og for at kunne gå hen i
det katalog de skal uploade i og tilsvarende downloade fra, men stort
set har de ikke brug for mere. De har ikke brug for at kunne bevæge
sig rundt på hele maskinen, og det bør de ikke i have lov til. Dette
undgås ved, at man "chroot'er" dem, dvs., at man f.eks. får kataloget
<FILENAME>/home/ftp</FILENAME> til at se ud som roden af filsystemet
(dvs. /). Brugeren kan ikke se resten af filsystemet og kun få ordrer
kan anvendes.  Dermed er serveren ikke nær så udsat, som hvis alle og
enhver kunne logge "rigtigt" ind. Det er kun lidt, der skal sættes op,
før et chroot'et environment virker (så bla. "ls" og "cd" virker) -
nogle filer skal kopieres til <FILENAME>/home/ftp/lib</FILENAME>,
<FILENAME>/home/ftp/bin</FILENAME> og
<FILENAME>/home/ftp/etc</FILENAME> filer. Dette er gjort for dig i
alle de store Linuxdistributioner.
</para>

<para>
Endelig bør man huske, at <FILENAME>/home/ftp</FILENAME> ikke bør
været ejet af den bruger, folk logger ind som, dvs. anonymous eller
ftp. Så kan de ændre environment, lave .rhosts-filer og andet, som kan
bringe net-sikkerheden i fare.
</para>

<para>
Der er et par ting mere, man bør tænke på. For det første bør der ikke
være læse og skriverettigheder på det samme katalog. Folk skal uploade
et sted og download'e et andet, og serverens administrator skal så
sørge for at uploadede ting evt. bliver tilgængelige til
download. Dette skyldes, at hvis man bare lader sin server stå åben
for up - og downloads uden kontrol, vil folk bruge den til
piratsoftware, porno etc. Derfor er det smart først at lade det folk
uploader være tilgængeligt for download, efter at man har kigget det
igennem.
</para>

<para>
Der er en sidste ting, man skal være opmærksom på med en ftp
server. Folk kan med vilje eller ved et uheld uploade så meget, at
harddisken løber fuld. Det kan give Linuxsystemet problemer, så det
skal man undgå.  Det kan styres ved at lade uploadkataloget ligge på
en partition (eller disk) for sig selv, eller ved i opsætningen af ftp
serveren at lave begrænsninger for størrelsen af den uploadede mængde.
Hvis folk med vilje fylder ens disk op, for at systemet skal holde op
med at fungere, kaldes det et "denial of service attack" ("ude af
drift angreb", også kendt som DOS attack) - maskinen nægter brugerene
den service, som skulle leveres, fordi den er sat ud af drift af
angrebet. Der findes også sikkerhedshuller til andre slags DOS attacks
i nogle ftp-servere.  Hvis du ikke skal bruge ftp, bør du slå den fra
i /etc/inetd.conf.
</para>

<SCREEN>
ftp    stream  tcp     nowait  root    /usr/sbin/tcpd  in.ftpd -l -a
</SCREEN>

<para>
bliver til
</para>

<SCREEN>
#ftp    stream  tcp     nowait  root    /usr/sbin/tcpd  in.ftpd -l -a
</SCREEN>

<para>
Husk at "reloade" inetd.
</para>
</sect2>

<sect2 id="finger">
<title>Finger</title>

<para>
Finger er et program, som viser hvem, der er logget på maskinen lige nu,
hvornår de sidst var logget ind og hvor længe:
</para>

<SCREEN>
[robin@sherwood]$ finger robin
Login: robin                             Name:
Directory: /home/robin                   Shell: /bin/bash
On since Fri Jul  9 10:18 (CEST) on tty1    1 hour 14 minutes idle
     (messages off)
On since Sat Jul 10 01:13 (CEST) on tty2    1 hour 14 minutes idle
     (messages off)
On since Sat Jul 10 01:14 (CEST) on pts/0   1 hour 15 minutes idle
     (messages off)
On since Sat Jul 10 01:14 (CEST) on pts/2   26 minutes 11 seconds idle
     (messages off)
No mail.
No Plan.                    
</SCREEN>

<para>
Denne kommando kan køres fra andre maskiner mod din maskine, og kan 
anvendes af folk udefra til f.eks. at finde frem til en brugerkonto,
der ikke har været brugt længe. Denne information bør du ikke give 
videre ud over maskinen selv.
Derfor bør du i <FILENAME>/etc/inetd.conf</FILENAME> tilføje et "#" foran linien
</para>

<SCREEN>
finger  stream  tcp     nowait  root    /usr/sbin/tcpd  in.fingerd      
</SCREEN>

<para>
Finger er for de fleste fuldstændig unødvendig og en dum
sikkerhedsrisiko at lade stå åben.  Hvis du kan finde en undskyldning
for, at du har brug for finger, så skal den i hvert fald
<emphasis>kun</emphasis> være tilgængelig internt. Dvs., at adgang fra
andre maskiner skal være spærret f.eks. med tcp-wrappers.
</para>
</sect2>

<sect2 id="pop">
<title>POP</title>

<para>
Hvis din maskine ikke skal være mailserver, så udkommenter pop-2,
pop-3 og imap i <FILENAME>/etc/inetd.conf</FILENAME>.
</para>

<para>
POP står for Post Office Protocol, og man bruger POP til at
hente mail fra en mailserver og lægge i sin inbox på ens egen maskine. 
Bemærk, at selvom man slår POP-serveren fra lokalt, forhindrer det ikke,
at man kan hente mail via sin udbyders POP-server.
Da POP-daemonen skal skrive i brugernes hjemmekataloger,
er den nødt til at køre som root. Dette er et sikkerhedsproblem.
Ligesom med telnetd og ftpd er det desuden et stort problem, 
at POP kører med ukrypteret transmission af brugernavn og password.
</para>

<para>
Afhængig af hvad man skal bruge POP til, kan man sikre den. Hvis den 
kun skal bruges internt i ens firma, kan man enten
</para>

<itemizedlist mark="bullet">
  <listitem><para>
   sørge for, at der ikke kan checkes mail udefra ved opsætning
   TCP-wrappers og/eller firewall.
  </para></listitem>
  <listitem><para>
    bruge krypteret overførsel, hvis man kun har mailklienter,
    man selv bestemmer over.
  </para></listitem>
</itemizedlist>

<para>
Man kan kryptere POP, men igen er dette en udvidelse, som kræver at
alle klienter understøtter det. Det er ikke altid tilfældet. Der
findes også en metode, der hedder APOP, som de fleste POP-programmer
understøtter. Med APOP sendes passwordet krypteret. Dette er baseret
på MD5-kodning, hvor der også er et time stamp involveret. Mere
information kan findes i RFC 1725.
</para>
   
<para>
IMAP er en udvidet version af POP. Den kan sætte sig selv til at køre 
med brugerens privilegier noget af tiden i stedet for root, og man
kan meget mere med den end med POP. F.eks. kan man med IMAP være 
flere brugere om én account, nøjes med at downloade
headerene fra sine mails og lade resten ligge på serveren, etc.
</para>

<para>
For at slå POP og IMAP fra i <FILENAME>/etc/inetd</FILENAME> skal
følgende linier udkommenteres:
</para>

<SCREEN>
pop-2   stream  tcp     nowait  root    /usr/sbin/tcpd ipop2d
pop-3   stream  tcp     nowait  root    /usr/sbin/tcpd ipop3d
imap    stream  tcp     nowait  root    /usr/sbin/tcpd  imapd
</SCREEN>

<para>
bliver til
</para>

<SCREEN>
#pop-2   stream  tcp     nowait  root    /usr/sbin/tcpd ipop2d
#pop-3   stream  tcp     nowait  root    /usr/sbin/tcpd ipop3d
#imap    stream  tcp     nowait  root    /usr/sbin/tcpd  imapd
</SCREEN>
</sect2>

<sect2 id="linuxconf">
<title>Linuxconf</title>

<para>
Anvender du en nyere Linux distribution, kan det være, at du har 
programmet linuxconf kørende på din maskine på port 98. Du kan 
i <FILENAME>/etc/initd.conf</FILENAME> se, om du har linuxconf kørende ved 
at lede efter en linie, der indeholder ordet <COMMAND>linuxconf</COMMAND>. Den kan
f.eks. se sådan ud:
</para>

<SCREEN>
linuxconf stream tcp wait root /bin/linuxconf linuxconf --http
</SCREEN>

<para>
Ganske vist kan linuxconf umiddelbart kun tilgås fra den lokale
maskine og ikke fra netværket, men programmets egen usikrede webserver
bør man ikke stole blindt på. Luk det, hvis du har et usikkert
net. Tilsvarende argumenter kan anvendes overfor programmer såsom
webmin, som giver et webinterface til systemadministration. Webmin er
normalt ikke installeret, men skal hentes som særskilt pakke. For at
værktøjet til webadministration kan accepteres på et usikkert net, skal
SSL eller bedre kryptering indbygges i server og klient.
</para>
</sect2>
</sect1>

<sect1 id="rpc-og-portmap">
<title>RPC og portmap</title>
<para>
Ud over services, som konfigureres via
<FILENAME>/etc/inetd.conf</FILENAME>, er der en klasse af services,
som anvender RPC - Remote Procedure call. Vi vil se lidt på RPC og de
mest kendte RPC-baserede services.
</para>

<para>
RPC går ud på, at man har et netværk af computere og kan få dem til at
arbejde sammen som et system. Altså en slags "distributed
computing". Man kan driste sig til at kalde det en tidlig forgænger
for <ulink url="http://www.omg.org">CORBA</ulink>. Det overordnede princip
er, at man kalder en funktion, som enten udføres af den lokale maskine
eller en anden maskine i netværket.
</para>

<para>
I praksis betyder det, at der kan køre en række RPC services på
din maskine. I stedet for at RPC services kører på et bestemt portnummer,
får de tildelt et portnummer ved opstart. De registrerer sig hos portmapper 
daemonen, når de bliver startet. Portmapper daemon'en holder styr på 
hvilken RPC services der kører på hvilket portnummer, og videresender 
forespørgsler fra klienter til den rette service. RPC services
behøver altså ikke køre på et bestemt portnummer, som klienten kender i 
forvejen. Klienten henvender sig til portmap på serveren og bliver
"stillet igennem" til den rigtige service. 
</para>

<para>
Dette er meget smart, men det komplicerer opsætningen af firewalls, da
man ikke på forhånd ved, hvilken port den RPC service vil
benytte. Prøv at skrive
</para>


<SCREEN>
[robin@sherwood robin]$ /usr/sbin/rpcinfo -p localhost
   program vers proto   port
    100000    2   tcp    111  rpcbind
    100000    2   udp    111  rpcbind
    100005    1   udp    635  mountd
    100005    2   udp    635  mountd
    100005    1   tcp    635  mountd
    100005    2   tcp    635  mountd
    100003    2   udp   2049  nfs
    100003    2   tcp   2049  nfs
[robin@sherwood robin]$
</SCREEN>

<para>
(Dette er fra et Red Hat system. På Debian står der portmapper i
stedet for rpcbind). Man kan se at NFS og mountd (NFS mount) kører, 
men ikke NIS.
</para>


<para>
Portmapperen kører normalt på port 111. Hvis man ikke har brug for, at nogle
RPC services er tilgængelige udefra, kan man i sin firewall blokere port 111.
Hvis ikke du ved, om du bruger RPC, så gør du det ikke. Fjern det, og stop
portmapper servicen.
</para>

<para>
Det er i øvrigt ikke nok at stoppe portmapperen. Der findes værktøjer
til at sniffe på alle åbne porte og dermed afsløre kendte RPC-services uden
at spørge portmapperen.
</para>

<para>
Udefra  kan man spørge maskinen hvilke netværksprocesser, som
tilbydes. Et program, som er velegnet til dette, er "nmap", som kan
download'es fra 
<ulink url="http://www.insecure.org/nmap">http://www.insecure.org/nmap</ulink>.
Prøv at køre nmap på din egen maskine:
</para>

<SCREEN>
[robin@sherwood robin]$ nmap localhost

Starting nmap V. 2.2-BETA4 by Fyodor (fyodor@dhp.com, www.insecure.org/nmap/)
Interesting ports on localhost (127.0.0.1):
Port    State       Protocol  Service
25      open        tcp       smtp
37      open        tcp       time
53      open        tcp       domain
70      open        tcp       gopher
80      open        tcp       http
98      open        tcp       linuxconf
111     open        tcp       sunrpc
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
113     open        tcp       auth
139     open        tcp       netbios-ssn
143     open        tcp       imap2
513     open        tcp       login
514     open        tcp       shell
515     open        tcp       printer
635     open        tcp       unknown
2049    open        tcp       nfs
6000    open        tcp       X11

Nmap run completed -- 1 IP address (1 host up) scanned in 0 seconds
</SCREEN>

<para>
Man kan således udefra se, at sherwood har sunrpc til at lytte på
port 111 - sunrpc er det samme som portmapperen. Processen - det
kørende program - hedder portmap, men servicen hedder sunrpc. Bliv
ikke forvirret, kært barn har mange navne. Kør <COMMAND>ps -aux |grep
portmap</COMMAND> på dit system, og du kan indefra se, at portmapper daemonen
kører.
</para>

<para>
Portmapper daemonen er et program, der hedder portmap (på nogle systemer
hedder det rpcbind). Den bliver startet op i dine startup scripts
(Red Hat: <FILENAME>/etc/rc.d/init.d/portmap</FILENAME>, Debian: 
<FILENAME>/etc/init.d/netbase)</FILENAME>.
</para>

<para>
RPC er rent sikkerhedsmæssigt noget skidt.  RPC er, som
alt muligt andet fra dengang, designet med henblik på funktionalitet
og stabilitet fremfor sikkerhed. RPC blev i sin tid lavet af Sun, men det blev
hurtigt efterlignet af andre og vandt stor udbredelse. Problemet med
RPC er, at metoden til autentifikation er baseret alene på brugerens UID
og GID (User/Gruppe ID). RPC serveren tror på, at man er den, man giver
sig ud for at være - uden yderligere validering af identitet.
Udgiver man sig for at være en bruger med adgang, så bliver man lukket ind.
</para>

<para>
Sun kom senere med en mere sikker version, secure RPC, som bruger en
kryptering baseret på DES. Secure RPC vandt aldrig den samme udbredelse,
fordi den ikke blev efterlignet af andre (noget med at den anvendte
krypteringsmetode var patenteret, og man skulle købe en licens for at
bruge den).
</para>

<para>
Det er en dårlig ide at slå portmapper daemonen fra, før du har
undersøgt hvilke programmer, der bruger den. NFS kører f.eks. via RPC,
hvilket vi allerede så, da vi kørte rpcinfo programmet. Vi så faktisk
alle de services, der har registreret sig hos portmapperen. Portmap er
selv en af dem (kan hedde rpcbind). Alt efter hvor mange services, du
har startet op, så kan du se, at services som nfs, mountd, nis,
automounteren amd m.fl.kører på dit system via RPC.
</para>

<para>
Du er nødt til at tage stilling til, om du har brug for disse
services, hvis ikke skal de slås fra. Hvis <COMMAND>rpcinfo -p
localhost</COMMAND> kun viser portmapperen selv, evt fordi du har
slået de andre services fra, så kan du godt slå portmap fra også.  Men
bemærk, at den skal slås til igen, hvis du vil anvende en af de
services, der benytter RPC.
</para>


<sect2 id="nis-og-nis-plus">
<title>NIS og NIS+</title>
<para>
NIS (Network Information Service) er en måde, hvorpå man kan nøjes med
at have sin <FILENAME>/etc/passwd</FILENAME> fil og andre konfigurationsfiler
(typisk en del filer fra <FILENAME>/etc/</FILENAME>) på én server.  Klienterne
får de nødvendige oplysninger af serveren via NIS. NIS er baseret på
RPC. Med NIS slipper man for at vedligeholde sine konfigurationsfiler 
på en masse maskiner. Det gør det lettere at holde styr på sine brugere,
grupper og hvem, der har lov
til hvad. NIS er mere komplekst end UNIX bruger og gruppe
rettighedssystemet og gearet til at holde styr på et stort netværk,
hvor en bruger ikke må det samme på alle maskiner. NIS+ er en mere
sikker version med lettere administration af store systemer (lettere
opdatering af serveren etc).
</para>

<para>
Klient daemonen til NIS hedder
ypbind, server daemonen ypserv og kommandoerne starter med yp (et
levn fra dengang NIS hed yellow pages).  Se i øvrigt 
<ulink url="http://www.sunsite.auc.dk/ldp/HOWTO/NIS-HOWTO-6.html">http://www.sunsite.auc.dk/ldp/HOWTO/NIS-HOWTO-6.html</ulink>.
</para>
</sect2>

<sect2 id="nfs">
<title>NFS</title>
<para>
NFS (Network File System) er et netværksfilsystem, som muliggør
af flere maskiner kan dele den samme disk via netværket. Med NFS 
kan man eksportere hele eller dele af sit lokale filsystem, så en
bruger kan mounte det fra andre maskiner over nettet. Det er dumt 
og unødvendigt at eksportere hele sin systemdisk - man bør nøjes med
at eksportere de dele af filsystemet, der er behov for NFS-adgang til. 
NFS kører normalt på port 2049.
</para>

<para>
NFS er en RPC baseret service og er afhængig af at portmapperen kører.
NFS startes af et startupscript (Red Hat:
<FILENAME>/etc/rc.d/init.d/nfs</FILENAME>, Debian:
<FILENAME>/etc/init.d/nfs-server</FILENAME>.  Daemonerne hedder
<COMMAND>rpc.mountd</COMMAND> og <COMMAND>rpc.nfsd</COMMAND>. mountd
daemonen tager sig af selve mount processen, imens NFS daemonen tager
sig af at åbne, lukke, læse og skrive filer etc.
</para>

<para>
Filsystemer, der skal være tilgængelige via NFS, angives i
<FILENAME>/etc/exports</FILENAME>, f.eks.
</para>

<SCREEN>
/home/robin     192.168.0.0/255.255.255.252(rw)  
</SCREEN>

<para>
Denne linje eksporterer kataloget <FILENAME>/home/robin/</FILENAME>
med adgang for maskinerne 192.168.0.1, 192.168.0.2 og 192.168.0.3. Den
eneste option, der er sat i ovenstående linie, er "rw" (read
write). Der findes desuden nogle sikkerhedsrelaterede options til
<FILENAME>/etc/exports</FILENAME>, men angiver du ingen, er de sat til
det sikreste. Du skal således manuelt slå dem til for at få den mere
usikre version.  F.eks. "secure" option, som betyder at en
forespørgsel skal komme fra en port mindre end 1024. Den er default
slået til - vil man slå den fra, må man specificere
"insecure". Beskrivelse af yderligere options findes i <COMMAND>man
exports</COMMAND>.
</para>

<para>
Lad ikke dette forlede dig til at tro, at NFS er sikkert. Det er
grundlæggende usikkert, da det kører via RPC, som du ikke kan betragte
som sikker. Selve datatrafikken er heller ikke krypteret. 
Begræns din filsystemexport til det, du rent faktisk har
brug for, og mount kun de drev du har brug for. Lad være med at mounte
alle eksporterede drev på alle klientmaskiner, hvis der ikke er behov
for det. Dette er i øvrigt klogt af hensyn til den almindelige
driftstabilitet, idet du kun bliver afhængig af de maskiner, du skal bruge.
</para>

<para>
Hvis du ikke bruger NFS, så slå den fra. I Red Hat, Debian eller SuSE
gøres det ved at fjerne symlinkene til startup scriptet i de
forskellige runlevel kataloger <FILENAME>/etc/rc.d/rcN.d</FILENAME> /
<FILENAME>/etc/rcN.d</FILENAME>, hvor N er runlevel (0-6). I nogle
distributioner er det i stedet nødvendigt at fjerne de linier, der har
med NFS opstart at gøre, i et større script, der køres, når maskinen
startes, og som starter mange andre ting end NFS. Kører du Red hat, så
kig på programmet <COMMAND>chkconfig</COMMAND>, som er et nemt og
overskueligt værktøj til at styre, hvad der startes ved de forskellige
runlevels.
</para>
</sect2>
</sect1>

<sect1 id="apache">
<title>Apache webserveren</title>

<para>
Apache er verdens mest anvendte webserver. Den følger standard med
Linux, og findes desuden til alle andre UNIX systemer. Ofte sker det 
under installationen af Linux, at Apache er installeret uden, at du
har lagt mærke til det. Hvis din maskine ikke skal fungere som webserver,
har du kun brug for Apache, hvis du vil lege med CGI-scripts,
PHP eller andre smarte ting (hvor du for alvor skal passe på din sikkerhed).
Check om du kører Apache eller en anden webserver på port 80
(kan være andre steder såsom port 8080) ved at skrive
</para>

<SCREEN>
[robin@sherwood robin]$ telnet MASKINNAVN 80
</SCREEN>

<para>
og så skriv f.eks. "?" og tryk retur. Ser du noget HTML kode, så 
er der en webserver. Apache er meget stabil og gennemtestet, men 
tænk over, om du behøver den.
</para>
</sect1>

<sect1 id="sendmail">
<title>Sendmail</title> 
<para>
Sendmail er en MTA (Mail Transfer Agent). Den bruges til at dirigere 
email rundt på systemet og lytter normalt også på smtp porten.
Sendmail er et meget komplekst program at sætte op og meget
komplekst at forstå. Hvis du er begynder, vil vi anbefale, at du ikke
begynder at sætte dig dybdegående ind i sendmail lige nu, medmindre
du har brug for det. Vi vil her kort forsøge at forklare, hvornår
dit system anvender sendmail, hvorfor/hvornår det er farligt, og
hvilke alternativer, der er.
</para>

<sect2 id="hvorfor-ikke-sendmail">
<title>Hvorfor er sendmail farlig?</title>
<para>
Sendmail er en meget gammel sag, og den har et ret dårligt rygte, 
hvad sikkerhed angår, men er uhyre anvendt. Den har eksisteret i mange år og
har i tidens løb haft mange slemme sikkerhedshuller.  Se 
<ulink url="ftp://koobera.math.uic.edu/www/maildisasters/sendmail.html">
ftp://koobera.math.uic.edu/www/maildisasters/sendmail.html</ulink>. 
Disse er dog blevet rettet efterhånden - men der kan komme nye. Da
sendmail er et meget komplekst program, kan der også godt være nogle
fejl, som der går lang tid, før nogen opdager. Sendmail kører med
root-privilegier, d.v.s., den har adgang til hele systemet og kan gøre
alt, hvad en administrator også kan gøre. Den fungerer på de fleste
systemer som daemon, dvs., at den kører hele tiden og lytter på sin
port (sendmail kører default på port 25), om der er noget mail, den
skal tage imod. Hvis sendmail kører som daemon, og der er et
sikkerhedshul i den, kan enhver ude fra nettet sende en forespørgsel
til dens port og udnytte sikkerhedshullet. En af grundene til, at man
ofte hører skrækhistorier om sendmail, er at den kører på langt de
fleste maskiner, der håndterer email på Internet.  Fordi den kører på
så mange systemer, er det let nok at finde et system at udnytte, hvis
man har fundet et sikkerhedshul. Det er dog ofte folk, der kører gamle
versioner af sendmail, der er udsat. Hvis man hele tiden holder sin
sendmail opdateret, er risikoen ikke så stor. Hent den nyeste version
på <ULINK
URL="http://www.sendmail.org/">http://www.sendmail.org/</ulink>.
</para>
</sect2>

<sect2 id="slaa-sendmail-fra">
<title>Skal jeg slå sendmail fra?</title>
<para>
Det er desværre ikke så smart at slå sendmail helt fra - med mindre
man i stedet installerer et sikrere alternativ som qmail eller postfix - 
da flere dele af systemet skal kunne levere mails internt på maskinen. 
Skal maskinen imidlertid ikke acceptere mail udefra, men kun fordele
mail lokalt, kan man lade være med at lade sendmail køre i "daemon mode", 
hvor den lytter på en port. Man kan i stedet starte den i "queue mode". 
Sendmail kører stadig som en baggrundsproces, som med jævne mellemrum 
kommer frem og tømmer mailkøen. F.eks. en gang i timen, eller en 
gang hvert kvarter. Men den lytter ikke længere efter forespørgsler på
port 25. Sendmail startes i "daemon mode", der tømmer mailkøen en gang 
i timen, ved at starte den med parametrene
</para>

<SCREEN>
sendmail -q1h
</SCREEN>

<para>
i stedet for 
</para>

<SCREEN>
sendmail -bd -q1h
</SCREEN>

<para>
hvor <FILENAME>-q1h</FILENAME> betyder at køen tømmes en gang hver
time, og <COMMAND>bd</COMMAND> betyder, at den startes i "daemon
mode". Sendmail startes normalt fra et startup script. I Red Hat er
det <FILENAME>/etc/rc.d/init.d/sendmail</FILENAME>. I SuSE skal man i
<FILENAME>/etc/rc.config</FILENAME> ændre linien
</para>

<SCREEN>
SENDMAIL_ARGS="-bd -q30m -om"
</SCREEN>

<para>
til
</para>
<SCREEN>
SENDMAIL_ARGS="-q30m -om"
</SCREEN>

<para>
Parameteren -q30m betyder, at mail-køen tømmes hver 30. minut.  Hvis
man ikke vil køre sendmail i "daemon mode", kan man ændre i startup
scriptet. Hvis man slet ikke vil køre sendmail, skal man fjerne det
symlink, der er til sendmail startup scriptet under de forskellige
runlevels kataloger. I Red Hat er det
<FILENAME>/etc/rc.d/rcN.d</FILENAME>, hvor N er runlevel nummeret. På
Debian hedder det <FILENAME>/etc/rcN.d</FILENAME>.  Red Hat eksempel:
Prøv at skrive
</para>

<SCREEN>
[robin@sherwood robin]$ ls -l /etc/rc.d/rc3.d |grep sendmail
lrwxrwxrwx   1 root     root           18 Oct  3  1998 S80sendmail -> ../init.d/sendmail
</SCREEN>

<para>
Der kan man se at sendmail bliver startet i runlevel 3. Hvis sendmail ikke
skal startes, skal dette symlink slettes. Ligeså under de andre runlevels,
og husk også at slette shutdown symlinkene til sendmail (dem der starter
med K).
</para>

<para>
Man kan også vælge at køre sendmail i "queue mode", selvom man har
brug for, at maskinen tager imod mails udefra. Dette kræver, at man
anvender en anden smpt-daemon, f.eks. optuse smtpd (<ulink
url="http://www.obtuse.com">http://www.obtuse.com</ulink>). Den tager
sig af indgående smtp og lægger posten over i sendmails kø, hvor
sendmail så kan overtage.  Vi kan også nævne smap/smapd, som er en del
af TIS Internet i Firewall Toolkit (<ulink
url="http://www.tis.com/research/software/fwtk/fwtk_over.html">http://www.tis.com/research/software/fwtk/fwtk_over.html</ulink>).
</para>
</sect2>

<sect2 id="sikring-af-sendmail">
<title>Sikring af sendmail</title>
<para>
Hvis du kører sendmail som i "dameon mode", kan du sikre den. Du
kan bl.a enable nogle security options i <FILENAME>/etc/sendmail.cf</FILENAME> - som 
er en ret forvirrende fil ved første blik. Man kan f.eks. sætte linien 
</para>

<SCREEN>
O PrivacyOptions=authwarnings,needmailhelo, noexpn, novrfy
</SCREEN>

<para>
ind i sin
<FILENAME>/etc/sendmail.cf</FILENAME>. <FILENAME>authwarnings</FILENAME>
enabler email authentication warnings, så man får
x-authentication-warning beskeder i sine mail headers, som f.eks.
</para>

<SCREEN>
X-Authentication-Warning: sherif.nottingham.dk: sherif owned process doing -bs.</SCREEN>

<para>
<FILENAME>authwarnings</FILENAME> er pr. default slået
til. <FILENAME>needmailhelo</FILENAME> gør, at den maskine, der vil
sende mail til sendmail, skal identificere sig før den får lov.
<FILENAME>novrfy</FILENAME> forhindrer <FILENAME>VRFY</FILENAME>
kommandoen, som bruges til at bekræfte, om et bestemt brugernavn
findes på maskinen.  <FILENAME>noexpn</FILENAME> forhindrer
<FILENAME>EXPN</FILENAME>, som er en kommando, der bruges til at finde
ud af hvilken bruger/program på systemet en email adresse reelt peger
på, dvs., hvem et mail alias dækker over, hvem der modtager root mails
på systemet etc.
</para>

<para>
Prøv at skrive <COMMAND>telnet hostname 25</COMMAND>, hvor hostname er
navnet på en maskine, der har sendmail (evt. din egen linux box - du
behøver ikke 2 forskellige maskiner til dette). Sendmail bruger
normalt port nummer 25. Så du kan faktisk kommunikere direkte med
sendmail på maskinen ved at bruge telnet:
</para>

<SCREEN>
[robin@sherwood robin]$ telnet locksley 25
Trying 192.168.0.1...
Connected to locksley.herne.dk.
Escape character is '^]'.
220 sherwood.dk ESMTP Sendmail 8.9.3/8.9.3; Mon, 19 Jul 1999 22:47:59 +0200
VRFY robin
250 &lt;robin@sherwood.dk>
EXPN robin
250 &lt;robin@sherwood.dk> 
</SCREEN>

<para>
Vi fik at vide at maskinen kører sendmail version 8.9.3, at robin fandtes
på maskinen, og at mail til robin går til robin. Skal andre også have 
dette - og måske mere følsomme ting - at vide? Hvad nu hvis robin bare 
var et mail alias for brugeren marion - kommer det andre ved? Skal andre 
kunne se, at roots mail også går til marion? Vi prøver samme kommando,
når VRFY og EXPN er slået fra.
</para>

<SCREEN>
[robin@sherwood robin]$ telnet locksley 25
Trying 192.168.0.1...
Connected to locksley.herne.dk.
Escape character is '^]'.
220 sherwood.dk ESMTP Sendmail 8.9.3/8.9.3; Mon, 19 Jul 1999 22:53:17 +0200
VRFY robin
252 Cannot VRFY user; try RCPT to attempt delivery (or try finger)
EXPN robin
502 Sorry, we do not allow this operation
</SCREEN>

<para>
Der er flere muligheder. Man kan nøjes med at slå <FILENAME>expn</FILENAME> og 
<FILENAME>vrfy</FILENAME> fra, indtil
den fremmede maskinen har identificeret sig selv. Se 
<ULINK URL="http://hoth.stsci.edu/man/man1m/sendmail.html">http://hoth.stsci.edu/man/man1m/sendmail.html</ulink>.
</para>
</sect2>

<sect2 id="mail-relay">
<title>Mail relaying</title>
<para>
Derudover skal man slå mail relaying fra. Det gøres i accessfilen -
<FILENAME>/etc/sendmail.cf</FILENAME> indeholder oplysningerne om,
hvor den ligger.  På Red Hat hedder den
<FILENAME>/etc/mail/access</FILENAME>.  Der må gerne stå f.eks.
</para>

<SCREEN>
localhost.localdomain           RELAY
localhost                       RELAY
</SCREEN>

<para>
- dette tillader relaying for den lokale maskine. Men der må ikke stå 
andre linier med RELAY. (Man kan f.eks. også bruge IP-adressen på sit interne
netværk og tillade intern mail relaying). Hvis man tillader
extern mail relaying - dvs. at folk, der logger ind udefra, kan sende
mails, så det ser ud som om, de er sendt indefra - så kan man risikere,
at spammere bruger en som afsender for deres spam. Så selvom det til 
tider kunne være praktisk at logge ind på sin computer, når man er ude,
og sende email med sin "hjemmeadresse" som afsender, så tillader 
Internetsikkerheden i dag ikke dette. Man bliver <emphasis>meget</emphasis> upopulær,
hvis nogle garvede internet folk opdager, at man har mail relaying slået
til. Man kan komme på deres sortlister, så en masse folk ikke kan modtage
mail fra ens domæne etc. Man kan dog også træffe andre foranstaltninger
imod mail relaying end at slå det fra i sendmail.
</para>

<para>
Mere om sendmail kan læses på
<ulink url="http://www.kom.id.ethz.ch/sendmail.html">http://www.kom.id.ethz.ch/sendmail.html</ulink>.
Læs desuden <COMMAND>man sendmail</COMMAND>. 
</para>

<para>
Der skal også nævnes, at der findes interessante alternativer til 
sendmail: qmail 
(<ulink url="http://www.qmail.org">http://www.qmail.org</ulink>) 
og postfix 
(<ulink url="http://www.porcupine.org/postfix-mirror/start.html">http://www.porcupine.org/postfix-mirror/start.html</ulink>). 
Begge er fra begyndelsen designet med tanke 
på sikkerhed. De er bl.a.sikrere, fordi smtpd her er en selvstændig 
proces, som ikke kan skrive til nogen filer. Hver lille delopgave
foretages af et separat program, som kun har en snæver, veldefineret funktion.
Sendmail er derimod designet som et enkelt do-it-all program. Det er en 
grundlæggende i designfejl, som gør den håbløs i sikkerhedssammenhæng.
</para>

<para>
Vi kommer ikke her nærmere ind på qmail og postfix, men har man et i
seriøst mailserver behov, kan det godt anbefales at kigge nærmere på disse
to programmer. 
</para>
</sect2>
</sect1>

<sect1 id="andre-services">
<title>Andre services</title>
<para>
Udenfor de forrige kategorier falder XDM og DNS:
</para>

<sect2 id="xdm">
<title>Xdm-lignende login</title>
<para>
En service man ikke må overse, er XDM, som er en X-login daemon, der
normalt kører på UDP port 177. Det er muligt at forbinde sig til en kørende
XDM-server, dvs. direkte til X-systemet, ved at skrive "X -query SERVER". 
Alt efter Linux distribution, kan du have xdm, kdm (KDE's XDM) eller
gdm (GNOME XDM) kørende. Hvis XDM kører, starter maskinen op med en grafisk
login menu i stedet for den almindelige konsol mode login prompt. Hvis du
er i konsol mode, kan du se, om du har en X-login daemon kørende, ved at
trykke Alt-F7. Er der en menu, hvor du kan skrive loginnavn og
password ind, så kører du en XDM-lignende service.
</para>

<para>
På din hjemmecomputer kan det grafiske login være meget rart, men hvis du
administrerer en server, er det en uacceptabel sikkerhedsrisiko. Luk den 
ned og sørg for, at dette ikke automatisk startes op fra startupscriptet i
<filename>/etc/rc.d</filename>:
</para>

<itemizedlist mark="bullet">
<listitem><para>SuSE 6.1: slet /etc/rc.d/rc3.d/*xdm</para></listitem>
<listitem><para>Red Hat 6.0: Udkommenter sidste linien i <filename>/etc/inittab</filename></para>
<screen>
x:5:respawn:/etc/X11/prefdm -nodaemon   
</screen>
<para>
så den ser ud som 
</para>
<screen>
#x:5:respawn:/etc/X11/prefdm -nodaemon   
</screen>
</listitem>
</itemizedlist>

<para>
I øvrigt bør man slet ikke køre X på en server, hvis det kan undgås.
Kan du af en eller anden grund ikke undgå at have XDM kørende, så bør
du som minimum læse 
<ulink url="http://metalab.unc.edu/LDP/HOWTO/mini/Remote-X-Apps.html">http://metalab.unc.edu/LDP/HOWTO/mini/Remote-X-Apps.html</ulink>.
Dette sted beskriver, hvordan du med "magic cookies" kan gardere dig
mod sådan noget som spoofingangreb, hvor andre på nettet prøver at tage din
identitet. Det kan nævnes, at vi i <ulink url="netvaerk.html">Artikel
4. Remote login og netværksaflytning</ulink> ser nærmere på, hvordan
du kan transmittere X-programmer fuldt krypteret. Denne løsning er
klart at foretrække, hvis man ser på netværks-sikkerheden.
</para>

</sect2>

<sect2 id="dns">
<title>DNS</title>

<para>
DNS (Domain Name System) er navne service, som anvendes til at få
oversat et hostnavn f.eks. sunsite.auc.dk til dets IP-nummer.
DNS er en af de 
store grundpiller i Internet og derfor også meget gennemprøvet
men ret komplekst. Der er blevet fundet sikkerhedshuller i
DNS-programmerne, f.eks. var der en fejl i Red Hat 4.2, hvor man kunne
sende en meget stor datamængde til en nameserver, hvilket medførte,
at den blev "overrasket" (buffer overflow problem) og fejlede. 
Man kunne derefter mirakuløst udføre rootkommandoer på systemet!
Resultatet var fatalt. Det er nok ikke sandsynligt, at du
kører en nameserver (på port 53) uden at vide dette, men du kan
verificere dette ved at skrive.
</para>

<SCREEN>
[robin@sherwood robin]$ ps aux |grep named
</SCREEN>

<para>
Du skal kun køre et nameserverprogram, hvis maskinen reelt skal bruges
som nameserver.
</para>
</sect2>
</sect1>

<sect1 id="epilog">
<title>Epilog</title>

<para>
Selvom vi har været inde på mange services her, har vi ikke været inde
på alle. Programmer som <COMMAND>nmap</COMMAND> og kommandoer som
<COMMAND>rpcinfo</COMMAND> og <COMMAND>netstat</COMMAND> kan vise dig
hvilke porte, der benyttes, hvilke services, der kører, og hvilke
netværksforbindelser, der er etableret. Brug også <COMMAND>ps
aux</COMMAND> flittigt og se hvilke processer, der rent faktisk kører
på dit system. Sørg for at alle unødvendige services i
<FILENAME>/etc/inetd.conf</FILENAME> er kommenteret ud, og check dine
runlevel kataloger. Læs manualsiderne til de services, du vælger at
køre. Følg med på sikkerhedslister på Internet, og følg med i
fejlrapportet for din Linuxdistribution.  Tænk dig om, og hold øje med
dine logfiler.  Og læs de resterende artikler i denne serie.
</para>
</sect1>
</chapter>


<chapter id="root-access">
<title>Root access - hvem, hvordan og hvorfor ikke?</title>

<para>
Når en bruger for første gang skal til at anvende Linux (eller en anden
UNIX), så det kan måske være svært at forstå, hvorfor man ikke skal 
være logget ind som systemadministrator - dvs. brugeren root - hele
tiden. Dette vil vi starte denne artikel med at diskutere. Derefter
vil vi se på fornuftig håndtering af root rettigheder.
</para>

<para>
Der er flere sikkerhedsaspekter forbundet med root-adgang. Ud over risikoen 
for selv at komme til at ødelægge noget på sit system, er der spørgsmålet om
hvilke personer ud over systemadministratoren, der skal have root 
privilegier - om nogen. I den
forbindelse vil vi også se på nogle af de elementære forholdsregler, man 
bør tage for at forhindre, at uautoriserede personer får root adgang.
Desuden vil vi se på valg af passwords. Det er meget vigtigt - 
specielt for root-kontoen - at der vælges passwords, der ikke kan gættes.
Som det sidste i artiklen ser vi på SUDO  og suid programmer, 
dvs. programmer, der kører med rettigheder, som om de var startet af
root. Dette kan naturligvis være et sikkerhedsmæssigt problem. Disse lokale
problemer bliver til netværksproblemer i det øjeblik, nogen trænger ind
på systemet via netværket. Er en cracker inde som almindelig bruger, er
det endnu begrænset, hvor meget skade han kan gøre. 
Det er nok desværre sandsynligt, at crackeren vil gå efter at 
få root-rettigheder for at have fuld kontrol over din computer.
</para>

<para>
Det ville også være slemt, hvis nogen fra
<emphasis>salgsafdelingen</emphasis> fik fat i dit root
password... Fra <ulink url="http://www.userfriendly.org/static">http://www.userfriendly.org/static</ulink>
</para>

<FIGURE ID="uf000955-fig" FLOAT="1">
<TITLE>User Friendly</TITLE>
<GRAPHIC FILEREF="uf000955.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>  

<sect1 id="hvem-er-root">
<title>Hvem er root?</title>
<para>
På et Linuxsystem er der som regel et antal brugere med forskellige
rettigheder. Linux er grundlæggende et fler-bruger system. Hvis man
f.eks. bruger Linux i en virksomhed, eller på en skole, er der forskel
på, hvad folk skal have lov til at gøre på maskinen. Hvor nogle brugere
kun kan hente deres email fra maskinen, kan andre betroede brugere
have lov til at logge ind på maskinen og køre programmer. De
forskellige brugere har et brugernavn og et password, som de logger
ind på systemet med. Ud fra bruger-ID nummeret (fås ud fra
brugernavnet) afgør systemet, hvilke handlinger man har lov til at
udføre. Passwordet sikrer, at man er den man giver sig ud for at være.
Ingen af de "almindelige" brugere kan ændre systemfiler, konfigurere
ny hardware eller re-installere software. Derfor har Linux brugeren
root, som kan alt dette. Er man root, så har man total kontrol over
maskinen. At være root kan du blive ved at logge ind med brugernavnet
root, og det dertil hørende password. Brugerkontoen root er en
systemadministratorkonto, som du også kan skifte til og fra ved brug
af <COMMAND>su</COMMAND> kommandoen. Det skal nævnes, at det er bruger-ID
0, som giver root-rettigheder, egentlig ikke alene navnet root. Hvis
du derfor finder flere brugere med bruger-ID 0 (nul), så skal du være meget
opmærksom på, hvad der er sket.
</para>

<para>
Hvis du er systemadministrator for en Linux maskine og kender root 
passwordet, er det stadig vigtigt, at du har en almindelig bruger konto, 
som du bruger til daglig. Man bør kun være root, når det er nødvendigt,
for at udføre opgaver, hvor root rettigheder er nødvendige. Lad os illustrere 
hvorfor.
</para>

<para>
Antag som første eksempel, at du arbejder i et lokale, hvortil andre har
adgang, og at du altid logger ind som root. Du skal i løbet af dagen
forlade din maskine et antal gange f.eks. til frokost eller
møder. Hvis du bare en gang glemmer at sætte en password-beskyttet 
screensaver på eller logge helt ud, kan enhver, som kommer forbi
dit kontor ødelægge hele din maskine. F.eks. ved at skrive <COMMAND>rm
-rf /</COMMAND> som vil slette <emphasis>alle</emphasis> filer på din harddisk uden
at spørge, om du mener det - og der er ingen fortrydelsesmulighed. 
Eksemplet er naturligvis grelt og ren
sabotage, men det er faktisk sket, at andre <emphasis>lige</emphasis> skulle rette
noget på et tidspunkt, hvor systemadministratoren lige var ude, og med
root-login forvoldte stor skade, fordi vedkommende overvurderede
sine evner som UNIX-administrator. Andre uheldige hændelser sker ved, at en
root glemmer at logge ud, og andre ser dette. For at drille skiver de
så <COMMAND>rm -rf /</COMMAND> men uden at trykke retur - dvs. ordren er
ikke udført endnu. Hvis den rigtige root så kommer tilbage og ved et
uheld trykker retur, er alt tabt, og han har selv udført handlingen. Det,
som var en sjov spøg, blev pludselig til et sort uheld. Desværre er
uheld, som disse set før.
</para>

<para>
Lad os som det næste eksempel se på de uheld, man selv kan komme til at
lave, når man er logget ind som root. Den hyppigste grund til fejl og 
ulykker er nok slåfejl eller rettere sløseri. 
På en Linuxmaskine vil du normalt altid få 
udført den ordre, du skriver, og du må selv garantere for fornuften i 
dette. Linux har den fordel, at du som almindelig bruger ikke kan slette 
systemfiler, såsom den meget vigtige fil <FILENAME>/etc/passwd</FILENAME>, der
indeholder information om brugerne og deres passwords. Prøver du, som
almindelig bruger at slette password-filen, vil blot blot få en besked 
med "Permission denied" - og det skal du faktisk være glad for. Sker
det samme, imens du er root, vil du få lov til at slette filen. Styrer 
maskinen emails for 500 brugere, så går der sikkert mellem 10 og 20 
sekunder før at din telefon er rødglødende af sure folk, som ikke længere 
kan hente emails eller logge ind på maskinen.
</para>

<para>
Selvom man bare har sin Linuxmaskine derhjemme, og der ikke er andre, der 
bruger den, er det stadig vigtigt at have mindst én almindelig konto ud over 
root kontoen.
</para>

<para>
Når du skal lave systemarbejde, så kan følgende fremgangsmåde være 
anvendelig: Tag en speciel rød kasket på hovedet,
som tegn på at du nu vil være root :-) Skift nu til root arbejde ved
at skrive <COMMAND>su - root</COMMAND>. Bemærk at nogle gange udelades
minustegnet. Det kommer vi tilbage til. Og før du skriver den mindste
ordre, så placer begge hænder under din bagdel. I den tilstand tænker
du dig så grundigt om, før du skriver og udfører ordrer - for du kan
ALT som root. Det lyder nok lidt komisk, men der er alvor i noget af
det. Skil dit normale arbejde på maskinen, såsom at læse din egne
emails og programmere, fra root arbejdet. Vær kun root, når det er
nødvendigt og brug root kontoen med stor varsomhed. Sørg bl.a. for at
videresende emails til root til en almindelig brugerkonto (din egen),
idet du <emphasis>ikke</emphasis> bør læse emails, når du er logget ind som root.  

Hvis du hører til dem, der tror, at de sagtens kan
administrere at være root hele tiden, så kan vi kun sige, at du ikke
er den første. Det er noget man typisk hører fra begyndere, der endnu
ikke har oplevet, hvor let det er som root at ødelægge meget med en
lillebitte forkert kommando. 
Hvis du vil være root hele tiden, så kræver det stor disciplin. Du bør
overveje, om du vil udsætte dig selv for de risici, det indebærer at
være root hele tiden.
</para>

<para>
Vi vil gerne sige det en gang for meget, så det er helt klart: En god
administrator giver altid så få rettigheder som muligt til
brugerne og tilsvarende til sig selv. Kun når det er nødvendigt, 
skifter systemadministratoren fra sin egen personlige konto til root
kontoen, og man låner ikke sit root password ud. I praksis vil man mange
steder synes, at denne meget restriktive måde at administrere sikkerhed
er unødigt streng og ofte fører til alt for langsomme ændringer af systemet,
men det er den afvejning man altid skal lave mellem kontrol, sikkerhed og
fleksibel brug af et computersystem. 
</para>

<sect2 id="su-root">
<title>su root</title>
<para>
Så hvad er forskellen på <COMMAND>su root</COMMAND> og <COMMAND>su -
root</COMMAND>?  Minus-tegnet betyder at root brugerens environment
(miljø-variable) bliver brugt. Hvis minus-tegnet udelades, beholder
root de miljø-variable, som brugeren der skrev <COMMAND>su</COMMAND>
kommandoen havde.  Dette kan være et sikkerhedsaspekt. En brugers
miljø-variable indeholder bl.a. hans personlige sti til de programmer,
han vil køre, gemt i variablen PATH. Forrest i en brugers PATH kan man
ofte finde ".", som betyder "det aktuelle katalog". Det betyder, at
når man skriver en kommando, vil maskinen først lede efter programmet
i det aktuelle katalog. Det kan være meget praktisk, men som root er
det farligt. Vi antager, at en bruger har skrevet et program og kaldt
det <COMMAND>ls</COMMAND>, og lagt det i sit hjemmekatalog. Root står
tilfældigvis i denne brugers hjemmekatalog, og skriver
<COMMAND>ls</COMMAND>. Hvis root har "." forrest i sin PATH, hvad sker
der så? I stedet for at <COMMAND>ls</COMMAND> kommandoen bliver kørt,
bliver brugerens eget program kørt - som root! Root bør
<emphasis>ikke</emphasis> have "." i sin egen PATH - og slet ikke
forrest.  Dette er bare et eksempel. Brugeren kan også have aliaser i
sine opstartsfiler, så kommandoer ikke gør det, man forventer, og der
kan ske uheld - selvom man som regel bruge "su" fra sin egen bruger
konto, hvor man kender opsætningen.  Desuden har root ofte
<FILENAME>/sbin</FILENAME> og måske <FILENAME>/usr/sbin</FILENAME> i
sin PATH, hvor der ligger en række systemkommandoer. Det er en god ide
altid at bruge minus-tegnet.
</para>
</sect2>

<sect2 id="root-rettigheder">
<title>Uddeling af root rettigheder</title>
<para>
Som systemadministrator vil du komme ud for, at nogle
brugere har behov for at kunne lave noget "specielt" systemarbejde, og 
derfor mener de skal have root passwordet. Det kunne f.eks. være selv 
at kunne genstarte en webserver, måske stoppe/genstarte maskinen eller 
dræbe processer efter programmer, som ikke fungerer.
Disse ting kræver at root passwordet anvendes på tidspunkter, som
ikke kan forudsiges. Du kan bevare root passwordet på 
få hænder og alligevel give nogle brugere de
tilstrækkelige systemrettigheder ved at installere programmet "sudo".
</para>

<para>
Programmet sudo følger ikke med alle Linux distributioner, men kan
downloades fra 
<ulink url="http://www.courtesan.com/sudo">http://www.courtesan.com/sudo</ulink>.
Programmet er nemt at oversætte og installere - gør følgende som root:
</para>

<SCREEN>
[root@sherwood robin]# tar xvzf cu-sudo.v1.5.9p2.tar.gz 
[root@sherwood robin]# cd cu-sudo.v1.5.9p2
[root@sherwood sudo.v1.5.9p2]# ./configure; make; make install
[root@sherwood sudo.v1.5.9p2]# exit
</SCREEN>

<para>
Derefter skal du lære at konfigurere sudo rigtigt. Dette afgør,
hvilke programmer bestemte personer kan tilgå. 
Du bør også følge med i hvilke sikkerhedsfejl, der bliver fundet i sudo 
(følg med på deres hjemmeside).
Der er på sudo-hjemmesiden en kortfattet eksempelfil. Læs desuden
man-sider for
<COMMAND>sudo</COMMAND>, <COMMAND>sudoers</COMMAND> og
<COMMAND>visudo</COMMAND>.
</para>

<para>
Konfigurationen startes som root ved at skrive
</para>

<SCREEN>
[root@sherwood robin]# /usr/local/sbin/visudo
</SCREEN>

<para>
Nu kommer editoren vi frem med den konfigurationsfil, du skal udfylde.
Som et eksempel lader vi brugeren robin kunne genstarte
NFS-serveren.
Find linien med 
</para>

<SCREEN>
root    ALL=(ALL) ALL 
</SCREEN>

<para>
Under denne tilføjer du, at brugeren robin på maskinen sherwood må køre
kommandoen <command>/etc/rc.d/init.d/nfs restart</command>.
</para>

<SCREEN>
robin     sherwood=/etc/rc.d/init.d/nfs restart
</SCREEN>

<para>
Gem filen og prøv nu som brugeren robin at genstarte nfs.
</para>

<para>
Det eneste trick er, at du, som almindelig bruger, skal skrive sudo
foran den kommando, du skal kunne køre med root-rettigheder. Efter en
lille formaning om at passe på skal robin som almindelig bruger skrive
sit <emphasis>eget</emphasis> passsword. Derefter udføres kommandoen,
som om det var root, der gjorde det. Man skal skrive sit password
som en sikkerhedsforanstaltning, der beskytter imod, at andre brugere
kan udnytte ens sudo rettigheder. Hvis du f.eks. er gået til frokost
uden at logge ud, så kan kollegaen ikke gå over og lave sudo
kommandoer fra din maskine, da han stadig ikke kender dit password.
</para>

<SCREEN>
[robin@ sherwood]$ sudo /etc/rc.d/init.d/sendmail restart

We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these two things:

        #1) Respect the privacy of others.
        #2) Think before you type.

Password:
Shutting down sendmail:                                    [  OK  ]
Starting sendmail:                                         [  OK  ]           
</SCREEN>

<para>
Eksemplet er fra Red Hat 6.0, men kan være taget med en vilkårlig
Linuxdistribution.
</para>

<para>
<command>super</command> er et andet program, som kan meget af det
samme som sudo, og som kan downloades fra 
<ulink url="ftp://ftp.ucolick.org/pub/users/will">ftp://ftp.ucolick.org/pub/users/will</ulink>.
Umiddelbart har <command>super</command> flere muligheder, 
men det er sværere at anvende end <command>sudo</command>.
</para>

<para>
Endelig skal det siges, at programmet <command>sudo</command> også er
smart, selvom du har spredt root password på flere hænder, idet det
tvinger brugeren til at være lidt forsigtig med root-kontoen. Som
afslutning vil vi dog påpege, at hvis du tildeler personer rettigheder
via <command>sudo</command>, så bør det ikke være ene generelt
blankocheck til at kunne køre alt som root. Istedet bør du anføre hver
af de services, der skal kunne startes og stoppes via
<command>sudo</command>. En god grund til dette er, at du så ikke
havner i en sitation, hvor dine basale binære programmer eller
bibioteker er bliver udskiftet pga. misforståelser eller destruktiv
handling. Hvis en person virkelig skal være root ofte, så er det måske
klogere, at personen også har root-password og et tilsvarende ansvar.
</para>
</sect2>
</sect1>

<sect1 id="password-valg">
<title>Valg af password</title>
<para>
Det er vigtigt at hemmeligholde sine passwords - især sit root password.

På en Linuxmaskine logger man ind med et bruger-id såsom 
"robin" og et tilhørende password. Vi vil se på, hvorfor det 
er vigtigt, at du beskytter dit password, og hvordan du kan beskytte 
det. Vi vil se nærmere på, hvad der sker med dit password på Linuxmaskinen,
og på nogle af de værktøjer, du kan bruge til at højne 
sikkerheden omkring passwords.
</para>

<sect2 id="gem-password">
<title>Skriv ikke dit password, hvor andre kan se det</title>
<para>
Styrer du en Linuxmaskine med et antal brugere, der har hver sin
login-konto, så er det vigtigt, at de alle forstår, at de hver især er
ansvarlige for deres password. Hvis de skriver det på en lap papir og
sætter den på opslagstavlen eller på skærmen, er de med til at
bryde sikkerheden. Man kan grine af dette, men det er langt mere
udbredt, end man skulle tro. Sagen er, at en vilkårlig anden person, som
kender din kombination af login-navn og password, kan logge
ind som <emphasis>dig</emphasis> og arbejde som dig, misbruge, ødelægge eller
spionere i dit navn. Det skal selvfølgelig undgås.
</para>
</sect2>

<sect2 id="valg-af-password">
<title>Hvordan vælger man passwords ?</title>

<para>
Ud over at password ikke må skrives, hvor andre kan se det, så er det 
ikke lige meget, hvordan du vælger dit password
og specielt ikke dit root password. Desuden bør man skifte password
med passende mellemrum. Passwords kan knækkes ved en
kombination af gode gæt og rå beregningskraft. Før vi ser på dette, så
lad os se på, hvordan dit password er gemt på på din Linuxmaskine.
</para>

<para>
Dit password og information om dit login-navn og gruppe gemmes i filen
<FILENAME>/etc/passwd</FILENAME>. Hvis du ikke anvender <emphasis>shadow
passwords</emphasis> (hvad det er kommer vi ind på senere), så kan en linie
i passwd-filen ligne følgende:
</para>

<SCREEN>
robin:A1$HN1r2zxs$A2rmawluybzv8hkf4Hpzz0:501:501::/home/robin:/bin/bash
</SCREEN>

<para>
De første to felter er dit login-navn og dit krypterede password.
Når du ændrer password (med kommandoen passwd), så vil
Linuxmaskinen kryptere dit password til noget meget ukendeligt og
gemme dette i <FILENAME>/etc/passwd</FILENAME>. Ideen bag dette er, at man
har en algoritme, som hurtigt kan generere noget unikt krypteret 
tekst ud fra en anden tekst såsom dit password, men at det i praksis 
er umuligt at gå den anden vej. Det vil sige at der ikke findes en metode, 
hvor man finde det originale password ud fra det krypterede password. Som et
lille matematisk eksempel kan vi nævne, at man nemt kan finde y hvis man 
kender x, ud fra y = x^3+2*x^2-3*x+2, mens det er langt mere besværligt 
at finde x ud fra y - i dette eksempel skal man løse en tredie grads 
ligning. De metoder, man anvender til at kryptere passwords, er meget 
smartere end bare en trediegradsligning. Metoderne er udviklet, således 
at man garanterer, at der kun er et password, som svarer til det krypterede 
password.
</para>

<para>
Fra den mere muntre afdeling kan vi lige igen vise en stribe fra 
<ulink url="http://www.userfriendly.org/static">http://www.userfriendly.org/static</ulink>
</para>

<FIGURE ID="uf000933-fig" FLOAT="1">
<TITLE>User Friendly</TITLE>
<GRAPHIC FILEREF="uf000933.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>  
</sect2>


<sect2 id="DES-kryptering">
<title>DES kryptering af passwords</title>
<para>
På det fleste UNIX systemer har det i mange år været standard, at et 
password måtte være op til otte tegn langt, og ud fra dette blev der gemt 13
krypterede tegn i din password-fil. På Linux har man længe anvendt
crypt, som benytter sig af DES (Data Encryption Standard). Læs mere 
om DES på
 <ulink url="http://csrc.ncsl.nist.gov/cryptval/des/des.txt">http://csrc.ncsl.nist.gov/cryptval/des/des.txt</ulink>.
</para>
<para>
Funktionen crypt bruger det indtastede password som krypteringsnøgle. Den
tekst, der krypteres, er blot en række nuller. Men det er ikke hele 
passwordet, der bruges som DES-nøgle, den sidste bit i hvert tegn smides 
væk. Desuden sættes 2 tilfældige tegn ind, det såkaldte "salt", der blot 
er beregnet til at gøre det sværere at rekonstruere passwordet. Se i 
øvrigt<COMMAND> man crypt</COMMAND>.
</para>
</sect2>

<sect2 id="MD5">
<title>MD5</title>
<para>
I gamle dage, hvor man ikke havde så store computere, var crypt en god
løsning til passwords, da den er nærmest umulig at bryde på kort tid.
Men i dag har man rå computerkraft nok til, at man ikke behøver at
bryde krypteringen. Man kan i stedet sætte sine computere til at prøve
sig frem fra en ende af. Derfor er der i dag brug for længere passwords,
som er sværere at bryde.
</para>

<para>
Linux Red Hat 6.0 har en langt mere veludviklet håndtering af
passwords end tidligere UNIX systemer, hvis man har valgt at kryptere med 
MD5 checksums. Man kan nu med MD5 vælge passwords, der har mere end
otte tegn, og uanset længden af det man taster ind, gemmes der altid
34 krypterede tegn i password-filen. Det er langt sværere at knække de
lange passwords.
</para>

<para>
Det, vi ønsker med vores avancerede kryptering, er, at der kun er en
måde, hvorpå du kan få det ukrypterede password ud fra det krypterede -
ved at indtaste det korrekte password. Er du cracker, må du prøve at 
gætte på passwordet, kryptere alle disse passwords og sammenligne 
det krypterede gæt med det rigtige krypterede password. Er
de to krypterede passwords ens, så er gættet og det rigtige ukrypterede
password ens - du kender nu passwordet og kan logge ind på systemet som
den pågældende bruger. Derfor bør man vælge et password, der er svært at
gætte. Ydermere kan vi igen anbefale, at du bruger shadow passwords,
for så har man ikke adgang til det krypterede password.
</para>
</sect2>

<sect2 id="knaekke-passwords">
<title>Jeg knækker dit password</title>
<para>
Der findes programmer, som kan bruges til at knække passwords
effektivt. Man kan måske mene, at det er med til at svække sikkerhed
generelt, at der ligger programmer frit tilgængeligt på Internet, som
gør det nemt at cracke passwords. Vi mener, at det er for enkelt at 
tænke sådan. Enhver kan i princippet skrive et program til at knække 
passwords, og derfor bør man måske selv lade sit password komme 
igennem sådan et program. Hvis det ikke er knækket indenfor en måned, 
er det ikke så ringe... Men så er det alligevel på tide at skifte det 
ud. Et udbredt program til at knække passwords er <emphasis>John the Ripper</emphasis>, 
der kan findes på 
<ulink url="http://www.openwall.com/john/">http://www.false.com/security/john/</ulink>.
Man kan finde programmer, som er en del hurtigere til blindt at knække 
passwords fra en ende af, men John the Ripper har nogle spændende aspekter. 
Nedenfor er vist, hvordan programmet knækker passwords for brugeren robin i
med tre forskellige passwords, hhv. "a", "ab" og "qsw". Udskriften stammer fra
en 300 MHz PII, og det viser, at et bogstav knækkes på få sekunder,
mens to og tre tilfældige bogstaver kan knækkes på 5 hhv. 8 minutter.
Generelt så bliver det meget langsommere at knække et passwords for
hver gang at der kommer et tegn mere i passwordet. Derfor bør man altid 
vælge passwords med mere end syv tegn.
</para>

<SCREEN>
Loaded 1 password (FreeBSD MD5 [32/32])
a                (robin)
guesses: 1  time: 0:00:00:06 100% (2)  c/s: 746  trying: a

Loaded 1 password (FreeBSD MD5 [32/32])
ab               (robin)
guesses: 1  time: 0:00:05:12 (3)  c/s: 665  trying: ab

Loaded 1 password (FreeBSD MD5 [32/32])
qsw              (robin)
guesses: 1  time: 0:00:08:08 (3)  c/s: 669  trying: qsw
</SCREEN>

<para>
John the Ripper er lidt langsom til de "tilfældige" passwords ovenfor,
fordi det er programmeret ud fra, hvordan mange brugere i praksis vælger
password. Man vælger ofte kærestens navn, måske koblet med en
fødselsdag, et sted man er glad for, eller andre ting man kan
huske. Det er ikke klogt, fordi det er for nemt at gætte, hvilket følgende 
viser. Først har vi ladet brugeren robin have password "abc" som står 
i alle ordbøger. Det koster kun 4 sekunder, før det er fundet. Dernæst 
er vist, at fem bogstaver som i ordet "apple" findes på 3 sekunder, og 
endelig gentagelsen "appleapple" med 10 bogstaver som kun tager 19 
sekunder at knække - skræmmende, ikke sandt? Ordbøger findes til alle 
sprog, så vælg altid passwords som <emphasis>ikke</emphasis> står i en ordbog - bland 
tal ind i ord og lav et underligt system, andre ikke har en 
chance for at gætte. Brug f.eks. forbogstaver fra en sætning eller 
en sang, og flet specialtegn og numre med ind. Vær dog lidt varsom med
specialtegn i passwords - specialtegnenes placering på tastaturet kan 
variere alt efter hvilket land, tastaturet er sat op til. Man kan f.eks. 
komme ud for et dansk tastatur, som er sat op som et amerikansk,  hvor 
det kan det være ret svært at finde specialtegnene. Jo længere password du
vælger des bedre - og altid på mere end syv tegn. Root passwordet skal
helst være endnu længere og vælges med særlig omhu. I øvrigt bør du med 
jævne mellemrum ændre password, men sørg for at dette sker enten på selve 
maskinen eller via en krypteret adgang til maskinen såsom ssh (secure shell).
</para>

<SCREEN>
Loaded 1 password (FreeBSD MD5 [32/32])
abc              (robin)
guesses: 1  time: 0:00:00:04 100% (2)  c/s: 837  trying: abc

Loaded 1 password (FreeBSD MD5 [32/32])
apple            (robin)
guesses: 1  time: 0:00:00:03 100% (2)  c/s: 891  trying: apple

Loaded 1 password (FreeBSD MD5 [32/32])
appleapple       (robin)
guesses: 1  time: 0:00:00:19 100% (2)  c/s: 710  trying: appleapple
</SCREEN>
</sect2>

<sect2 id="shadow-files">
<title>Shadow files</title>
<para>
Den almindelige password-fil, <FILENAME>/etc/passwd</FILENAME>, kan
læses af alle. Dette er nødvendigt, da en del programmer bruger filen
til at koble en brugers bruger-id (tredie felt i password-filen) med
det tilhørende brugernavn. At alle kan læse filen betyder imidlertid
også, at alle kan se dit krypterede password. Derfra kan man cracke
dit password, og som vi har beskrevet, så kan det gøres hurtigt, hvis
du har valgt et svagt password. Med flere Linux distributioner
bl.a. Red Hat 6.2 bliver du ved installationen spurgt, om du vil
anvende shadow passwords, hvilket du bør svare ja til. Når du har
installeret dette, så vil du se, at der står et "x" i
<FILENAME>/etc/passwd</FILENAME>, hvor dit krypterede password før
ville have stået:
</para>

<SCREEN>
robin:x:501:501::/home/robin:/bin/bash
</SCREEN>

<para>
Dit krypterede password er nu flyttet til <FILENAME>/etc/shadow</FILENAME>,
som kun kan læses af root - dvs., ingen almindelig bruger på maskinen
nu kan læse dit krypterede password. Hvis du har installeret
Linux, men ikke har shadow passwords slået til, kan det gøres med kommandoen
<COMMAND>/usr/sbin/pwconv</COMMAND>, som skal køres som root. Den
laver shadow filen ud fra password filen og tilsvarende laves en shadow 
gruppe-fil <FILENAME>/etc/gshadow</FILENAME> ud fra  
<FILENAME>/etc/group</FILENAME> med
programmet <COMMAND>/usr/sbin/grpconv</COMMAND>. For at dette virker, skal 
dine Linuxprogrammer være oversat til at kunne håndtere dette - tidligere var
dette ikke altid tilfældet. Læs manualsiden for pwconv for detaljer.
</para>

<para>
I det ovenstående, hvor vi skriver, at alle kan læse password-filen,
går vi ud fra, at det er brugere med lokal adgang. Hvordan får en
cracker udefra adgang til min password-fil, så han kan se mit krypterede 
password? Ofte er det CGI-scripts på en web-server, som pga. simple
programmeringsfejl eller pga. fejl i de anvendte programmeringsssprog
kan lokkes til at vise de krypterede passwords fra
password-filen. Dygtige crackere finder fra tid til anden nye metoder 
til at gøre dette. Normalt findes tilsvarende rettelser til 
disse huller - hold derfor altid din maskine opdateret.
</para>
</sect2>
</sect1>

<sect1 id="suid">
<title>SUID root programmer</title>

<para>
SUID betyder, at et program kører "som sin ejer", og ikke "som" den
bruger, der udfører det. Dvs. at det kører med ejerens rettigheder.
Et program, som robin ejer, og som er SUID, har f.eks. ret til at
skrive i robins hjemmekatalog, selvom det er en anden bruger, der
eksekverer det. Et SGID program er det samme bare med gruppe
rettigheder i stedet.
</para>

<para>
Hvorfor er det farligt? SUID er specielt farligt, når det er et 
SUID-program som root ejer. Så længe programmet opfører sig pænt,
er det ikke noget problem. Men hvis der er fejl eller sikkerhedshuller
i programmet, kan det være en trussel mod sikkerheden. Man kan
forestille sig, at et program har et sikkerhedshul, som gør det
muligt for en almindelig bruger at gå ind og overskrive noget af
programmets hukommelse, imens det kører, og få det til at gøre noget 
andet, end det skal. Så har denne bruger faktisk root adgang til
systemet. Man har set eksempler på dette med efterfølgende 
sikkerhedsopdateringer til følge.
</para>

<para>
Lad os nu se på hvilke programmer, der på en normal Linux maskine er 
SUID programmer.

<SCREEN>
[robin@sherwood robin]$ su - root
[root@sherwood root]$ find / -perm +4000
</SCREEN>

Sådan finder du alle SUID programmer. Men det er kun SUID root 
programmer, som vi vil være bange for i dag. Hvis andre brugere selv
laver SUID programmer så lad os antage, at de ved, hvad de laver
og selv tager eventuelle konsekvenser.
Vi går nu efter de programmer, hvor root er ejeren og som er SUID. Så vi tager 
parametrene "-user root" med til find kommandoen:
</para>

<SCREEN>
[robin@sherwood robin]$ su - root
Password:
[root@sherwood robin]# find / -perm +4000 -user root
/bin/ping
/bin/mount
/bin/umount
/bin/su
/bin/login
/sbin/dump
/sbin/restore
/sbin/pwdb_chkpwd
/sbin/cardctl
/usr/bin/rcp
/usr/bin/rlogin
/usr/bin/rsh
/usr/bin/at
/usr/bin/dos
/usr/bin/chage
/usr/bin/lpq
/usr/bin/lpr
/usr/bin/lprm
/usr/bin/passwd
/usr/bin/suidperl                                                           
/usr/bin/procmail
/usr/bin/screen
/usr/bin/nwsfind
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/newgrp
/usr/bin/crontab
/usr/bin/zgv
/usr/bin/gpasswd
/usr/bin/sperl5.00405
/usr/X11R6/bin/xterm
/usr/X11R6/bin/XConsole
/usr/X11R6/bin/nxterm
/usr/X11R6/bin/xscreensaver
/usr/X11R6/bin/Xwrapper
/usr/lib/news/bin/startinnfeed
/usr/local/bin/ssh1
/usr/sbin/usernetctl
/usr/sbin/inndstart
/usr/sbin/sendmail
/usr/sbin/traceroute
/usr/libexec/pt_chown
find: /proc/1144/fd: Permission denied
find: /proc/1145/fd: Permission denied
find: /proc/6286/fd/4: No such file or directory
/opt/kde/bin/kvt
/opt/kde/bin/kppp
</SCREEN>

<para>
Outputtet er de SUID root programmer, der findes på systemet. Der er
også et par fejl fra find nede fra /proc kataloget. Det skal du ikke
tage dig af, /proc er et interface til den kørende kerne, og der ligger 
ikke almindelige filer (f.eks. SUID root programmer) der.
Det er <emphasis>mange</emphasis> programmer at passe på, måske er der et sikkerhedshul 
i nogle af dem. Har du brug for alle disse programmer? Er der mon 
nogle af dem, der kan køre uden SUID root eller helt fjernes? Check 
programmernes man page, check om andre programmer er afhængige af 
SUID-programmet, som det f.eks. er tilfældet med 
<COMMAND>/bin/su</COMMAND>.
Det kan ofte undersøges med systemets pakkemanager. Er der 
sikkerhedsopdateringer til nogle af programmerne, du burde installere?
Kan du overskue at følge med i sikkerhedsopdateringer for alle disse
programmer? 
Konklusionen er, at du aldrig skal installere flere programmer, end
der skal bruges. 
</para>


<para>
SGID - set group ID - er også farligt, hvis gruppen er root. Det er
ikke så almindeligt at anvende SGID
</para>

<SCREEN>
[root@sherwood robin]# find / -perm +2000 -group root
/sbin/netreport
/usr/sbin/sendmail
find: /proc/1144/fd: Permission denied
find: /proc/1145/fd: Permission denied
find: /proc/6296/fd/4: No such file or directory
</SCREEN>

<para>
Der var ikke så mange, men dem skal man også være opmærksom på.
</para>

<para>
Lad os som et eksperiment prøve at lade <COMMAND>/bin/ping</COMMAND> være ejet 
af robin i stedet for root, og lad os se om den stadig virker:
</para>

<SCREEN>
[root@sherwood robin]# ls -l /bin/ping
-rwsr-xr-x   1 root     root        14116 Jun 18  1998 /bin/ping
[root@sherwood robin]# chown robin /bin/ping
[root@sherwood robin]# ls -l /bin/ping
-rwsr-xr-x   1 robin     root        14116 Jun 18  1998 /bin/ping
[root@sherwood robin]# ping 10.10.10.3
ping: ping must run as root
[root@sherwood robin]#
</SCREEN>

<para>
Ups, det kunne man ikke. Vi må hellere skifte tilbage:
</para>

<SCREEN>
[root@sherwood robin]# chown root /bin/ping
</SCREEN> 

<para>
Programmet ping er svært at undvære og er nødt til at køre som SUID
root. Du kan i øvrigt se, at det er SUID ved det "s" som kommer frem,
når du kører <COMMAND>ls -al</COMMAND> på filen.  Programmet
<COMMAND>/usr/bin/passwd</COMMAND> er svært at undvære, og det er nødt til
at køre som root for at kunne ændre i /etc/passwd filen.
Et program som kppp kunne derimod afinstalleres, hvis du ikke bruger
det. Kppp er et KDE program, der bruges til at koble sig til Internet
via modem. Tilsvarende kan du afinstallere <COMMAND>/sbin/cardctl</COMMAND>, 
hvis du ikke har PCMCIA kort i din maskine. Anvender du en RPM baseret 
Linuxdistribution såsom Mandrake, SuSE eller Red Hat, kan du have 
glæde af at finde ud af fra hvilken pakke, et givent SUID program kommer
fra.
</para>

<SCREEN>
[root@sherwood root]# rpm -qf /sbin/cardctl
kernel-pcmcia-cs-2.2.5-15
</SCREEN>

<para>
Så kan du checke hvilke filer, pakken indeholder. Når du frem til,
at pakken ikke bruges, så afinstaller den:
</para>

<SCREEN>
[root@sherwood root]# rpm -ql kernel-pcmcia-cs-2.2.5-15
...klip mange linier
[root@sherwood root]# rpm -e kernel-pcmcia-cs-2.2.5-15
</SCREEN>

<para>
SUID root programmer er en alvorlig sikkerhedsrisiko, og man bør i
hvert fald ikke lave SUID root programmer selv for at løse en given
opgave.  Der er ting man ikke har fundet smartere løsninger på endnu,
men de fleste ting kan gøres uden. I Linux har man som en
sikkerhedsforanstaltning overfor SUID root programmer indbygget, at et
script (tekstfil med kommandoer) ikke kan køres som SUID root.
</para>
</sect1>
</chapter>


<chapter id="remote-login">
<title>Remote login og netværksaflytning</title>

<para>
En af de store styrker ved en Linux (UNIX) maskine er, at
man kan administrere den fra en anden maskine via netværk. For at være
kompatibel med alle andre UNIX varianter følger de gode gamle værktøjer 
telnet og ftp med i Linux distributionerne, og de er meget anvendte 
til fjernadministration. Vi vil i denne artikel se på, hvorfor 
værktøjer som telnet og ftp ikke bør anvendes, hvis maskinen er koblet til 
Internet eller et andet usikkert netværk. Vi skal se på, hvordan 
netværkstrafik kan aflyttes. Derefter skal vi se nærmere på alternativer 
til telnet og ftp, hvor datastrømmen bliver krypteret. Specielt 
fokuserer vi på ssh (secure shell) og viser installation og anvendelse.
Meget af det, der beskrives i artiklen, gælder ikke blot for Linux, men
også for andre UNIX'er.
</para>

<sect1 id="usikker-nettrafik">
<title>Nem men usikker netværkstrafik</title>
<para>
Fra en Linux maskine kan man nemt logge ind på en anden Linux maskine
og køre programmer, endog grafiske programmer. Dermed kan man køre
tunge programmer på en stærk server og få vist resultater på en anden 
(måske langsommere) maskine. 
</para>

<para>
Antag, at vi har et lokalnet bestående af tre maskiner. Vi anvender
maskinen "sherwood" (IP adresse 192.168.0.1) med brugernavnet robin, men vi
vil køre programmer fra maskinen "locksley" (192.168.0.2). I netværket 
finder vi desuden maskinen "nottingham" (192.168.0.3), som vi leger er 
en ondsindet maskine, der ønsker at bryde vores sikkerhed. I praksis 
kunne det være tre maskiner på Internet, hvor netværkstrafik mellem 
"sherwood" og "locksley" tilfældigvis også kommer forbi "nottingham".
</para>

<para>
Resten af artiklen vil handle om programmer til remote login, som telnet, 
rlogin og ssh, samt programmer til filoverførsel (ftp og scp). Men hvad
bruges det til? Med remote login kan man udføre tekstkommandoer på den
maskine, man er logget ind på, men man kan også køre X-programmer over
nettet.
</para>

<sect2 id="telnet-og-xhost">
<title>telnet og xhost</title>

<para>
Hvis du på sherwood kører en X-baseret grafisk brugergrænseflade, og du vil køre
X-programmer (grafiske programmer) fra maskinen locksley, skal du starte med at
fortælle sherwood, at det er i orden, at locksley benytter dens display. 
Dette gøres ved at føje locksley til listen over godkendte hosts med 
kommandoen xhost:
</para>

<SCREEN>
[robin@sherwood robin]$ xhost + locksley
locksley being added to access control list 
</SCREEN>

<para>Dermed vil grafiske programmer fra locksley vil blive accepteret af
sherwood. Udelades maskinnavnet, betyder det, at alle maskiner kan vise
grafik på din skærm. Lad være med det, da det sikkerhedsmæssigt er
en dårlig ide. 
</para>

<para>
Lad os nu logge ind på locksley med telnet,
</para>

<SCREEN>
[robin@sherwood robin]$ telnet locksley
Trying 192.168.0.2...
Connected to locksley.herne.dk.
Escape character is '^]'.
Debian GNU/Linux 2.1 locksley.herne.dk

locksley login: robin
Password:
</SCREEN>

<para>
Efter at have skrevet loginnavn og password på locksley maskinen får
du en kommandolinie, og du kan udføre programmer på maskinen, som om du
var logget ind lokalt. 
</para>

<para>
For at kunne få de grafiske programmer, du starter på locksley, til at
vise sig på sherwoods skærm er det nødvendigt at sætte DISPLAY
environment variablen:
</para>

<SCREEN>
[robin@sherwood robin]$ export DISPLAY=sherwood:0.0
</SCREEN>

<para>
Mange X-programmer kan dog også kaldes med "-display" som option. 
</para>

<para>
Nu kan du køre dit X-program, f.eks. "xload", som om du sad på 
locksley. Programmet kører på locksley, men
alt grafik vises på sherwood, og programmet styres fra sherwood. 
</para>

<SCREEN>
[robin@locksley robin]$ xload -display sherwood:0.0 -geometry 60x60 -nolabel &
</SCREEN>

<FIGURE ID="xload-fig" FLOAT="1">
<TITLE>xload</TITLE>
<GRAPHIC FILEREF="xload.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>  

<para>
Det er nemt, og allerede ved disse enkle operationer kan du have
mistet hele din password-sikkerhed. Sagen er, at da man i sin tid
designede telnet tænkte man ikke så meget på sikkerhed, men mere på
driftstabilitet.  Når man laver telnet fra en maskine til en anden,
sender man først sit brugernavn og derefter password. <emphasis>Begge sendes
klar tekst</emphasis>. Det kan selvfølgelig udnyttes til at stjæle passwords
på Internet - og det gøres!
</para>
</sect2>

<sect2 id="sende-passwords-over-net">
<title>Pas på passwords sendt over netværk</title>
<para>
For at aflytte netværkstrafikken kan man downloade programmet sniffit
til Linux. Når det startes op vises alle kommunikationslinier,
såsom telnet- og ftp-forbindelser, mellem maskinerne på netværket. Det
kommer an på konfiguration af routere, firewalls, switche og hubs,
hvor meget man reelt får at se.  Sniffit kan downloades fra 
<ulink url="http://reptile.rug.ac.be/~coder/sniffit/sniffit.html">http://reptile.rug.ac.be/~coder/sniffit/sniffit.html</ulink>. 
Sniffit skal køres som root.
</para>

<para>
Lad os antage, at den ondsindede "nottingham" (192.168.0.3) lytter med på, 
hvad vi laver mellem "sherwood" (192.168.0.1) og "locksley" (192.168.0.2).
Programmet sniffit startes  i interactive mode med angivelse af
hvilket netværks-interface, der skal lyttes på: 
</para>

<SCREEN>
[root@nottingham root]# sniffit -F eth0 -i 
</SCREEN>

<para>
hvor eth0 betyder første ethernet kort i maskinen, og i betyder
interactive mode. Ud kommer nedenstående billede, hvor man ser, at
maskinen med netværksadresse 192.168.0.1 (sherwood) har oprettet en
forbindelse til port 23 på maskinen med netværksadresse 192.168.0.2
(locksley). Port 23 er den port, telnet lytter på. Port 3211, som man
sender fra, er valgt blandt maskinens ledige porte, dvs. de porte, der
ikke er nogen service, der lytter på.  Der er valgt et portnummer, som
er større end 1024, dvs. en ikke priviligeret port.
</para>

<para>
Trykkes return på en linie vil den blive markeret med "*LOGGED*",
og det mindre vindue mod højre vil vise trafikken på den forbindelse. 
Først kommer login navn: "robin", og efter to punktummer kommer passwordet 
i klar tekst: "qwe123". Der skal ikke stor fantasi til at forestille sig, 
at dette program nemt kan sættes til at dumpe samhørende loginnavne og 
passwords ned i en fil over en periode, indtil der er gevinst. 
</para>

<FIGURE ID="sniffit2-fig" FLOAT="1">
<TITLE>Sniffit</TITLE>
<GRAPHIC FILEREF="sniffit2.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>  


<para>
Vi har vist, at man ikke skal bruge telnet til at kommunikere mellem
to maskiner, hvis der er risiko for, at nogen lytter med, og slet ikke
hvis man skal logge ind som root på maskinen. Det er simpelthen for
nemt at lede efter loginnavn root og derefter få passwordet. Derfor
har mange Linux distributioner per default forhindret, at root logger
ind via netværket. Red Hat 6.0, Debian 1.3 og SuSE 6.2 har filen
"/etc/securetty", der indeholder de konsoller, hvor root må logge ind.
Dette kan være "tty1" til "tty6", som er de tekst login konsoller, der
normalt er på selve Linux maskinen - dvs. ikke via netværket. Hvis man
absolut vil tillade root login via netværk, kan man tilføje "0", "1"
og opefter (for Linux kerne 2.2.X) svarende til hvor mange logins, du
forventer på maskinen fra netværket. Normalt er det
<emphasis>ikke</emphasis> klogt at tillade direkte root login via
netværk.
</para>
</sect2>

<sect2 id="ftp-sniffit">
<title>ftp</title>
<para>
Hvis vi vil overføre filer fra "sherwood" (192.168.0.1) til
"locksley" (192.168.0.2), er ftp et af de gennemprøvede og gamle 
værktøjer. Også her er der sikkerhedsproblemer.
Vi sætter igen "nottingham" (192.168.0.3) til at køre sniffit som vist 
nedenfor. Denne gang sætter vi sniffit op til at vise alle pakker som 
ankommer til "locksley" (192.168.0.2), og man kan nemt se, 
hvad der sker.
</para>

<SCREEN>
[root@nottingham root]# sniffit -t192.168.0.2 -a -F eth0  
</SCREEN>

<SCREEN>
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1299-192.168.0.2.21
 E . . 4 . . @ . @ . . . . . . . . . . . . . . . . . b . . . . . P . } x i !
 . . U S E R   r o b i n . .

Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1299-192.168.0.2.21
 E . . ( . . @ . @ . . . . . . . . . . . . . . . . . b ( . . . . P . } x . .
 . .

Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1299-192.168.0.2.21
 E . . 5 . . @ . @ . . . . . . . . . . . . . . . . . b ( . . . . P . } x N D
 . . P A S S   q w e 1 2 3 . .
</SCREEN>

<para>
På den første af de tre data-linier kan man se login navn (robin), og som 
vist på den sidste data-linie, vil man direkte kunne læse passwordet (qwe123). 
Ser man lidt nøjere efter, vises også ftp-porten, port 21. Port 
1299 er ligesom ved telnet en ledig port, der vælges til denne session.
</para>

<para>
Som vi ser, er ftp også et meget usikkert program, hvor andre kan lytte med.
Så brug det med omtanke.
For en systemadministrator er paranoia ikke en sygdom, men en kvalifikation...
</para>

<para>
Det skal nævnes, at også resten af den nettrafik, du laver med telnet og
ftp, kan læses i klar tekst via f.eks. sniffit. Starter du andre
programmer, kan man se det. Laver du "su - root" og skriver root-passwordet, 
er sikkerheden på den maskine væk, for root passwordet er ude, hvis du
bliver aflyttet.
</para>
</sect2>

<sect2 id="remote-shell">
<title>Remote login, remote shell og remote copy</title>

<para>
To andre velkendte programmer i samme kategori er "rlogin" og "rsh".
Programmerne virker næsten ens. Begge 
giver interaktivt login på maskinen, men rsh kan udføre en kommando 
samtidig med, at man logger ind. F.eks. vil den følgende kommando logge 
ind direkte fra sherwood til locksley og køre kommandoen "df" (som viser 
hvor fyldte dine diske er).
</para>

<SCREEN>
[robin@sherwood robin]$ rsh locksley df
</SCREEN>

<para>
Nu prøver vi at køre sniffit på en rlogin session for at se, hvad man kan se.
På maskinen "nottingham" kører vi sniffit:
</para>

<SCREEN>
[root@nottingham root]# sniffit -x -s192.168.0.1 -a -F eth0
</SCREEN>

<para>
Vi logger ind fra sherwood til locksley med kommandoen:
</para>

<SCREEN>
[robin@sherwood robin]$ rlogin locksley
Password: qwe123
$ 
</SCREEN>

<para>
hvor password'et naturligvis ikke kan ses på skærmen, når man taster det ind.
Udklip fra sniffit's output:
</para>

<SCREEN>
TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA41   ACK (hex): 105DA03F
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ? s . @ . @ . F Q . . . . . . . . . . . . . . . A . ] . ? P . } x C .
 . . r o b i n . r o b i n . x t e r m / 9 6 0 0 .     


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA58   ACK (hex): 105DA040
   FLAGS: -A----   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ( s . @ . @ . F g . . . . . . . . . . . . . . . X . ] . @ P . } x } A
 . .


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA58   ACK (hex): 105DA041
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . 4 s . @ . @ . F J . . . . . . . . . . . . . . . X . ] . A P . } x . .
 . . . . s s . . . P . . . l


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA64   ACK (hex): 105DA04B
   FLAGS: -A----   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ( s . @ . @ . F U . . . . . . . . . . . . . . . d . ] . K P . } x } *
 . .


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA64   ACK (hex): 105DA04B
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ) s . @ . @ . F S . . . . . . . . . . . . . . . d . ] . K P . } x . !
 . . q


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA65   ACK (hex): 105DA04B
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ) s . @ . @ . F R . . . . . . . . . . . . . . . e . ] . K P . } x .
 . . w


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA66   ACK (hex): 105DA04B
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ) s . @ . @ . F Q . . . . . . . . . . . . . . . f . ] . K P . } x . .
 . . e


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA67   ACK (hex): 105DA04B
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ) s . @ . @ . F P . . . . . . . . . . . . . . . g . ] . K P . } x L .
 . . 1


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA68   ACK (hex): 105DA04B
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ) s . @ . @ . F O . . . . . . . . . . . . . . . h . ] . K P . } x K .
 . . 2


TCP Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
   SEQ (hex): C2D0BA69   ACK (hex): 105DA04B
   FLAGS: -AP---   Window: 7D78
Packet ID (from_IP.port-to_IP.port): 192.168.0.1.1023-192.168.0.2.513
 E . . ) s . @ . @ . F N . . . . . . . . . . . . . . . i . ] . K P . } x J .
 . . 3
</SCREEN>

<para>
Igen ser man tydeligt brugernavn og password blive sendt ukrypteret
over nettet (se sidste tegn på hver linie).  Man kan se, at rlogin på
locksley bruger port 513, og at der på sherwood sendes fra port 1023.
</para>

<para>
Skal du kopiere filer mellem to maskiner, så er ftp som tidligere
skrevet meget anvendt. Alternativt kan remote copy
<command>rcp</command> anvendes.  Skal du kopiere filen
<filename>.emacs</filename> fra sherwood til locksley, sker dette med
</para>

<SCREEN>
[robin@sherwood robin]$ rcp .emacs locksley:
</SCREEN>

<para>
Sikkerhedsmæssigt er <command>rcp</command> på linie med
<command>rlogin</command> og <command>rsh</command>. Vi skal senere i
artiklen vende tilbage til et fuldt krypteret alternativ til
<command>rcp</command>.
</para>

<para>
Med rlogin, rsh og rcp kan man vælge, at login kan ske uden
password. Dette gøres ved at sætte sit hostnavn og evt. brugernavn ind
i filen <filename>~/.rhosts</filename> i sit hjemmekatalog på den
maskine, der skal logges ind på. Hvis du gerne vil kunne logge ind fra
sherwood til locksley uden password, som brugeren robin, kan
<filename>.rhosts</filename>-filen i dit hjemmekatalog på locksley se
sådan ud:
</para>

<SCREEN>
sherwood robin
</SCREEN>

<para>
Der kan godt stå mange flere linier med andre hostnavne. Brugernavnet
kan udelades, idet brugeren sættes til den, hvis hjemmekatalog filen
ligger i.  Hvis filen er læsbar for alle, er det kun en bruger med
samme brugernavn som sit eget, der kan logge ind fra en anden
maskine. Er filen ikke læsbar for andre, kan man anføre linier i
<filename>.rhosts</filename>-filen med først maskinnavn og dernæst det
brugernavn, som anvendes på den anden maskine. For at "marian" skal
logge på ind på "sherwoord" som "robin", kan man således bruge
<command>rlogin sherwood -l robin</command>.
</para>

<para>
Den viste <filename>.rhosts</filename>-fil vil betyde, at du fra
maskinen sherwood som brugeren robin, godt må komme ind på locksley
som robin, uden password. Det kræver, at brugeren findes på begge
maskiner, og ".rhosts" filen skal ligge i brugerens hjemmekatalog på
den maskine, man prøver at logge ind på. Det er nemt og giver
lynhurtig adgang til, at man hopper fra maskine til maskine og laver
meget effektive arbejdsgange. Det lyder smart, men medaljen har en
bagside. En med root-adgang på maskinen "nottingham" (eller andre
maskiner i netværket) kan aflytte rsh/rlogin netværkstrafik et stykke
tid, og derved finde ud af fra hvilken maskine og med hvilket bruger
navn, man kan logge ind direkte.  Derefter kan man med lidt snilde
sætte maskinen "nottingham" lidt anderledes op, så "locksley" tror, at
den er "sherwood".
</para>

<para>
Der kan imidlertid være situationer, hvor det kan virke mere sikkert
at lade en bruger logge ind uden password fra en kendt host end at
lade brugeren have et password. Har man tillid til sit interne
netværk, og er det nødvendigt, at nogle brugere kan logge på en udsat
maskine, kan man vælge, at disse brugere ikke har noget password på
den udsatte maskine.  I stedet får de en stjerne ("*") i
<filename>/etc/passwd</filename>, der hvor passwordet normalt ville
stå.  Dette vil forhindre dem i at logge ind fra andre maskiner end
dem, der er angivet i deres <filename>~/.rhosts</filename> fil i deres
hjemmekatalog på den udsatte maskine. Når en bruger ikke har et
password, kan man ikke bryde ind på den udefra ved at gætte eller
knække passwordet. Men kan kun logge ind som denne bruger, hvis man
kan overbevise maskinen om, at man logger ind fra en betroet
maskine. Der kan i øvrigt læses mere om passwords beskyttelse og
håndtering i <ulink url="rootaccess.html">Artikel 3 - Root access -
hvem, hvordan og hvorfor ikke?</ulink>.
</para>

<para>
Hvis man ikke tillader <filename>.rhosts</filename>-filer, vil der ved
hver login sendes passwords i klar tekst over nettet. Hvis der er
<filename>.rhosts</filename>-filer, bliver der slet ikke sendt
passwords over nettet - i stedet for at give sit password skal man
logge ind fra en betroet host. Ingen kan nu opsnappe passwords - til
gengæld kan de udgive sig for at være den betroede host.  Stoler man
ikke på sit interne netværk, eller er nogen <emphasis>sluppet
ind</emphasis>, er begge dele nok lige dårligt.
</para>

<para>
Vi vil anbefale, at man i stedet for rlogin bruger et program, der 
krypterer login såvel som selve dataoverførslen, som f.eks. ssh giver
mulighed for.
</para>

<para>
Som systemadministrator kan du se om dine brugere har
<FILENAME>.rhosts</FILENAME> filer, og hvis det ikke er ønsket, kan du
slette dem (og skælde brugeren ud).  Hvis brugerne har hjemmekataloger
under <FILENAME>/home/</FILENAME>, så kan dette gøres med
</para>

<SCREEN>
[root@sherwood root]# find /home/* -maxdepth 1 -name <FILENAME>.rhosts</FILENAME> -print;
</SCREEN>

<para>
Hvis man samtidigt vil slette de fundne .rhosts filer kan man anvende
</para>

<SCREEN>
[root@sherwood root]# find /home/* -maxdepth 1 -name <FILENAME>.rhosts</FILENAME> -print -exec rm {} \;
</SCREEN>


<para>
Det er enklere at disable brugernes egne
<FILENAME>.rhosts</FILENAME>-filer ved, at man tilføjer parameteren
<FILENAME>-l</FILENAME> efter <FILENAME>in.rshd</FILENAME> i filen
<FILENAME>/etc/inetd.conf</FILENAME> og genstarter inetd-dæmonen. 
</para>

<para>
Et andet argument imod at tillade ".rhosts"-filer er, at brugeren kan
komme til at køre et program, som skriver til en fil uden hans viden.
Filen kunne "~/.rhosts" og dermed give adgang til en
ekstern bruger, som ikke behøver at have en konto på maskinen.
</para>


<para>
Et alternativ til "~/.rhosts" metoden er "hosts level
equivalence" via filen "/etc/hosts.equiv". Dine brugere har
ikke adgang til denne fil, og kun root kan rette i den. Root kan
vælge at sætte en række hostnavne ind i denne fil eller evt. bare et
plus. Det betyder, at disse hosts (+ betyder alle maskiner)
har adgang til at udføre rlogin og rsh kommandoer uden password. Dette
gælder alle brugere (dog ikke root) - brugeren skal dog findes på
begge maskiner. Filen "/etc/hosts.equiv" kan være en bekvem løsning,
men den er en bombe under systemsikkerheden - find en anden løsning,
hvis du har et åbent eller halvåbent netværk.
</para>

<para>
Her i <ulink url="http://www.userfriendly.org/cartoons/archives/97dec/19971212.html">User Friendly fra den 12. december 1997</ulink> kan Greg fra Columbia Internet 
aflytte netværkstrafikken i forsvarsministeriet...
</para>

<FIGURE ID="uf16x122-fig" FLOAT="1">
<TITLE>User Friendly</TITLE>
<GRAPHIC FILEREF="uf16x122.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>  

<para>
Fortsættelsen kan findes på <ulink url="http://www.userfriendly.org/cartoons/archives/97dec/19971216.html">http://www.userfriendly.org/cartoons/archives/97dec/19971216.html</ulink> :-)
</para>
</sect2>
</sect1>

<sect1 id="sikker-net-trafik">
<title>Nem og sikker netværkstrafik</title>
<para>
Hvis der er risiko for, at andre lytter med på netværkstrafikken,
er der behov for erstatningsprogrammer for telnet,
ftp og rlogin. Samtidig ønsker vi stadig at kunne afvikle programmer fra en
maskine og se resultater på en anden, naturligvis også de grafiske
programmer. Med andre ord ønsker vi samme funktionalitet - men med sikkerheden
i orden.
</para>

<para>
Der findes flere sikre alternativer til de gamle, ukrypterede protokoller.
Vi vil mest beskæftige os med ssh, men der findes også andre muligheder.
Et alternativ til telnet er stelnet, som står for secure telnet. Programmet 
baserer sig på SSL (Secure Sockets Layer), som er en måde at lave 
krypterering af datatrafikken. Kombinationen af stelnet og SSL er ikke så 
udbredt som ssh, og det er ikke så nemt at sætte op som ssh. 
Programmet stelnet kan findes på <ulink url="http://www.quick.com.au/ftp/pub/sjg">http://www.quick.com.au/ftp/pub/sjg</ulink>,
og selve krypteringslaget SSL til Linux kan findes på <ulink
url="http://www.psy.uq.oz.au/~ftp/Crypto/">http://www.psy.uq.oz.au/~ftp/Crypto/</ulink>. Denne sidste URL har også en hel del dokumentation.
</para>

<para>
Et andet alternativ til telnet og ftp, som er på vej, er SRP. Se mere
om SRP på <ulink url="http://srp.stanford.edu/srp">http://srp.stanford.edu/srp</ulink>.</para>

<para>
Det, der umiddelbart i dag er det bedste valg som erstatning for telnet
og rlogin, er ssh (Secure SHell). Programmet er lavet af et finsk firma
med navn SSH Communications Security med hjemmesiden 
<ulink url="http://www.ssh.fi">http://www.ssh.fi</ulink>.
Ssh har bl.a. den store fordel fremfor stelnet, at grafiske vinduer (XWindow) 
kan sendes over kryptererede linier. 
</para>

<para>
Programmet ssh er komplet, gennemprøvet og veldokumenteret, og der er
kildekode til det. Programmet må anvendes gratis til 
ikke-kommercielle formål, ellers skal der købes en licens. 
</para>

<para>
Det er et reelt problem, at ssh ikke er 
<ulink url="http://www.opensource.org">Open Source</ulink>, og derfor er der et
frit GNU program igang med at reimplementere koden under navnet
PSST. Du kan finde mere information om dette på 
<ulink url="http://www.net.lut.ac.uk/psst">http://www.net.lut.ac.uk/psst</ulink>. 
Hjemmesiden
for PSST bør følges fra tid til anden, men status i øjeblikket
(september 1999) er, at man er igang med at implementere, og derfor
ikke kan garantere for at koden virker, eller at den er sikker. 
</para>

<para>
En anden, forholdsvis ny implementering af ssh-protokollen er
OpenSSH, som er Open Source og er lavet af OpenBSD folkene.
implementering af SSH. Den er allerede er lagt ind i OpenBSD 
distributionen, der har ry for at være
særdeles sikker. OpenSSH er ligeledes på vej ind i Debian
distributionen. 
Hjemmesiden for OpenSSH er 
<ulink url="http://www.openssh.com/">http://www.openssh.com/</ulink>.
OpenSSH er baseret på OpenSSL, som kan downloades under support samme
sted, som OpenSSH findes. Man kan enten compile programmerne selv eller
installere de RPM-pakker, som findes præ-compilerede. 
</para>

<para>
Vi vælger i det følgende at koncentere os om ssh, men OpenSSH virker
helt på samme måde som ssh, så reelt er det op til dig, hvad du vælger
at prøve. OpenSSH i den nyeste version har dog en stor fordel: Den
implementerer også ssh2 protokollen, så man kan snakke med både
ssh1 og ssh2 klienter,
</para>


<sect2 id="installation-af-ssh">
<title>Installation af ssh</title>

<para>
Start med at downloade 
<ulink url="ftp://sunsite.auc.dk/pub/security/ssh/ssh-1.2.27.tar.gz">ftp://sunsite.auc.dk/pub/security/ssh/ssh-1.2.27.tar.gz</ulink>,
eller en evt. nyere 1.2 version, hvis dette findes. Tag dog ikke en
ældre version, idet der er konstateret sikkerhedsbrister i disse.
</para>

<SCREEN>
[root@sherwood root]# tar xvzf ssh-1.2.27.tar.gz
[root@sherwood root]# cd ssh-1.2.27
[root@sherwood ssh-1.2.27]# ./configure
[root@sherwood ssh-1.2.27]# make
[root@sherwood ssh-1.2.27]# make install
</SCREEN>

<para>
Det er kun nødvendigt at være root under "make install".
Under installationen (make install) genereres nøgler til at
identificere maskinen, derefter skal du selv til at lave dine
hemmelige nøgler. Dine personlige nøgler bruges til at kryptere
login-proceduren. Den efterfølgende datatrafik krypteres ud fra de to
maskiners nøgler. Alle disse nøgler 
er reelt filer på harddisken, men terminologien "nøgler"
skyldes, at nøgle-filerne skal bruges til at låse og låse op for den
krypterede datatrafik.
</para>

<para>
Lad os først se på, hvad der blev installeret. Der er kommet filer
tre steder, som vi nu vil se nærmere på. 
</para>

<SCREEN>
[robin@sherwood robin]$ ls -al /etc/ssh*
-rw-r--r--   1 root     root          880 jul 11 10:05 /etc/ssh_config
-rw-------   1 root     root          526 jul 11 10:05 /etc/ssh_host_key
-rw-r--r--   1 root     root          330 jul 11 10:05 /etc/ssh_host_key.pub
-rw-r--r--   1 root     root          683 jul 11 10:05 /etc/sshd_config
</SCREEN>

<para>
Filerne "/etc/ssh*" er konfigurationsfiler, der styrer
ssh opsætningen. Det er kun "/etc/sshd_config",
du evt. skal rette i. F.eks. kan du ændre "PermitRootLogin yes"
til "PermitRootLogin no", hvis du mener, at root ikke må logge ind via
ssh. Det kan være en god ide at forbyde root remote login i det hele taget.
Tilsvarende kan du forbyde tomme passwords ved at ændre
"PermitEmptyPasswords yes" til "PermitEmptyPasswords no" - vent lige
med at lave disse ændringer til du har fået ssh til at virke.
</para>

<para>
I "/usr/local/sbin/" er der installeret et vigtigt program.
Programmet sshd er ssh-daemonen, som skal være startet op af root, for
at du kan anvende ssh til login på maskinen. Dette gøres ved at sætte
programmet ind i maskinens startup scripts.
</para>

<SCREEN>
[robin@sherwood robin]$ ls -al /usr/local/sbin/ssh*
lrwxrwxrwx   1 root     root            5 jul 11 10:05 /usr/local/sbin/sshd -> sshd1
-rwxr-xr-x   1 root     root       623527 jul 11 10:05 /usr/local/sbin/sshd1
</SCREEN>


<para>
I Red Hat er det nemmeste, at server-daemonen programmet startes fra
"/etc/rc.d/rc.local" filen, som køres under system-opstart. Dette
gøres som root én gang for alle. 
</para>

<SCREEN>
[root@sherwood root]# echo "/usr/local/sbin/sshd" >> /etc/rc.d/rc.local
</SCREEN>

<para>
I SuSE Linux skal man i stedet tilføje til filen  "/sbin/init.d/boot.local"
</para>

<SCREEN>
[root@sherwood root]# echo "/usr/local/sbin/sshd" >> /sbin/init.d/boot.local
</SCREEN>

<para>
Hvis du ønsker mere kontrol med at kunne starte, stoppe, og checke
status på ssh-daemonen, bør du i stedet lave en rigtig start-fil
svarende til dem du i SuSE finder i "/etc/rc.d/" og for Red Hat i
"/etc/rc.d/init.d".  Vi kan nævne, at hvis du installerer OpenSSH som
RPM-pakke, så er alt dette lavet ordentligt med start script-filer,
som du finder i "/etc/rc.d/init.d/sshd".
</para>

<para>
Vi skal også lige nævne, at ssh forbindelser normalt ikke styres via
initd-systemet, som du i øvrigt kan finde beskrevet i
<ulink url="services.html">Artikel 2 - Services - at slå services fra og
begrænse adgang</ulink>. Grunden er, at det ville være for langsomt, idet
der ved opstart af sshd skal genereres en server-nøgle. Dette kan
tage flere sekunder for hver opstart.
</para>

<para>
Lad os nu gå videre op se på de programmer, som brugeren kommer til at
anvende. I "/usr/local/bin/" er der installeret en stribe brugerprogrammer:
</para>

<SCREEN>
[robin@sherwood robin]$ ls -al /usr/local/bin/ssh*
lrwxrwxrwx   1 root     root            4 jul 11 10:05 /usr/local/bin/ssh -> ssh1
lrwxrwxrwx   1 root     root            8 jul 11 10:05 /usr/local/bin/ssh-add -> ssh-add1
-rwxr-xr-x   1 root     root       321326 jul 11 10:05 /usr/local/bin/ssh-add1
lrwxrwxrwx   1 root     root           10 jul 11 10:05 /usr/local/bin/ssh-agent -> ssh-agent1
-rwxr-xr-x   1 root     root       328445 jul 11 10:05 /usr/local/bin/ssh-agent1
lrwxrwxrwx   1 root     root           12 jul 11 10:05 /usr/local/bin/ssh-askpass -> ssh-askpass1
-rwxr-xr-x   1 root     root        87725 jul 11 10:05 /usr/local/bin/ssh-askpass1
lrwxrwxrwx   1 root     root           11 jul 11 10:05 /usr/local/bin/ssh-keygen -> ssh-keygen1
-rwxr-xr-x   1 root     root       311029 jul 11 10:05 /usr/local/bin/ssh-keygen1
-rws--x--x   1 root     root       589457 jul 11 10:05 /usr/local/bin/ssh1
</SCREEN>

<para>
Der er links til version-1 programmer (f.eks. /usr/local/bin/ssh
-> ssh1), da der er lavet en version 2 af ssh, kaldet ssh2. Den
frigives under en mere restriktiv licens, men den må stadig anvendes
gratis til ikke-kommercielle formål. Indtil videre er ssh1, dvs. version 
1.2.27, dog den mest gennemprøvede. Version 1.2.28 er nu på vej pga. 
en identificeret svaghed i den nuværende version.
</para>
</sect2>

<sect2 id="Opsaetning-af-ssh">
<title>Opsætning af ssh</title>

<para>
For at kunne tilgå de nye programmer skal du sørge for at have
"/usr/local/bin/" med i din PATH, som du sikkert sætter
i din "~/.profile" eller din "~/.bashrc". Derefter skal du til at lave 
din hemmelige nøgle, hvilket du kun skal gøre den første gang.
</para> 

<para>
Kør programmet "ssh-keygen" - ikke som root men under din
almindelige brugerkonto. 
Først vælges nogle kæmpe primtal automatisk, som
anvendes til at generere dine nøgler (keys). Programmet spørger dig, 
om der skal gemmes nøgler i "~/.ssh/identity",
hvilket du bare skal acceptere. Dernæst skal du skrive en
"passphrase", som er et udvidet password. Skriv her en lang
sætning, som du skal anvende hver gang du logger ind via ssh. Din
passphrase skal naturligvis ikke komme fra en kendt remse, eller andet sted,
som andre har en chance for at kende. 
Erstat eller tilføj også et par specialtegn og
numre nogle steder, du vil kunne huske. Programmet gemmer en lang
offentlig nøgle (public key), der er over 300 tegn lang. Vi har
dog kortet denne linie ned i det næste eksempel. Kører du selv
programmet, vil din passphrase ikke vises på skærmen.
</para>

<SCREEN>
[robin@sherwood robin]$ ssh-keygen
Initializing random number generator...
Generating p:  .................................++ (distance 514)
Generating q:  ............++ (distance 234)
Computing the keys...
Testing the keys...
Key generation complete.
Enter file in which to save the key (/home/robin/.ssh/identity): 
Enter passphrase: V1 hANDLER me spaghett1
Enter the same passphrase again: V1 hANDLER me spaghett1
Your identification has been saved in /home/robin/.ssh/identity.
Your public key is:
1024 33 122323...923 robin@sherwood
Your public key has been saved in /home/robin/.ssh/identity.pub             
</SCREEN>

<para>
Hvis sshd er startet op, er alt klar til at kommunikere sikkert, 
også over usikre netværk. Start med at skrive
</para>

<SCREEN>
[robin@sherwood robin]$ ssh locksley
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)?          
</SCREEN>

<para>
Første gang du kobler til en fremmed maskine, der ligeledes har fået
installeret ssh, skal ssh acceptere at udveksle nøgler med en
ukendt maskine. Dette spørgsmål skal du således acceptere, og næste
gang du anvender samme fremmede maskine, skal du ikke igennem dette
spørgsmål. Efter at have svaret "yes" skal du aflevere dit
almindelige password, og du er så logget ind på maskinen. Dette kan du
fortsætte med, men hvis du vil højne sikkerheden yderligere, bør du
gemme din offentlige nøgle på fjernmaskinen. Har du denne nøgle gemt, 
kan man ikke logge ind med dit password men kun med din lange og 
kryptiske passphrase.
</para>

<para>
Log ud ved at skrive exit (eller trykke Ctrl-D) for at komme tilbage 
til din egen maskine. Kopier nu din public key fra
din egen maskine (sherwood) til fjern maskinen og gem
den under "~/.ssh/authorized_keys", som ingen andre end
dig skal kunne læse. Denne kopiering laver vi med en ny kommando
"scp" (secure copy).
</para>
<SCREEN>
[robin@sherwood robin]$ cd ~/.ssh
[robin@sherwood .ssh]$ scp identity.pub locksley:authorized_keys
</SCREEN>

<para>
Nu skal du lave den sidste opsætning på locksley. Du laver kataloget
"~/.ssh", hvor du gemmer din offentlige nøgle, og sikrer, at andre ikke
kan læse denne. Dit hjemmekatalog skal andre heller ikke have lov til
at skrive i - denne foranstantning er altid klog, men det er også
nødvendig for at din offentlige nøgle "identity.pub" virker efter, at
den er kopieret til fjernmaskinens "authorized_keys". Det er en
egenskab ved ssh.
</para>


<SCREEN>
[robin@sherwood robin]$ ssh locksley
[robin@locksley robin]$ mkdir ~/.ssh
[robin@locksley robin]$ mv authorized_keys ~/.ssh
[robin@locksley robin]$ chmod go-w ~
[robin@locksley robin]$ chmod -R go-rwx .ssh
[robin@locksley robin]$ exit
</SCREEN>
</sect2>

<sect2 id="krypteret-data">
<title>Krypteret dataoverførsel</title>
<para>
Nu kan du slappe af. Alt er sat op, og du kan uden at skulle
frygte for netværkssikkerheden logge ind på locksley. F.eks. kan du
starte et grafik program såsom "xload" ved at skrive
</para>

<SCREEN>
[robin@sherwood robin]$ ssh locksley xload
Enter passphrase for RSA key 'robin@locksley': V1 hANDLER me spaghett1
</SCREEN>



<para>
Du blev nu mødt af noget nyt igen, idet du skulle skrive din
passphrase og ikke dit password. Bemærk, at i virkeligheden vises din
passphrase naturligvis ikke på skærmen.
xload vil nu køre fra locksley og vises på din egen maskine (sherwood). 
Skal du logge ind på locksley, så skriver du blot "ssh locksley", og skal 
du have udført et program derfra, tilføjer du blot programnavnet til denne
ordre. 
</para>


<para>
Skal du kopiere en fil fra sherwood til locksley, skriver du
</para>

<SCREEN>
[robin@sherwood robin]$ scp LOKALT_FILNAVN locksley:FJERN_FILNAVN
</SCREEN>

<para>
Du har altså ikke en fuld erstatning for ftp, men scp erstatter rcp
(remote copy), som arbejder med samme syntaks.
</para>

<para>
Hvis du ikke frygter, hvem der kan tilgå din egen maskine, kan du
få endnu nemmere adgang til de andre maskiner ved, at du en
gang for alle i den X session, du har igang, giver din passphrase.
</para>

<SCREEN>
[robin@sherwood robin]$ ssh-agent bash
[robin@sherwood robin]$ ssh-add
Need passphrase for /home/robin/.ssh/identity (robin@sherwood).
Enter passphrase:         
</SCREEN>

<para>
Derefter kan du med ssh fra den terminal logge ind og ud af "locksley" 
og andre ssh maskiner uden at skulle bruge passphrase. Vil du
have at alle terminal-vinduer skal kunne dette, skal du rette i din 
"~/.xsessionrc", "~/.xinitrc" eller
lignende, hvor din window manager startes op. Er det f.eks. KDE,
skal du ændre "startkde" til "ssh-agent startkde" og kun en
enkelt gang køre "ssh-add". Derefter kan du slippe for at indtaste din 
passphrase i resten af den X session. Brug "ssh-agent" med omtanke.
</para>

<para>
Anvender du ssh, kan andre med sniffit se, at der laves kommunikation
på port 22, men prøver de at følge netværkstrafikken, kommer der
ikke login navne, passwords, eller efterfølgende kommandoer i klar
tekst - alt er krypteret. Den lille boks i sniffit, som for telnet
viste login sekvensen med passwords osv., vil med ssh være fyldt med en
bunke tilfældige tegn uden sammenhæng - kun ssh selv kan i praksis
afkode kommunikationen. 
</para>

<para>
Lad os vende tilbage til sniffit og se, hvad der med ssh kommer over
netværket under login via ssh. På næste billede kan vi se, at port 22
på locksley modtager tekst, der er krypteret og dermed ikke læseligt
for andre. Igen er det "sniffit -F eth0 -i", som køres. Derefter
har vi valgt at følge den linie fra 192.168.0.1, som kommer
ind via port 22 til 192.168.0.2. I det lille vindue kan du se resultatet
af vilkårlige og almindelige Linux kommandoer - i dette tilfælde "ls
-al /home".
</para>

<FIGURE ID="sniffit3-fig" FLOAT="1">
<TITLE>Sniffit</TITLE>
<GRAPHIC FILEREF="sniffit3.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>  

</sect2>

<sect2 id="epilog2">
<title>Epilog</title>
<para>
Der er mange forskellige smarte features i
ssh, såsom at maskinerne skal acceptere hinandens identitet, brugeres
skal accepteres via en passphrase, og en gang hver time vil maskiner
endda skifte nøgler, så en eventuel ondsindet person, som vil lytte
med skal begynde forfra i dekodning af krypterings-nøgler.
</para>

<para>
Vi skal også nævne, at ssh kan anvendes til at lave VPN løsninger
(Virtual Private network) mellem to lokale netværk, der forbindes via
et usikkert net. Skal man køre revisionssystemer på Linux, kan vi
anbefale CVS, som drager nytte af ssh til at skabe krypteret tilgang
til ens server. Det er kun en environment variabel (sæt $CVS_RSH=ssh), så
kører det. Tilsvarende kan rsync kobles med ssh (sæt $RSYNC_RSH=ssh)
for at lave synkroniseret data mellem flere maskiner, hvor
dataudveksling sker med secure shell.
</para>

<para>
Ud over Linux (UNIX) server og klient programmer, som er
indeholdt i ssh-pakken, så kan du måske også have glæde af klienter
til Windows.  

Med en af disse kan du fra en Windows maskine logge sikkert ind på
din Linux maskine. Du kan på hhv.
<ulink url="ftp://ftp.replay.com/pub/crypto/crypto/SSH/3rd_party/putty">ftp://ftp.replay.com/pub/crypto/crypto/SSH/3rd_party/putty</ulink>,
<ulink url="http://www.mindbright.se/mindterm">http://www.mindbright.se/mindterm</ulink>
og <ulink url="http://guardian.htu.tuwien.ac.at/therapy/ssh/">http://guardian.htu.tuwien.ac.at/therapy/ssh/</ulink>
finde ssh-klienter til Windows - som vi dog ikke kan garantere for.
Der findes også en kommerciel Windows ssh-version, som kan købes fra 
<ulink url="http://www.datafellows.com">http://www.datafellows.com</ulink>.
</para>

<para>
Endelig så skal du vide, at ssh koster ekstra belastning af din CPU,
idet data krypteres og dekrypteres. Performance tabet afhænger af
maskinerne som anvendes. For moderne PC'ere (Pentium 120 Mhz eller
nyere) er det dog ikke mærkbart.
</para>
</sect2>
</sect1>

</chapter>

<chapter id="filcheck">
<title>Har du haft net-indbrud?</title>

<para>
Selvom du er omhyggelig med, hvordan din Linux maskine er konfigureret, 
og du håndterer passwords forsigtigt, er dit system aldrig fuldstændig
sikkert. Et nyt sikkerhedshul i et af de programmer du anvender, kan blive 
opdaget. Et password kan være sluppet ud eller være blevet knækket, 
eller du kan have overset noget i opsætningen af din maskine. Det kan også
være, at du af funktionalitetshensyn har valgt fortsat at benytte en usikker 
service til trods for de sikkerhedsproblemer, det medfører. 
Derfor er det vigtigt, at du holder øje med, om der har været fremmede 
inde på dit system.
</para>

<para>
Lad os nu uden at tænke på hvordan antage, at en dygtig eller heldig
cracker har fået root-adgang til din maskine. Denne cracker
har med andre ord adgang til alt på din maskine, og har måske endda 
installeret nye programmer med hemmelige bagdøre på maskinen, der gør
det nemmere at komme ind næste gang.
</para>

<para>
En person, der trænger ind på andres computere, har ofte et formål 
med det. Det kan være en som vil snuse rundt efter informationer,
eller en som alene skal bruge maskinen til at angribe andres
maskiner. Ofte vil han samtidig forsøge at sløre sit eget spor. 
Der er mange muligheder for adfærd for en cracker, som du skal kunne følge. 
I denne situation er det crackeren, der vælger angrebstidspunkt og metode, 
og du kan i praksis ikke overvåge alt 24 timer i døgnet på maskinen. Men 
ligesom du kan opdage en indbrudstyv i dit hjem, kan du opdage ham på din 
computer ved at lytte efter unormal adfærd og sætte tyverialarmer op, 
som vækker dig ved indbrud. 
</para>

<para>
Det, vi skal se nærmere på i denne artikel, er den interne overvågning
af din maskine. Vi vil se på, hvordan du som systemadministrator
kan finde ud af, at der har været indbrud, og hvordan du kan se hvad 
crackeren har lavet om på maskinen. Vi vil komme ind på de generelle 
forholdsregler, du som systemadministrator kan tage, samt en række værktøjer, 
som kan hjælpe dig. 
</para>

<para>
En cracker kan finde på at installere skadelige programmer på din
computer. Her en stribe fra <ulink url="http://www.userfriendly.org">User Friendly</ulink>
</para>

<FIGURE ID="uf980915-fig" FLOAT="1">
<TITLE>User Friendly</TITLE>
<GRAPHIC FILEREF="uf980915.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>  

<sect1 id="log-filer">
<title>Log-filer</title>

<para>
En Linux maskine gemmer løbende en masse information om, hvad der sker 
på maskinen. Informationen gemmes i log-filer, som kan bl.a. bruges til 
at spore unormal anvendelse.
</para>

<sect2 id="messages">
<title>/var/log/messages</title>

<para>
Den vigtigste log-fil er <FILENAME>/var/log/messages</FILENAME>, hvor mange af de
vigtige systeminformationer gemmes, såsom
</para>

<itemizedlist mark="bullet">
 <listitem><para>hvem der loggede ind på maskinen hvornår</para></listitem>
 <listitem><para>hvem der skiftede identitet med su</para></listitem> 
 <listitem><para>hvornår maskinen blev genstartet</para></listitem>
 <listitem><para>internet opkoblinger med ppp</para></listitem>
 <listitem><para>start og stop af services, såsom NFS</para></listitem>
 <listitem><para>fejl i kernemoduler</para></listitem>
</itemizedlist>

<para>
og meget andet.
</para>

<para>
Lad os se på fire eksempler som alle er brudstykker fra
<FILENAME>/var/log/messages</FILENAME>. Vi ser, at det kræver lidt
øvelse at overskue alt i messages-filen, men modsat er der mange
nyttige informationer om systemets drift. Lad os først se på eksempel
1 nedenfor, som viser de linier, der kommer i messages-filen, når
systemet startes.
</para>

<para>
<emphasis>Eksempel 1 - <FILENAME>/var/log/messages</FILENAME> ved systemstart</emphasis>
<SCREEN>
Jun 30 20:17:45 sherwood syslogd 1.3-3: restart.
Jun 30 20:17:45 sherwood syslog: syslogd startup succeeded
Jun 30 20:17:45 sherwood syslog: klogd startup succeeded
Jun 30 20:17:45 sherwood kernel: klogd 1.3-3, log source = /proc/kmsg started.
Jun 30 20:17:45 sherwood kernel: Inspecting /boot/System.map-2.2.5-15
Jun 30 22:17:16 sherwood rc.sysinit: Loading default keymap succeeded 
Jun 30 22:17:16 sherwood rc.sysinit: Setting default font succeeded 
Jun 30 22:17:16 sherwood swapon: swapon: warning: /dev/hdb1 has insecure permissions 0660, 0600 suggested 
Jun 30 22:17:16 sherwood rc.sysinit: Activating swap partitions succeeded 
Jun 30 22:17:16 sherwood rc.sysinit: Setting hostname sherwood.galaxy.dk succeeded 
Jun 30 22:17:16 sherwood fsck: /dev/hda3: clean, 56029/311296 files, 748112/1242864 blocks 
Jun 30 22:17:16 sherwood rc.sysinit: Checking root filesystem succeeded 
Jun 30 22:17:16 sherwood isapnp: Board 1 has Identity 70 01 00 00 00 01 00 93 05:  ALS0001 Serial No 16777216 [checksum 70] 
Jun 30 22:17:16 sherwood isapnp: ALS0001/16777216[0]{ALS100 Media Audio Controller}: Ports 0x220 0x330; IRQ5 DMA1 DMA5 --- Enabled OK 
Jun 30 22:17:16 sherwood isapnp: /etc/isapnp.conf:293 -- Fatal - resource conflict allocating 8 bytes of IO at 388 (see /etc/isapnp.conf) 
Jun 30 20:17:47 sherwood kernel: Loaded 6721 symbols from /boot/System.map-2.2.5-15.
Jun 30 20:17:47 sherwood kernel: Symbols match kernel version 2.2.5.
Jun 30 20:17:47 sherwood kernel: Loaded 146 symbols from 11 modules.
Jun 30 20:17:47 sherwood kernel: Linux version 2.2.5-15 (root@porky.devel.redhat.com) (gcc version egcs-2.91.66 19990314/Linux (egcs-1.1.2 release)) #1 Mon Apr 19 22:21:09 EDT 1999 
Jun 30 20:17:47 sherwood kernel: Detected 120003903 Hz processor. 
Jun 30 20:17:47 sherwood kernel: Console: colour VGA+ 80x25 
Jun 30 20:17:47 sherwood kernel: Calibrating delay loop... 47.82 BogoMIPS 
Jun 30 20:17:47 sherwood kernel: Memory: 63140k/65536k available (996k kernel code, 412k reserved, 928k data, 60k init) 
Jun 30 20:17:47 sherwood kernel: VFS: Diskquotas version dquot_6.4.0 initialized 
Jun 30 20:17:47 sherwood kernel: CPU: Intel Pentium 75 - 200 stepping 06 
Jun 30 20:17:47 sherwood kernel: Checking 386/387 coupling... OK, FPU using exception 16 error reporting. 
Jun 30 20:17:47 sherwood kernel: Checking 'hlt' instruction... OK. 
</SCREEN>
</para>

<para>
Ud fra den ottende linie kan vi se, at harddisk partitionen
<FILENAME>/dev/hdb1</FILENAME> ikke har fornuftige læse/skriverettigheder. 
Vi kan også se, et ISA lydkort ALS100 bliver
detekteret af isapnp-pakken, men at det ikke er konfigureret
rigtigt. Derefter en del information om selve maskin-typen,
CPU-hastighed (det er fra en Pentium 120 MHz PC). Du bør lige 
checke fra tid til anden, at der ikke
logges fejl, såsom problemet med forkerte læse/skrive rettigheder
eller hardwareproblemer. I øvrigt kan den opmærksomme læser se, at nogle
tidspunkter er kl. 22 og andre 20. Dette skyldes, at nogle dele af
systemet kører med lokaltid og andre med GMT. 
Vi kan også her nævne, at du med kommandoen "dmesg" kan se de
fleste af de systemmeddelelser, som blev vist på skærmen under
systemopstart. Tilsvarende information findes i <FILENAME>/var/log/dmesg</FILENAME>.
</para>

<para>
Eksempel 2 viser hvordan telnet, ftp og SSH logins gemmes i messages-filen. 
Den 3. juli kl. 10.06 kommer brugeren robin ind fra IP nummer 192.168.0.10 
via secure shell (SSH). To minutter efter logges der ud igen. 
Dagen efter er det en telnet login, som går igennem PAM-password check 
(PAM_pwdb).  Kun et minut er robin inde. Endelig er brugeren tuck kommet
ind via ftp (ftpd) den 4. juli og kun blevet fire sekunder.
</para>

<para>
<emphasis>Eksempel 2 - <FILENAME>/var/log/messages</FILENAME> ved remote logins</emphasis>
<SCREEN>
Jul  3 10:06:51 sherwood sshd[763]: log: Connection from 192.168.0.10 port 1023
Jul  3 10:06:57 sherwood sshd[763]: log: RSA authentication for robin accepted.
Jul  3 10:06:57 sherwood sshd[765]: log: executing remote command as user robin
Jul  3 10:08:58 sherwood sshd[763]: log: Closing connection to 192.168.0.10
Jul  4 23:07:07 sherwood PAM_pwdb[24298]: (login) session opened for user robin by (uid=0)
Jul  4 23:08:10 sherwood PAM_pwdb[24298]: (login) session closed for user robin
Jul  4 23:10:28 sherwood ftpd[24757]: FTP LOGIN FROM tuck @ vinglad.sherwood.dk [192.168.0.199], 
Jul  4 23:10:32 sherwood ftpd[24757]: FTP session closed
</SCREEN>
</para>

<para>
Lad os dernæst se på en Internet opkobling via modem (ppp). Vi kan i de
følgende linier fra messages-filen se, at brugeren har koblet op via
"/dev/ppp0". De to linier med identd skyldes secure
shell. Der er lavet en SSH-login til www.sslug.dk under opkoblingen.
De sidste linier viser, at der er sendt 55395 bytes til maskinen
og 80884 bytes fra maskinen under opkoblingen.
</para>

<para>
<emphasis>Eksempel 3 - <FILENAME>/var/log/messages</FILENAME> ved Internet opkobling</emphasis>
<SCREEN>
Aug 18 21:28:35 sherwood ifup-ppp: pppd started for ppp0 on /dev/modem at 115200
Aug 18 21:28:36 sherwood pppd[10800]: pppd 2.3.7 started by root, uid 0
Aug 18 21:29:03 sherwood pppd[10800]: Serial connection established.
Aug 18 21:29:03 sherwood pppd[10800]: Using interface ppp0
Aug 18 21:29:03 sherwood pppd[10800]: Connect: ppp0 <--> /dev/modem
Aug 18 21:29:11 sherwood pppd[10800]: Remote message: Login Succeeded
Aug 18 21:29:12 sherwood pppd[10800]: local  IP address 212.54.78.125
Aug 18 21:29:12 sherwood pppd[10800]: remote IP address 212.54.64.66
Aug 18 21:29:16 sherwood identd[10930]: Connection from www.sslug.dk
Aug 18 21:29:16 sherwood identd[10930]: from: 192.38.71.98 ( www.sslug.dk ) for: 1132, 25
Aug 18 21:35:14 sherwood pppd[10800]: Terminating on signal 15.
Aug 18 21:35:14 sherwood pppd[10800]: Connection terminated.
Aug 18 21:35:14 sherwood pppd[10800]: Connect time 6.2 minutes.
Aug 18 21:35:14 sherwood pppd[10800]: Sent 80884 bytes, received 55395 bytes.
Aug 18 21:35:14 sherwood pppd[10800]: Exit.
</SCREEN>
</para>

<para>
Det sidste eksempel fra messages-filen er et sted, hvor man kan se, at
bruger nummer 500 (robin) skifter bruger-ID over til root for at kunne 
stoppe sendmail. Derefter logges det at su-root sessionen afsluttes.
</para>

<para>
<emphasis>Eksempel 4 - <FILENAME>/var/log/messages</FILENAME> ved su og nedlukning af sendmail</emphasis>
<SCREEN>
jul 26 22:15:04 sherwood PAM_pwdb[4220]: (su) session opened for user root by (uid=500)
jul 26 22:15:25 sherwood sendmail: sendmail shutdown succeeded
jul 26 22:15:41 sherwood PAM_pwdb[4220]: (su) session closed for user root
</SCREEN>
</para>

<para>
<FILENAME>/var/log/messages</FILENAME> kan blive meget stor. Da alle systemhændelser
bliver logget i mellem hinanden, kan det således være svært 
umiddelbart at skelne de interessante beskeder i mængden. 
</para>

</sect2>

<sect2 id="log-rotate">
<title>Rotering af log-filer</title>
<para>
Du kan opleve at finde filer i <FILENAME>/var/log</FILENAME>, der f.eks. hedder
<FILENAME>messages.1</FILENAME> og <FILENAME>messages.2</FILENAME>, eller
<FILENAME>messages.1.gz</FILENAME>.  Dette skyldes, at man på Linux systemer ofte
har et cron-job sat op til at rotere logfilerne, herunder
messages-filen. Dette sker f.eks. en gang i døgnet eller en gang om
ugen. I så fald indeholder <FILENAME>/var/log/messages</FILENAME> kun det nyeste
log-information, som er sket siden sidste rotation.  
</para>
<para>
Under Red Hat styres rotering med af logfiler med logrotate-pakken,
som konfigureres i filen <FILENAME>/etc/logrotate.conf</FILENAME>
</para>
</sect2>

<sect2 id="secure">
<title>/var/log/secure</title>
<para>
Fordi vigtig information så nemt kan drukne i anden information i
messages-filen, findes filen <FILENAME>/var/log/secure</FILENAME>, som kun 
indeholder sikkerhedsrelateret information. Eksempel 5 viser 
<FILENAME>/var/log/secure</FILENAME> filen. Brugerne robin og john logget
ind via terminal tty1 nogle gange, og en telnet og en ftp login findes
i bunden af filen. <FILENAME>/var/log/secure</FILENAME> kan være en meget vigtig
fil at se igennem jævnligt.
</para>

<para>
<emphasis>Eksempel 5 - <FILENAME>/var/log/secure</FILENAME></emphasis>
<SCREEN>
Aug 15 14:45:16 sherwood login: LOGIN ON tty1 BY robin
Aug 16 15:13:53 sherwood login: LOGIN ON tty1 BY john
Aug 16 21:00:55 sherwood login: LOGIN ON tty1 BY robin
Aug 17 11:22:41 sherwood login: LOGIN ON tty1 BY john
Aug 17 17:45:16 sherwood login: LOGIN ON tty1 BY robin
Aug 18 07:11:29 sherwood login: LOGIN ON tty5 BY robin
Aug 18 12:49:56 sherwood login: LOGIN ON tty1 BY john
Aug 18 20:17:07 sherwood login: LOGIN ON tty1 BY robin
Aug 18 23:07:03 sherwood in.telnetd[24297]: connect from 192.168.0.1
Aug 18 23:07:07 sherwood login: LOGIN ON 3 BY robin FROM sherwood
Aug 18 23:10:24 sherwood in.ftpd[24757]: connect from 192.168.0.1
</SCREEN>
</para>
</sect2>

<sect2 id="maillog">
<title>/var/log/maillog</title>
<para>
En anden vigtig fil er <FILENAME>/var/log/maillog</FILENAME>, hvor information om 
email-trafik til og fra maskinen gemmes. Vi kan i eksempel 6 se,
at robin sender en email fra sherwood.galaxy.dk til sslug-teknik@sslug.dk.
Maillog-filen kan nemt blive ekstremt stor og svær at overskue.
</para>

<para>
<emphasis>Eksempel 6 - <FILENAME>/var/log/maillog</FILENAME></emphasis>
<SCREEN>
Jun 18 23:00:42 robin sendmail[1966]: XAA01966: from=&lt;robin@sherwood.dk&gt;, size=496, class=0, pri=30496, nrcpts=1, msgid=&lt;Pine.LNX.4.10.9906182300010.662-100000@sherwood.dk&gt;, proto=ESMTP, relay=robin@localhost
Jun 18 23:00:44 sherwood sendmail[1968]: XAA01966: to=&lt;sslug-teknik@sslug.dk&gt;, delay=00:00:02, xdelay=00:00:02, mailer=esmtp, relay=mail.sslug.dk. [192.38.71.98], stat=Sent (ok 929739581 qp 27375)
</SCREEN>
</para>
</sect2>

<sect2 id="rapportering-log">
<title>Rapporting af log-meddelelser</title>

<para>
I stedet for at læse logfiler direkte kan man installere programmer,
der kan sortere i logfilerne og fremhæve vigtige ting. Vi vil nu se nærmere på
LogWatch, der kan hentes fra 
<ulink url="http://www.kaybee.org/~kirk/html/linux.html">http://www.kaybee.org/~kirk/html/linux.html</ulink>.
</para>

<para>
LogWatch sættes normalt op til at køre en gang i døgnet via Linux
maskinens crontab system. LogWatch skanner alle log-filerne og
sender en samlet rapport til systemadministratoren som en email. I
filen <FILENAME>/etc/log.d/logwatch.conf</FILENAME> er det muligt at konfigurere
LogWatch. Det kan f.eks. anbefales at sætte parameteren "Detail" fra
"Low" til "High", så alle login og "su" hændelser rapporteres. 
</para>

<para>
LogWatch kan f.eks. give følgende email tilbage for en dags trafik
for en maskine, der ikke kører telnet, men som tillader ftp download og
kører SSH. Man kan se, at ftp dæmonen har overført 5MB, og filerne er
vist sammen med navnet på modtagermaskinen. På maskinen har der i
PAM_pwdb (dvs. password håndteringen) været en række skift af
bruger-id. Desuden er alle SSH opkoblinger til maskinen vist, 
derefter cron kørsler og endelig de problemer, som navneserveren har
haft igennem dagen. Let og overskueligt at se igennem. Har man pludselig
logins fra uventede domæner, er det noget, der skal kigges nærmere på.
</para>

<para>
<emphasis>Eksempel 7 - logwatch</emphasis>
</para>

<SCREEN>
 --------------------- ftpd-messages Begin ------------------------ 

Anonymous FTP Logins:
   laptop.etsted.dk (192.168.0.10) : IE40user@ - 4 Time(s)
   dbserver.etandetsted.dk (192.168.0.98) :  mozilla@ - 1 Time(s)
   dbserver.etandetsted.dk (192.168.0.99) :  getright@ - 2 Time(s)

 ---------------------- ftpd-messages End ------------------------- 



 --------------------- ftpd-xferlog Begin ------------------------ 
TOTAL KB OUT: 5339KB (5MB)
TOTAL KB IN: 0KB (0MB)

Outgoing Anonymous FTP Transfers:
   /pub/linuxbog.pdf.gz -> dbserver.etandetsted.dk
   /pub/utils/cvsstat -> 192.168.1.10
   /pub/linuxbog.pdf.gz -> 192.168.10.12
   /pub/videoclips/Linux1601.mpg -> ns.etandetsted.dk
   /pub/utils/cvs2html -> cvs.etandetsted.dk

 ---------------------- ftpd-xferlog End ------------------------- 



 --------------------- Identd Begin ------------------------ 
Identd Lookups:


 ---------------------- Identd End ------------------------- 



 --------------------- PAM_pwdb Begin ------------------------ 

SU Sessions:
      robin(uid=71) -> john - 1 Time(s)
      john(uid=0) -> root - 3 Time(s)
      robin(uid=0) -> root - 5 Time(s)
      sherif(uid=0) -> root - 1 Time(s)
      john(uid=5192) -> charles - 1 Time(s)
      robin(uid=5192) -> charles - 5 Time(s)

Opened Sessions:
   Service: su
      User nobody - 1 Time(s)
      User news - 1 Time(s)

 ---------------------- PAM_pwdb End ------------------------- 



 --------------------- SSHD Begin ------------------------ 

Connections:
   laptop.etsted.dk (192.168.0.10) : 1 Connection(s)
   dbserver.etandetsted.dk (192.168.0.98) : 27 Connection(s)

 ---------------------- SSHD End ------------------------- 



 --------------------- Cron Begin ------------------------ 

Commands Run:
   User root:
      /usr/bin/mrtg /etc/mrtg/mrtg.cfg >/dev/null 2>&1: 288 Time(s)
      /usr/local/bin/daily_backup: 1 Time(s)
      run-parts /etc/cron.daily: 1 Time(s)
      run-parts /etc/cron.hourly: 24 Time(s)


 ---------------------- Cron End ------------------------- 


 --------------------- Named Begin ------------------------ 

**Unmatched Entries**
   Response from unexpected source ([157.151.95.204].53): 1 Time(s)
   bad referral (US !< RESTON.VA.US): 6 Time(s)
   bad referral (US !< SF.CA.US): 6 Time(s)

 ---------------------- Named End ------------------------- 

</SCREEN>


<para>
Et alternativ til LogWatch er logcheck, som kan downloades fra 
<ulink url="http://www.psionic.com/download/">http://www.psionic.com/download/</ulink>.
Ideen er den samme, og virkemåden er umiddelbart også ens. Blot er
formatteringen af log-rapporter ikke sorteret så elegant som
med LogWatch. Prøv begge programmer, og vælg selv dit foretrukne.
</para>


<para>
Problemet med programmer som LogWatch og logcheck er bl.a., at
programmet normalt køres en gang per døgn (dette kan ændres). Ergo kan
et eventuelt indbrud sløres, f.eks. ved at personen blot sletter
linier i log-filerne svarende til egen adfærd. Det eneste alternativ
er nok, at væsentlig log-information skrives til en enhed som kun
accepterer tilføjelser - ikke redigering af data. Nogle bruger
f.eks. en almindelig gammel linie-printer, som udskriver
log-meddelelser straks efter hændelsen.
</para>
</sect2>

<sect2 id="alarmer">
<title>Alarmer</title>

<para>
Du kan lave dine egne hjemmelavede alarmer på dit Linux system.
Har du en maskine med meget få logins, kan det være interessant,
at der afsendes en email til en fast ekstern modtager, hver gang der
laves login på din maskine. Emailen kan f.eks. sendes til en
mobiltelefon eller pager, for at du med det samme kan få at vide, når der er
gæster. Der er mange muligheder for, hvordan dette kan gøres. Den enkle
måde er at tilføje følgende til filerne <FILENAME>/etc/csh.login</FILENAME> og 
<FILENAME>/etc/profile</FILENAME>.
</para>

<SCREEN>
mail < /dev/null > /dev/null -s "login at `date`" robin@sherwood.herne.dk
</SCREEN>

<para>
Derved får "robin@sherwood.herne.dk" en email med tidspunkt for login,
uden at den, der logger ind, kan se det. Personen kan dog bagefter selv
læse <FILENAME>/etc/csh.login</FILENAME> og <FILENAME>/etc/profile</FILENAME> og se, at der er 
lagt en fælde, og evt. vælge at forsvinde. En interessant beskrivelse af 
indbrud, alarmer og fælder kan læses på <ulink url="http://www.ja.net/CERT/Cheswick/berferd.txt">http://www.ja.net/CERT/Cheswick/berferd.txt</ulink>
</para>

<para>
En anden mulighed er at bruge en almindelig brugerkonto på systemet til at 
have et crontab job, der køres hvert minut, og ser hvem der er logget 
ind (via "who") og sender resultatet til din eksterne maskine, 
hvis der er brugere logget ind. Man vælger selv hvordan den type og
niveau af alarm der sættes op, alt efter hvor paranoid man er :-)
</para>

<para>
Man skal dog passe på, at de alarmsystemer, der sættes op, ikke åbner
et nyt sikkerhedshul. Som eksempel kan det være, at du har ændret
kildeteksten til <COMMAND>/bin/login</COMMAND>, så der logges mere
information til f.eks. <FILENAME>/var/log/messages</FILENAME>, men du kom måske
ved et uheld til at få en buffer overflow fejl, som efterfølgende
udnyttes af en ihærdig cracker. Det er heldigvis sådan, at den person,
som bryder ind på din maskine, ikke i forvejen ved, hvor du lægger
fælder, og forhåbentlig ikke har en chance for at vide, hvordan de
virker, før du har opdaget indbruddet.
</para>

<para>
Husk også de følgende tre ting: Backup, backup og backup. Lav jævnligt
backup af din maskine. Har du haft besøg af en ondsindet cracker, kan
du have mistet alt. Sørg også for at have ældre backups. Hvis dit system 
har været inficeret igennem et stykke tid, er dine nyeste backups også
inficerede. En sund strategi er, at have en system backup, som du laver
før systemet sættes i drift - alle ændringer skrives ned, så de kan
geninstalleres fra din sikre backup.  Derudover skal du lave jævnlige
separate backups af dine brugeres data.
</para>
</sect2>

<sect2 id="aendret-filsystem">
<title>Ændringer af filsystemet</title>
<para>
Du bør holde øje med hvilke filer på dit system, der ændrer sig.
Forestil dig, at en person er kommet ind på din maskine og har
haft held til at erstatte <COMMAND>passwd</COMMAND> kommandoen med en ny
binær fil, som dels laver det den skal men samtidig emailer
login-navn og password til supercracker@passwordcracker.net. 
Det er ikke urealistisk svært at lave sådan et program, idet alle har 
adgang til kildeteksten til Linux systemet, og dermed kan lave ændringerne 
uden at behøve at skrive hele programmet forfra. Er crackeren først inde 
på dit system, og har han lavet programændringerne på forhånd, skal han blot 
erstatte de rigtige programmer med de nye. 
Det er normalt de binære filer i <FILENAME>/usr/bin</FILENAME>, 
<FILENAME>/bin</FILENAME>, <FILENAME>/usr/sbin/</FILENAME>, <FILENAME>/usr/X11R6/bin</FILENAME> og 
<FILENAME>/sbin</FILENAME>, man skal passe på, samt biblioteker, som normalt findes 
i <FILENAME>/lib</FILENAME>, <FILENAME>/usr/X11R6/lib</FILENAME> og <FILENAME>/usr/lib</FILENAME>.
</para>

<para>
Generelt leder man efter ændringer af filsystemet ved at checke
fire ting:
</para>

<itemizedlist mark="bullet">
<listitem><para>Om ejerskab/gruppeejerskab er ændret</para></listitem>
<listitem><para>Om filens rettigheder (permissions) er ændret</para></listitem>
<listitem><para>Om filstørrelse er ændret</para></listitem>
<listitem><para>Om indholdet er ændret</para></listitem> 
</itemizedlist>

<para>
Hvis vi kan stole på output af kommandoen "ls", så er de tre første nemme at
undersøge. Man kan f.eks. sammenligne output fra "ls -l FILNAVN" før og
efter ændringer.
</para>

<para>
Det er dog straks sværere at checke, om indholdet af filen er
intakt. For et filsystem med en stor mængde data er det ikke muligt at
have en kopi af hele filsystemet og checke byte for byte, om de er ens. Det
tager for meget diskplads og alt for lang tid. Derfor er en del
matematisk forskning gået på at udtænke metoder til at generere en
funktion, som tager f.eks. indholdet af en fil og ud fra dette
genererer et langt tal, som i princippet skal være unikt. Denne
hash-funktion må således kun give det samme tal for to filer, hvis de er 
helt ens. Dermed kan man kontrollere, om en fil er ændret, blot ved at
generere et tal for filen med hash-funktionen og sammenligne med
det tal, filen gav sidste gang. Giver hash-funktionen 
samme output, antager vi, at filen er urørt.
</para>

<para>
En simpel hashfunktion kunne være summen af alle de tal, som filen
består af. Den er blot alt for nem at forfalske. I litteraturen vil
man ofte støde på CRC checks, som er relativt nemme funktioner at
beregne. Mange komprimeringsprogrammer anvender CRC til at
kontrollere, om det, der pakkes ud, er i orden. Til at opdage ændringer af filer
med tanke på sikkerhed, er CRC checks ikke gode nok. Et hyppigt anvendt 
alternativ er MD5, som genererer en 128 bit kode ud fra en
fil. På de fleste Linux systemer findes programmet <COMMAND>md5sum</COMMAND>, som køres
med et filnavn som argument.
</para>

<SCREEN>
[robin@sherwood robin]$ md5sum /bin/ls
dc2ac9d1c1658d5b4381ca2c280425ee  /bin/ls
</SCREEN>

<para>
Det er meget meget svært at ændre i filen <COMMAND>/bin/ls</COMMAND> og stadig få samme
MD5 checksum. Lad os lave et eksempel med en lille fil, der får
indholdet ændret, men hvor man kan ikke se udefra, at den er ændret.
</para>

<SCREEN>
[robin@sherwood robin]$ echo "robin og tuck" > testfil 
[robin@sherwood robin]$ touch -d 19990719 testfil
[robin@sherwood robin]$ ls -al testfil
-rw-r--r--   1 robin      robin            14 Jul 19 00:00 testfil  

[robin@sherwood robin]$ md5sum testfil 
e829f144f6e43d55daa442baf1462544  testfil   

[robin@sherwood robin]$ echo "tuck og robin" > testfil 
[robin@sherwood robin]$ touch -d 19990719 testfil
[robin@sherwood robin]$ ls -al testfil
-rw-r--r--   1 robin      robin            14 Jul 19 00:00 testfil  

[robin@sherwood robin]$ md5sum testfil 
18b8426e71e781dc68f8f4ee415963cc  testfil   
</SCREEN>

<para>
Vi ser, at filen i de to tilfælde indeholder de samme bogstaver, har
samme længde (14 tegn), har samme datostempel (efter lidt snyd
med touch-kommandoen) - men MD5 checksummen er helt forskellig. Derfor
ved vi, at indholdet ikke det samme. Prøv selv at eksperimentere med dette.
</para>

<para>
Der er andre hash-funktioner end MD5, såsom MD4 og
snefnu. Det er i praksis ikke så vigtigt, om det er den ene eller den
anden eller kombinationer af dem alle, man anvender - de er meget
sikre. En inkarneret matematiker vil naturligvis protestere... men vi
er jo kun ingeniører :-)
</para>


<para>
Vi vil nu omtale fire forskellige programmer til at hjælpe dig med at
lave check af ændringer i filsystemet; RPM, Tripwire, L5 og Aide. 

</para>
</sect2>
</sect1>

<sect1 id="rpm-Va">
<title>rpm -Va</title>

<para>
Med Linux distributionerne SuSE, Caldera Open Linux, Mandrake og
Red Hat følger programmet "rpm", som er et pakkestyringsprogram. 
Rpm holder styr på, hvad der er
installeret. Samtidig er der mulighed for at holde styr på 
ændringer af filerne. Du kan checke alle RPM-styrede filer med
kommandoen "rpm -Va".  Denne kommando vil checke for følgende
ændringer siden installation:
</para>

<itemizedlist mark="bullet">
 <listitem><para>S - Ændringer af filstørrelse</para></listitem>
 <listitem><para>M - Mode - Ændringer i permissions og filtype</para></listitem>
 <listitem><para>5 - MD5 sum check</para></listitem>
 <listitem><para>? - Normalt problemer med at læse filen</para></listitem>
 <listitem><para>L - Symlink</para></listitem>
 <listitem><para>D - Device ændringer</para></listitem>
 <listitem><para>U - User - Ændringer i ejerskab</para></listitem>
 <listitem><para>G - Group - Ændringer i gruppeejerskab</para></listitem>
 <listitem><para>T - Mtime - Modifikationstidspunkt</para></listitem>
 <listitem><para>missing - Hvis en fil er forsvundet</para></listitem>
 <listitem><para>c - Konfigurationsfil.</para></listitem>
 <listitem><para>. - Testen gik fint.</para></listitem>
</itemizedlist>

<para>
Bogstaverne til venstre er dem, der vises på skærmen, når man kører
<command>rpm -Va</command>. Alle de filer, der er ændret i siden
installationen, bliver vist. Hver af de ændrede filer vises efter
formatet "SM5?LDUGT c filnavn", hvor hver af bogstaverne er forklaret
ovenfor. Hvis den enkelte test gik godt, vises et punktum, ellers
vises det bogstav for testen, der gik galt. Et typisk output kan være
(i forkortet form)
</para>

<para>
<emphasis>Eksempel 8 - rpm -Va</emphasis>
</para>

<SCREEN>
..?..... c /etc/securetty
S.5....T c /etc/services
....L...   /usr/local
.M......   /usr/local/bin
.M......   /usr/local/lib
..?.....   /usr/share/afterstep/ascp/help/animate.hlp
..?.....   /usr/share/afterstep/ascp/help/audio.hlp
..?.....   /usr/share/afterstep/ascp/help/autoexec.hlp
..?.....   /usr/share/afterstep/ascp/help/pager.hlp
missing    /usr/share/afterstep/ascp/icons/wharf2.xpm
missing    /usr/share/afterstep/ascp/icons/woptions.xpm
....L... c /etc/localtime
......G.   /etc/aliases.db
S.5....T c /etc/rc.d/init.d/sendmail
S.5....T c /etc/sendmail.cf
S.5....T c /etc/sendmail.cw
..5....T c /etc/sysconfig/sendmail
S.5....T   /var/log/sendmail.st
</SCREEN>

<para>
Nu er det op til dig, som systemadministrator, at vurdere hvilke ændringer,
der er i orden, og hvilke, der kan være farlige. Der vil altid være ændringer, 
siden pakkerne er installeret, men nogle af ændringerne må gerne være der. 
Du ved forhåbentlig nogenlunde, hvad du selv har ændret. Ændringer, du ikke
selv kan huske at have foretaget, kan vurderes ud fra, hvor filerne ligger og
hvilken type filer, det drejer sig om. F.eks. virker filerne i 
<FILENAME>/usr/share/afterstep/</FILENAME> ikke særlig farlige. Det er nok bare noget
konfiguration af Window manageren Afterstep. Tegnet "?" tyder på at 
problemet i skyldes, at brugeren, der har udført kommandoen, ikke har 
rettigheder til at læse <FILENAME>/etc/securetty</FILENAME> og de fire hlp-filer. Vi 
kan se, at dette faktisk er tilfældet 
</para>

<para>
<SCREEN>
[robin@sherwood robin]$ ls -al /etc/securetty
-rw-------  1 root  root  40 Sep 4  1995 /etc/securetty
</SCREEN>
</para>

<para>
Om filerne faktisk er ændrede, kan vi således først se, hvis vi kører
"rpm -Va" som root. Vi kan også se, at der åbenbart mangler to
xpm-filer (billeder) i "/usr/share/afterstep/ascp/icons". 
</para>

<para>
Næste punkt er at kataloget <FILENAME>/usr/local</FILENAME> efter installation
faktisk blev flyttet til en anden partition, så det er fint, at der er
meldt fejl der. Filen <FILENAME>/etc/localtime</FILENAME> er et symbolsk link og en
konfigurationsfil ("L" og det lille "c"). Da Linux blev installeret,
skulle man vælge hvilken tidszone man var i - og så ændrede filen sig 
naturligvis.  Kun ved at se hvor linket peger hen, kan man se, at det nok 
_nu_ er i orden. Bemærk, at linket senere kan ændres til at pege på 
noget andet, måske noget "farligt", men vi vil stadig kun se samme 
fejl-meddelelse.
</para>

<SCREEN>
lrwxrwxrwx  1 root  root  39 May 15 16:27 /etc/localtime -> ../usr/share/zoneinfo/Europe/Copenhagen
</SCREEN>

<para>
Det ses også, at en stribe sendmail filer er blevet ændret. Det passer 
med, hvad jeg som systemadministrator på maskinen ved, at der er lavet - 
men bemærk dog, at der kan være senere ændringer af de samme filer. 
På denne måde kan vi fortsætte. Viden om systemet er med andre
ord nødvendig, men rpm er er godt sted at starte. 
</para>

<para>
Ovenstående gennemgang med "rpm -Va" afslørede et grimt problem. Efter
systeminstallation og systemtilpasning er der allerede sket en del
ændringer.  Man kan måske ikke overskue, hvad der er
farlige ændringer, og hvilke der er banale. Et andet problem er, at "rpm
-Va" ikke kan kontrollere programmer på systemet, der er installeret 
udenom rpm, såsom WordPerfect og StarOffice. Hvad værre er, så kan man
teoretisk tænke sig, at en cracker afinstallerede en pakke, og
installerede en farlig rpm-pakke i stedet for, hvor alle checks med
rpm gik glat. Eller installerede en falsk udgave af selve rpm programmet! 
Derfor er det ønskeligt at få et godt supplement til rpm.
</para>

<para>
Desuden er der Linux distributioner, der ikke bruger rpm, f.eks. Slackware
og Debian.
</para>
</sect1>

<sect1 id="tripwire">
<title>Tripwire</title> 
<para>
Tripwire er et program, der kan checke filsystemet for ændringer.
Der genereres en database for alle filer i filtræet. For hver fil 
gemmes informationer om sidste ændringsdato, indhold (via en checksum), 
og det er nemt at checke og tilsvarende opdatere for ændringer, siden 
databasen er genereret.
</para>

<para>Tripwire kan findes på 
<ulink url="http://www.tripwire.com/downloads/">http://www.tripwire.com/downloads/</ulink>.
</para>

<para>
Tripwire er et godt produkt, men det er ikke Open Source.
Det kan downloades gratis hvis man udfylder en formular med navn, adresse
etc etc. Selv ens telefonnummer forlanger de...
</para>

<para>
Pt hedder det version 2.2.1 for Linux på intel, og skulle virke med de
fleste Linux'er - se på Tripwires webside. Det er en tar.gz fil man
downloader.
</para>
</sect1>

<sect1 id="L5">
<title>L5</title> 
<para>
Programmet L5 er skrevet et par år tilbage som en
neddroslet udgave af Tripwire, og det kan findes på 
<ulink url="ftp://avian.org/src/hacks">ftp://avian.org/src/hacks</ulink>.  L5
giver for hver fil en linie med modes, ejer/gruppe og MD5
checksum. Et eksempel er 
</para>

<SCREEN>
[robin@sherwood robin]$ l5 l5 /bin/login
/bin/login//F 28765 104755 1 0/0 20164 3718bd8a 3a098UjgB8I2B5rzvRJp1N
</SCREEN>

<para>
Giver man et katalog som argument, får man L5 kørt for selve kataloget 
samt alle filer i dette katalog. Den store svaghed ved
L5 er styringen af programmet. Der er ikke hjælp med til at styre 
hvilke filer, der gerne må ændre sig i de kataloger, man vil holde 
øje med. Eksempelvis må filer i <FILENAME>/etc</FILENAME> generelt ikke ændre sig 
ofte, men filen <FILENAME>/etc/mtab</FILENAME> vil for hver reboot
have ændret tidsstempel. Derfor skal <FILENAME>/etc/mtab</FILENAME> og en mere statisk fil
<FILENAME>/etc/resolv.conf</FILENAME> behandles forskelligt.
Programmet L5 er simpelt og hurtigt - men skal du bruge det på din maskine, 
skal du være forberedt på, at du selv skal skrive script-filer til styring
af programmet. Script-filerne skal så holde øje med system filer, der
oftest findes i følgende kataloger:
<FILENAME>/dev</FILENAME>, <FILENAME>/etc</FILENAME>, <FILENAME>/usr/bin</FILENAME>, <FILENAME>/sbin</FILENAME>,
<FILENAME>/bin</FILENAME>, <FILENAME>/lib</FILENAME>, <FILENAME>/usr/lib</FILENAME> og <FILENAME>/usr/src</FILENAME>.
</para>
</sect1>

<sect1 id="Aide">
<title>Aide</title>
<para>
Der er naturligvis folk, som har set problemet i, at Tripwire var et
godt produkt, men at det ikke er holdt ajour med udviklingen. Tilsvarende 
er det et problem, at Tripwire ikke er Open Source Software, så det kunne 
blive holdt ved lige af internettets gode programmører i fællesskab.
</para>

<para>
Et særdeles interessant alternativ til Tripwire er Aide (Advanced
Intrusion Detection Environment), der kan findes på 
<ulink url="http://www.cs.tut.fi/~rammer/aide.html">http://www.cs.tut.fi/~rammer/aide.html</ulink>.
Versionsnummeret på Aide er 0.4, hvilket indikerer, at Aide ikke er
færdigt, og man-siderne skriver også ærligt, at der kan forventes at
være fejl. Aide er dog allerede nu lovende og programmet kan køres
og finde ændringer i filer. Det er tydeligt, at man har set på, hvad
Tripwire kan, og lavet helt tilsvarende funktionalitet.
</para>

<para>
Aide er Open Source (GPL), det vil sige, at den kommer med fuld kildetekst. 
Aide oversættes 
med <COMMAND>./configure</COMMAND> og <COMMAND>make</COMMAND>,
og installeres som root med <COMMAND>make install</COMMAND>.
</para>

<para>
Efter oversættelsen og installationen ligger der en
test-konfigurationsfil i doc-kataloget under det katalog, hvor du
oversatte aide. Du kan med <COMMAND>man aide.conf</COMMAND> se lidt om
syntaksen i konfigurationsfilen. Selv aide-programmet er installeret
under <FILENAME>/usr/local/bin</FILENAME> (medmindre du har ændret i
opsætningen).  For at generere en database over dine filer, skrives
</para>


<SCREEN>
[root@sherwood /root]# aide --init
</SCREEN>

<para>
Hvor databasen kommer til at ligge, afgøres af konfigurationsfilen, ligesom 
den afgør hvilke filer, der skal med i databasen. Ligeledes er de
regler, der afgør hvilke checks, der skal udføres, defineret i aide.conf. 
Som standard leder aide efter konfigurationsfilen i det katalog, hvor
du står, når du kører programmet. Opdatering af databasen sker med
</para>

<SCREEN>
[root@sherwood /root]# aide --update
</SCREEN>

<para>
og check af ændringer med
</para>

<SCREEN>
[root@sherwood /root]# aide --check
</SCREEN>

<para>
Se i øvrigt <COMMAND>man aide</COMMAND>. 
</para>

<para>
Vi ville gerne anbefale dette lovende program, men det er ikke færdigt
endnu, og hvis du bruger det, er det på eget ansvar. Vi tør imidlertid 
godt spå en lysende fremtid for aide og vil opfordre til, at man følger 
med i udviklingen og evt.  bidrager til projektet.
</para>
</sect1>

<sect1 id="skanning-af-filsystem">
<title>Generelt om skanning af filsystemet</title>
<para>
Når du skal checke filsystemet, bør du boote maskinen via
en "sikker" Linux kerne. Det kan være fra en diskette eller CDROM.
Ligeledes bør du bruge en CDROM eller andet read only medie, til at
gemme program og database over filsystem på. Ellers kan 
du ikke checke filtræet mod
tidligere skanninger og være sikker på, at du får de reelle forskelle,
da en cracker så vil kunne ændre i din gemte database, filcheck programmet 
eller i selve Linux kernen.
</para>


<sect2 id="epilog3">
<title>Epilog</title>
<para>
Som afslutning kan vi nævne at der er mange spændende ting på Internet
omkring emnet "Intrusion Detection", som denne artikel omhandler. 
Programmet Gog&amp;Magog 
<ulink url="http://www.multimania.com/cparisel/gog">http://www.multimania.com/cparisel/gog</ulink>
er værd at se på som et gratis alternativ til 
Tripwire, når et netværk af maskiner skal overvåges. Blot er det et problem,  
<ulink url="netvaerk.html">at man skal køre ftp mellem maskinerne</ulink>. 
</para>

<para>
Et andet interessant program er Sbscan, som kan downloades fra
<ulink url="http://sb.n3.net/security/sbscan">http://sb.n3.net/security/sbscan</ulink>.
Programmet er ikke færdigt, men kan allerede en del. Sbscan kører en
tung gennemgang af egen maskine for spor efter indbrud, såsom sniffit
logfiler, eller andre sjove ting, som crackere hyppigt anvender.
</para>

<para>
Men uanset hvor mange fine programmer, du installerer, er det ikke en 
erstatning for at være vågen og kende sit system.
Hold øje med dine log-filer, tag backup, og lad dig aldrig lulle ind i 
en falsk tro på, at dit system er helt sikkert. Det er det ikke.
</para>
</sect2>
</sect1>
</chapter>

<chapter id="Linux-firewalling">
<title>Linux firewalling</title>

<sect1 id="hvad-er-firewall">
<title>Hvad er en Firewall?</title>

<para>
At forbinde sin virksomheds eller sit kollegies lokale computernetværk til 
Internet kan være en risikabel ting at gøre. Ofte er man interesseret i at 
medarbejderene/beboerne får adgang til email og til den store mængde 
information, man kan finde på Internet. 
Men forbinder man uden videre sit lokale netværk til Internet, kan man 
blive man udsat for, at andre kan trænge ind på firmaets eller kollegiets 
interne computere, læse og ændre følsomme data, få servere til at gå i stå osv.
</para>

<para>
Der er flere måder at beskytte sig på. Først og fremmest bør man sætte
hver enkelt computer i netværket op på en sikker måde. Dette er
beskrevet i <ulink url="index.html">tidligere artikler</ulink>. Men man kan
også opnå en slags isolation imellem Internet og lokalnetværket
ved hjælp af en såkaldt firewall.
</para>

<para>
En firewall er det engelske ord for brandvæg eller brandmur. I 
byggebranchen bruges en brandmur til at skille en bygning eller
et område i forskellige sektioner. Skulle der udbryde brand i en 
sektion, vil brandmuren forhindre, at branden breder sig til andre sektioner.
</para>

<para>
I computerverdenen bruges en firewall ligeledes til at opdele et
netværk i sektioner, som er beskyttet imod hinanden. En firewall
spærrer for al trafik imellem de to netværk på hver sin side, undtagen
det den er sat op til at slippe igennem. Eller den kan omvendt slippe
al trafik igennem undtagen det, den er sat op til at spærre for. Begge
dele kan være sikkert, hvis det er sat rigtigt op, og <emphasis>begge
dele kan være usikkert, hvis det er sat forkert op</emphasis>. Man kan
sagtens opdele sit lokale netværk med en række firewalls, men det mest
almindelige er at bruge en firewall til at holde sit lokale netværk
adskilt fra det verdensomspændende Internet.
</para>

<para>
Det er vigtigt at forstå, at en firewall ikke er spor sikker, hvis den
er sat forkert op. Når firewall'en er sat op, bør man grundigt teste, at
den nu også gør, som man forventer. En vigtig del af sikkerheden omkring 
en firewall er desuden, at man logger og overvåger den trafik, der 
passerer igennem den. Hvis man glemmer at holde øje med de 
<ulink url="filcheck.html">log-filer</ulink>, firewall'en genererer, er ens
sikkerhed reelt væk. Man kan så risikere, at man ikke opdager, at der
har været indbrud. En firewall er aldrig helt sikker, og man bør kun
sætte en firewall op, hvis man har i sinde at vedligeholde den. 
</para>

<para>
En forkert opsat firewall eller en firewall, ingen holder øje med,
kan være værre end ingen firewall! Tilstedeværelsen af en firewall
giver let en falsk fornemmelse af tryghed, så man ikke er omhyggelig
nok med at beskytte hver enkelt computer. Det er også meget vigtigt,
at man holder sig ajour med <ulink url="intro.html">nyheder om fejl i den
software</ulink>, der anvendes på firewall'en.
</para>

<para>
Selvom man har sat en firewall op for at beskytte et netværk imod
folk på Internet, bør man stadig være omhyggelig med sikkerheden i det
lokale netværk. For det første kan det være, at nogen bryder igennem
ens firewall, og dermed er der kun lokalnetværkets sikkerhed tilbage. For det
andet beskytter en firewall ikke imod internt misbrug af ens netværk. 
I en virksomhed eller på et kollegie e. lign. kan man ikke altid stole
på de lokale brugere. Nye opgørelser fra IBM peger på, at der ca. er 
ligeså mange interne netværksindbrud som eksterne.
</para>

<para>
Så det er vigtigt at bemærke, at en firewall ikke er en universal
løsning på sikkerhed, som mange tror i dag. Den er god at have, hvis
man er indstillet på at gøre det ordentligt. Men den er ikke en
erstatning for alle de andre sikkerhedsforanstaltninger på et netværk.
</para>

<para>
Man er aldrig helt sikker, selv bag en firewall...
</para>

<FIGURE ID="uf000784-fig" FLOAT="1">
<TITLE>User Friendly</TITLE>
<GRAPHIC FILEREF="uf000784.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>  
</sect1>

<sect1 id="firewall-links">
<title>Links</title>
<para>
I denne artikel henvises der til en række HOWTO's og andre dokumenter rundt 
om i teksten. Her er en hurtig oversigt:
</para>

<para>
HOWTO's:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
    Linux IPCHAINS-HOWTO <ulink url="http://sunsite.auc.dk/ldp/HOWTO/IPCHAINS-HOWTO.html">http://sunsite.auc.dk/ldp/HOWTO/IPCHAINS-HOWTO.html</ulink>
  </para></listitem> 
  <listitem><para>
    Firewall and Proxy Server HOWTO <ulink url="http://sunsite.auc.dk/ldp/HOWTO/Firewall-HOWTO.html">http://sunsite.auc.dk/ldp/HOWTO/Firewall-HOWTO.html</ulink>
  </para></listitem>
  <listitem><para>
    Transparent Proxy with Squid mini-HOWTO <ulink url="http://sunsite.auc.dk/ldp/HOWTO/mini/TransparentProxy.html">http://sunsite.auc.dk/ldp/HOWTO/mini/TransparentProxy.html</ulink>
  </para></listitem>
  <listitem><para>
    Linux 2.4 Packet Filtering HOWTO <ulink url="http://netfilter.kernelnotes.org/unreliable-guides/packet-filtering-HOWTO.html">http://netfilter.kernelnotes.org/unreliable-guides/packet-filtering-HOWTO.html</ulink>
  </para></listitem>
  <listitem><para>
    Linux 2.4 NAT HOWTO <ulink url="http://netfilter.kernelnotes.org/unreliable-guides/NAT-HOWTO.html">http://netfilter.kernelnotes.org/unreliable-guides/NAT-HOWTO.html</ulink>
  </para></listitem>
  <listitem><para>
    (Linux IP Masquerade HOWTO <ulink url="http://sunsite.auc.dk/ldp/HOWTO/IP-Masquerade-HOWTO.html">http://sunsite.auc.dk/ldp/HOWTO/IP-Masquerade-HOWTO.html</ulink>
  </para></listitem>
</itemizedlist>

<para>
Andet:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
    Sikkerhed på Linux <ulink url="http://www.sslug.dk/artikler/Linux_sikkerhed/">http://www.sslug.dk/artikler/Linux_sikkerhed/</ulink>
  </para></listitem>
  <listitem><para>
    TCP/IP Security <ulink url="http://www.cis.ohio-state.edu/~dolske/gradwork/cis694q/">http://www.cis.ohio-state.edu/~dolske/gradwork/cis694q/</ulink>
  </para></listitem>
  <listitem><para>
    Linux - Friheden til at vælge <ulink url="http://www.sslug.dk/linuxbog/bog/">http://www.sslug.dk/linuxbog/bog/</ulink>
  </para></listitem>
  <listitem><para>
    IPChains i Linux 2.2 <ulink url="http://www.sslug.dk/sikkerhed/ipchains.html">http://www.sslug.dk/sikkerhed/ipchains.html</ulink>
  </para></listitem>
  <listitem><para>
    The Netfilter Project HomePage <ulink url="http://netfilter.kernelnotes.org/">http://netfilter.kernelnotes.org/</ulink>
  </para></listitem>
  <listitem><para>
    Squid Web Proxy Cache <ulink url="http://www.squid-cache.org/">http://www.squid-cache.org/</ulink>
  </para></listitem>
</itemizedlist>
</sect1>

<sect1 id="firewall-funktion">
<title>Hvad gør en firewall</title>
<para>
Man kan dele firewalls op i tre typer, der beskytter netværket på hver 
sit niveau:
</para>

<itemizedlist mark="bullet">
  <listitem><para>Pakkefiltrering (packet filtering)</para></listitem>
  <listitem><para>Proxy (kontrol med forbindelser)</para></listitem>
  <listitem><para>SMLI (Stateful Multi-Layer Inspection)</para></listitem>
</itemizedlist>
<para>
De to første typer, vil vi nu se nærmere på.
Den tredie type firewall vil vi ikke beskrive i artiklen.
</para>


<sect2 id="firewall-pakkefiltrering">
<title>Pakkefiltrering</title>
<para>
Data sendes igennem et netværk i form af datapakker. På Internet bruges
IP-pakker. En IP-pakke består af en header med information om, hvor den 
skal hen, hvor den kommer fra, hvad den er for en slags samt nogle data. 
Ved pakkefiltrering kigger man på informationen i headeren og bestemmer, 
hvad der skal ske med pakken: Om den skal afvises eller slippes igennem.
</para>

<para>
Ikke alle IP-pakker skal slippes igennem en firewall. F.eks. bør man 
blokere :
</para>

<itemizedlist mark="bullet">
  <listitem><para>Pakker fra services, der ikke skal bruges. Hvis en server f.eks. ikke
      tilbyder ftp, og der er en bruger, der prøver at oprette en 
       ftp-forbindelse, ved man med det samme, at disse pakker kan afvises.</para></listitem>
  <listitem><para>Pakker med mistænkelige bits sat som IP source routing (kan bruges til
        spoofing). </para></listitem>
  <listitem><para>Pakker, der er til en lokal host, som ikke burde modtage 
      pakker udefra. Det vil sige pakker, som er direkte addreseret til en
      maskine, som ikke har lov til at snakke med fremmede maskiner på
      Internet.</para></listitem>
</itemizedlist>

<para>
Følgende URL kommer mere ind på sikkerhed i TCP/IP og bl.a. IP source
routing:
<ulink url="http://www.cis.ohio-state.edu/~dolske/gradwork/cis694q/">http://www.cis.ohio-state.edu/~dolske/gradwork/cis694q/</ulink>. 

For mere information om IP, TCP og netværk generelt se 
f.eks. "Introduktion til Netværk" af Geir Steen-Olsen &
Arne Stalheim (IDG-bog til 69 kr.).
</para>

<para>
Pakkefiltrering kan sættes op med en router. En router er en enhed, der 
forbinder to eller flere netværk. Dvs at den styrer pakker til og fra et 
eller flere bestemte net. En Linux-PC kan sættes op til at fungere 
som router med pakkefiltrering, men det kan også være en separat, færdig 
boks. Man kan købe færdige routere, der giver mulighed for pakkefiltrering, 
ligesom de automatisk stopper de pakker, der er til adresser, som er 
reserveret til lokale netværk.
</para>

<para>
Det er muligt at <ulink url="services.html">åbne for en række porte</ulink>
i firewall'en, således at det på disse porte er tilladt at oprette
forbindelser. Dette kan bruges til at tillade bestemte protokoller,
som vi ved benytter netop disse porte. Dette giver dog problemer med
en service som http, da den benytter porte vi ikke kender nummeret på
på forhånd. Det kan derfor være nødvendigt at tillade forbindelser på
alle porte, indefra. Udefra bør man som udgangspunkt ikke tillade 
forbindelser med mindre man kører en server - det kan dog være nødvendigt, 
hvis ens brugere skal kunne benytte ftp. Man kan vælge at håndtere
dette problem på connection niveau i stedet for på pakke niveau.
</para>
</sect2>

<sect2 id="kontrol-af-forbindelser">
<title>Kontrol med oprettelse af forbindelser</title>
<para>
Man kan også bruge en firewall til at styre hvilke forbindelser, der må 
oprettes imellem de to adskilte netværk, samt logge, hvad der sker på 
disse forbindelser.

Vil en bruger indefra i kontakt med en server udenfor (f.eks.
surfe på Internet), skal der oprettes en forbindelse fra brugerens
computer til en server på den anden side af firewall'en. Omvendt kan
det også være, at nogen udefra vil i kontakt med en computer inden for
firewall'en. Normalt ønsker vi at tillade, at en bruger indefra
surfer på Internet, men vi ønsker ikke at folk udefra kan oprette
forbindelse til en maskine inden for firewall'en.  Det kan også være, at
vi gerne vil tillade folk udefra en adgang til dele af vores net, f.eks.
web-serveren. 
</para>
</sect2>

<sect2 id="proxy">
<title>Proxy</title>
<para>
En måde at håndtere forbindelserne på, er at sætte en proxy-server
op. Proxy betyder stedfortræder. En proxy er en slags relæ, der
forwarder connection requests fra det lokale netværk til det
eksterne, uden at de kommer i direkte kontakt med hinanden. Den
lokale maskine skal som regel være sat op til at bruge en proxy. Den
opretter en forbindelse til proxy'en, og det er proxy'en, der opretter 
den rigtige forbindelse ud på Internet. Det betyder, at for det 
eksterne netværk ser det ud som om, alle forbindelser fra dit netværk kommer fra
proxy'en, ikke fra de lokale maskiner. Det giver en vis sikkerhed, at
folk udefra ikke får kendskab til de lokale maskiners eksistens, og
ikke får lov at have direkte forbindelse med dem.

Med en proxy kan brugerene have "fri adgang" til Internet igennem de 
tilladte services, typisk http og ftp, uden at det kompromitterer 
sikkerheden på det lokale netværk.
</para>

<para>
At anvende en proxy server har flere fordele. Først og fremmest undgår
man, at maskiner ude på Internet får direkte kontakt med ens interne
maskiner på "indersiden" af proxy'en. Man isolerer sit lokale netværk
fra det udenfor, så der aldrig oprettes en forbindelse igennem
proxy'en. Det er altid proxy'en, der opretter forbindelsen ud, og derfor
kun proxy'en, der er kendt udenfor. Et helt andet aspekt er, at man et
centralt sted får direkte mulighed for at begrænse, hvad der kan
downloades, og administratoren får relativ nem adgang til at overvåge,
hvad der downloades. Her skal man dog være opmærksom på både etiske
regler og registerlovene - det er ikke alt, der må overvåges.
</para>


<para>
Der findes forskellige typer proxy:
</para>

<itemizedlist mark="bullet">
<listitem><para><emphasis>Traditionel proxy</emphasis> 
En traditionel proxy virker sådan, at
den lokale maskine "myhost" henvender i sig til proxy-serveren "myproxy"
for at få en internet forbindelse. Maskinen "myproxy" opretter
forbindelsen og afleverer resultatet, f.eks. en webside, til
"myhost". Maskinen "myhost" opretter kun en forbindelse til "myproxy",
og den maskine, der kontaktes ude på Internet, bliver reelt
kontaktet af "myproxy". Den får ikke kendskab til, at "myhost"
eksisterer. Det besværlige ved en traditionel proxy er, at hvert
Internet-program (netscape, ftp osv.) på "myhost" skal være klar over,
at der benyttes proxy, og kunne håndtere dette.
</para></listitem>

<listitem><para><emphasis>Transparent proxy</emphasis>
Transparent proxy løser problemet, med at programmerne skal være klar over,
at der er en proxy. "Myhost" skal bruge "myproxy" som default gateway. "Myhost"
skal så blot forsøge at oprette en forbindelse direkte til internettet. Når
denne forespørgsel kommer igennem "myproxy", overtager proxy'en opgaven med
at oprette forbindelsen, og maskinen ude på Internet kan stadig kun se
"myproxy". Den lokale maskine tror, den har en forbindelse direkte til
Internet. Når resultatet, f.eks. en webside, kommer til "myproxy", giver den
det blot videre til den ventende forbindelse fra "myhost".
</para></listitem>

<listitem><para><emphasis>Masquerading/NAT</emphasis> Masquerading er <emphasis>ikke</emphasis> proxy, og det
giver ikke den sikkerhed, en proxy gør. Vi har det med her alligevel, fordi
mange bruger det på Linux, og vi gerne vil forklare, hvad det er.
Masquerading er en form for NAT - <emphasis>N</emphasis>etwork <emphasis>A</emphasis>ddress 
<emphasis>T</emphasis>ranslation - som Linux kernen tilbyder, hvor man omskriver
pakkerne, når de kommer igennem masquerading maskinen. For nemheds
skyld kalder vi den stadig "myproxy". Ved masquerading ser det stadig
ud for Internet, som om alting kommer fra "myproxy". Men forbindelsen
til internet er faktisk direkte, bortset fra at pakkerne bliver
omskrevet i "myproxy". "Myproxy" skal igen være default gateway. De
udgående pakker bliver omskrevet med "myproxy" som afsenderadresse i
stedet for "myhost". De indgående pakker er naturligvis adresseret til
"myproxy", men masquerading systemet holder styr på, hvem der er den
rigtige modtager, og når pakkerne kommer forbi, bliver de omskrevet
med "myhost" som modtager.
</para></listitem>
</itemizedlist>
<para>
(Se <ulink url="http://sunsite.auc.dk/ldp/HOWTO/IPCHAINS-HOWTO-3.html">http://sunsite.auc.dk/ldp/HOWTO/IPCHAINS-HOWTO-3.html</ulink>)
</para>
</sect2>
</sect1>

<sect1 id="SMLI">
<title>SMLI</title>
<para>
I dag taler man også om en tredie type firewall, kaldet SMLI - 
<emphasis>S</emphasis>tateful <emphasis>M</emphasis>ulti-<emphasis>L</emphasis>ayer <emphasis>I</emphasis>nspection. 
Denne type firewall kommer vi ikke nærmere ind på i artiklen, 
men det går kort fortalt ud på, at en pakke inspiceres på flere niveauer,
og dermed både implementerer pakkefiltrering og kontrol med forbindelser,
omend på en anden måde end proxy'er gør. 
</para>

<sect2 id="Ftp-problemet">
<title>Ftp-problemet</title>

<para>
Traditionel ftp, også kaldet aktiv ftp, er lidt et problem i forbindelse med 
firewalls, da det laver indgående forbindelser. Ikke alene laver det 
indgående forbindelser, men det er ikke muligt på forhånd at vide hvilken
port, forbindelsen laves på. Det vil sige, at for at tillade sine brugere at
benytte aktiv ftp, er man
nødt til at lade en masse porte stå åbne. Lad os se, hvad der sker,
når man bruger traditionel ftp:
</para>

<SCREEN>
Aktiv ftp 

  Klient                  Server
                     command  data
57726 57724               21   20
  @    @                  @    @
  |    |1__               |    |
  |    |   \__port 57726__|    |
  |    |                  |    |
  |    |              ___2|    |
  |    |____ok__ ____/    |    |
  |    |                  |    |
  |____|_                 |    |
  |    | \_data channel___|___3|
  |    |                  |    |
  |    |                __|____|
  |4___|________ ok___ /  |    |
  |    |                  |    |
  |    |                  |    |

</SCREEN>

<itemizedlist mark="bullet">
<listitem><para>1) Først oprettes en forbindelse fra klienten på en tilfældig port
(57724) til port 21, ftp kommando porten, på serveren. Klienten overfører 
et portnummer, som den vil benytte til dataoverførslen (57726).</para></listitem>
<listitem><para>2) Serveren siger ok</para></listitem>
<listitem><para>3) Serveren opretter en dataforbindelse fra sin ftp dataport - port 20 -
til den angivne port på klienten (57726).</para></listitem>
<listitem><para>4) Klienten siger ok</para></listitem>
</itemizedlist>

<para>
Man kan se, at serveren opretter en forbindelse til klienten på port
57726.  Da man ikke på forhånd kan vide hvilken port, der vil blive
brugt på klienten - ftp-programmet vælger bare en ledig port - er det
nødvendigt at lade et portinterval på klienten stå åbent for ftp
forbindelser, så ftp klienten kan virke.
</para>

<para>
Problemet kan løses med nyere udgaver af ftp,
som kan køre "passiv ftp" i stedet for. Ved passiv ftp er det kun klienten,
der starter forbindelser op. 
</para>

<SCREEN>
Passiv ftp 

  Klient                  Server
                     command      data
57726 57724               21       20
  @    @                  @  58734   @
  |    |1__               |    @    |
  |    |   \_PASV_________|    |    |
  |    |                  |    |    |
  |    |______ok_58734___2|    |    |
  |    |                  |    |    |
  |3___|__                |    |    |
  |    |  \__data_channel_|____|    |
  |    |                  |    |    |
  |____|_______ok_________|___4|    |
  |    |                  |    |    |
  |    |                  |    |    |
  |    |                  |    |    |
  |    |                  |    |    |
</SCREEN>

<itemizedlist mark="bullet">
<listitem><para>1) Først oprettes en forbindelse fra klienten på en tilfældig port
(57724) til port 21, ftp kommando porten, på serveren. Klienten overfører 
en kommando, der fortæller serveren, at der skal bruges passiv ftp.</para></listitem>
<listitem><para>2) Serveren siger ok og fortæller hvilket portnummer, den vil have,
at klienten connecter til.</para></listitem>
<listitem><para>3) Klienten opretter en dataforbindelse fra sin ønskede dataport - her 
port 57726 - til den angivne port på serveren (58734).</para></listitem>
<listitem><para>4) Serveren siger ok</para></listitem>
</itemizedlist>

<para>
Lad os se på, hvad der er vundet. Hvis man vedligeholder en firewall
bag hvilken, der er klienter, der gerne vil downloade via
ftp, er man ved traditionel ftp nødt til at lade et portinterval stå
åbent til indgående forbindelser, som de forskellige ftp-servere, folk
downloader fra, skal oprette. Bruges der derimod passiv ftp, skal man
kun tillade udgående forbindelser - man behøver ikke længere lade et
portinterval stå åbent til de indgående forbindelser fra diverse ftp
servere.
</para>
<para>
Ftp serveren skal til gengæld lade en port stå åben til data, men den 
bestemmer selv hvilken. Den oplysning sender den med over, før 
dataforbindelsen oprettes. Alligevel betragtes det nogle steder som 
et problem på serversiden. Selvom de fleste ftp-programmer - herunder
web-browsere - understøtter passiv ftp, er det derfor ikke alle ftp-servere, 
der understøtter det.
</para>

</sect2>
</sect1>

<sect1 id="Linux-som-firewall">
<title>Linux som Firewall</title>
<para>
De forskellige versioner af Linux kernen bruger forskellige 
pakkefiltreringssystemer. Dette er ikke for at gøre livet besværligt for
os andre, men fordi firewalling er et område, som udvikler sig med stor hast. 
De nyere programmer er mere fleksible, og det er gjort nemmere at sætte sine
firewall regler (policies) op.
</para>

<para> 
I denne artikel er kerne 2.2 i fokus. Vi vil ikke beskæftige os med 
kerne 2.0, men vi vil kaste et blik på næste generation af firewall 
værktøjer til Linux kerne 2.3, som endnu er på et udviklingsstadie,
og som kommer til at hedde 2.4, når den er færdig.</para>

<para>
Desuden vil vi kigge nærmere på proxy opsætning med squid, samt på
IP masquerading i kerne 2.2, og snuse lidt til Network Address Translation 
i kerne 2.3 (2.4).
</para> 
</sect1>


<sect1 id="pakkefiltrering">
<title>Pakkefiltrering</title>

<sect2 id="ipchains">
<title>Ipchains - kerne 2.2</title>
<para>
I kerne 2.2, som er den Linux-kerne, man hovedsagelig anvender i dag, hedder 
firewall værktøjet ipchains. Ipchains er en omskrivning af ipfwadm, som
man anvendte i kerne 2.0. 
</para>

<para>
En mere grundig introduktion til ipchains kan findes i IPCHAINS-HOWTO
<ulink url="http://sunsite.auc.dk/ldp/HOWTO/IPCHAINS-HOWTO.html">http://sunsite.auc.dk/ldp/HOWTO/IPCHAINS-HOWTO.html</ulink>.
</para>
</sect2>

<sect2 id="har-jeg-ipchains">
<title>Er ipchains installeret på min maskine?</title>
<para>
Ipchains er en del af selve Linux kernen. Man skal altså bruge en kerne, 
som ipchains er kompileret ind i. Undersøg om kernen er oversat med 
support for ipchains: 
</para>

<SCREEN>
[root@sherwood /root]# ls /proc/net/ip_fwchains
</SCREEN>

<para>
Hvis filen eksisterer, er ipchains understøttet i den kerne, der er
installeret. Hvis den ikke gør, skal der oversættes
(kompileres) en ny kerne. Vi vil ikke her komme ind på, hvordan man
oversætter en ny kerne. Der findes en del beskrivelser på Internet om
dette, f.eks. <ulink url="http://www.sslug.dk/linuxbog/bog/kernelcompile.html">
http://www.sslug.dk/linuxbog/bog/kernelcompile.html</ulink>. Man skal
under konfiguration af den nye kerne vælge "Network Firewalls" og "IP 
firewalling" under "network options". Hvis maskinen også skal bruge IP
masquerading, så vælg dette med ind i kernen med det samme - se
afsnittet om
<ulink url="#masquerading">Masquerading med ipchains</ulink>.
</para>
</sect2>


<sect2 id="rules">
<title>Opsætning af rules</title>
<para>
Pakkefiltreringen styres af en række rules (regler), som 
systemadministratoren selv sætter op.  Disse regler styrer, hvilke
pakker, der slippes ind og ud, baseret på afsender, modtager og
typeinformation i pakke-headeren.
</para>

<para>
En rule kan f.eks. være:
</para>

<SCREEN>
[root@sherwood /root]# ipchains -A input -s 127.0.0.1 -p icmp -j DENY
</SCREEN>

<para>
som betyder, at ICMP pakker, der kommer fra 127.0.0.1 (loopback
interfacet) skal afvises. Dette er nok ikke en god regel at køre med
til daglig, da det betyder, at man ikke kan pinge sin localhost, men
den er glimrende som eksempel.
</para>

<para>
Vi kommer nærmere ind på de forskellige dele af den ovenstående kommando 
i resten af dette afsnit.
</para>

<para>
<emphasis>Chains</emphasis>
Rules puttes ind i kæder (chains). Pakkerne passerer igennem disse kæder, 
og checkes imod hver rule, der er i kæden. Der er tre indbyggede kæder:
</para>

<itemizedlist mark="bullet">
<listitem><para>

<emphasis>input</emphasis>: Input-kæden bruges på alt, hvad der kommer ind til
maskinen udefra, lige når det kommer ind. Det kan være pakker, der
kommer på netkortet (ethx), modemet (pppx) eller loopback (lo)
interfacet. </para></listitem> 

<listitem><para><emphasis>output</emphasis>: Output-kæden bruges lige
inden, en pakke forlader maskinen.
</para></listitem>

<listitem><para><emphasis>forward</emphasis>: Forward-kæden benyttes
på pakker, der kommer ind, som har en anden maskine som
destination. Dvs. pakker der skal videresendes.</para></listitem>

</itemizedlist>

<para>
I eksemplet ovenfor er det input kæden, vi arbejder med.
</para>

<para>
Chain relaterede options til ipchains:
</para>

<itemizedlist mark="bullet">
<listitem><para>-N Opret ny kæde</para></listitem> 
<listitem><para>-X Slet tom kæde </para></listitem>
<listitem><para>-F Flush (tøm) kæde</para></listitem>
<listitem><para>-L Vis de rules, der er i en kæde</para></listitem>
<listitem><para>-Z Nulstil (zero) pakke- og byte-tællere på alle rules i en kæde</para></listitem>
</itemizedlist>

<para>
Pakke- og byte-tælleren på en rule tæller hvor mange pakker hhv
bytes, der har været forbi, som har "opfyldt" den rule.
</para>

<para>
<emphasis>Private chains</emphasis>:
Ud over de tre indbyggede kæder kan man lave sine egne. Det kan være smart, 
da det bl.a gør ens firewall-regler mere overskuelige.</para>

<para>
Hvis man f.eks. har et system, hvor ppp0 (modemet) er det interface, der er
forbundet til internet, vil man nok gerne sætte en masse firewall-regler op
i input-kæden for ppp0-interfacet. Disse kan samles i en hjemmelavet kæde. 
</para>

<para>
Lad os kalde vores hjemmelavede kæde for
ppp0-rules. Vi sætter så en regel op i input-kæden, der kalder ppp0-rules
kæden, hvis en pakke kommer ind på ppp0. På den måde undgår man dels, at
input-kæden bliver uoverskuelig pga. alt for mange regler, dels opnår man,
at reglerne for ppp0 kun gennemløbes, hvis pakken rent faktisk er kommet 
ind på ppp0.
</para>

<SCREEN>
                  __________
                _|ppp0-rules|__> ppp0 rule 1 __> ppp0 rule 2 ..._
               ^ |__________|                                    |
              _|_____                                            |
             /if ppp0\                                           |
             \__else_/ _    _____________________________________|
               ^        |  |
   ______      |        v  v
__|input |__> rule 1    rule 2 __> rule 3
  |______|  
   ______
__|output|
  |______| 
   _______
__|forward|
  |_______|

</SCREEN>

<para>
En kæde oprettes med kommandoen:
</para>

<SCREEN>
[root@sherwood /root]# ipchains -N ppp0-rules
</SCREEN>

<para>
og kan slettes igen med
</para>

<SCREEN>
[root@sherwood /root]# ipchains -X ppp0-rules.
</SCREEN>

<para>
Man kan kun slette en tom kæde. En kæde kan flushes (tømmes) med en 
"-F" option til ipchains kommandoen. Det betyder, at alle regler i 
kæden slettes.
</para>

<para>
<emphasis>Targets</emphasis>: 
En rule har et target (mål), som fortæller hvad der
skal ske med pakken. Logikken i navnet "target" kan diskuteres, men
sådan hedder det. Pakkens skæbne kan være
</para>

<itemizedlist mark="bullet">
<listitem><para>ACCEPT betyder, at pakken accepteres.</para></listitem> 

<listitem><para>REJECT betyder, at pakken afvises, og at 
afsenderen orienteres om dette.</para></listitem> 

<listitem><para>DENY betyder at pakken afvises, uden at 
afsenderen får det at vide.</para></listitem>  

<listitem><para>MASQ er relateret til masquerading og 
bruges kun i forward kæden. Se om masquerading senere i artiklen
</para></listitem>  
<!-- HUSK -->

<listitem><para>REDIRECT betyder, at pakken sendes til en lokal port i
stedet for at gå videre til destinationsmaskinen. REDIRECT kan kun
bruges i input kæden og kun med pakker til UPD eller TCP
protokollerne.</para></listitem>

<listitem><para>RETURN betyder, at man straks springer
til enden af kæden.</para></listitem> 
</itemizedlist>

<para>
I eksemplet
</para>

<SCREEN>
[root@sherwood /root]# ipchains -A input -s 127.0.0.1 -p icmp -j DENY
</SCREEN>

<para>
er target sat til DENY. Option "-j", som bruges til at definere target,
kan huskes ved at tænke "jump to", 
hvilket måske siger mere om betydningen end "target" gør.
</para>

<para>
<emphasis>Default policy</emphasis> 
er det, der sker, hvis en pakke når enden af en af de tre 
standardkæder uden at være blevet afvist eller accepteret. Default policy 
kan være et af de fire første targets: ACCEPT, REJECT, DENY eller MASQ - 
MASQ bruges dog stadig kun i forward kæden.
</para>

<para>
Default policy for en kæde sættes med en "-P" options til ipchains:
</para>

<SCREEN>
[root@sherwood /root]# ipchains -P input ACCEPT
</SCREEN>

<para>
En rule behøver ikke at have et target. En pakke, som matcher en rule, der
ikke har noget target, går bare videre til næste rule. En rule uden target
kan f.eks. bruges til at tælle antallet af pakker, der opfylder bestemte
kriterier.
</para>

<para>
<emphasis>Rules</emphasis>
Rule relaterede options til ipchains:
</para>
<itemizedlist mark="bullet">
<listitem><para>-A Tilføj (append) rule</para></listitem> 
<listitem><para>-D Slet (delete) rule</para></listitem>
<listitem><para>-R Erstat (replace) rule</para></listitem>
<listitem><para>-I Indsæt (insert) rule</para></listitem>
</itemizedlist>



<para>
Lad os beholde vores rule-eksempel fra ovenfor.
</para>

<SCREEN>
[root@sherwood /root]# ipchains -A input -s 127.0.0.1 -p icmp -j DENY
</SCREEN>

<para>
"-A" betyder at vi tilføjer en rule (append). 
</para>

<para>
En regel kan indeholde forskellige betingelser, som gør, at pakkerne matcher
eller ikke matcher.
</para>

<para>
<emphasis>Betingelser</emphasis>
</para>

<itemizedlist mark="bullet">
<listitem><para>-p Protokol</para></listitem>
<listitem><para>-s Source IP adresse</para></listitem>
<listitem><para>-d Destination IP adresse</para></listitem>
<listitem><para>-i Interface</para></listitem>
<listitem><para>-y SYN pakker (kun TCP)</para></listitem>
<listitem><para>-f Fragmenter af en pakke</para></listitem>
</itemizedlist>

<para>Desuden kan der ved TCP eller UPD specificeres en port eller et
port interval efter source eller destination IP adresse. Ved ICMP kan
der specificeres en ICMP type og kode efter source eller destination
adressen. 
</para>

<para>
En oversigt over protokollerne findes i
<FILENAME>/etc/protocols</FILENAME>. ICMP typerne kan ses med kommandoen
</para>

<SCREEN>
[root@sherwood /root]# ipchains -h icmp | more
</SCREEN>

<para>
Lad os prøve at lave nogle rules i praksis. Vi ser igen på vores eksempel 
fra tidligere:
</para>

<SCREEN>
[root@sherwood /root]# ipchains -A input -s 127.0.0.1 -p icmp -j DENY 
</SCREEN>

<para>
Den betyder, at der ikke må komme ICMP pakker ind på lo (loopback interfacet), 
og derfor kan man ikke kan pinge sin localhost:
</para>

<SCREEN>
[root@sherwood /root]# ping -c 1 localhost
PING localhost (127.0.0.1): 56 data bytes 
</SCREEN>

<para>
Før eller siden vil man få timeout på sin ping kommando. For at fjerne
den nye rule igen skrives
</para>

<SCREEN>
[root@sherwood /root]# ipchains -D input -s 127.0.0.1 -p icmp -j DENY
</SCREEN>

<para>
og prøv at pinge localhost igen:
</para>

<SCREEN>
[root@sherwood /root]# ping -c 1 localhost
PING localhost (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=0.1 ms

--- localhost ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 0.1/0.1/0.1 ms
</SCREEN>

<para>
En rule kan også fjernes ved blot at angive dens nummer i stedet for hele i
dens indhold. Da vores rule fra før havde nummer 1, kunne den være fjernet med
</para>

<SCREEN>
[root@sherwood /root]# ipchains -D input 1
</SCREEN> 

<para>
Rules får nummer i den rækkefølge, man laver dem: Næste rule vi laver, får
nummer 2. 
</para>

<SCREEN>
[root@sherwood /root]# ipchains -A input -s 127.0.0.1 -p icmp -j DENY 
[root@sherwood /root]# ipchains -A input -s 192.168.1.1
</SCREEN>

<para>
Den første kommando danner rule nummer et, den næste rule nummer 2. Slettes 
nummer et, rykker nummer 2 frem og bliver nummer 1.
</para>

<para>
Man kan dog indsætte rules inde i en kæde med -I optionen.
Dette gøres ved at angive det ønskede rule nummer:
</para>

<SCREEN>
[root@sherwood /root]# ipchains -A input -s 127.0.0.1 -p icmp -j DENY 
[root@sherwood /root]# ipchains -I input 1 -s 192.168.1.1
</SCREEN>

<para>
Her vil den sidste rule blive nummer 1, pga -I optionen og ettallet, i
der er angivet efter kædenavnet (input).
</para>
</sect2>

<sect2 id="eksempel-hjemmebruger">
<title>Eksempel:  hjemmebruger</title>
<para>
Nu har vi lært lidt om at oprette og slette rules. Lad os kigge på hvilken
opsætning af kæder og regler, man kunne ønske sig i virkeligheden.
</para>

<para>
Det eksempel, vi skal se på, er en hjemmebruger, der har en eller
flere computere og en opkobling til Internet. Vores hjemmebruger
kører sin egen webserver. Han kører også en auth server til validering 
af hvilken bruger, der kører en bestemt service. 
</para>

<para>
Desuden bruger han en
række klienter, der kræver forbindelser (connections): ftp, DNS og Real Audio. 
</para>

<para>
Figuren viser et netværk der består af to computere, en på det lokale
LAN og en, der skal fungere som firewall. Der kunne selvfølgelig godt være
mange flere maskiner indenfor firewall'en. Men selvom man kun har én
computer, kan det godt give mening at installere ipchains på den
alligevel, for at sortere i, hvilke pakker der skal slippe igennem
til maskinens egne lokale services.
</para>

<SCREEN>
   ________            __________            __________
  |        |eth0      |          |ppp0      |          |
  | myhost |----------| firewall |----------| Internet |
  |________|      eth0|__________|          |__________|
</SCREEN>

<para>

Først skal vi sætte vores default policy op. I input og output kæden kan 
man vælge ACCEPT, DENY eller REJECT. Vælger man ACCEPT, skal man sætte
rules op for at spærre for alt det, der ikke må komme igennem. Vælger man
DENY eller REJECT, skal man sætte rules op for alt det, der gerne må komme
igennem. Det er nemt at regne ud, at det sidste er det mest sikre. Især på
input kæden kan det frarådes at køre ACCEPT som default policy, med mindre
man er helt sikker på, at man ved, hvad man gør, eller sikkerheden ikke er så
vigtig i det pågældende netværk I forward kæden kan man desuden vælge MASQ, 
dette kommer vi ind på i afsnittet om
masquerading.
</para>

<!-- HUSK -->

<para>
Vores hjemmebruger bag firewall'en ønsker adgang til Internet
igennem firewall'en. Derimod vil han gerne skærme sit lokale netværk
imod de indgående forbindelser fra fremmede maskiner.
</para>

<para>
Først sætter vi "default policies" op.
</para>

<SCREEN>
ipchains -P input DENY
ipchains -P output ACCEPT
ipchains -P forward DENY
</SCREEN>
</sect2>

<sect2 id="eksempel-for-vores-hjemmebruger">
<title>Rules for vores hjemmebruger</title>
<para>
Tillad alt på loopback interfacet
</para>

<SCREEN>
ipchains -A input -p all -j ACCEPT -i lo
</SCREEN>

<para>
Tillad alt på LAN
</para>

<SCREEN>
ipchains -A input -p all -j ACCEPT -i eth0
</SCREEN>

<para>
Nu er der kun indgående trafik fra Internet (ppp0) tilbage.  Vi
starter med TCP pakker. Tillad alt, hvad der <emphasis>ikke</emphasis>
forsøger at oprette en forbindelse, det vil sige alt, hvad der ikke
har SYN bitten sat:
</para>

<SCREEN>
ipchains -A input -p tcp -j ACCEPT \! -y
</SCREEN>

<para>
Tillad forbindelser til vores http, https og auth server:
</para>

<SCREEN>
ipchains -A input -p tcp -j ACCEPT -s 0/0 -d 0/0 http -y
ipchains -A input -p tcp -j ACCEPT -s 0/0 -d 0/0 https -y
ipchains -A input -p tcp -j ACCEPT -s 0/0 -d 0/0 auth -y
</SCREEN>

<para>
Tillad ftp dataforbindelser (når vores hjemmebruger vil lave ftp
downloads og ftp dir kommandoer på ftp-servere ude i verden)
</para>

<SCREEN>
ipchains -A input -p tcp -j ACCEPT -s 0/0 ftp-data -d 0/0 56000:65096 -y
</SCREEN>

<para>
UDP pakker: Tillad DNS replies:
</para>

<SCREEN>
ipchains -A input -p udp -j ACCEPT -s 0/0 domain -d 0/0 56000:65096
</SCREEN>

<para>
Tillad Real Audio / Real video i bedste kvalitet:
</para>

<SCREEN>
ipchains -A input -p udp -j ACCEPT -d 0/0 32768:37769
</SCREEN>

<para>
ICMP
</para>

<para>
Tillad ikke redirect (kan principielt bruges til at manipulere
routing)
</para>

<SCREEN>
ipchains -A input -p icmp -s 0/0 redirect -j DENY --log
ipchains -A input -p icmp -s 0/0 timestamp-request -j DENY --log
ipchains -A input -p icmp -s 0/0 address-mask-request -j DENY --log
ipchains -A input -p icmp -j ACCEPT
</SCREEN>

<para>
Log resten
</para>

<SCREEN>
ipchains -A input --log
</SCREEN>


<para>
Alt, hvad der kommer på inputkæden, og som ikke er blevet accepteret af 
en af de andre regler, matcher denne sidste regel. Reglen gør, at der
logges information om disse pakker i kerne-logfilen (ofte
<FILENAME>/var/log/messages</FILENAME>).
</para>

<para>
En log entry kan f.eks. se sådan ud:
</para>

<SCREEN>
input - ppp0 PROTO=17 4.3.2.1:4000 1.2.3.4:1872 L=53 S=0x00      
I=60456 F=4000 T=240 (#14)
</SCREEN>

<para>
hvor <emphasis>1.2.3.4</emphasis> er vores hjemmebrugers egen
ip-adresse på ppp0. Man kan se, at det er kommet ind på
<emphasis>input</emphasis>kæden, interface <emphasis>ppp0</emphasis>.
<emphasis>PROTO=17</emphasis> betyder, at det er udp (se
<FILENAME>/etc/protocols</FILENAME>).
</para>

<para>
<emphasis>4.3.2.1:4000</emphasis> er afsender-adressen, port
4000. Pakken er forsøgt sendt til port <emphasis>1872</emphasis> hos
vores bruger. <emphasis>L=53</emphasis> betyder, at pakken var 53
bytes lang. <emphasis>S</emphasis> betyder type of
service. <emphasis>I</emphasis> betyder IP ID, <emphasis>F</emphasis>
betyder fragment offset, og <emphasis>T</emphasis> betyder Time to
live. <emphasis>#14</emphasis> betyder, at det var vores rule nummer
14, der loggede pakken. Se
<ulink url="http://sunsite.auc.dk/ldp/HOWTO/IPCHAINS-HOWTO.html">
ipchains HOWTO'en</ulink> for yderligere detaljer.
</para>

<para>
Hvis ftp ikke virker med det angivne portinterval (56000:65096), er det fordi,
maskinen er sat op til at bruge nogle andre porte til at oprette 
forbindelser på. Det kan systemadministratoren selv sætte med kommandoen
</para>

<SCREEN>
echo "56000 60999" >/proc/sys/net/ipv4/ip_local_port_range
</SCREEN>

<para>
Se i øvrigt et glimerende eksempel på ipchains opsætning på
<ulink url="http://www.sslug.dk/sikkerhed/ipchains.html">http://www.sslug.dk/sikkerhed/ipchains.html</ulink>
</para>
</sect2>

<sect2 id="aktivere-rules">
<title>At aktivere sine rules ved opstart</title>

<para>
Ipchains styres af en række rules. Selve pakkefiltreringen
sker i kernen, så det eneste, man skal gøre, er, at fortælle kernen om sine
ipchain rules.
</para>

<para>
Da rules gemmes i kernen, går de imidlertid tabt ved reboot. Derfor er
det en god ide at gemme dem i en fil. Man kan så lave et startup
script, som læser filen og sætter kernen op til at bruge de rules ved
genstart af maskinen. Ipchains rules gemmes i en fil med følgende
kommando:
</para>

<SCREEN>
[root@sherwood root]# ipchains-save > /etc/ipchains.rules
</SCREEN>

<para>
Det følgende startup script kan hvert fald bruges med Red Hat, SuSE og
Debian:
</para>

<SCREEN>
#!/bin/sh
#ipchains startup script
#To be run before starting network on startup
#and to be shut down after network on shutdown 

# If no rules, do nothing.
[ -f /etc/ipchains.rules ] || exit 0

case "$1" in
    start)
        echo -n "Turning on packet filtering:"
        /sbin/ipchains-restore &lt; /etc/ipchains.rules || exit 1
        echo 1 &gt; /proc/sys/net/ipv4/ip_forward
        echo "."
        ;;
    stop)
        echo -n "Turning off packet filtering:"
        echo 0 &gt; /proc/sys/net/ipv4/ip_forward
        /sbin/ipchains -X
        /sbin/ipchains -F
        /sbin/ipchains -P input ACCEPT
        /sbin/ipchains -P output ACCEPT
        /sbin/ipchains -P forward ACCEPT
        echo "."
        ;;
    *)                        
        echo "Usage: /etc/init.d/packetfilter {start|stop}"
        exit 1
        ;;
esac                
</SCREEN>

<para>

Lav et symlink til det i <FILENAME>/etc/rc.d/rc</FILENAME><emphasis>N</emphasis><FILENAME>.d</FILENAME> (N=runlevel) 
directory'erne (Red Hat) eller 
<FILENAME>/etcrc</FILENAME><emphasis>N</emphasis><FILENAME>.d</FILENAME>
(Debian/SuSE), så det bliver startet op før
netværket. Hvis netværket f.eks. startes op med et symlink, der hedder
<FILENAME>S10network</FILENAME>, skal ipchains symlinket hedde et lavere
tal. F.eks. <FILENAME>S9ipchainsrules</FILENAME>.  Så er ipchains altid kørende før
netværket startes op. Ligeledes bør netværket lukkes ned før ipchains
lukkes ned. Selvom der er grænser for, hvor meget skade en cracker kan
nå at gøre på systemet, før det når at lukke ned.  Det skal specielt
bemærkes, at hvis man med det viste script anvender stop-kommandoen,
efterlader man sit system i en særdeles usikker tilstand med alt
nettraffik tilladt. Lad være med at gøre det, mens systemet er i
drift. Man lukker simpelthen ned for firewall'en.
</para>

<para>
Se i øvrigt en udemærket HOWTO på <ulink url="http://sunsite.auc.dk/ldp/HOWTO/IPCHAINS-HOWTO.html">http://sunsite.auc.dk/ldp/HOWTO/IPCHAINS-HOWTO.html</ulink>.
</para>
</sect2>

<sect2 id="netfilter">
<title>Iptables (Netfilter) - kerne 2.3 (2.4)</title>
<para>
Kerne 2.3-serien er en ustabil udviklingsgren af Linux-kernen, som
forhåbentlig snart bliver til kerne 2.4, den næste stabile
kerne-serie.  Vi vil ikke gå så meget i dybden med kerne 2.3 her, da
vi antager, at denne artikels primære målgruppe ikke bruger en
udviklingskerne, og da tingene kan nå at være lavet om igen, inden den
endelige 2.4 kerne frigives. Afsnittene om kerne 2.3 skal derfor blot
forstås som en forsmag på, hvad der venter i næste version. Vi vil
ikke komme med eksempler på opsætning af iptables.
</para>

<para>
I kerne 2.3 (2.4) er firewalling systemet igen lavet om.  Kommandoen,
der før hed ipchains, hedder nu iptables.  Systemet består af to dele:
Pakkefiltrering og NAT (<emphasis>N</emphasis>etwork
<emphasis>A</emphasis>ddress <emphasis>T</emphasis>ranslation).  NAT,
som er lidt mere avanceret end masquerading, vender vi tilbage til
<ulink url="#nat">i et senere afsnit</ulink>.  Hele systemet hedder
netfilter, og er grundlæggende et framework i kernen, som iptables
bygger på.
</para>

<para>
Der er nogle grundlæggende ændringer i designet, men kommandoerne og
navnene ligner næsten sig selv fra ipchains. Man skal dog ikke lade sig
narre - iptables kan meget mere.
</para>
</sect2>

<sect2 id="hvad-skal-jeg-bruge">
<title>Hvad skal jeg bruge?</title>
<para>
For at komme igang med netfilter skal man bruge en 2.3 kerne med netfilter
kompileret ind samt user space værktøjet iptables. Iptables kan downloades
fra Netfilter hjemmesiden: <ulink url="http://netfilter.kernelnotes.org/">http://netfilter.kernelnotes.org/</ulink> .
</para>

<para>
Kommer man fra ipchains er det ikke svært at følge med i kommandoerne til 
iptables - der er dog ændringer.
</para>
</sect2>

<sect2 id="chains">
<title>Chains</title>
<para>
Ligesom i ipchains er der i iptables 3 indbyggede kæder: INPUT, OUTPUT
og FORWARD. Chain relaterede options til iptables er uændret fra ipchains
</para>

<sect3 id="targets">
<title>Targets</title>
<para>Der er lavet lidt om i targets: </para>
<itemizedlist mark="bullet">
<listitem><para>DROP betyder, at pakken smides væk</para></listitem>
<listitem><para>ACCEPT betyder, at pakken accepteres</para></listitem>
<listitem><para>RETURN betyder, "gå til anden af kæden"</para></listitem>
<listitem><para>QUEUE betyder, at pakken skal sættes i kø til user mode processering</para></listitem>
</itemizedlist>

<para>
Når vi sammenligner med ipchains, kan vi se, at REJECT er forsvundet.
Den findes dog som modul (extension):
</para>

<itemizedlist mark="bullet">
<listitem><para>REJECT</para></listitem>
<listitem><para>LOG</para></listitem>
</itemizedlist>

<para>
er de to extensions, der standard følger med iptables. Det er muligt at skrive
sine egne extension og derved lave andre "targets".
</para>

<para>
Desuden er MASQ og REDIRECT forsvundet - de hører til NAT, og deres
funktionalitet er kommet over i NAT delen af iptables 
(se <ulink url="#nat">afsnittet om
Network Address Translation med iptables</ulink>).
</para>
</sect3>

<sect3 id="default-policy">
<title>Default policy</title>
<para>
Default policy er som i ipchains
</para>

<sect4 id="chains-rules">
<title>Rules</title>
<para>
Rule relaterede options til iptables er som i ipchains
</para>
</sect4>

<sect4 id="betingelser">
<title>Betingelser</title>
<para>
En regel kan indeholde forskellige betingelser, som gør, at pakkerne matcher
eller ikke matcher.
</para>

<para>
<emphasis>Betingelser</emphasis>
</para>

<itemizedlist mark="bullet">
<listitem><para>-p Protokol</para></listitem>
<listitem><para>-s Source IP adresse</para></listitem>
<listitem><para>-d Destination IP adresse</para></listitem>
<listitem><para>-i Input interface</para></listitem>
<listitem><para>-o Output interface</para></listitem>
<listitem><para>-f Fragmenter af en pakke</para></listitem>
</itemizedlist>

<para>
Vi ser at <emphasis>-i</emphasis> nu ikke betyder interface, men input
interface, og <emphasis>-o</emphasis> er kommet til for output
interface.  Desuden er <emphasis>-y</emphasis> (SYN) forsvundet, men
bare rolig, den kommer om lidt.
</para>

<para>
Ud over standardbetingelserne er der en del protokolspecifikke udvidelser:
</para>

<para>
<emphasis>TCP</emphasis>
</para>

<itemizedlist mark="bullet">
<listitem><para>--tcp-flags (SYN,ACK,FIN,RST,URG,PSH)</para></listitem>
<listitem><para>--syn (SYN,RST,ACK SYN)</para></listitem>
<listitem><para>--source-port </para></listitem>
<listitem><para>--destination-port </para></listitem>
<listitem><para>--tcp-option </para></listitem>
</itemizedlist>

<para>
<emphasis>UDP</emphasis>
</para>

<itemizedlist mark="bullet">
<listitem><para>--source-port </para></listitem>
<listitem><para>--destination-port </para></listitem>
</itemizedlist>

<para>
<emphasis>ICMP</emphasis>
</para>

<itemizedlist mark="bullet">
<listitem><para>--icmp-type</para></listitem>
</itemizedlist>

<para>
Desuden er der skrevet en række extensions, som følger med iptables:
</para>

<para>
<emphasis>Andre extensions</emphasis>
</para>

<itemizedlist mark="bullet">
<listitem><para>mac</para></listitem>
<listitem>
  <itemizedlist mark="bullet">
  <listitem><para>--mac-source</para></listitem>
  </itemizedlist>
</listitem>
<listitem><para>limit</para>
  <itemizedlist mark="bullet">
  <listitem><para>--limit</para></listitem>
  <listitem><para>--limit-burst</para></listitem>
  </itemizedlist>
</listitem>
<listitem><para>owner</para>
  <itemizedlist mark="bullet">
  <listitem><para>--uid-owner userid</para></listitem>
  <listitem><para>--uid-owner groupid</para></listitem>
  <listitem><para>--pid-owner processid</para></listitem>
  <listitem><para>--sid-owner processid</para></listitem>
  </itemizedlist>
</listitem>
<listitem><para>unclean</para></listitem>
<listitem><para>state</para></listitem>
<listitem>
  <itemizedlist mark="bullet">
  <listitem><para>NEW</para></listitem>
  <listitem><para>ESTABLISHED</para></listitem>
  <listitem><para>RELATED</para></listitem>
  <listitem><para>INVALID</para></listitem>
  </itemizedlist>
</listitem>
</itemizedlist>

<para>Extension modulerne loades med <emphasis>-m</emphasis>, f.eks.</para>
<SCREEN># iptables -A INPUT -m mac --mac-source 192.168.0.1</SCREEN>
<para>Det er også muligt at skrive extensions selv.</para>

</sect4>
</sect3>
</sect2>

<sect2 id="state">
<title>State</title>
<para>
State er værd at kigge lidt nærmere på, da det bruges til at checke 
på connection tracking. Det vil sige, at man kan sortere på, om en pakke er en 
del af en eksisterende forbindelse (ESTABLISHED), om den vil etablere en ny 
forbindelse (NEW), om den er relateret til en eksisterende forbindelse, 
f.eks. en ICMP fejl (RELATED), eller om den ikke kan genkendes (INVALID).
</para>

<para>
BEMÆRK: iptable er på udviklingsstadiet endnu, og man kan altså ikke
regne med, at det er stabilt.
</para>

<para>
For mere information om iptables og netfilter anbefaler vi at læse 
Linux 2.4 Packet Filtering HOWTO:
<ulink url="http://netfilter.kernelnotes.org/unreliable-guides/packet-filtering-HOWTO.html">http://netfilter.kernelnotes.org/unreliable-guides/packet-filtering-HOWTO.html</ulink>
</para>
</sect2>
</sect1>

<sect1 id="proxy-server">
<title>Linux som proxy server</title>

<itemizedlist mark="bullet">
<listitem><para>Squid</para></listitem>
<listitem><para>Masquerading med ipchains</para></listitem>
<listitem><para>Network Address Translation med iptables (Netfilter)
i kerne 2.3 (2.4)</para></listitem>
</itemizedlist>

<sect2 id="proxy-squid">
<title>Proxy med Squid</title>

<para>
Squid er en god proxy server bl.a. til Linux, der kan findes på 
<ulink url="http://www.squid-cache.org/">http://www.squid-cache.org/</ulink>. Squid
er en agent, der downloader de hjemmesider, brugeren beder om, og
videresender resultatet til brugeren. Samtidig kan Squid fungere som
proxy-cache - den gemmer hjemmesiden i cache, og er der nu en anden
bruger, der vil se den samme hjemmeside, hentes den direkte fra den
lokale hukommelses- eller disk-cache på proxy-maskinen - det vil sige,
uden at man skal via Internet. Squid tester, om en hjemmeside på
nettet er nyere end den i cachen, og kun hvis cachen er forældet, vil
en ny version blive hentet. Fordelen ved en proxy-cache er således, at
man ofte kan spare måske 50% på båndbredden.
</para>

<para>
Det er naturligvis ikke alt, som kan gemmes i en cache, f.eks.
fungerer skal cgi-kald netop ikke køre fra cache. Disse hindringer
håndterer Squid dog transparent. Ud over hjemmesider (HTTP) er FTP,
GOPHER, SSL og WAIS protokollen understøttet. Squid kan dog ikke klare
POP-mail, NNTP (News grupper) og RealAudio.
</para>
</sect2>

<sect2 id="installation-squid">
<title>Installation af Squid-serveren</title>
<para>
Man bør ikke installere Squid, så den kører som root. Ofte vælger man
at lade Squid køre som brugeren <COMMAND>squid</COMMAND> i sin egen gruppe
<COMMAND>squid</COMMAND>, og kun med få rettigheder.
</para>

<para>
Vi har installeret <FILENAME>squid-2.2.STABLE5-1.i386.rpm</FILENAME>,
som kan downloades fra <ulink
url="http://www.squid-cache.org/">http://www.squid-cache.org/</ulink>. Squid
startes op via <FILENAME>/etc/rc.d/init.d/squid</FILENAME>. Squids
opsætningsfil hedder <FILENAME>/etc/squid/squid.conf</FILENAME>. Der er
<emphasis>mange</emphasis> konfigurationsmuligheder. Basalt set skal
man fjerne kommentartegnene fra nogle linier i
<FILENAME>/etc/squid/squid.conf</FILENAME> og udkommentere andre, og
så starte Squid.  Den originale
<FILENAME>/etc/squid/squid.conf</FILENAME> er stor, og vi vil nu se
nærmere på en simpel opsætning af squid.
</para>

<sect3 id="basal-squid-conf">
<title>Basal opsætning af squid.conf</title>
<para>
Man kan i <FILENAME>/usr/doc/squid-2.2.STABLE5/QUICKSTART</FILENAME>
finde en minimal beskrivelse af parametre for
<FILENAME>squid.conf</FILENAME>. En meget bedre gennemgang fås ved at
læse brugermanualen til Squid, som kan findes på 
<ulink url="http://www.squid-cache.org/Doc/Users-Guide/">http://www.squid-cache.org/Doc/Users-Guide/</ulink>.
En anden god start er også at læse (og gemme) den originale
<FILENAME>/etc/squid/squid.conf</FILENAME>, som fulgte med RPM-pakken.
</para>

<para>
Vi skal nu vise en kort <FILENAME>squid.conf</FILENAME>, hvor vi lader squid køre som 
brugeren <FILENAME>squid</FILENAME>.
</para>

<SCREEN>
#squid.conf -  Basal opsætning

#Laveste niveau af logging
debug_options ALL,1

#Gruppe af IP numre, som kan tilgå Squid (Access Control List) 
#Vil man kun give access til netværket 192.168.0.0/255.255.255.0
#så brug følgende linie
acl all src 192.168.0.0/255.255.255.0

#Skal alle kunne bruge Squid så udkommenter følgende linie.
#acl all src 0.0.0.0/0.0.0.0

#Port, man anvender til konfiguration af Netscape klienter
http_port 3128

#Lad alle i ACL bruge Squid til HTTP
http_access allow  all

#test følgende sites for at checke, om maskinen er koblet til Internet
dns_testnames internic.net usc.edu cs.colorado.edu mit.edu yale.edu

#Kør som effektiv bruger squid og gruppe squid
cache_effective_user squid squid

# Squid vil oftest bruge to-tre gange denne RAM størrelse. Vil man max
# bruge 24 MB RAM til Squid, så sæt cache_ram til 8 MB. 
# Jo mere cache_mem desto hurtige er cachen (mindre diskaccess).
cache_mem  8 MB

#Maximal størrelse på object i cache
maximum_object_size 4096 KB

# Næste parameter-opsætning er disk cache struktur. Parametre er
#  Dirname - hvor på disken er disk cache dvs. spool dir
#  Mbytes under spool dir - hvor mange MB må gemmes i disk cache.
#  Level-1 dir antal - Antal underkataloger under Dirname
#  Level2 dir antal - Antal underkataloger for hver Level-1 kataloger
# Sæt ikke produktet mellem de to sidste vildt højt!
cache_dir /var/spool/squid 100 16 256
</SCREEN>


<para>
Lad os se nærmere på, hvad der installeres, og hvordan squid
kører. Installer squid med 
</para>

<SCREEN>
#rpm -ivh squid-2.2.STABLE5-1.i386.rpm
</SCREEN>

<para>
Ret <FILENAME>/etc/squid/squid.conf</FILENAME> til som vist ovenfor. Husk dog at gemme 
den originale <FILENAME>/etc/squid/squid.conf</FILENAME> før ovenstående eksempel anvendes.
</para>

<itemizedlist mark="bullet">

<listitem><para><FILENAME>/etc/squid/</FILENAME> indeholder konfigurationsfiler - specielt er
<FILENAME>/etc/squid/squid.conf</FILENAME> vigtig.</para></listitem> 

<listitem><para><FILENAME>/var/spool/squid</FILENAME> indeholder den dynamiske database. (se
parameteren <FILENAME>cache_dir</FILENAME> i <FILENAME>squid.conf</FILENAME>). Over 4000 filer laves med
ovenstående opsætning.</para></listitem>

<listitem><para><FILENAME>/var/log/squid</FILENAME> indeholder log-filer.
</para></listitem>
<listitem>
  <itemizedlist mark="bullet">
    <listitem><para><FILENAME>access.log</FILENAME> - Hvad blev hentet
    fra  nettet. 
    Her kan systemadministratoren overvåge trafik.</para></listitem>
  <listitem><para><FILENAME>cache.log</FILENAME> - Opstartsmeddelelser.</para></listitem>
<listitem><para><FILENAME>store.log</FILENAME> - Oversigt over, hvad der findes i proxy-cache nu.</para></listitem>
  </itemizedlist>
</listitem>

</itemizedlist>

<para>
Med installation af squid blev <FILENAME>squid</FILENAME> brugeren og tilsvarende
gruppe oprettet. Kataloget <FILENAME>/var/spool/squid</FILENAME> er tomt
men ejet af brugeren squid. Selve databasestrukturen skal man en gang
for alle sætte op - hertil bruges parameteren <FILENAME>cache_dir</FILENAME>.
</para>

<SCREEN>
[root@sherwood root]# /usr/sbin/squid -z
</SCREEN>

<para>
Anvender man 16 og 256 som de sidste to parametre til <FILENAME>cache_dir</FILENAME>, skal
man ikke blive bange, når man initialiserer databasen. Der køres hårdt på
harddisken, og det tager måske flere minutter - databasen bliver stor!
</para>
</sect3>

<sect3 id="squid-bruger">
<title>Brugerens opsætning</title>

<para>
For at man kan få squid til at virke sammen med lynx og wget, kan man
sætte følgende environment variable 
(her hedder vores proxy-server "proxy.herne.dk")
</para>

<SCREEN>
% setenv http_proxy http://proxy.herne.dk:3128/
% setenv gopher_proxy http://proxy.herne.dk:3128/
% setenv ftp_proxy http://proxy.herne.dk:3128/ 
</SCREEN>

<para>
I Netscape skal brugerne under
<FILENAME>Edit->Preferences->Advanced->Proxies</FILENAME> vælge
<FILENAME>Manual proxy configuration</FILENAME> og tryk på
<FILENAME>View</FILENAME>. Som det kan ses på det næste billede, skal
man skive navnet på proxy maskinen (her anvender vi
<FILENAME>proxy.herne.dk</FILENAME>), og port 3128 svarer til
parameteren "http_port" i <FILENAME>squid.conf</FILENAME>.
</para>

<FIGURE ID="proxy-fig" FLOAT="1">
<TITLE>Proxy opsætning i Netscape</TITLE>
<GRAPHIC FILEREF="proxy.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>  



<para>
Squid er i dagligdagen et meget driftsikkert program og kan anbefales.
Vi skal dog lige huske at nævne, at hvis der ikke er blokeret for det
via en firewall, så kan brugeren af Netscape faktisk godt køre
forbi proxy cachen ved enten at udelade proxy-opsætningen eller 
at holde SHIFT nede, før der trykkes på et
link. Derfor skal firewall opsætningen være lavet, så
proxy-programmet godt kan hente data fra Internet, men at brugere
ikke kan - hvis man virkelig ønsker, at folk skal bruge
proxy-serveren.
</para>
</sect3>
</sect2>
</sect1>

<sect1 id="transparent-proxy">
<title>Transparent proxy med squid</title>
<para>
Man kan lave noget transparent proxy med squid sammen med ipchains. 
Kernen skal være kompileret med "Transparent proxying". Vi vil ikke
beskrive det her, men der findes en mini-HOWTO på
<ulink url="http://sunsite.auc.dk/ldp/HOWTO/mini/TransparentProxy.html ">http://sunsite.auc.dk/ldp/HOWTO/mini/TransparentProxy.html </ulink>.
</para>

<sect2 id="Masquerading-med-ipchains">
<title>Masquerading med ipchains (kerne 2.2)</title>
<para>
Masquerading er ikke proxying men en speciel form for NAT (<emphasis>N</emphasis>etwork
<emphasis>A</emphasis>ddress <emphasis>T</emphasis>ranslation). Det giver delvis samme funktionalitet som proxying,
- at man kan få sit lokalnetværk på internettet med kun een gyldig IP-adresse -
men det giver ikke den samme sikkerhed som proxying.
Linux-kernen understøtter masquerading som en del af ipchains.
</para>

<para><emphasis>Bemærk at masquerading ikke er særlig sikkert. Der er
fundet flere sikkerhedshuller. Bl.a et som går ud på, at man kan
omskrive portnummeret på udp svarpakkerne til en masqueraded maskine,
og derved kan få adgang til selv at sende pakker til en host inde
bagved masqueraring.</emphasis> </para>

<para>
Med IP masquerading opnås, at mange forskellige maskiner kan komme på internet
med kun én IP-adresse. Man sætter en masquerading server op, og alle 
maskinerne bagved skal bruge den som default gateway. Masquerading serveren 
omskriver så alle pakkerne, der kommer forbi, til at have dens egen IP adresse
som afsender. Den "husker" så hvilke pakker, der har været sendt ud, og bruger 
denne information til at genkende svaret, så den kan sørge for, at svaret 
kommer til den maskine, der sendte forespørgslen ud.
</para>

<para>
I sagens natur skal forwarding være slået til her, og der
<emphasis>er</emphasis> oprettet direkte forbindelse imellem den
lokale maskine og en maskine ude på Internet.  Fællestrækket ved proxy
og masquerading er, at man kan sætte mange maskiner på Internet ved
hjælp af kun én "ægte" ip-adresse. En fordel ved masquerading fremfor
proxying er, at med masquerading kan man alt - der er ting, man ikke
kan få igennem en proxy.  Men det er på bekostning af sikkerheden:
Masquerading giver ikke den samme beskyttelse som en proxy. Man kan
dog beskytte sig en del ved at sætte firewall-regler op i kernen. Se
afsnittet om pakkefiltrering tidligere i artiklen.
</para>

<para>
Vi skal nu til at sætte forwardkæden op - den kan ud over de tre 
almindelige policies også sættes til MASQ.
</para>

<para>
Den simple og hurtige måde at sætte IP masquerading op på er:
</para>

<SCREEN>
[root@myhost /root]# ipchains -A forward -i ppp0 -j MASQ
ipchains -A forward -s 0.0.0.0/0 -d 0.0.0.0/0 -l -j REJECT
[root@myhost /root]# echo 1 > /proc/sys/net/ipv4/ip_forward
</SCREEN>

<para>
hvor ppp0 er det interface, der peger ud imod verden, imod Internettet, imod 
det net, man vil give sine maskiner adgang til via masquerading.
</para>

<para>
Det kan også give mening at sætte timeouts for masquerading forbindelserne:
</para>

<SCREEN>
[root@myhost /root]# ipchains -M -S 7200 10 160
</SCREEN>

<para>
Det første tal er timeout for en tcp forbindelse, det næste er hvor længe en 
tcp forbindelse skal kunne eksistere efter modtagelsen af en FIN pakke, og det
sidste er timeout for UDP. Timeout tiderne er i sekunder. Default er 15 
minutter, og det kan være lidt kort for en tcp session.
</para>

<para>
Nu sættes de andre maskiner i lokalnetværket til at bruge myhost som
default gateway, og voila! Man kan komme på Internettet fra de andre
maskiner. 
</para>
</sect2>
</sect1>

<sect1 id="ipchains-moduler">
<title>Moduler til ipchains</title>
<para>
Og dog. Http mm virker nu, men der er et par protokoller, der kræver særlige 
hensyn. Det er bla. ftp, realaudio, irc og forskellige spil.
</para>
<para>For at kunne bruge ftp, real audio, irc, spille quake mm via masquerading,
er vi nødt til gøre det lidt mere indviklet. Der findes moduler til ipchains, 
der kan håndtere en del forskellige applikationer: ip_masq_ftp, ip_masq_raudio,
ip_masq_irc, ip_masq_quake etc. For at kunne bruge disse moduler, skal de
være kompileret med, da man lavede kernen. Det er inde under networking options,
hvor man skal slå "IP masquerading special module support"
og "ipportfw masq support" til. I kerne 2.2.12 er det nødvendigt at
slå "prompt for development and/or incomplete code/drivers" til for at
få lov til at vælge ipportfw.
</para>
<para>
Modulerne loades nu med
</para>
<SCREEN>
[root@myhost /root] /sbin/modprobe ip_masq_ftp
[root@myhost /root] /sbin/modprobe ip_masq_raudio
</SCREEN>
<para>
Nu virker ftp og realaudio fra de andre maskiner. Gør det samme med
de andre moduler, der skal bruges. Der findes også et værktøj, der hedder 
IPMASQADM, man kan bruge. 
Der findes en slags beskrivelse af emnet i IP-Masquerade-HOWTO'en på
<ulink url="http://sunsite.auc.dk/ldp/HOWTO/IP-Masquerade-HOWTO-6.html#ss6.8">http://sunsite.auc.dk/ldp/HOWTO/IP-Masquerade-HOWTO-6.html#ss6.8</ulink>
</para>
</sect1>

<sect1 id="opsaetning-andre-maskiner">
<title>Opsætning af de andre maskiner i nettet</title>
<para>
Default gateway sættes med kommandoen <COMMAND>route</COMMAND>:
</para>

<SCREEN>
route add default gw myhost
</SCREEN>

<para>
Hvis det skal være permanent, er der lidt forskel på distributionerne.
Nogle har et fint konfigurationsværktøj, det vil vi ikke komme ind på
her. I SuSE er det en <FILENAME>/etc/route.conf</FILENAME>, man kan
sætte det ind i.  I debian er det direkte i
<FILENAME>/etc/init.d/</FILENAME> i et netværks startup script.  I
RedHat er det filen <FILENAME>/etc/sysconfig/network</FILENAME>, man
sætter sin default gateway ind i.
</para>

<para>
For yderligere information om IP masquerading kan man læse
IP-Masquerade-HOWTO'en
<ulink url="http://sunsite.auc.dk/ldp/HOWTO/IP-Masquerade-HOWTO">http://sunsite.auc.dk/ldp/HOWTO/IP-Masquerade-HOWTO</ulink> .
HOWTO'en indeholder også referencer til en række gode ressourcer.
</para>
</sect1>

<sect1 id="NAT">
<title>Network Address Translation med iptables (Netfilter) i kerne 2.3 (2.4)</title>
<para>
I kerne 2.3 (2.4) er ipchains erstattet af iptables, som er en del af
netfilter. Ipchains understøttede en bestemt form for NAT kaldet
ip-masquerading. Iptables kan meget mere indenfor NAT. Ud over NAT
bruges iptables også til pakkefiltrering, som er beskrevet tidligere i
artiklen.  For at kunne mappe alle svarene på NAT pakkerne rigtigt,
benytter iptable sig af connection tracking - den holder styr på de
oprettede forbindelser.  Dette kan man checke på i sit pakkefilter -
en meget spændende ny feature.  Se afsnittet om
"state" under Iptables (Netfilter) - kerne 2.3 (2.4).
<!-- UPS -->
</para>
</sect1>

<sect1 id="source-NAT">
<title>Source NAT</title>
<para>
NAT går ud på at man kan "mappe" IP adresser. F.eks. kan man mappe en 
række lokale IP-adresser til til en begrænset pulje af rigtige 
Internet-IP-adresser. IP masquerading er et særtilfælde af dette, hvor 
man mapper alle sine lokale IP-adresser til kun een gyldig internet-IP-adresse.
I ovenstående tilfælde er det source adressen, man manipulerer - Source NAT.
</para>
</sect1>

<sect1 id="Desination-NAT">
<title>Destination NAT</title>
<para>
Man kan også mappe destinationsadressen - Destination NAT - så folks 
forespørgsler f.eks. bliver redirigeret hen til den lokale webserver eller 
til en server pool. 
</para>

<para>
For TCP og UDP kan man lave portmapping med iptables, hvor man skifter
destinationsporten ud. F.eks. kan en klient oprette en forbindelse til
en web-server på port 80, og NAT-serveren kan mappe pakkerne til sin
egen port 3128, hvor der kører en squid. Dette kaldes redirect,
men er også en form for destination NAT. Resultatet er transparent proxying.
</para>
</sect1>

<sect1 id="hvordan-NAT">
<title>Hvordan</title>
<para>
For at bruge NAT skal modulet <FILENAME>iptables_nat</FILENAME> være loadet.
NAT med iptables laves med "-t nat" option til iptables.
<emphasis>-t</emphasis> fortæller iptables, at det er NAT-tabellen den skal bruge.
Til pakkefiltrering bruges filter-tabellen.</para>

<para><emphasis>Chains:</emphasis> 
NAT har tre chains, hvor man kan sætte rules op for pakkerne:</para>
<itemizedlist mark="bullet">
  <listitem><para>PREROUTING - Destination NAT</para></listitem>
  <listitem><para>POSTROUTING - Source NAT</para></listitem>
  <listitem><para>OUTPUT - Destination NAT fra lokale porte</para></listitem>
</itemizedlist>

<para>
<emphasis>Targets:</emphasis> 
</para>
<itemizedlist mark="bullet">
  <listitem><para>SNAT -source NAT</para></listitem>
  <listitem><para>DNAT - destination NAT</para></listitem>
  <listitem><para>MASQUERADING - Masquerading på dial-up interface</para></listitem>
  <listitem><para>REDIRECT - destination NAT til lokal port</para></listitem>
</itemizedlist>

<para>
Man kan angive <filename>-p protokol</filename>, og for tcp og udp kan
man også angive portnummer eller port range. <filename>--to</filename>
angiver den/de ip-adresse(r) der skal NAT'es til.
</para>

<sect2 id="eksempel-masq">
<title>Eksempler</title>
<para>Opsætning af IP masquerading med iptables:</para>

<para>Med fast ip-adresse:</para>

<SCREEN>
# iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to 1.2.3.4
</SCREEN>

<para>Med dynamisk ip-adresse:</para>
<SCREEN>
# iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE
</SCREEN>

<para>
MASQUERADING target er specielt til masquerading med en dynamisk
tildelt ip-adresse, som en dial-up forbindelse har. Den finder 
selv ud af det, når ip-adressen på ppp0 skifter. 
</para>
<para>Lav destination NAT til ip 1.2.3.4, 1.2.3.5 eller 1.2.3.6</para>
<SCREEN>
# iptables -t nat -A PREROUTING -i eth1 -j DNAT --to 1.2.3.4-1.2.3.6
</SCREEN>

<para>Lav destinations NAT fra port 80 til den lokale port 3128, hvor squid kører</para>
<SCREEN>
# iptables -t nat -A PREROUTING -i eth1 -p tcp --dport 80 \ 
-j REDIRECT --to-port 3128
</SCREEN>

<para>
Eksemplerne er taget mere eller mindre direkte fra Linux 2.4 NAT HOWTO, og
er blot ment som illustration af, hvad man kan med iptables NAT.
</para>

<para>
For nærmere beskrivelse, se Linux 2.4 NAT HOWTO på <ulink
url="http://netfilter.kernelnotes.org/unreliable-guides/NAT-HOWTO.html">http://netfilter.kernelnotes.org/unreliable-guides/NAT-HOWTO.html</ulink>
Se desuden man-siden for iptables.
</para>

<para>
Hvis man går i gang med at lege med iptables, enten til NAT eller 
pakkefiltrering, mens det stadig er under udvikling, skal man være 
opmærksom på, at det ikke er færdigt, og at der ikke er nogen garanti 
for hvor sikkert, det er endnu. 
</para>
</sect2>
</sect1>

<sect1 id="firewall-test">
<title>Test af firewall</title>
<para>
Når man har sat sin firewall op, skal man altid teste, 
at den virker som forventet.</para>

<itemizedlist mark="bullet">

<listitem><para>
  <emphasis>Funktionalitet: </emphasis>Test at de services, der skal
  kunne benyttes, virker. Både indefra og udefra. Der er dog stor
  chance for, at brugerne nok skal fortælle meget hurtigt, hvis det
  ikke er tilfældet.
</para></listitem>

<listitem><para>
  <emphasis>Sikkerhed: </emphasis>Test at firewall'en rent faktisk
  lukker for de ting, den burde. Prøv at bruge services, der skulle
  være lukket for, ved at prøve at oprette forbindelser
  udefra. Portscan firewall'en for at se, hvad folk kan få at vide om
  den udefra. Der findes også mere omfattende tests. Man kan forsøge
  sig med diverse cracker-programmer, eller man kan betale andre for
  at teste firewall'en.
</para></listitem>

<listitem><para>
  <emphasis>Vedligeholdelse: </emphasis> Hold altid softwaren på
  firewall'en opdateret med de nyeste sikkerhedsrettelser. Læs altid
  logfiler.
</para></listitem>
</itemizedlist>

</sect1>

<sect1 id="epilog4">
<title>Epilog</title>

<para>
Firewall-løsninger kan ikke beskrives fuldstændigt i en artikel. Vi
har taget en del af Linux mulighederne, men der er meget, vi ikke har dækket:
</para>

<itemizedlist mark="bullet">
  <listitem><para>
    Trusted Information Systems Firewall Toolkit (FWTK): Se 
    <ulink url="http://www.fwtk.org/fwtk/">http://www.fwtk.org/fwtk/</ulink>
  </para></listitem>
  <listitem><para>
    T.REX: Open Source firewall: Se <ulink url="http://www.opensourcefirewall.com/">http://www.opensourcefirewall.com/</ulink> 
  </para></listitem>
  <listitem><para>
    En side med mange links om firewalls: Se <ulink url="http://www.linux-firewall-tools.com/linux/">http://www.linux-firewall-tools.com/linux/</ulink>
  </para></listitem>
  <listitem><para>
    Firewall-1 er en fuld kommerciel firewall: 
    Se <ulink url="http://www.checkpoint.com/products/firewall-1/">http://www.checkpoint.com/products/firewall-1/</ulink>
  </para></listitem>
  <listitem><para>
    Socks5 er en proxy server, der anvendes mange steder. 
    Se <ulink url="http://www.socks.nec.com">http://www.socks.nec.com</ulink>
  </para></listitem>
  <listitem><para>
    Mange gode netværkssikkerhedsvækrtøjer og ressourcer findes på
    <ulink url="http://www.freefire.org">http://www.freefire.org</ulink>
  </para></listitem>
</itemizedlist>
</sect1>
</chapter>
