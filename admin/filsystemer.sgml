<chapter id="filsystemer">
<title>Filsystemer</title>
<indexterm><primary>Filsystemer</primary></indexterm>
<indexterm><primary>Filsystemer</primary>
  <secondary>ext2</secondary></indexterm>
<indexterm><primary>ext2</primary></indexterm>
<para>
Linux bruger som standard et filsystem kaldet
<emphasis>ext2</emphasis> (Extended file system version 2), men kan
også læse fra og skrive til mange andre filsystemer, f.eks. FAT-baserede
filsystemer, der bruges af DOS og Windows.
</para>

<indexterm>
 <primary>mkfs</primary>
</indexterm>

<indexterm>
  <primary>Harddisk</primary>
  <secondary>Formatering af harddisk</secondary>
</indexterm> 
 <!-- Formatering med: /sbin/mke2fs -->


<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mkfs, Oprette filesystem </secondary>
</indexterm>
<indexterm>
 <primary>Filsystem</primary>
 <secondary>Oprette</secondary>
</indexterm>

<para>
Generelt formateres et filsystem under Linux ved at benytte kommandoen
<command>mkfs</command> (MaKe File System). Har du en uformateret
partition (her <filename>/dev/hda5</filename>), som du ønsker at
formatere, sker formateringen ved at skrive (som root):
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>mkfs /dev/hda5</userinput>
</screen>

<para>
Programmet <command>mkfs</command> finder selv ud af, hvilket filsystem
du har valgt til den ønskede partition, idet denne oplysning findes i
partitionstabellen.
</para>

<para>
Når din computer går ned (ja, det sker, f.eks. når strømmen går), kan
du komme ud for at dine filsystemer er i en fejlbehæftet tilstand. Det
kan dog ofte reddes af programmet <command>fsck</command> (File
System ChecK). Faktisk
køres dette program altid ved opstart for at sikre at alle filsystemer
er i en god tilstand.
</para>

<para>
Vi du køre filtjek manuelt på en ext2-partition, så kan du direkte
bruge <command>e2fsck</command>:
</para>
<indexterm><primary>fsck</primary></indexterm>
<indexterm><primary>e2fsck</primary></indexterm>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/sbin/e2fsck /dev/hda5</userinput>
</screen>

<!-- skrevet af Hanne Munkholm http://www.linuxlab.dk/fcl/technotes/badblocks.php -->
<!-- Senere udvidet og rettet af Jacob Sparre Andersen. -->
<sect1 id="bad-blocks">
 <title>Defekte blokke på harddisken</title>

 <indexterm>
  <primary>badblocks</primary>
 </indexterm>

 <indexterm>
  <primary>e2fsck</primary>
 </indexterm>

 <indexterm>
  <primary>defekte blokke på harddisk</primary>
 </indexterm>

 <indexterm>
  <primary>harddisk</primary>
  <secondary>defekte blokke</secondary>
 </indexterm>

 <para>
  Hvis man har en harddisk med defekte blokke på så bliver man nødt
  til at finde dem og få filsystemet til at gå uden om.  I det
  følgende gives en vejledning i at gøre dette.
 </para>

 <sect2 id="starte-alternativt-system">
  <title>Starte maskinen uden om harddisken(e)</title>

<indexterm><primary>rescue</primary></indexterm>
<indexterm><primary>Hjælp &ndash; kan ikke boote</primary></indexterm>

  <para>
   Hvis du har en Red Hat-cd-rom, kan du starte maskinen fra den. Det
   kan kræve en ændring i opsætningen af din BIOS-opsætning, som vi
   dog ikke vil komme ind på her. Når der kommer en LILO-promt frem
   skriver du: "linux rescue".
  </para>

  <para>
   Redningsproceduren (eng. rescue) vil bede om at få sprog og
   tastatur valgt &ndash; eksakt som det gøres ved en egentlig
   installation. Bare rolig &ndash; det er ikke en installation vi starter
   på. Når redningsproceduren beder om at montere rod-filsystemet
   under <filename>/mnt/sysimage</filename> skal der bare svares "no"
   (nej) hvis man ikke tør mounte harddisken, og "yes" hvis man
   kører rescue-CD'en for at redde data på harddisken eller fx.
   vil editere en system-konfigurationsfil, inden man genstarter
   systemet. Man svarer et eller andet, og derefter får man en
   kommandofortolker (et kommando-linie prompt. Ingen grafiske
   user-interface ting her).
  </para>

  <para>
   Hvis du har en rednings-CD eller et "bootable business card" fra fx.
   <ulink url="http://lnx-bbc.org/"> lnx-bbc.org (Linux -
   Bootable Business Card projektet) </ulink> som er en CD-ROM i
   visitkortstørrelse, kan du også boote fra fra den. Når
   systemet er startet, får du besked om, hvad systemets
   brugernavn (login-name eller bare login) og password
   (adgangskode) er. På rescue CD fra <ulink
   url="http://www.sysresccd.org/"> http://www.sysresccd.org/
   </ulink> er der faktisk slet ikke nogen adgangskode, man er
   logget på med det samme.
  </para>
 </sect2>

 <sect2 id="hvilke-filsystemer-skal-tjekkes">
  <title>Hvilke filsystemer skal tjekkes?</title>

  <para>
   En rednings-CD (rescue CD) kan give dig en liste over
   partitioner og filsystemer på den harddisk, som er direkte
   koblet på systemet:
  </para>

<screen>
   <userinput>
   fdisk -l /dev/hda
   </userinput>
   # hvis det er en IDE eller FAST IDE disk, eller hvis det er SCSI:
   <userinput>
   fdisk -l /dev/sda
   </userinput>
</screen>
   
  <para>
   Den kommando vil give dig en liste med de tilgængelige filsystemer.
   Den kan for eksempel se sådan ud:
  </para>

<screen>
   Device Boot    Start       End    Blocks   Id  System
/dev/hda1   *         1        12     96358+   b  Win95 FAT32
/dev/hda2            13        63    409657+  83  NTFS
/dev/hda3            64       127    514080   8e  Linux LVM
/dev/hda4           128      3722  28876837+   5  Extended
/dev/hda5           179      1198   8193118+  83  Linux
/dev/hda6          3239      3279    329301   82  Linux swap
</screen>

  <para>
   Nu kan du så mounte disse partitioner og arbejde på dem.
  </para>

  <para>
   Hvis du er interesseret i at se filerne på et Linux filsystem,
   så kan du mounte det som ext2, også selv om det er ext3.
   Forskellen er, at hvis du kører fsck (File System Consistency
   checK) så er det hurtigere, hvis man har ext3 og en gyldig
   "journal-file", som ofte ligger udenfor partitionen og oftest
   heldigvis ikke er beskadiget.
  </para>

  <para>
   Hvis du kører en rescue-CD, som automatisk mounter dine
   disk-partitioner for dig (som Knoppix kan gøre) så vil du
   typisk være interesseret i de filsystemer, der er monterede
   som <filename>/mnt/</filename>-et-eller-andet-tal, og som er af
   typen "ext2". Vi kan foreksempel være interesserede i filsystemet
   på partitionen <filename>/dev/hda2</filename>.
  </para>

  <para>
   Du kan bruge kommandoen <command>mount</command> til at
   få oplysninger om hvilke filsystemer der er monterede (eng.: mounted):
  </para>

<screen>
<prompt>[root@lnx-bbc ~]# </prompt><userinput>mount</userinput>
/dev/sda2 on / type ext2 (rw) []
none on /proc type proc (rw)
/dev/sda3 on /boot type ext2 (rw) []
/dev/vg1/lv_home on /home type ext2 (rw)
/dev/vg1/lv_usr on /usr type ext2 (rw)
none on /dev/pts type devpts (rw,gid=5,mode=620)
/dev/hdb1 on /backup type ext2 (rw) []
</screen>

<para>
   Og hvis det ikke giver nok oplysninger, kan du bruge kommandoen
   <command>fdisk</command> til at spørge til partitioneringen af dine
   diske. IDE-diske (det typiske i skrivebordsmaskiner) har i Linux
   navnene <filename>/dev/hd</filename>-et-eller-andet-bogstav. Et
   linux-systems anden IDE-disk hedder således
   <filename>/dev/hdb</filename> og du kan spørge til dens opdeling
   med kommandoen:
</para>

<screen>
<prompt>[root@lnx-bbc ~]# </prompt><userinput>fdisk -l /dev/hdb</userinput>

Disk /dev/hdb: 16 heads, 63 sectors, 59560 cylinders
Units = cylinders of 1008 * 512 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hdb1             1     59560  30018208+  83  Linux
</screen>
 </sect2>

 <sect2 id="finde-og-maerke-daarlige-blokke">
  <title>Finde og mærke dårlige blokke</title>
<indexterm><primary>badblocks</primary></indexterm>
<indexterm><primary>e2fsck</primary></indexterm>
<indexterm><primary>fsck</primary></indexterm>
<indexterm><primary>defekt harddisk</primary></indexterm>
<indexterm><primary>fejl på harddisk</primary></indexterm>

  <para>
   Kør nu kommandoen <command>badblocks -o /tmp/blocks
   /dev/hda5</command> hvor <filename>hda5</filename> erstattes af den
   partition man ønsker at tjekke for defekte blokke, og
   <filename>/tmp/blocks</filename> er et arbitrært valgt filnavn.
  </para>

  <para>
   Ældre udgaver af programmet <command>badblocks</command> skal have
   at vide hvor mange blokke der er på den partition der skal
   tjekkes. Den oplysning kan man få ved at bede
   <command>fdisk</command> om en liste med alle partitionerne på den
   relevante disk. Den disk partitionen <filename>/dev/hda2</filename>
   ligger på hedder <filename>/dev/hda</filename> (man stryger altså
   bare nummeret):

<screen>
<prompt>[root@lnx-bbc ~]# </prompt><userinput>fdisk -l /dev/hda</userinput>
...
   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        70    529168+  82  Linux Swap
/dev/hda2   *        71       487   3152520   83  Linux
...
</screen>

   Det er tallet <literal>3152520</literal> vi er ude efter. Det føjes
   til som et sidste argument til <command>badblocks</command>:

<screen>
<prompt>[root@lnx-bbc ~]# </prompt><userinput>badblocks -o /tmp/blocks /dev/hda 3152520</userinput>
</screen>
  
   Derefter <emphasis>kan</emphasis> man læse filen med <command>cat
   /tmp/blocks</command> for at se om der blev fundet nogle defekte
   blokke. Hvis der ikke blev fundet nogen, så behøver man ikke at
   fortsætte.
  </para>

  <para>
   Hvis der blev fundet defekte blokke skal du dernæst køre kommandoen
   <command>e2fsck -l /tmp/blocks /dev/hda5</command>.  Den indsætter
   listen over de defekte blokke fra <filename>/tmp/blocks</filename>
   i filsystemets liste med defekte blokke. Til sidst taster du
   "Ctrl-d" for at komme ud af kommandofortolkeren og genstarte
   maskinen.  Husk at tage din cd-rom ud.
  </para>

  <para>
   Herefter vil maskinen ikke længere prøve at bruge de defekte blokke
   <command>badblocks</command> fandt på harddisken.  Du kan finde en
   mere information om de kommandoerne med <command>man
   badblocks</command> og <command>man e2fsck</command>.
  </para>

<para>
Se også <ulink url="http://www.redhat.com/mailing-lists/ext3-users/msg02454.html">http://www.redhat.com/mailing-lists/ext3-users/msg02454.html</ulink> for mere information om emnet.
</para>

 </sect2>
</sect1>

<sect1 id="partitionstabel-vaek">
<title>Hjælp min partitionstabel er væk</title>

<para>
Hvis man er særlig uheldig, så kan man miste sin partitionstabel ved
et Windows-crash. Her er et par erfaringer. Skriv partitionstabellen
(anvend <filename>fdisk /dev/hda</filename>, hvis din harddisk er
<filename>/dev/hda</filename>) ud på papir og gem den sammen med
udskrift af <filename>/etc/fstab</filename>. Hvis du har disse informationer
så kan man typisk genskabe indhold af harddisken. 
</para> 

<para>
Hvis man ikke har styr på hvor på harddisken man havde de enkelte
partitioner, så kan de programmer på <ulink
url="http://inet.uni2.dk/~svolaf/utilities.htm">http://inet.uni2.dk/~svolaf/utilities.htm</ulink>
være af <emphasis>STOR</emphasis> gavn. Med
<filename>findext2.exe</filename> er det muligt at find
Linux-partitioner af ext2/ext3-typen. Programmet kræver en
DOS-diskette med en fortolker og det tager typisk et par timer at søge
harddisken igennem for mulige partitioner. 
</para>

<para>
Nedenfor er vist hvad programmet kan give af informationer. Programmet er
kørt 29/6-2003. Dagen efter at partitionstabellen blev slettet.
Tre linjer indikerer hvilke partitioner som er "rigtige" &ndash; bemærk datoer
for hvornår de blev monteret og tjeket sidste gang &ndash; dagen før.
</para>

<para>
Konklusionen blev at der var tre partitioner, som skulle reddes ved at indtaste
følgende grænser manuelt i <command>fdisk</command>.
</para>

<screen>
Linuxpartition 1 : start 474  - slut 920
Linuxpartition 2 : start 951  - slut 2739
Linuxpartition 3 : start 2740 - slut 4865
</screen>

<screen>
Findext2, version 1.6
Copyright Svend Olaf Mikkelsen, 2002.

Searches for ext2/ext3 superblocks. False positives might be found.
The partition location can be wrong. Data MB may be used megabytes,
especially for superblock 0. Mount/Write/Check are date/time if
valid. Note that cylinders are numbered from 0. Linux fdisk
numbers from 1.

OS:  DOS 7.10  WINDOWS 4.10

Disk: 1   Cylinders: 4865   Heads: 255   Sectors: 63   MB: 38162

Start cylinder: 0   End cylinder: 4864

-PCyl N ID -----LBA -----Num ---MB -Start CHS- --End CHS-- BS  CHS

    0 - 83    48191 14329917  6997    2 254 60  894 253 59 B0   OK
      Data MB    1857                Actual end sector: 54
      Mount 2002.07.16  19:55:28     Superblock 0  Block 0
      Write 2002.07.16  19:55:28     Superblock LBA 48193
      Check 2002.07.16  16:36:30     Superblock CHS 2/254/62
      Blocks:  KB: 4    First: 0     Per group: 32768
      Ext3
      Searched        100   0  1

    0 - 83       63 14329917  6997    0   1  1  891 254 63 B5   OK
      Data MB    142                 Actual end sector: 58
      Mount                    0     Superblock 9  Block 294912
      Write 2002.07.16  16:36:36     Superblock LBA 2359359
      Check 2002.07.16  16:36:30     Superblock CHS 146/220/10
      Blocks:  KB: 4    First: 0     Per group: 32768
      Ext3
      Searched        200   0  1
      Searched        300   0  1
      Searched        400   0  1

<emphasis>    0 - 83  7620209  7164927  3498  474  85 45  920  84 44 B0   OK</emphasis>
      Data MB    2396                Actual end sector: 37
      Mount 2003.06.28  14:24:18     Superblock 0  Block 0
      Write 2003.06.28  14:24:18     Superblock LBA 7620211
      Check 2003.04.12  16:09:18     Superblock CHS 474/85/47
      Blocks:  KB: 4    First: 0     Per group: 32768
      Ext3

    0 - 83  7614873  7164927  3498  474   1  1  919 254 63 B    OK
      Data MB    87                  Actual end sector: 56
      Mount                    0     Superblock 1  Block 32768
      Write 2003.04.12  16:09:21     Superblock LBA 7877017
      Check 2003.04.12  16:09:18     Superblock CHS 490/82/2
      Blocks:  KB: 4    First: 0     Per group: 32768
      Ext3
      Searched        500   0  1
      Searched        600   0  1
      Searched        700   0  1
      Searched        800   0  1
      Searched        900   0  1

<emphasis>    0 - 83 15277878 28740222 14033  951   1  1 2739 254 63 B0   OK</emphasis>
      Data MB    13873               Actual end sector: 57
      Mount 2003.06.28  14:24:33     Superblock 0  Block 0
      Write 2003.06.28  23:05:59     Superblock LBA 15277880
      Check 2002.07.17  00:43:41     Superblock CHS 951/1/3
      Blocks:  KB: 4    First: 0     Per group: 32768
      Ext3
      Searched       1000   0  1
      Searched       1100   0  1
      Searched       1200   0  1
      Searched       1300   0  1
      Searched       1400   0  1
      Searched       1500   0  1

    0 - 83 25415665  8388740  4096 1582  13 17 2104  57 54 B    OK
      Data MB    4096          
      Mount          -1535052965     Superblock 30168  Block-1241421144
      Write 2020.12.31  90:03:06     Superblock LBA 25415665
      Check 1997.05.24  00:00:14     Superblock CHS 1582/13/17
      Blocks:  KB: 1    First: 0     Per group:-1024238801
      Ext3
      Searched       1600   0  1
      Searched       1700   0  1
      Searched       1800   0  1
      Searched       1900   0  1
      Searched       2000   0  1
      Searched       2100   0  1
      Searched       2200   0  1
      Searched       2300   0  1
      Searched       2400   0  1
      Searched       2500   0  1
      Searched       2600   0  1
      Searched       2700   0  1

<emphasis>    0 - 83 44018163 34147192 16673 2740   1  1 4865 144 58 B0   OK?</emphasis>
      Data MB    6096          
      Mount 2003.06.28  14:24:34     Superblock 0  Block 0
      Write 2003.06.28  23:05:59     Superblock LBA 44018165
      Check 2002.09.22  09:51:38     Superblock CHS 2740/1/3
      Blocks:  KB: 4    First: 0     Per group: 32768
      Ext3
      Searched       2800   0  1
      Searched       2900   0  1
      Searched       3000   0  1
      Searched       3100   0  1
      Searched       3200   0  1
      Searched       3300   0  1
      Searched       3400   0  1
      Searched       3500   0  1
      Searched       3600   0  1
      Searched       3700   0  1
      Searched       3800   0  1

    0 - 83 61836487     1952     0 3849  36 35 3849  67 33 B0   OK
      Data MB    1             
      Mount 2002.09.10  20:31:45     Superblock 0  Block 1
      Write 2002.09.10  20:31:45     Superblock LBA 61836489
      Check 2002.09.10  20:31:45     Superblock CHS 3849/36/37
      Blocks:  KB: 1    First: 1     Per group: 8192

    0 - 83 61843559     1632     0 3849 148 51 3849 174 44 B0   OK
      Data MB    1             
      Mount 2002.09.10  20:31:50     Superblock 0  Block 1
      Write 2002.09.10  20:31:51     Superblock LBA 61843561
      Check 2002.09.10  20:31:50     Superblock CHS 3849/148/53
      Blocks:  KB: 1    First: 1     Per group: 8192
      Searched       3900   0  1
      Searched       4000   0  1
      Searched       4100   0  1
      Searched       4200   0  1
      Searched       4300   0  1
      Searched       4400   0  1
      Searched       4500   0  1
      Searched       4600   0  1
      Searched       4700   0  1
      Searched       4800   0  1
</screen>

<para>
Langt hurtigere er <filename>findpart.exe</filename> som også kan give
partitionsgrænserne direkte, men den viser ikke hvornår de enkelte partitioner
blev anvendt sidst.
</para>

<screen>
Findpart, version 4.33 - for Windows 95/98/ME/NT/2000/XP.
Copyright Svend Olaf Mikkelsen, 2003.

Searches for partitions type 01, 04, 06, 07, 0B, 0C, 0E, 82, 83,
plus Fdisk F6 and Lilo sectors. Information based on bootsectors
is marked B. If the disk is larger than supported by BIOS, the
supported part of the disk is examined. Disks are numbered from 1.

OS:  Windows 4.10

Disk: 1   Cylinders: 4865   Heads: 255   Sectors: 63   MB: 38162

-PCyl N ID -----Rel -----Num ---MB -Start CHS- --End CHS-- BS  CHS
<emphasis>    0 - 0B       63  7616512  3719    0   1  1  474  28  1 B    OK</emphasis>
    Fdisk F6 sector                   3   0  1
    Fdisk F6 sector                   5   1  1
  474 1 83       63 70550487 34448  474   1  1 1023 254 63 NB   NB?
<emphasis>  920 1 82       63   497952   243  920   1  1  950 254 63      OK</emphasis>
  920 2 05  7663005 62887545 30706  951   0  1 1023 254 63 474  NB?
<emphasis>  951 1 83       63 28740222 14033  951   1  1 2739*254 63 OK 3 OK</emphasis>
  951 2 05 36403290 34147260 16673 2740#  0  1 1023 254 63 474  NB?
 2740 1 83       63 34147197 16673 2740#  1  1 1023 254 63 NB   NB?
<emphasis> 2740 - 83       63 34147192 16673 2740   1  1 4865 144 58 B0 3 OK?</emphasis>
    Fdisk F6 sector                4407   0  1
    Fdisk F6 sector                4407   1  1
</screen>

<para>
Det skal bemærkes at de værktøjer som er nævnt ovenfor regner start og 
slut sektorer fra 0, hvor <command>fdisk</command> regner fra 1 og frem. 
Derfor skal man trække en fra hvis man anfører de grænser i <filename>/etc/fstab</filename>.
</para>

<para>
Det kan nævnes at den rigtige partitionstabel var
</para>

<screen>
Disk /dev/hda: 40.0 Gb, 40020664320 byte
255 hoveder, 63 sektorer/spor, 4865 cylindre
Enheder = cylindre af 16065 * 512 = 8225280 byte

    Enhed Opstart Start       Slut   Blokke   Id  System
/dev/hda1   *         1       474   3807373+   c  Win95 FAT32 (LBA)
/dev/hda2           475      4866  35275275    5  Udvidet
/dev/hda5           475       921   3590496   83  Linux
/dev/hda6           922       951    240943+  82  Linux swap
/dev/hda7           952      2740  14370111   83  Linux
/dev/hda8          2741      4866  17073598+  83  Linux
</screen>

<para>
og den tilsvarende <filename>/etc/fstab</filename> var
</para>

<screen>
/dev/hda1 /mnt/windows vfat iocharset=iso8859-15,codepage=850,umask=0 0 0
/dev/hda5 / ext3 defaults 1 1
/dev/hda6 swap swap defaults 0 0
/dev/hda7 /home ext3 defaults 1 2
/dev/hda8 /storage ext3 defaults 1 2
</screen>

<indexterm><primary>rescue</primary></indexterm>
<para>
Endelig skal det nævnes at bl.a. Mandrake har en mulighed for at boote op på første
cd-rom og vælge <emphasis>rescue</emphasis> og genskabe boot-information, hvis det
er muligt. Dette er ikke altid muligt...
</para>

<para>
Andre relevante links er <ulink url="http://www.stud.uni-hannover.de/user/76201/gpart/">http://www.stud.uni-hannover.de/user/76201/gpart/</ulink> som har Linuxprogrammet <command>gpart</command> som kan nogenlunde det samme. 
</para>

</sect1>

<sect1 id="reiserFS">
<title>ReiserFS</title>
<indexterm><primary>ReiserFS</primary></indexterm>

<indexterm>
 <primary>Filsystemer</primary>
 <secondary>ReiserFS</secondary>
</indexterm>
<indexterm>
 <primary>mkreiserfs</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mkreiserfs</secondary>
</indexterm>
<indexterm>
 <primary>mount -t reiserfs</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mount -t reiserfs</secondary>
</indexterm>


<para>
ReiserFS er et af de nyere filsystemer til Linux, og har kun været i de
officielle kerner siden version 2.4.1.
</para>

<para>
ReiserFS er en anden type filsystem end den der kendes fra Linux'
ext2, og DOS/Windows' FAT-drev, idet ReiserFS er et journaliserende
filsystem. Det betyder, at alle filer til en hver tid er
opdaterede. Det betyder, at hvis din computer går ned pga. en
strømafbrydelse, vil du ikke miste data. Endvidere betyder det, at de
partitioner som er formateret ved hjælp af ReiserFS, ikke skal tjekkes
ved opstart. Hvis du har meget store harddiske vil det betyde at du
får en meget kortere opstartstid. Dette kan være vigtigt, hvis din
computer er server med f.eks. 100 Gb harddisk (ikke ualmindeligt i den
virkelige serververden).
</para>

<para>
Tidligere versioner af ReiserFS ville ikke virke med Lilo-boot fra en
ReiserFS-partition. Det kunne løses ved at lægge
<filename>/boot</filename> på en ext2-partition, og hvis
<filename>/boot</filename> er en lille selvstændig partition, kan
<filename>/</filename>-partitionen være ReiserFS-formateret.
I de nyeste versioner af ReiserFS (november 2000) bør denne
begrænsning være væk, blot man monterer boot-partitionen med et ekstra
flag, "<literal>notail</literal>":
</para>

<programlisting>
/dev/hda2 on / type reiserfs (rw,notail)
</programlisting>


<para>
ReiserFS følger med Mandrake (fra version 7.1) og SuSE (fra
6.4) og under disse distributioner er det let at vælge
formatering med ReiserFS i stedet for ext2 under
installationen.
Men selv under andre distributioner er det ikke
svært. Du skal sikre dig, at kernen understøtter ReiserFS som
filsystem. Måske skal du omkonfigurere din kerne (se også <xref
linkend="kernelcompile"/>). Det kan godt betale sig at få ReiserFS
oversat som et kernemodul. Modulsystemet vil typisk selv finde ud af,
at modulet skal bruges, dvs. når du begynder at bruge kommandoer som
involverer en ReiserFS-baseret partition, vil modulet automatisk blive
indlæst.
</para>

<para>
Først og fremmest skal du have en partition, som er tom. Du kan 
oprette en partition til formålet. Her kan du bruge programmer som 
<command>fdisk</command> og <command>cfdisk</command>. Når du har 
en partition klar, skal du formatere den. I eksemplet benytter vi
partitionen <filename>/dev/hda5</filename>, som vi antager allerede er 
oprettet.
</para>

<para>
<screen>
<prompt>[root@linus root]#</prompt> <userinput>mkreiserfs /dev/hda5</userinput>
<-----------MKREISERFS, 1999----------->
ReiserFS version 3.5.18
Block size 4096 bytes
Block count 325576
First 16 blocks skipped
Super block is in 16
Bitmap blocks are : 
   17, 32768, 65536, 98304, 131072, 163840, 196608, 229376, 262144, 294912
Journal size 8192 (blocks 18-8210 of device 0x3:0x5)
Root block 8211
Used 8221 blocks
ATTENTION: ALL DATA WILL BE LOST ON '/dev/hda5'! (y/n) <userinput>y</userinput>
Initializing journal - 0%....20%....40%....60%....80%....100%
Syncing..

ReiserFS core development sponsored by SuSE Labs (suse.com)

Journaling sponsored by MP3.com.

Item handlers sponsored by Ecila.com

To learn about the programmers and ReiserFS, please go to
http://www.devlinux.com/namesys

Have fun.
<prompt>[root@linus ~]#</prompt>
</screen>
</para>

<para>
Du er nu klar til at montere din partition. Følgende vil montere partitionen
<filename>/dev/hda5</filename> som <filename>/home</filename>.
</para>

<para>
<screen>
<prompt>[root@linus ~]#</prompt> <userinput>mount -t reiserfs /dev/hda5 /home</userinput>
Checking ReiserFS transaction log (device 03:35)  ...
Relayed 0 transaction in 0 seconds
ReiserFS version 3.5.18
</screen>
</para>

<para>
Naturligvis kan du indsætte din nye partition i filen
<filename>/etc/fstab</filename> med typen
<emphasis>reiserfs</emphasis>. Derved vil partitionen blive monteret
under opstart.
</para>

<indexterm>
 <primary>ext2</primary>
 <secondary>sammenligning med journaliserende filesystemer</secondary>
</indexterm>

<para>
En glimrende oversigtsartikel, der sammenligner det gamle ext2, det
nyere ext3, ReiserFS og endelige XFS kan læses på 
<ulink url="http://www.linuxgazette.com/issue68/dellomodarme.html">http://www.linuxgazette.com/issue68/dellomodarme.html</ulink>. En sammenligning kan findes på <ulink url="http://oregonstate.edu/~kveton/fs/"> http://oregonstate.edu/~kveton/fs/</ulink>. Se også <ulink url="http://www.namesys.com/benchmarks/benchmark-results.html">http://www.namesys.com/benchmarks/benchmark-results.html</ulink>.
</para>
</sect1>

<sect1 id="migrering-ext2-ext3">
<title>Migrering fra ext2 til ext3</title>

<indexterm>
 <primary>ext3</primary>
</indexterm>
<indexterm>
 <primary>ext2</primary>
 <secondary>ext3 migrering</secondary>
</indexterm>

<para>
Hvis du ønsker at flytte eksisterende ext2-partitioner over til ext3, så kan man på <ulink
url="http://www.symonds.net/~rajesh/howto/ext3/index.html">http://www.symonds.net/~rajesh/howto/ext3/index.html</ulink>
finde en vejledning til dette. Det er egentlig nemt. Først skal man
sikre sig at ens Linux distribution er klar til ext3 - det er alle
nyere Linux-distributioner i dag. Derefter skriver man som root
<command>tune2fs -j /dev/hda1</command> hvis det er
<filename>/dev/hda1</filename> der skal flyttes til ext3. Dette
gentages for hver af de ext2-partitioner, der skal flyttes. Endelig
skal med i <filename>/etc/fstab</filename> rette alle steder med ext2
til ext3 og genstarte maskinen.
</para>

<para>
Denne øvelse kræver dog at din Linux-kerne er oversat med ext2 og ext3-understøttelse.
Dette er tilfældet med de nyere Linux-distributioner, men pas på her.
</para>


</sect1>

<sect1 id="software-raid">
<title>Software-RAID</title>
<indexterm><primary>RAID</primary></indexterm>
<!-- Skrevet af peter_frederiksen@danbbs.dk -->
<!-- sprog rettet lidt til : pto -->

<sect2 id="hvad-er-raid">
<title>Hvad er RAID?</title>
<para>
RAID er en metode til at slå flere diske sammen til én
<emphasis>volume</emphasis> (dvs. én logisk disk); det kan gøres for
at opnå et større brugerdrev eller for at højne sikkerheden ved
redundans.
</para>

<para>
Derfor er der flere måder at kombinere diske til et RAID, og man har
derfor vedtaget nogle RAID-levels.
</para>
</sect2>

<sect2 id="hw-sw-raid">
<title>Forskel mellem hardware- og software-RAID</title>

<para>
RAID kan laves hardware- eller software-mæssigt. Det sikreste
er via hardware eller med andre ord en RAID-controller.
</para>

<sect3 id="Hardwareraid">
<title>Hardware-RAID</title>
<indexterm><primary>RAID</primary><secondary>Hardware</secondary></indexterm>

<para>
Ved at lade hardwaren styre diskene og "narre" styresystemet til at
tro at der er tale om et eller flere logiske drev, behøver man ikke at
bekymre sig så meget om opsætning af Linux, da hardwareproducenterne
som regel har en brugervenlig opsætningsmenu installeret i kortets
BIOS.
</para>

<para>
Ulempen er at disse kort som regel er dyre at anskaffe og ofte
benytter sig af de noget dyrere scsi-diske. Med andre ord: En
RAID-controller er ofte "bare" en avanceret scsi-controller.
</para>
</sect3>

<sect3 id="Softwareraid">
<title>Software-RAID</title>
<indexterm><primary>RAID</primary><secondary>Software</secondary></indexterm>

<para>
Her lader man et stykke software styre RAID, hvilket sparer en
RAID-controller og det er muligt at blande scsi-diske med IDE eller kun
benytte sig af IDE.
</para>

<para>
Ulempen er at man så selv skal sætte RAID op.  På Linux er
det lidt besværligt.
</para>
</sect3>
</sect2>


<sect2 id="spejlet-raid">
<title>Opsætning af spejlede diske.</title>
<indexterm>
 <primary>RAID</primary>
 <secondary>spejling</secondary>
</indexterm>
<indexterm>
 <primary>mkraid /dev/md </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mkraid /dev/md </secondary>
</indexterm>
<indexterm>
 <primary>mount /dev/md0 /spejl </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mount /dev/md0 /spejl </secondary>
</indexterm>
<para>
Et disk-spejl er hvis man ønsker 2 diske som en logisk enhed,
hvor begge diske indeholder samme data. Sikkerheden er her at hvis en
disk står af, så kører den anden videre.
</para>

<para>
Hvis man ønsker yderligere sikkerhed, kan man benytte en ekstra
reservedisk som vil kunne erstatte en nedbrudt disk i spejlet. På den
måde undværer man kun sikkerheden i den tid som det tager
RAID-softwaren at opbygge et nyt spejl på reservedisken.
</para>

<sect3 id="spejlet-raid-howto">
<title>Fremgangsmåde</title>

<para>
Start i enkeltbrugertilstand - (<command>linux s</command> ved opstart eller
<command>init 1</command>).
</para>

<para>
Opret partitionen på begge diske med <command>fdisk</command>. Filsystemet
skal være "Linux RAID autodetect". Skriv enhedens nummer ned.
</para>

<para>
Opret en <filename>/etc/raidtab</filename>-fil, med indhold som
kunne se således ud:
</para>

<programlisting>
raiddev               /dev/md0
raid-level                   1
nr-raid-disks                2
chunk-size                   8
persistent-superblock        1
nr-spare-disks               0
    device           /dev/sdc1
    raid-disk                0
    device           /dev/sdd1
    raid-disk                1         
</programlisting>


<para>
Opret RAID-enheden med kommandoen <command>mkraid /dev/md0</command>.
</para>

<para> 
Opret filsystemet til din logiske enhed
<filename>/dev/md0</filename> med kommandoen <command>mkfs /dev/md0</command>.
</para>

<para> 
Montér det logiske drev med f.eks. <command>mount /dev/md0 /spejl</command>
</para>

<para> 
 Opret en linje i <filename>/etc/fstab</filename> svarende til det nye spejl.
</para>

<programlisting>
/dev/sda1  /           ext2    defaults        1 1
/dev/md0   /Spejl      ext2    defaults        1 2
/dev/sda5  /home       ext2    defaults        1 2
/dev/cdrom /mnt/cdrom  iso9660 noauto,owner,ro 0 0
/dev/sdb5  /vol2       ext2    defaults        1 2
/dev/sdb1  swap        swap    defaults        0 0
/dev/fd0   /mnt/floppy ext2    noauto,owner    0 0
none       /proc       proc    defaults        0 0
none       /dev/pts    devpts  gid=5,mode=620  0 0
</programlisting>


<para>
Har du tidligere haft et RAID-system sat op på diskene, skal du bruge
<command>mkraid --force /dev/md0</command> til at initialisere 
diskene igen, også selvom de er slettede med fdisk. Husk dog at tage
backup (f.eks. <command>tar pcfz data.tar.gz /mount/data</command>, 
før du anvender 
<command>mkraid --force /dev/md0</command>, da RAID-diskene slettes
derved.
</para>

</sect3>
</sect2>

<sect2 id="linear-raid">
<title>Opsætning af linear RAID</title>
<indexterm>
 <primary>linear RAID</primary>
</indexterm>
<indexterm>
 <primary>RAID</primary>
 <secondary>linear</secondary>
</indexterm>

<para>
Betegnelsen <emphasis>Linear RAID</emphasis> betyder, at man 
ønsker at slå flere diske sammen til én logisk
enhed og udnytte den samlede disk kapacitet. Det giver ikke større 
data-sikkerhed - kun større samlet plads.
Et eksempel på en <filename>/etc/raidtab</filename>
hvor 2 diske som slås sammen er følgende:
</para>


<programlisting>
raiddev                /dev/md0
raid-level             linear
nr-raid-disks          2
chunk-size             8
persistent-superblock  1
nr-spare-disks         0
    device             /dev/sdc1
    raid-disk          0
    device             /dev/sdd1
    raid-disk          1         
</programlisting>
</sect2>


<sect2 id="raidhotadd-remove">
<title>raidhotadd og raidhotremove</title>
<indexterm>
 <primary>RAID</primary>
 <secondary>raidhotadd og raidhotremove</secondary>
</indexterm>

<indexterm>
 <primary>raidhotremove -a </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>raidhotremove -a</secondary>
</indexterm>

<indexterm>
 <primary>raidhotadd -a </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>raidhotadd -a </secondary>
</indexterm>

<para>
Det er muligt at tilføje og fjerne diske fra RAID-systemet medens systemet
kører. Det kan være en god ting, hvis filsystemet af en eller anden
grund er gået i stykker på den ene af diskene. Det kan
ske uden at disken rent fysisk har fejlet.
</para>



<para> 
<emphasis>Fjern disk</emphasis>
</para>

<para>
F.eks. fjern disken <filename>/dev/hdd1</filename> fra RAID-systemet:
</para>

<screen>
<prompt>[root@linus /etc]# </prompt><userinput>raidhotremove -a /dev/md0 /dev/hdd1</userinput>
</screen>

<para>
Nu kan man arbejde på disken med <command>fdisk</command>.
</para>

<para> 
<emphasis>Tilføj disk</emphasis>
</para>

<para>
Disken som er blevet repartitioneret, kan tages i brug således:
</para>

<screen>
<prompt>[root@linus /etc]# </prompt><userinput>raidhotadd -a /dev/md0 /dev/hdd1</userinput>
</screen>

<para>
RAID-systemet vil automatisk blive opdateret, og et evt. spejl vil blive
genopbygget medens produktionen kører, performance-nedgangen er lille
selv ved IDE-diske.
</para>

</sect2>
</sect1>

<sect1 id="harddisk-tuning">
<title>Harddisk-tuning</title>
<indexterm><primary>Harddisk</primary><secondary>tuning af hastighed</secondary></indexterm>
<indexterm><primary>UDMA</primary><secondary>tuning af harddisk</secondary></indexterm>
<indexterm><primary>DMA</primary><secondary>tuning af harddisk</secondary></indexterm>
<indexterm><primary>hdparm</primary></indexterm>
<indexterm><primary>/sbin/hdparm</primary></indexterm>
<para>
Har du brug for at få ekstra "tryk" på din IDE-harddisk,
så kan du bruge <command>hdparm</command> til at tune hastigheden.
Her er givet de to vigtigste parametre (bruge DMA og lookahead), som
nærmest alle nyere diske understøtter. Der kan tunes endnu mere - have
fun! :-)
</para>

<para>
 <indexterm>
  <primary>start af systemet</primary>
  <secondary>kørsel af programmer ved</secondary>
 </indexterm>

 <indexterm>
  <primary>systemstart</primary>
  <secondary>kørsel af programmer ved</secondary>
 </indexterm>

 <indexterm>
  <primary>opstart af systemet</primary>
  <secondary>kørsel af programmer ved</secondary>
 </indexterm>

 <indexterm>
  <primary>boot (systemstart)</primary>
  <secondary>kørsel af programmer ved</secondary>
 </indexterm>

 Når det virker fint, kan og bør du lægge kommandoerne ind i filer, der
 køres når systemet startes op. I Red Hat f.eks. i bunden af
 <filename>/etc/rc.local</filename> (SuSE
 <filename>/etc/rc.d/boot.local</filename>).
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/sbin/hdparm -tT /dev/hda</userinput>
 
/dev/hda:
 Timing buffer-cache reads:   128 MB in  3.21 seconds = 39.88 MB/sec
 Timing buffered disk reads:  64 MB in 10.14 seconds =  6.31 MB/sec
</screen>

<para>
Den første og sidste kommando måler hastigheden på harddisken. Der kommer to 
tal. Det første "buffer-cache" er reelt et mål for processor- og bushastighed, 
mens det andet tal angiver I/O fra disken. 
</para>

<para>
For de fleste diske er den standardopsætning du har fin, men får du væsentligt
mindre på det andet tal (se ovenfor), så skal du i gang med at lege :-)
</para>

<para>
Start med at notere hvordan dine parametre er nu (og som virker):
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/sbin/hdparm /dev/hda</userinput>

/dev/hda:
 multcount    = 16 (on)
 I/O support  =  0 (default 16-bit)
 unmaskirq    =  0 (off)
 using_dma    =  0 (off)
 keepsettings =  0 (off)
 nowerr       =  0 (off)
 readonly     =  0 (off)
 readahead    =  8 (on)
 geometry     = 39703/16/63, sectors = 40020624, start = 0
</screen>


<para>
Nogle af de parametre du kan dreje på er følgende:
</para>

<itemizedlist mark="bullet">

<listitem> 
 <para>
-u[0|1] Styrer interrupt-masker for disken. Det er noget der giver en del.
 </para>
</listitem>

<listitem>
 <para>
-m[tal] »Multiple sector«-tilstand (dvs. IDE Block Mode), er om man kan hente mere data pr. gang. De fleste chipsæt understøtter nu dette. 2, 4, 8, 16 og 32 er lovlige værdier. 16 eller 32 er nok interessant for de fleste. 
 </para>
</listitem>


<listitem>
 <para>
-d[0|1] er tilkobling/fravalg af DMA-overførsel. Dette genkendes 
oftest automatisk, og sættes default til -d1 hvis det er muligt.
 </para>
</listitem>

<listitem> 
 <para>
-X[tilstand] sættes til højest mulige hastighed pr. default.
Anvend -X66 for UltraDMA-tilstand 2, -X67 for UltraDMA-tilstand 3 osv. 
Dog er UltraDMA-tilstand 3, 4 og 5 meget eksperimentelle.
 </para>
</listitem>

<listitem> 
 <para>
-c[0|1|2|3] E)IDE 32-bit I/O-support. 
0 for at fravælge 32-bit I/O-support, 
1 for at tilkoble 32-bit dataoverførsel og 
3 for 32-bit dataoverførsel med synkronisering (mange chipsæt kræver dette. 
 </para>
</listitem>
</itemizedlist>


<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/sbin/hdparm -u1 -m16 -c3 -d1 -X66 /dev/hda</userinput>

/dev/hda:
 setting 32-bit I/O support flag to 3
 setting multcount to 16
 setting unmaskirq to 1 (on)
 setting using_dma to 1 (on)
 setting xfermode to 66 (UltraDMA mode2)
 multcount    = 16 (on)
 I/O support  =  3 (32-bit w/sync)
 unmaskirq    =  1 (on)
 using_dma    =  1 (on)

<prompt>[root@linus /root]#</prompt> <userinput>/sbin/hdparm -tT /dev/hda</userinput>
/dev/hda:
 Timing buffer-cache reads:   128 MB in  3.23 seconds = 39.63 MB/sec
 Timing buffered disk reads:  64 MB in  5.76 seconds = 11.11 MB/sec
</screen>


<para>
I eksemplet giver jeg kommandoer
som passer til de nyere Ultra DMA 66-controllere, og får derved en lidt højere hastighed.
Målefunktionen bør dog køres en del gange før man kan få en statistisk korrekt
vurdering af ydelsen. Du skal være opmærksom på, at du kan låse din maskine, 
hvis du angiver mere end hvad din maskine kan yde. I praksis ser du nok 
et reboot hvis du går for langt. Tilføj den endelige optimale opsætning til 
<filename>/etc/rc.local</filename> (SuSE <filename>/etc/rc.d/boot.local</filename>) eller tilsvarende opstartsfil, når du er 
sikker på at maskinen kører godt. Se også <command>man hdparm</command>.
</para>

<para>
Med Red Hat kan du justere i filerne: <filename>/etc/sysconfig/harddiskhd[a-h]</filename> og så gør <filename>/etc/rc.sysinit</filename> resten ved 
systemstart. Udfør <command>cp /etc/sysconfig/harddisks /etc/sysconfig/harddiskhdX</command>, hvor X er a, b, c osv. for hda, hdb, hdc osv.
Der er følgende parametre: 
</para>

<programlisting>
USE_dma=1    
# det samme som -d1 
# brug DMA   fra = 0, til = 1

lookahead=1
# det samme som -A1 

MULTIPLE_io=16
# det samme som -m16 

EIDE_32bit=3

EXTRA_params= -X69  
# -X69 UDMA5 for ATA/100 
# UDMAX er -X(64 + X) hvor X er et number 1-5.
</programlisting>

<para>
Læs også Red Hat 7.1-filen <filename>/etc/sysconfig/harddisks</filename> hvor 
generel opsætning kan laves for alle diske.
</para>

<para>
Samme program, <command>hdparm</command>, kan bruges til at få
harddisken til at spinne ned i hastighed - f.eks. efter 5
sekunder. Det betyder mere slid på harddisken, men din maskine
bliver stille. 
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/sbin/hdparm -S 1 /dev/hda</userinput>
</screen>

<para>
Hvis man har et eller flere programmer der jævnligt tjeker om nogle filer
er ændret skal disse filers access-tid også opdateres jævnligt - det
giver skrivninger til disken selvom filsystemets egentlige data ikke ændres
(kun dets meta-data). Det kan være en god idé at montere disken via <filename>/etc/fstab</filename> noget i stil med
</para>

<programlisting>
/dev/hda1  /  ext2  defaults,noatime  1 1
</programlisting>


<para>
Kernens IDE-driver skal understøtte det IDE-chipsæt, der anvendes af
bundkortet, og ikke alle IDE-chipsæt er understøttet med (U)DMA. Så
hvis en given funktion ikke tillades af <command>hdparm</command>, så
kan det være forklaringen.
</para>

<para>
<command>hdparm</command> har kun begrænset anvendelse med scsi. 
Til scsi skal man dels
se på driveren, dvs. tilføje eventuelle modulparametre. Symbios
scsi-driverne kan dog fintunes via <command>/proc/scsi</command> under
drift. Et nyttigt grafisk værktøj til at tune scsi-diske er
<command>scsi-config</command>, selvom der normalt ikke er så meget at
"tune".
</para>

<para>
Du kan måske også være interesseret i at se mere på 
<ulink url="http://www.iozone.org/">http://www.iozone.org/</ulink>
hvor der er et program til at benchmark-teste harddisk-ydelse.
</para>

<para>
Mere info om <command>hdparm</command> kan finds på
<ulink url="http://linux.oreillynet.com/pub/a/linux/2000/06/29/hdparm.html">http://linux.oreillynet.com/pub/a/linux/2000/06/29/hdparm.html</ulink>.
</para>

</sect1>

<sect1 id="hvad-laver-hvad">
<title>Hvilke filer har programmet åbne?</title>

<indexterm><primary>Fil</primary><secondary>åbne</secondary></indexterm>
<indexterm><primary>lsof</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>lsof </secondary></indexterm>
<indexterm><primary>/sbin/lsof</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>/sbin/lsof </secondary></indexterm>
<indexterm><primary>fuser</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>fuser </secondary></indexterm>
<indexterm><primary>/sbin/fuser</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>/sbin/fuser </secondary></indexterm>
<indexterm><primary>pid</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>pid </secondary></indexterm>
<indexterm><primary>ps aux</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>ps aux </secondary></indexterm>
<indexterm><primary>process-ID</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>pidof </secondary></indexterm>
<indexterm><primary>pidof </primary></indexterm>

<sect2 id="lsof">
<title>lsof</title>
<para>
Ofte vil dit program have filer åbne som du måske ikke lige
vidste. Med <command>lsof</command> kan du se hvad der sker. Vi kan
f.eks. se hvad programmet arbejder med. Som eksempel kan vi se hvad
der sker, når man har <command>ping</command> kørende. Først finder vi
den <emphasis>pid</emphasis> - proces-ID - som <command>ping</command>
kører med. Der er mindst to muligheder, enten med <command>ps
aux</command> eller <command>pidof</command>.
</para>


<screen>
<prompt>[root@linus /root]#</prompt> <userinput>ps aux | grep ping</userinput>
pto       9149  0.0  0.1  1264  228 pts/4    S    Apr29   0:00 ping eric
root      9418  0.0  0.4  1360  516 ttyp0    S    00:06   0:00 grep ping
<prompt>[root@linus /root]#</prompt> <userinput>pidof ping</userinput>
9149
<prompt>[root@linus /root]#</prompt> <userinput>lsof -p 9149</userinput>
COMMAND PID USER  FD TYPE DEVICE    SIZE   NODE NAME
ping   9149 root cwd  DIR    3,7    4096  30919 /home/pto/tmp
ping   9149 root rtd  DIR    3,5    4096      2 /
ping   9149 root txt  REG    3,5   17968 114094 /bin/ping
ping   9149 root mem  REG    3,5  340663  16023 /lib/ld-2.1.3.so
ping   9149 root mem  REG    3,5  169720  16071 /lib/libresolv-2.1.3.so
ping   9149 root mem  REG    3,5 4101324  16030 /lib/libc-2.1.3.so
ping   9149 root mem  REG    3,5  246652  16061 /lib/libnss_files-2.1.3.so
...
</screen>

<para>
Så man kan se, at programmer har fat i mange filer. Det skal nævnes at
<command>pidof</command> kræver at SysVinit-pakken er installeret og
stien til <command>pidof</command> varierer desværre alt efter
Linux-distribution. Det skal også nævnes, at <command>ps aux</command>
bruges på en Linux-maskine, mens mange andre Unix-varianter anvender
<command>ps -ef</command>.
</para>

<para>
Tilsvarende kan man have stor glæde af at kunne se, hvilke programmer
der har filer åbne under et givet katalog i filtræet. Det er meget
relevant ved afmontering af f.eks. cd-rom-drev. Prøv følgende:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>lsof +D /var/spool</userinput>
COMMAND  PID USER   FD   TYPE DEVICE SIZE  NODE NAME
atd      459 root  cwd    DIR    3,5 4096 32594 /var/spool/at
crond    473 root  cwd    DIR    3,5 4096    12 /var/spool/
lpd     9299 root    4w   REG    3,5    5  4507 /var/spool/lpd/lpd.lock
</screen>

<para>
Eksemplet viser, at der er tre programmer <command>at</command>,
<command>crond</command> og <command>lpd</command> som pt. anvender
filer under <filename>/var/spool</filename>. Meget nyttige ting for en
systemadministrator.
</para>
</sect2>

<sect2 id="fuser">
<title>fuser</title>

<para>
Et tilsvarende nyttigt program til nogenlunde samme formål er
<command>/sbin/fuser DEVICE</command>. F.eks. kan man se hvilket
proces-ID, som låser lydenheden <filename>/dev/dsp</filename> ved at skrive
<command>/sbin/fuser /dev/dsp</command>. Med <command>/sbin/fuser -k
/dev/dsp</command> kan man endda direkte dræbe den proces som låser
enheden.
</para>
</sect2>

<sect2 id="proc-afmontering">
<title>Afmontering af filsystem via /proc</title>
<indexterm><primary>/proc</primary>
<secondary>Problem med afmontering af filsystem</secondary></indexterm>

<para>
Et alternativ til ovenstående er at anvende <filename>/proc/</filename>.
Antag at man vil afmontere <filename>/usr/src/postgresql-7.2.1/</filename>
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>umount /usr/src/postgresql-7.2.1/</userinput>
umount: /usr/src/postgresql-7.2.1: device is busy
</screen>

<para>
Hvem pokker er synderne?
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>ls -l /proc/*/cwd|grep /usr/src/postgresql-7.2.1/</userinput>
lrwxrwxrwx 1 postgres postgres 0 Apr 30 03:49 /proc/3943/cwd -> /usr/src/postgresql-7.2.1/
lrwxrwxrwx 1 postgres postgres 0 Apr 30 03:49 /proc/3944/cwd -> /usr/src/postgresql-7.2.1/
lrwxrwxrwx 1 postgres postgres 0 Apr 30 03:49 /proc/3950/cwd -> /usr/src/postgresql-7.2.1/
</screen>

<para>
Aha! Det er således processerne 3943 3944 3950 som låser filsystemet.
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>kill -9 3943 3944 3950</userinput>
</screen>


<para>
Nogen kunne sikkert lave et script, der gjorde dræbningen nemmere:
</para>

<programlisting>
perl -e '$dir=shift; map {m:/proc/(\d+)/cwd -> $dir[/\n]: and do {print
"$1\n"; kill 9, $1 } } `ls -l /proc/*/cwd`' /usr/src/postgresql-7.2.1/
</programlisting>

</sect2>
</sect1>

<!-- Skrevet af Ole Tange -->
<sect1 id="fejlfinding">
<title>Fejlfinding</title>

<indexterm><primary>strace</primary></indexterm>
<indexterm><primary>emacs</primary><secondary>strace</secondary></indexterm>
<indexterm><primary>debugge programmer</primary></indexterm>
<indexterm><primary>fejlfinding af programmer</primary></indexterm>

<para>
Nogle gange er programmer ret dårlige til at forklare, hvorfor det gik
galt. Kommandoen <command>strace</command> er god til at fejlsøge
med. Det gælder specielt ved fejl som:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
Segmentation fault (core dumped)
 </para>
</listitem>
<listitem>
 <para>
File not found
 </para>
</listitem>
<listitem> 
 <para>
Access denied
 </para>
</listitem>
</itemizedlist>

<para>
Her vil <command>strace</command> ofte kunne give dig en idé om, hvad
der skete lige inden fejlen indtrådte, og med lidt held kan du ud af
dette gætte, hvad der gik galt. Måske mangler du en fil eller måske
bruger programmet den forkerte version af et library.
</para>

<para>
<command>strace</command> står for system trace og viser alle de kald,
der er til library-rutiner. Hvis man vil se, hvilke kald
<command>ls</command> laver, så skriver man:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>strace ls</userinput>
</screen>

<para>
Det går hurtigt op for een, at der kommer <emphasis>ret</emphasis>
meget output. Da problemerne ofte er fil-relateret, så kan man nøjes
med at få vist de fil-relaterede systemkald:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>strace -e trace=file ls</userinput>
</screen>

<para>
Hvis programmet starter andre processer (f.eks. ved at kalde andre
programmer), så kan man strace disse med '-ff'. Prøv at se forskellen
på disse to:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>strace time ls</userinput>
<prompt>[tyge@hven ~]$</prompt> <userinput>strace -ff time ls</userinput>
</screen>

<para>
Hvis du strace'r programmer, der kører under X, så vil du ofte få
utroligt meget output. Du kan proppe det i en fil ved at redirigere
stderr:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput> strace -ff time ls 2&gt;/tmp/fil</userinput>
</screen>

<para>
En anden mulighed er at starte <command>strace</command> fra en shell
i <command>emacs</command>:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>emacs</userinput>
M-x shell
<prompt>[tyge@hven ~]$</prompt> <userinput>strace ...</userinput>
</screen>

<para>
Herved får du mulighed for at bladre i outputtet med det samme.
</para>
</sect1>

</chapter>
