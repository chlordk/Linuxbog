<chapter id="filsystemer">
<title>Filsystemer</title>
<indexterm><primary>Filsystemer</primary></indexterm>
<indexterm><primary>Filsystemer</primary>
  <secondary>ext2</secondary></indexterm>
<indexterm><primary>ext2</primary></indexterm>
<para>
Linux bruger som standard et filsystem kaldet
<emphasis>ext2</emphasis> (Extended file system version 2), men kan
også læse fra og skrive til mange andre filsystemer, f.eks. FAT-baserede
filsystemer, der bruges af DOS og Windows.
</para>

<indexterm>
 <primary>mkfs</primary>
</indexterm>

<indexterm>
  <primary>Harddisk</primary>
  <secondary>Formatering af harddisk</secondary>
</indexterm> 
 <!-- Formatering med: /sbin/mke2fs -->


<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mkfs, Oprette filesystem </secondary>
</indexterm>
<indexterm>
 <primary>Filsystem</primary>
 <secondary>Oprette</secondary>
</indexterm>

<para>
Generelt formateres et filsystem under Linux ved at benytte kommandoen
<command>mkfs</command> (MaKe File System). Har du en uformateret
partition (her <filename>/dev/hda5</filename>), som du ønsker at
formatere, sker formateringen ved at skrive (som root):
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>mkfs /dev/hda5</userinput>
</screen>

<para>
Programmet <command>mkfs</command> finder selv ud af, hvilket filsystem
du har valgt til den ønskede partition, idet denne oplysning findes i
partitionstabellen.
</para>

<para>
Når din computer går ned (ja, det sker, f.eks. når strømmen går), kan
du komme ud for at dine filsystemer er i en fejlbehæftet tilstand. Det
kan dog ofte reddes af programmet <command>fsck</command> (File
System ChecK). Faktisk
køres dette program altid ved opstart for at sikre at alle filsystemer
er i en god tilstand.
</para>

<para>
Vi du køre filcheck manuelt på en ext2-partition, så kan du direkte
bruge <command>e2fsck</command>:
</para>
<indexterm><primary>fsck</primary></indexterm>
<indexterm><primary>e2fsck</primary></indexterm>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/sbin/e2fsck /dev/hda5</userinput>
</screen>

<!-- skrevet af Hanne Munkholm http://www.linuxlab.dk/fcl/technotes/badblocks.php -->
<!-- Senere udvidet og rettet af Jacob Sparre Andersen. -->
<sect1 id="bad-blocks">
 <title>Defekte blokke på harddisken</title>

 <indexterm>
  <primary>badblocks</primary>
 </indexterm>

 <indexterm>
  <primary>e2fsck</primary>
 </indexterm>

 <indexterm>
  <primary>defekte blokke på harddisk</primary>
 </indexterm>

 <indexterm>
  <primary>harddisk</primary>
  <secondary>defekte blokke</secondary>
 </indexterm>

 <para>
  Hvis man har en harddisk med defekte blokke på så bliver man nødt
  til at finde dem og få filsystemet til at gå uden om.  I det
  følgende gives en vejledning i at gøre dette.
 </para>

 <sect2 id="starte-alternativt-system">
  <title>Starte maskinen uden om harddisken(e)</title>

  <para>
   Hvis du har en Red Hat-cdrom, kan du starte maskinen fra den. Det
   kan kræve en ændring i opsætningen af din BIOS-opsætning, som vi
   dog ikke vil komme ind på her. Når der kommer en LILO-promt frem
   skriver du: "linux rescue".
  </para>

  <para>
   Redningsproceduren (eng. rescue) vil bede om at få sprog og
   tastatur valgt - eksakt som det gøres ved en egentlig
   installation. Bare rolig - det er ikke en installation vi starter
   på. Når redningsproceduren beder om at montere rod-filsystemet
   under <filename>/mnt/sysimage</filename> skal der bare svares "no"
   (nej), og derefter får man en kommandofortolker.
  </para>

  <para>
   Hvis du i stedet har et "bootable business card" fra Linuxcare (det
   er en cdrom i visitkort-størrelse), skal du igen starte maskinen
   fra den. Når systemet er startet får du besked om hvad visitkortets
   brugernavn og adgangskode er (på mit er det henholdsvis "root" og
   "linuxcare") og bliver bedt om at logge ind. Et lille
   irritationsmoment ved Linuxcares cdrom er at det går ud fra at der
   sidder et amerikansk tastatur på maskinen, så tasterne ikke
   nødvendigvis giver det tegn der er trykt på dem.
   <!-- Hvornår får vi tastaturer, der sender ISO-10646-koden for de
        tegn der er vist på deres taster, i stedet for meningsløse
        koder? -->
  </para>
 </sect2>

 <sect2 id="hvilke-filsystemer-skal-tjekkes">
  <title>Hvilke filsystemer skal tjekkes?</title>

  <para>
   Linuxcare-cdrom'en vil give dig en liste med de tilgængelige filsystemer
   når du er logget ind. Den kan for eksempel se sådan ud:
<screen>
...
/dev/cloop on /mnt/cdrom type ext3 (ro)
/dev/hda2 on /mnt/0 type ext2 (ro)
/dev/hda3 on /mnt/1 type ext2 (ro)
...
</screen>
   Du vil typisk være interesseret i de filsystemer, der er monterede
   som <filename>/mnt/</filename>-et-eller-andet-tal, og som er af
   typen "ext2". Vi kan foreksempel være interesserede i filsystemet
   på partitionen <filename>/dev/hda2</filename>.
  </para>

  <para>
   Hvis du ikke automatisk får en liste med hvad der er af filsystemer
   i maskinen, kan du bruge kommandoen <command>mount</command> til at
   få oplysninger om hvilke filsystemer der er monterede:
</para>

<screen>
<prompt>[root@lnx-bbc ~]# </prompt><userinput>mount</userinput>
/dev/sda2 on / type ext2 (rw) []
none on /proc type proc (rw)
/dev/sda3 on /boot type ext2 (rw) []
/dev/vg1/lv_home on /home type ext2 (rw)
/dev/vg1/lv_usr on /usr type ext2 (rw)
none on /dev/pts type devpts (rw,gid=5,mode=620)
/dev/hdb1 on /backup type ext2 (rw) []
</screen>

<para>
   Og hvis det ikke giver nok oplysninger, kan du bruge kommandoen
   <command>fdisk</command> til at spørge til partitioneringen af dine
   diske. IDE-diske (det typiske i skrivebordsmaskiner) har i Linux
   navnene <filename>/dev/hd</filename>-et-eller-andet-bogstav. Et
   linux-systems anden IDE-disk hedder således
   <filename>/dev/hdb</filename> og du kan spørge til dens opdeling
   med kommandoen:
</para>

<screen>
<prompt>[root@lnx-bbc ~]# </prompt><userinput>fdisk -l /dev/hdb</userinput>

Disk /dev/hdb: 16 heads, 63 sectors, 59560 cylinders
Units = cylinders of 1008 * 512 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hdb1             1     59560  30018208+  83  Linux
</screen>
 </sect2>

 <sect2 id="finde-og-maerke-daarlige-blokke">
  <title>Finde og mærke dårlige blokke</title>

  <para>
   Kør nu kommandoen <command>badblocks -o /tmp/blocks
   /dev/hda5</command> hvor <filename>hda5</filename> erstattes af den
   partition man ønsker at tjekke for defekte blokke, og
   <filename>/tmp/blocks</filename> er et arbitrært valgt filnavn.
  </para>

  <para>
   Ældre udgaver af programmet <command>badblocks</command> skal have
   at vide hvor mange blokke der er på den partition der skal
   tjekkes. Den oplysning kan man få ved at bede
   <command>fdisk</command> om en liste med alle partitionerne på den
   relevante disk. Den disk partitionen <filename>/dev/hda2</filename>
   ligger på hedder <filename>/dev/hda</filename> (man stryger altså
   bare nummeret):
   </para>


<screen>
<prompt>[root@lnx-bbc ~]# </prompt><userinput>fdisk -l /dev/hda</userinput>
...
   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        70    529168+  82  Linux Swap
/dev/hda2   *        71       487   3152520   83  Linux
...
</screen>

<para>
   Det er tallet <literal>3152520</literal> vi er ude efter. Det føjes
   til som et sidste argument til <command>badblocks</command>:
</para>
<screen>
<prompt>[root@lnx-bbc ~]# </prompt><userinput>badblocks -o /tmp/blocks /dev/hda 3152520</userinput>
</screen>
  

  <para>
   Derefter <emphasis>kan</emphasis> man læse filen med <command>cat
   /tmp/blocks</command> for at se om der blev fundet nogle defekte
   blokke. Hvis der ikke blev fundet nogen, så behøver man ikke at
   fortsætte.
  </para>

  <para>
   Hvis der blev fundet defekte blokke skal du dernæst køre kommandoen
   <command>e2fsck -l /tmp/blocks /dev/hda5</command>.  Den indsætter
   listen over de defekte blokke fra <filename>/tmp/blocks</filename>
   i filsystemets liste med defekte blokke. Til sidst taster du
   "Ctrl-d" for at komme ud af kommandofortolkeren og genstarte
   maskinen.  Husk at tage din cdrom ud.
  </para>

  <para>
   Herefter vil maskinen ikke længere prøve at bruge de defekte blokke
   <command>badblocks</command> fandt på harddisken.  Du kan finde en
   mere information om de kommandoerne med <command>man
   badblocks</command> og <command>man e2fsck</command>.
  </para>

<para>
Se også <ulink url="http://www.redhat.com/mailing-lists/ext3-users/msg02454.html">http://www.redhat.com/mailing-lists/ext3-users/msg02454.html</ulink> for mere information om emnet.
</para>

 </sect2>
</sect1>


<sect1 id="reiserFS">
<title>ReiserFS</title>
<indexterm><primary>ReiserFS</primary></indexterm>

<indexterm>
 <primary>Filsystemer</primary>
 <secondary>ReiserFS</secondary>
</indexterm>
<indexterm>
 <primary>Filsystemer</primary>
 <secondary>ext2</secondary>
</indexterm>
<indexterm>
 <primary>mkreiserfs</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mkreiserfs</secondary>
</indexterm>
<indexterm>
 <primary>mount -t reiserfs</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mount -t reiserfs</secondary>
</indexterm>


<para>
ReiserFS er et af de nyere filsystemer til Linux. Faktisk er det så nyt,
at det endnu ikke er en del af den officielle kerne. Før kerne
2.4 var det kun være det gamle velafprøvede ext2-filsystem, som 
kernen understøttede officielt, men med kerne
2.4.1 og senere er ReiserFS også med.
</para>

<para>
ReiserFS er en anden type filsystem end den der kendes fra Linux'
ext2, og DOS/Windows' FAT-drev, idet ReiserFS er et journaliserende
filsystem. Det betyder, at alle filer til en hver tid er
opdaterede. Det betyder, at hvis din computer går ned pga. en
strømafbrydelse, vil du ikke miste data. Endvidere betyder det, at de
partitioner som er formateret ved hjælp af ReiserFS, ikke skal tjekkes
ved opstart. Hvis du har meget store harddiske vil det betyde at du
får en meget kortere opstartstid. Dette kan være vigtigt, hvis din
computer er server med f.eks. 100 Gb harddisk (ikke ualmindeligt i den
virkelige serververden).
</para>

<para>
Tidligere versioner af ReiserFS ville ikke virke med Lilo-boot fra en
ReiserFS-partition. Det kunne løses ved at lægge
<filename>/boot</filename> på en ext2-partition, og hvis
<filename>/boot</filename> er en lille selvstændig partition, kan
<filename>/</filename>-partitionen være ReiserFS-formateret.
I de nyeste versioner af ReiserFS (november 2000) bør denne
begrænsning være væk, blot man monterer boot-partitionen med et ekstra
flag, "<literal>notail</literal>":
</para>

<programlisting>
/dev/hda2 on / type reiserfs (rw,notail)
</programlisting>


<para>
ReiserFS følger med Mandrake (fra version 7.1) og SuSE (fra
6.4) og under disse distributioner er det let at vælge
formatering med ReiserFS i stedet for ext2 under
installationen.
Men selv under andre distributioner er det ikke
svært. Du skal sikre dig, at kernen understøtter ReiserFS som
filsystem. Måske skal du omkonfigurere din kerne (se også <xref
linkend="kernelcompile">). Det kan godt betale sig at få ReiserFS
oversat som et kernemodul. Modulsystemet vil typisk selv finde ud af,
at modulet skal bruges, dvs. når du begynder at bruge kommandoer som
involverer en ReiserFS-baseret partition, vil modulet automatisk blive
indlæst.
</para>

<para>
Først og fremmest skal du have en partition, som er tom. Du kan 
oprette en partition til formålet. Her kan du bruge programmer som 
<command>fdisk</command> og <command>cfdisk</command>. Når du har 
en partition klar, skal du formatere den. I eksemplet benytter vi
partitionen <filename>/dev/hda5</filename>, som vi antager allerede er 
oprettet.
</para>

<para>
<screen>
<prompt>[root@linus root]#</prompt> <userinput>mkreiserfs /dev/hda5</userinput>
<-----------MKREISERFS, 1999----------->
ReiserFS version 3.5.18
Block size 4096 bytes
Block count 325576
First 16 blocks skipped
Super block is in 16
Bitmap blocks are : 
   17, 32768, 65536, 98304, 131072, 163840, 196608, 229376, 262144, 294912
Journal size 8192 (blocks 18-8210 of device 0x3:0x5)
Root block 8211
Used 8221 blocks
ATTENTION: ALL DATA WILL BE LOST ON '/dev/hda5'! (y/n) <userinput>y</userinput>
Initializing journal - 0%....20%....40%....60%....80%....100%
Syncing..

ReiserFS core development sponsored by SuSE Labs (suse.com)

Journaling sponsored by MP3.com.

Item handlers sponsored by Ecila.com

To learn about the programmers and ReiserFS, please go to
http://www.devlinux.com/namesys

Have fun.
<prompt>[root@linus ~]#</prompt>
</screen>
</para>

<para>
Du er nu klar til at montere din partition. Følgende vil montere partitionen
<filename>/dev/hda5</filename> som <filename>/home</filename>.
</para>

<para>
<screen>
<prompt>[root@linus ~]#</prompt> <userinput>mount -t reiserfs /dev/hda5 /home</userinput>
Checking ReiserFS transaction log (device 03:35)  ...
Relayed 0 transaction in 0 seconds
ReiserFS version 3.5.18
</screen>
</para>

<para>
Naturligvis kan du indsætte din nye partition i filen
<filename>/etc/fstab</filename> med typen
<emphasis>reiserfs</emphasis>. Derved vil partitionen blive monteret
under opstart.
</para>

<indexterm>
 <primary>ext2</primary>
 <secondary>sammenligning med journaliserende filesystemer</secondary>
</indexterm>

<para>
En glimrende oversigtsartikel, der sammenligner det gamle ext2, det
nyere ext3, ReiserFS og endelige XFS kan læses på 
<ulink url="http://www.linuxgazette.com/issue68/dellomodarme.html">http://www.linuxgazette.com/issue68/dellomodarme.html</ulink>. En nyere sammenligning kan findes på <ulink url="http://aurora.zemris.fer.hr/filesystems/">http://aurora.zemris.fer.hr/filesystems/</ulink>. Se også <ulink url="http://www.namesys.com/benchmarks/benchmark-results.html">http://www.namesys.com/benchmarks/benchmark-results.html</ulink>.
</para>

<indexterm>
 <primary>ext3</primary>
</indexterm>
<indexterm>
 <primary>ext2</primary>
 <secondary>ext3 migrering</secondary>
</indexterm>

<para>
Hvis du ønsker at migrere fra ext2 til ext3 (primært for Red Hat
7.2-brugere), så kan man på <ulink url="http://www.symonds.net/~rajesh/howto/ext3/index.html">http://www.symonds.net/~rajesh/howto/ext3/index.html</ulink> finde en vejledning til dette.
</para>


</sect1>

<sect1 id="software-raid">
<title>Software-RAID</title>
<indexterm><primary>RAID</primary></indexterm>
<!-- Skrevet af peter_frederiksen@danbbs.dk -->
<!-- sprog rettet lidt til : pto -->

<sect2 id="hvad-er-raid">
<title>Hvad er RAID?</title>
<para>
RAID er en metode til at slå flere diske sammen til én
<emphasis>volume</emphasis> (dvs. én logisk disk); det kan gøres for
at opnå et større brugerdrev eller for at højne sikkerheden ved
redundans.
</para>

<para>
Derfor er der flere måder at kombinere diske til et RAID, og man har
derfor vedtaget nogle RAID-levels.
</para>
</sect2>

<sect2 id="hw-sw-raid">
<title>Forskel mellem hardware- og software-RAID</title>

<para>
RAID kan laves hardware- eller software-mæssigt. Det sikreste
er via hardware eller med andre ord en RAID-controller.
</para>

<sect3 id="Hardwareraid">
<title>Hardware-RAID</title>
<indexterm><primary>RAID</primary><secondary>Hardware</secondary></indexterm>

<para>
Ved at lade hardwaren styre diskene og "narre" styresystemet til at
tro at der er tale om et eller flere logiske drev, behøver man ikke at
bekymre sig så meget om opsætning af Linux, da hardwareproducenterne
som regel har en brugervenlig opsætningsmenu installeret i kortets
BIOS.
</para>

<para>
Ulempen er at disse kort som regel er dyre at anskaffe og ofte
benytter sig af de noget dyrere scsi-diske. Med andre ord: En
RAID-controller er ofte "bare" en avanceret scsi-controller.
</para>
</sect3>

<sect3 id="Softwareraid">
<title>Software-RAID</title>
<indexterm><primary>RAID</primary><secondary>Software</secondary></indexterm>

<para>
Her lader man et stykke software styre RAID, hvilket sparer en
RAID-controller og det er muligt at blande scsi-diske med IDE eller kun
benytte sig af IDE.
</para>

<para>
Ulempen er at man så selv skal konfigurere RAID og på Linux er
det lidt besværligt.
</para>
</sect3>
</sect2>


<sect2 id="spejlet-raid">
<title>Opsætning af spejlede diske.</title>
<indexterm>
 <primary>RAID</primary>
 <secondary>spejling</secondary>
</indexterm>
<indexterm>
 <primary>mkraid /dev/md </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mkraid /dev/md </secondary>
</indexterm>
<indexterm>
 <primary>mount /dev/md0 /spejl </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mount /dev/md0 /spejl </secondary>
</indexterm>
<para>
Et disk-spejl er hvis man ønsker 2 diske som en logisk enhed,
hvor begge diske indeholder samme data. Sikkerheden er her at hvis en
disk står af, så kører den anden videre.
</para>

<para>
Hvis man ønsker yderligere sikkerhed, kan man benytte en ekstra
reservedisk som vil kunne erstatte en nedbrudt disk i spejlet. På den
måde undværer man kun sikkerheden i den tid som det tager
RAID-softwaren at opbygge et nyt spejl på reservedisken.
</para>

<sect3 id="spejlet-raid-howto">
<title>Fremgangsmåde</title>

<para>
Start i singleuser-mode - (<command>linux s</command> ved opstart eller
<command>init 1</command>).
</para>

<para>
Opret partition med fdisk på begge diske. Filsystemet skal være
"Linux RAID autodetect". Skriv device-nummeret ned.
</para>

<para>
Opret en <filename>/etc/raidtab</filename>-fil, med indhold som
kunne se således ud:
</para>

<programlisting>
raiddev               /dev/md0
raid-level                   1
nr-raid-disks                2
chunk-size                   8
persistent-superblock        1
nr-spare-disks               0
    device           /dev/sdc1
    raid-disk                0
    device           /dev/sdd1
    raid-disk                1         
</programlisting>


<para>
Opret RAID-devicen med kommandoen <command>mkraid /dev/md0</command>.
</para>

<para> 
Opret filsystemet til din logiske enhed
<filename>/dev/md0</filename> med kommandoen <command>mkfs /dev/md0</command>.
</para>

<para> 
Montér det logiske drev med f.eks. <command>mount /dev/md0 /spejl</command>
</para>

<para> 
 Opret en linje i <filename>/etc/fstab</filename> svarende til det nye spejl.
</para>

<programlisting>
/dev/sda1  /           ext2    defaults        1 1
/dev/md0   /Spejl      ext2    defaults        1 2
/dev/sda5  /home       ext2    defaults        1 2
/dev/cdrom /mnt/cdrom  iso9660 noauto,owner,ro 0 0
/dev/sdb5  /vol2       ext2    defaults        1 2
/dev/sdb1  swap        swap    defaults        0 0
/dev/fd0   /mnt/floppy ext2    noauto,owner    0 0
none       /proc       proc    defaults        0 0
none       /dev/pts    devpts  gid=5,mode=620  0 0
</programlisting>


<para>
Har du tidligere haft et RAID-system sat op på diskene, skal du bruge
<command>mkraid --force /dev/md0</command> til at initialisere 
diskene igen, også selvom de er slettede med fdisk. Husk dog at tage
backup (f.eks. <command>tar pcfz data.tar.gz /mount/data</command>, 
før du anvender 
<command>mkraid --force /dev/md0</command>, da RAID-diskene slettes
derved.
</para>

</sect3>
</sect2>

<sect2 id="linear-raid">
<title>Opsætning af linear RAID</title>
<indexterm>
 <primary>linear RAID</primary>
</indexterm>
<indexterm>
 <primary>RAID</primary>
 <secondary>linear</secondary>
</indexterm>

<para>
Betegnelsen <emphasis>Linear RAID</emphasis> betyder, at man 
ønsker at slå flere diske sammen til én logisk
enhed og udnytte den samlede disk kapacitet. Det giver ikke større 
data-sikkerhed - kun større samlet plads.
Et eksempel på en <filename>/etc/raidtab</filename>
hvor 2 diske som slås sammen er følgende:
</para>


<programlisting>
raiddev                /dev/md0
raid-level             linear
nr-raid-disks          2
chunk-size             8
persistent-superblock  1
nr-spare-disks         0
    device             /dev/sdc1
    raid-disk          0
    device             /dev/sdd1
    raid-disk          1         
</programlisting>
</sect2>


<sect2 id="raidhotadd-remove">
<title>raidhotadd og raidhotremove</title>
<indexterm>
 <primary>RAID</primary>
 <secondary>raidhotadd og raidhotremove</secondary>
</indexterm>

<indexterm>
 <primary>raidhotremove -a </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>raidhotremove -a</secondary>
</indexterm>

<indexterm>
 <primary>raidhotadd -a </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>raidhotadd -a </secondary>
</indexterm>

<para>
Det er muligt at tilføje og fjerne diske fra RAID-systemet medens systemet
kører. Det kan være en god ting, hvis filsystemet af en eller anden
grund er gået i stykker på den ene af diskene. Det kan
ske uden at disken rent fysisk har fejlet.
</para>



<para> 
<emphasis>Fjern disk</emphasis>
</para>

<para>
F.eks. fjern disken <filename>/dev/hdd1</filename> fra RAID-systemet:
</para>

<screen>
<PROMPT>[root@linus /etc]# </PROMPT><USERINPUT>raidhotremove -a /dev/md0 /dev/hdd1</USERINPUT>
</screen>

<para>
Nu kan man arbejde på disken med <command>fdisk</command>.
</para>

<para> 
<emphasis>Tilføj disk</emphasis>
</para>

<para>
Disken som er blevet repartitioneret, kan tages i brug således:
</para>

<screen>
<PROMPT>[root@linus /etc]# </PROMPT><USERINPUT>raidhotadd -a /dev/md0 /dev/hdd1</USERINPUT>
</screen>

<para>
RAID-systemet vil automatisk blive opdateret, og et evt. spejl vil blive
genopbygget medens produktionen kører, performance-nedgangen er lille
selv ved IDE-diske.
</para>

</sect2>
</sect1>

<sect1 id="harddisk-tuning">
<title>Harddisk-tuning</title>
<indexterm><primary>Harddisk</primary><secondary>tuning af hastighed</secondary></indexterm>
<indexterm><primary>UDMA</primary><secondary>tuning af harddisk</secondary></indexterm>
<indexterm><primary>DMA</primary><secondary>tuning af harddisk</secondary></indexterm>
<indexterm><primary>hdparm</primary></indexterm>
<indexterm><primary>/sbin/hdparm</primary></indexterm>
<para>
Har du brug for at få ekstra "tryk" på din IDE-harddisk,
så kan du bruge <command>hdparm</command> til at tune hastigheden.
Her er givet de to vigtigste parametre (bruge DMA og lookahead), som
nærmest alle nyere diske understøtter. Der kan tunes endnu mere - have
fun! :-)
</para>

<para>
Når det virker fint, kan og bør du lægge kommandoerne ind i filer, der
køres når systemet startes op. I Red Hat f.eks. i bunden af
<filename>/etc/rc.d/rc.local</filename>.
</para>

<screen>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>/sbin/hdparm -tT /dev/hda</userinput>
 
/dev/hda:
 Timing buffer-cache reads:   128 MB in  3.21 seconds = 39.88 MB/sec
 Timing buffered disk reads:  64 MB in 10.14 seconds =  6.31 MB/sec
</screen>

<para>
Den første og sidste kommando måler hastigheden på harddisken. Der kommer to 
tal. Det første "buffer-cache" er reelt et mål for processor- og bushastighed, 
mens det andet tal angiver I/O fra disken. 
</para>

<para>
For de fleste diske er den standardopsætning du har fin, men får du væsentligt
mindre på det andet tal (se ovenfor), så skal du i gang med at lege :-)
</para>

<para>
Start med at notere hvordan dine parametre er nu (og som virker):
</para>

<screen>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>/sbin/hdparm /dev/hda</userinput>

/dev/hda:
 multcount    = 16 (on)
 I/O support  =  0 (default 16-bit)
 unmaskirq    =  0 (off)
 using_dma    =  0 (off)
 keepsettings =  0 (off)
 nowerr       =  0 (off)
 readonly     =  0 (off)
 readahead    =  8 (on)
 geometry     = 39703/16/63, sectors = 40020624, start = 0
</screen>


<para>
Nogle af de parametre du kan dreje på er følgende:
</para>

<itemizedlist mark="bullet">

<listitem> 
 <para>
-u[0|1] Styrer interrupt-masker for disken. Det er noget der giver en del.
 </para>
</listitem>

<listitem>
 <para>
-m[tal] Multiple sector mode (dvs. IDE Block Mode), er om man kan hente mere data pr. gang. De fleste chipsæt understøtter nu dette. 2, 4, 8, 16 og 32 er lovlige værdier. 16 eller 32 er nok interessant for de fleste. 
 </para>
</listitem>


<listitem>
 <para>
-d[0|1] er tilkobling/fravalg af DMA-overførsel. Dette genkendes 
oftest automatisk, og sættes default til -d1 hvis det er muligt.
 </para>
</listitem>

<listitem> 
 <para>
-X[mode] sættes til højest mulige hastighed pr. default.
Anvend -X66 for UltraDMA mode 2, -X67 for UltraDMA mode 3 osv. 
Dog er UltraDMA mode 3, 4 og 5 meget eksperimentelle.
 </para>
</listitem>

<listitem> 
 <para>
-c[0|1|2|3] E)IDE 32-bit I/O-support. 
0 for at fravælge 32-bit I/O-support, 
1 for at tilkoble 32-bit dataoverførsel og 
3 for 32-bit dataoverførsel med synkronisering (mange chipsæt kræver dette. 
 </para>
</listitem>
</itemizedlist>


<screen>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>/sbin/hdparm -u1 -m16 -c3 -d1 -X66 /dev/hda</userinput>

/dev/hda:
 setting 32-bit I/O support flag to 3
 setting multcount to 16
 setting unmaskirq to 1 (on)
 setting using_dma to 1 (on)
 setting xfermode to 66 (UltraDMA mode2)
 multcount    = 16 (on)
 I/O support  =  3 (32-bit w/sync)
 unmaskirq    =  1 (on)
 using_dma    =  1 (on)

<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>/sbin/hdparm -tT /dev/hda</userinput>
/dev/hda:
 Timing buffer-cache reads:   128 MB in  3.23 seconds = 39.63 MB/sec
 Timing buffered disk reads:  64 MB in  5.76 seconds = 11.11 MB/sec
</screen>


<para>
I eksemplet giver jeg kommandoer
som passer til de nyere Ultra DMA 66-controllere, og får derved en lidt højere hastighed.
Målefunktionen bør dog køres en del gange før man kan få en statistisk korrekt
vurdering af ydelsen. Du skal være opmærksom på, at du kan låse din maskine, 
hvis du angiver mere end hvad din maskine kan yde. I praksis ser du nok 
et reboot hvis du går for langt. Tilføj den endelige optimale opsætning til 
<filename>/etc/rc.local</filename> eller tilsvarende opstartsfil, når du er 
sikker på at maskinen kører godt. Se også <command>man hdparm</command>.
</para>

<para>
Med Red Hat kan du justere i filerne: <filename>/etc/sysconfig/harddiskhd[a-h]</filename> og så gør <filename>/etc/rc.sysinit</filename> resten ved 
systemstart. Udfør <command>cp /etc/sysconfig/harddisks /etc/sysconfig/harddiskhdX</command>, hvor X er a, b, c osv. for hda, hdb, hdc osv.
Der er følgende parametre: 
</para>

<programlisting>
USE_DMA=1    
# det samme som -d1 
# brug DMA   fra = 0, til = 1

LOOKAHEAD=1
# det samme som -A1 

MULTIPLE_IO=16
# det samme som -m16 

EIDE_32BIT=3

EXTRA_PARAMS= -X69  
# -X69 UDMA5 for ATA/100 
# UDMAX er -X(64 + X) hvor X er et number 1-5.
</programlisting>

<para>
Læs også Red Hat 7.1-filen <filename>/etc/sysconfig/harddisks</filename> hvor 
generel opsætning kan laves for alle diske.
</para>

<para>
Samme program, <command>hdparm</command>, kan bruges til at få
harddisken til at spinne ned i hastighed - f.eks. efter 5
sekunder. Det betyder mere slid på harddisken, men din maskine
bliver stille. 
</para>

<screen>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>/sbin/hdparm -S 1 /dev/hda</userinput>
</screen>

<para>
Hvis man har et eller flere programmer der jævnligt checker om nogle filer
er ændret skal disse filers access-tid også opdateres jævnligt - det
giver skrivninger til disken selvom filsystemets egentlige data ikke ændres
(kun dets meta-data). Det kan være en god idé at montere disken via <filename>/etc/fstab</filename> noget i stil med
</para>

<programlisting>
/dev/hda1  /  ext2  defaults,noatime  1 1
</programlisting>


<para>
Kernens IDE-driver skal understøtte det IDE-chipsæt, der anvendes af
bundkortet, og ikke alle IDE-chipsæt er understøttet med (U)DMA. Så
hvis en given funktion ikke tillades af <command>hdparm</command>, så
kan det være forklaringen.
</para>

<para>
<command>hdparm</command> har kun begrænset anvendelse med scsi. 
Til scsi skal man dels
se på driveren, dvs. tilføje eventuelle modulparametre. Symbios
scsi-driverne kan dog fintunes via <command>/proc/scsi</command> under
drift. Et nyttigt grafisk værktøj til at tune scsi-diske er
<command>scsi-config</command>, selvom der normalt ikke er så meget at
"tune".
</para>

<para>
Du kan måske også være interesseret i at se mere på 
<ulink url="http://www.iozone.org/">http://www.iozone.org/</ulink>
hvor der er et program til at benchmark-teste harddisk-ydelse.
</para>

<para>
Mere info om <command>hdparm</command> kan finds på
<ulink url="http://linux.oreillynet.com/pub/a/linux/2000/06/29/hdparm.html">http://linux.oreillynet.com/pub/a/linux/2000/06/29/hdparm.html</ulink>.
</para>

</sect1>

<sect1 id="hvad-laver-hvad">
<title>Hvilke filer har programmet åbne?</title>

<indexterm><primary>Fil</primary><secondary>åbne</secondary></indexterm>
<indexterm><primary>lsof</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>lsof </secondary></indexterm>
<indexterm><primary>/sbin/lsof</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>/sbin/lsof </secondary></indexterm>
<indexterm><primary>fuser</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>fuser </secondary></indexterm>
<indexterm><primary>/sbin/fuser</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>/sbin/fuser </secondary></indexterm>
<indexterm><primary>pid</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>pid </secondary></indexterm>
<indexterm><primary>ps aux</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>ps aux </secondary></indexterm>
<indexterm><primary>process-ID</primary></indexterm>
<indexterm><primary>Kommandooversigt</primary><secondary>pidof </secondary></indexterm>
<indexterm><primary>pidof </primary></indexterm>

<sect2 id="lsof">
<title>lsof</title>
<para>
Ofte vil dit program have filer åbne som du måske ikke lige
vidste. Med <command>lsof</command> kan du se hvad der sker. Vi kan
f.eks. se hvad programmet arbejder med. Som eksempel kan vi se hvad
der sker, når man har <command>ping</command> kørende. Først finder vi
den <emphasis>pid</emphasis> - proces-ID - som <command>ping</command>
kører med. Der er mindst to muligheder, enten med <command>ps
aux</command> eller <command>pidof</command>.
</para>


<screen>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>ps aux | grep ping</userinput>
pto       9149  0.0  0.1  1264  228 pts/4    S    Apr29   0:00 ping eric
root      9418  0.0  0.4  1360  516 ttyp0    S    00:06   0:00 grep ping
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>pidof ping</userinput>
9149
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>lsof -p 9149</userinput>
COMMAND PID USER  FD TYPE DEVICE    SIZE   NODE NAME
ping   9149 root cwd  DIR    3,7    4096  30919 /home/pto/tmp
ping   9149 root rtd  DIR    3,5    4096      2 /
ping   9149 root txt  REG    3,5   17968 114094 /bin/ping
ping   9149 root mem  REG    3,5  340663  16023 /lib/ld-2.1.3.so
ping   9149 root mem  REG    3,5  169720  16071 /lib/libresolv-2.1.3.so
ping   9149 root mem  REG    3,5 4101324  16030 /lib/libc-2.1.3.so
ping   9149 root mem  REG    3,5  246652  16061 /lib/libnss_files-2.1.3.so
...
</screen>

<para>
Så man kan se, at programmer har fat i mange filer. Det skal nævnes at
<command>pidof</command> kræver at SysVinit-pakken er installeret og
stien til <command>pidof</command> varierer desværre alt efter
Linux-distribution. Det skal også nævnes, at <command>ps aux</command>
bruges på en Linux-maskine, mens mange andre Unix-varianter anvender
<command>ps -ef</command>.
</para>

<para>
Tilsvarende kan man have stor glæde af at kunne se, hvilke programmer
der har filer åbne under et givet katalog i filtræet. Det er meget
relevant ved afmontering af f.eks. cd-rom-drev. Prøv følgende:
</para>

<screen>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>lsof +D /var/spool</userinput>
COMMAND  PID USER   FD   TYPE DEVICE SIZE  NODE NAME
atd      459 root  cwd    DIR    3,5 4096 32594 /var/spool/at
crond    473 root  cwd    DIR    3,5 4096    12 /var/spool/
lpd     9299 root    4w   REG    3,5    5  4507 /var/spool/lpd/lpd.lock
</screen>

<para>
Eksemplet viser, at der er tre programmer <command>at</command>,
<command>crond</command> og <command>lpd</command> som pt. anvender
filer under <filename>/var/spool</filename>. Meget nyttige ting for en
systemadministrator.
</para>
</sect2>

<sect2 id="fuser">
<title>fuser</title>

<para>
Et tilsvarende nyttigt program til nogenlunde samme formål er
<command>/sbin/fuser DEVICE</command>. F.eks. kan man se hvilket
proces-ID, som låser lydenheden <filename>/dev/dsp</filename> ved at skrive
<command>/sbin/fuser /dev/dsp</command>. Med <command>/sbin/fuser -k
/dev/dsp</command> kan man endda direkte dræbe den proces som låser
enheden.
</para>
</sect2>

<sect2 id="proc-afmontering">
<title>Afmontering af filsystem via /proc</title>
<indexterm><primary>/proc</primary>
<secondary>Problem med afmontering af filsystem</secondary></indexterm>

<para>
Et alternativ til ovenstående er at anvende <filename>/proc/</filename>.
Antag at man vil afmontere <filename>/usr/src/postgresql-7.2.1/</filename>
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>umount /usr/src/postgresql-7.2.1/</userinput>
umount: /usr/src/postgresql-7.2.1: device is busy
</screen>

<para>
Hvem pokker er synderne?
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>ls -l /proc/*/cwd|grep /usr/src/postgresql-7.2.1/</userinput>
lrwxrwxrwx 1 postgres postgres 0 Apr 30 03:49 /proc/3943/cwd -> /usr/src/postgresql-7.2.1/
lrwxrwxrwx 1 postgres postgres 0 Apr 30 03:49 /proc/3944/cwd -> /usr/src/postgresql-7.2.1/
lrwxrwxrwx 1 postgres postgres 0 Apr 30 03:49 /proc/3950/cwd -> /usr/src/postgresql-7.2.1/
</screen>

<para>
Aha! Det er således processerne 3943 3944 3950 som låser filsystemet.
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>kill -9 3943 3944 3950</userinput>
</screen>


<para>
Nogen kunne sikkert lave et script, der gjorde dræbningen nemmere:
</para>

<programlisting>
perl -e '$dir=shift; map {m:/proc/(\d+)/cwd -> $dir[/\n]: and do {print
"$1\n"; kill 9, $1 } } `ls -l /proc/*/cwd`' /usr/src/postgresql-7.2.1/
</programlisting>

</sect2>
</sect1>

<!-- Skrevet af Ole Tange -->
<sect1 id="fejlfinding">
<title>Fejlfinding</title>

<indexterm><primary>strace</primary></indexterm>
<indexterm><primary>emacs</primary><secondary>strace</secondary></indexterm>
<indexterm><primary>debugge programmer</primary></indexterm>
<indexterm><primary>fejlfinding af programmer</primary></indexterm>

<para>
Nogle gange er programmer ret dårlige til at forklare, hvorfor det gik
galt. Kommandoen <command>strace</command> er god til at fejlsøge
med. Det gælder specielt ved fejl som:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
Segmentation fault (core dumped)
 </para>
</listitem>
<listitem>
 <para>
File not found
 </para>
</listitem>
<listitem> 
 <para>
Access denied
 </para>
</listitem>
</itemizedlist>

<para>
Her vil <command>strace</command> ofte kunne give dig en ide om, hvad
der skete lige inden fejlen indtrådte, og med lidt held kan du ud af
dette gætte, hvad der gik galt. Måske mangler du en fil eller måske
bruger programmet den forkerte version af et library.
</para>

<para>
<command>strace</command> står for system trace og viser alle de kald,
der er til library-rutiner. Hvis man vil se, hvilke kald
<command>ls</command> laver, så skriver man:
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>strace ls</userinput>
</screen>

<para>
Det går hurtigt op for een, at der kommer <emphasis>ret</emphasis>
meget output. Da problemerne ofte er fil-relateret, så kan man nøjes
med at få vist de fil-relaterede systemkald:
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>strace -e trace=file ls</userinput>
</screen>

<para>
Hvis programmet starter andre processer (f.eks. ved at kalde andre
programmer), så kan man strace disse med '-ff'. Prøv at se forskellen
på disse to:
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>strace time ls</userinput>
<prompt>[anne@linus ~]$</prompt> <userinput>strace -ff time ls</userinput>
</screen>

<para>
Hvis du strace'r programmer, der kører under X, så vil du ofte få
utroligt meget output. Du kan proppe det i en fil ved at redirigere
stderr:
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput> strace -ff time ls 2&gt;/tmp/fil</userinput>
</screen>

<para>
En anden mulighed er at starte <command>strace</command> fra en shell
i <command>emacs</command>:
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>emacs</userinput>
M-x shell
<prompt>[anne@linus ~]$</prompt> <userinput>strace ...</userinput>
</screen>

<para>
Herved får du mulighed for at bladre i outputtet med det samme.
</para>
</sect1>

</chapter>
