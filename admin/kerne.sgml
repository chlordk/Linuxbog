 <!-- $Id$ -->
<chapter id="kerne">
<title>Linux-kernen</title>

<para>
I dette kapitel ser vi nærmere på Linux-kernen. Først lidt teknisk om
hvordan kernen virker, dernæst mere om hvordan processer
håndteres. Det vises hvordan kernen oversættes og moduler håndteres
og endelig ser vi nærmere på kerne 2.4.
</para>

<!-- Lavet af Hanne Munkholm et al i "The Linux way" -->
<sect1 id="Hovedkarakteristika">
<title>Hovedkarakteristika ved Linux-kernen</title>

<itemizedlist mark="bullet">
<listitem>
 <para><emphasis>Multi-tasking</emphasis>
Linux understøtter ægte multi-tasking. Alle processer kører helt
uafhængigt af hinanden. Ingen processer behøver at tage højde for 
processor-tid til andre processer.
 </para>
</listitem>

<listitem> 
 <para><emphasis>Multi-bruger tilgang</emphasis>
Linux tillader flere brugere at benytte systemet samtidigt.
 </para>
</listitem>

<listitem> 
 <para>
  <emphasis>Demand load executables</emphasis> Kun de dele af et
program, som faktisk er påkrævet for udførslen, bliver hentet ind i
hukommelsen. Når en ny proces er skabt ved hjælp af
<command>fork()</command>, afsættes der ikke straks hukommelse, men i
stedet bruges hukommelsen fra forældre-processen af begge
processer. Hvis den nye proces så på et tidspunkt søger adgang til en
del af hukommelsen i "write mode", kopieres denne sektion før den
ændres. Dette koncept kendes som "copy-on-write"; det er med til at
øge hastigheden og sænke hukommelsesforbruget.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Paging</emphasis>
På trods af forsøg på at anvende fysisk hukommelse effektivt, kan det
ske, at den tilstedeværende hukommelse er brugt op. Linux ser så efter
4 kb hukommelsessider, som kan frigives. Sider med deres indhold
lagret på harddisk (f.eks. programfiler) frigives. Alle
andre sider kopieres ud på harddisken. Hvis der herefter søges adgang
til en af disse hukommelsessider, hentes den igen. Denne procedure
kaldes "paging". Den adskiller sig fra "swapping", som anvendes i ældre
Unix-systemer, hvor hele hukommelsen for en proces skrives til
harddisken, hvilket er betydeligt mindre effektivt.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Dynamisk cache for harddisken</emphasis> Brugere af MS-DOS
og Windows er kendt med behovet for at reservere hukommelse af en
bestemt størrelse til harddisk-cache-programmer som SMARTDRIVE. Linux
justerer dynamisk størrelsen af cache-hukommelse som bruges, for at
tilpasse sig den nuværende hukommelsessituation. Hvis der ikke er mere
hukommelse tilbage på et givet tidspunkt, reduceres størrelsen af
cachen for at frigive hukommelse. Når først hukommelse er frigivet,
øges cache-området igen.
 </para>
</listitem>


<listitem> 
 <para>
<emphasis>Delte biblioteker</emphasis> &ndash; biblioteker (på engelsk
"libraries") er samlinger af rutiner, som kan bruges af forskellige
programmer. Linux har et antal standardbiblioteker, der typisk bruges
af mange programmer der kører samtidigt. Det er derfor fornuftigt at
indlæse disse biblioteker i hukommelsen én gang for alle og lade alle
programmerne deles om den samme kode. Dette muliggøres med
<emphasis>delte biblioteker</emphasis> (på engelsk "shared libraries"). Da
disse først indlæses og sammenkædes med et program, når det kører og
har brug for dem, kendes de også som dynamisk sammenkædede biblioteker
(på engelsk "dynamically linked libraries" eller "DLLs").
 </para>
</listitem>

<listitem> 
 <para>Understøttelse for <emphasis>POSIX 1003.1-standard</emphasis> 
og delvis <emphasis>System V</emphasis> og <command>BSD</command>.
POSIX 1003.1 definerer et minimum interface for et 
operativsystem af Unix-typen. Dette interface er beskrevet
i C-funktionsdeklarationer. Denne standard understøttes nu af alle nyere og
relativt sofistikerede Unix-systemer. I dag understøtter Linux
tilnærmelsesvist POSIX 1003.1.
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>Forskellige formater for kørbare filer</emphasis>
Da det meste software i dag er skrevet til Microsoft Windows, er
det ønskværdigt at kunne køre programmer til disse systemmiljøer under
Linux. Derfor er emulatorer for MS-DOS og Microsoft Windows under udvikling.
Linux kan også køre programmer fra andre Intel-baserede
Unix-systemer, som går under iBCS2-standard. Det inkluderer f.eks.
mange kommercielle programmer brugt under SCO-Unix. iBCS2-emulering er
endnu ikke en del af standard-kernen, men den kan hentes fra
internettet.
 </para>
</listitem>

<listitem> 
 <indexterm><primary>tastatur</primary><secondary>nationalt</secondary></indexterm>
 <indexterm><primary>nationalt tastatur</primary></indexterm>
 <indexterm><primary>dansk tastatur</primary></indexterm>

 <para>
 <emphasis>Understøttelse af nationale tastaturer og tegnsæt</emphasis>
Under Linux kan mange nationale tastaturer og tegnsæt anvendes.
ISO-standarden UTF-8 definerer blandt andet Latin1-tegnsættet, som 
indeholder de europæiske specialtegn med mere.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Forskellige filsystemer</emphasis> Linux understøtter
forskellige filsystemer. Det mest almindeligt brugte filsystem er
Second Extended (ext2) File System. Dette understøtter filnavne op til
255 tegn, og har et antal træk der gør det mere sikkert end
almindelige Unix-filsystemer. Det er dog ikke et <emphasis>Journaling
filesystem</emphasis>, som giver endnu større sikkerhed imod
datatab. Som noget nyt i kerne-version 2.4.1 understøttes det
journaliserende filsystem ReiserFS, som sikrer en hurtig reetablering
af systemet efter en ikke-planlagt nedlukning (f.eks. efter strømsvigt).
</para>

<para>
Oftest anvendes ext2-diskformat, men Linux kan læse og skrive et hav
af andre diskformater, FAT, vfat, NTFS (kun læse), UDF (DVD-format),
ISO 9660 (cd-rom-format) og mange andre.
I netværk kan
man få adgang til filsystemet på andre systemer transparent ved hjælp
af NFS (Network File System) eller SMB (Windows filshare).
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>TCP/IP, SLIP og PPP-understøttelse</emphasis>
Linux kan integreres i lokale Unix-netværk. I princippet kan alle
netværkstjenester som NFS og Remote Login bruges. SLIP og PPP
understøtter brugen af TCP/IP-protokollen over serielle linjer. Det
betyder at link til internettet via telefonnetværk ved hjælp af et modem er
muligt.
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>BSD-sockets</emphasis>
Netværkskommunikation kræver naturligvis midler til
interproces-kommunikation mellem forskellige computere. Interfaces
hertil er i BSD-sockets.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>System V IPC</emphasis>
Linux bruger dette til at lave 'message queues', semaforer og 'shared
memory'. Disse er klassiske varianter til interproces-kommunikation.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Virtuelle konsoller</emphasis>
Linux understøtter virtuelle konsoller. Tastekombinationen &lt;ALT&gt; +
&lt;Function key&gt; bruges til at skifte imellem dem.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Multiprocessing</emphasis> Fra kerne 2.0 understøtter
Linux symmetrisk multiprocessing &ndash; samtidig kørsel af processer på et
antal processorer &ndash; op til 16 processorer. I kerne 2.2-serien var man
i praksis begrænset til 4 processorer, mens man med kerne 2.4-serien
kan opnå skalérbar performance på 16 og 32 processorer.
 </para>
</listitem>
</itemizedlist>

</sect1>

<sect1 id="Linux-er-ikke">
<title>Linux er ikke</title>
<indexterm><primary>Realtids Linux</primary></indexterm>
<para>
Linux er ikke et real-time system. Bl.a. virtuel hukommelse gør det
umuligt for Linux at overholde kravene til et "hard" real-time system,
men det kan laves mere real-time end det er i dag, bl.a. ved at
arbejde med scheduling'en og optimere interruptene. Der er bl.a. et
projekt, RTLinux, som har lavet en overbygning på kernen til realtidsbrug.
</para>

<para>
Linux var tidligere (før kerne 2.0) en monolitisk kerne, mens man med
kerne 2.0 fik adgang til at lave kerne-moduler. Dette var en nødvendig
måde at kunne understøtte meget forskellig hardware på. To brugere med
forskelligt lydkort anvender hver sit kernemodul, og derfor har de to
brugere ikke unødvendig meget programkode læst ind i hukommelsen.
</para>

<indexterm><primary>PVM</primary></indexterm>
<indexterm><primary>MPI</primary></indexterm>
<indexterm><primary>Parallel udførelse af
programmer</primary></indexterm>
<indexterm><primary>cluster</primary></indexterm>
<para>
Linux er ikke et distribueret operativsystem &ndash; alting foregår på én
maskine. Oven på Linux kan man så køre systemer såsom PVM og MPI til at
afvikle programmer på mange maskiner. Både PVM og MPI starter
processer på flere maskiner, udveksler data mellem maskinerne og
udnytter den store fælles datakapacitet til at køre programmerne
parallelt. Det kræver dog at programmerne er skræddersyet til det.
Linux kan også snildt bruges til at lave et cluster af maskiner. Med
MOSIX <ulink url="http://www.mosix.org">http://www.mosix.org</ulink>
kan man binde en række maskiner sammen, så de udefra ser ud som én stor
maskine. MOSIX-clusteret fordeler selv programmerne efter laveste
belastning af de enkelte maskiner, og man kan transparent flytte
programmer fra én maskine til den næste. Det er særdeles elegant.
</para>


<para>
Linux er ikke sikret efter de strengeste sikkerhedsprincipper, men der
er indbygget en vis beskyttelse mod uforvarende at komme til at
ødelægge systemet. Brugeren har ikke adgang til alle systemfiler, og
kan ikke slette andet end egne filer.
</para>
</sect1>

<sect1 id="proces-management">
<title>Proces-management</title>

<para>
Unix-operativsystemer er multi-programming og multi-user-systemer. Det
betyder at flere programmer kan køre på én computer samtidig, og
dermed også at flere personer kan bruge én computer som server
samtidig. For brugeren ser det ud som om programmerne kører parallelt,
og at flere processer dermed har CPU'en samtidig. Dette fungerer i
praksis ved, at hver proces har CPU'en i et bestemt tidsrum, hvorefter
den ryger bag i en kø og næste proces hentes ind (multi-tasking).
</para>

<para>
Linux understøtter, ligesom Unix, ægte multi-tasking. Alle processer
kører helt uafhængigt af hinanden, så ingen processer behøver at tage
højde for at give processor-tid til andre processer. Hver proces har
et hukommelses-område, som er beskyttet mod ændringer fra andre processer.
</para>

<para>
På <ulink url="http://www-106.ibm.com/developerworks/linux/library/l-rt7/?Open&amp;t=grl,l=252,p=mgth">http://www-106.ibm.com/developerworks/linux/library/l-rt7/?Open&amp;t=grl,l=252,p=mgth</ulink> findes en interessant artikel om Linux
i forhold til Windows 2000 og XP med hensyn til proces og tråd-håndtering.
</para>

<sect2 id="Processtruktur">
<title>Proces-struktur</title>
  
<para>
Det vigtigste og mest specielle ved et multi-tasking-system er
processerne og proces-strukturen. En proces er et program, som er under
udførelse.
</para>

<para>
x86-arkitekturen understøtter 4 privilegieniveauer (eng. »privilege levels«), hvor
niveau 0 er det mest privilegerede, og 3 det mindst privilegerede. Et
kørende program vil altid være på et af disse niveauer.
</para>

<para>
Linux bruger kun 2 niveauer, nemlig kerneniveau (eng. »kernel mode«) og brugerniveau (eng. »user mode«). Ved at
skelne mellem brugerniveau og kerneniveau kan man forhindre, at brugeren
har direkte adgang til de forskellige I/O-enheder.
</para>

<indexterm><primary>Kerneniveau</primary></indexterm>
<para>
Der er kun adgang til disse fra kerneniveau, og alle brugerprogrammer
kører på brugerniveau. Brugerprogrammer har derved kun adgang til 
I/O-enheder igennem et på forhånd specificeret systemkald, som resulterer
i et skift fra brugerniveau til kerneniveau. Derved slipper
programmøren af brugerprogrammer for at bekymre sig om detaljerne
omkring f.eks. I/O. Hardwarens kompleksitet skjules derved for
brugeren og udvikleren.
</para>

<para>
Et brugerprogram kan således bruge operativsystemet til at få udført
forskellige instruktioner, ved at lave et systemkald. Et
brugerprogram, der kører under Linux, vil derfor se Linux-kernen som
en udbyder af servicefunktioner.
</para>

<para>
Når en proces kører i systemtilstand, kan den være i en af følgende
tilstande:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
  <emphasis>Running</emphasis>
Running illustrerer et kørende program på brugerniveau. Det
meste af tiden kører et program på brugerniveau. En gang imellem er det
dog nødvendigt at skifte til kerneniveau. Det kan kun ske ved et interrupt
eller et systemkald.
 </para>
</listitem>
<listitem> 
 <para>
 <emphasis>Interrupt-rutine</emphasis>
Interrupt-rutinen bliver aktiv, når der kommer et hardware-signal,
f.eks. nye inddata fra tastaturet.
 </para>
</listitem>
<listitem> 
 <para>
  <emphasis>Systemkald</emphasis> 
Systemkald aktiveres af software interrupts. Et
systemkald kan suspendere en proces, så den skal vente på en hændelse.
 </para>
</listitem>
<listitem> 
 <para>
  <emphasis>Waiting</emphasis>
Processen venter på en ekstern hændelse, og processen vil ikke
fortsætte, før denne hændelse indtræffer.
 </para>
</listitem>
<listitem> 
 <para>
 <emphasis>Retur fra systemkald</emphasis>
Denne tilstand opnås efter hvert systemkald og efter nogle interrupts.
Herfra kan scheduleren skifte processen til Ready og aktivere en anden
proces.
 </para>
</listitem>
<listitem> 
 <para>
 <emphasis>Ready</emphasis>
Processen konkurrerer om at komme til processoren, som er optaget af
en anden proces.
 </para>
</listitem>
</itemizedlist>

</sect2>

<sect2 id="Linux-opstart">
<title>Opstart af Linux</title>
<para>
Når kernen er loadet starter den én enkeltbruger-proces,
nemlig /sbin/init. Som parameter får init-programmet det 
"run-level" som man angiver ved lilo-prompten, f.eks. "single"
der normalt fortolkes som "run-level 1".
</para>

<para><command>init</command> kigger så i <filename>/etc/inittab</filename>, og udfører
de kommandoer der står som aktive for run-level 1, eller alle
run-levels. På min Red Hat er det f.eks.
</para>

<programlisting>
# System initialization.
si::sysinit:/etc/rc.d/rc.sysinit
l1:1:wait:/etc/rc.d/rc 1
</programlisting>

<para> 
<command>rc.sysinit</command> bliver altså kørt uanset
run-level, mens <command>/etc/rc.d/rc 1</command> &ndash; som starter alle
de kommandoer der ligger i
<filename>/etc/rc.d/rc1.d/</filename>-kataloget &ndash; kun kører i run-level 1.
</para>

<para> Det er formentlig i <command>rc.sysinit</command> at du finder
et kald til f.eks. <command>sulogin</command>, der spørger dig efter
"root"s adgangskode førend den starter en kommandofortolker.
</para>

<para> Det er forresten ikke nogen naturlov, at kernen starter
<command>/sbin/init</command> som det første program. Man kan faktisk
angive hvilket program der skal startes med en lilo-parameter,
f.eks. vil <literal>init=/bin/bash</literal> starte en root-shell helt
uden om opstarts-scripts osv.
</para>
</sect2>  

<sect2 id="Procesrelationer">
<title>Procesrelationer</title>

<para>
Proces-hierarkiet i Linux er et forælder-barn-hierarki. En ny proces
kan kun skabes med systemkaldet <command>fork()</command>. Den nye
proces bliver barn-proces til den proces, der udførte
<command>fork()</command>.  
</para>

<para>
Den nye proces bliver oprettet ved at lave en næsten identisk kopi af
den proces der kaldte <command>fork()</command>. Ofte er det første,
en ny proces gør, at udføre et execve-kald, som overskriver den
arvede kode, stak, registre mv., så den ikke længere er en kopi af
forælderprocessen, men en ny proces.
</para>

<para>
Det kan være meget ressourcekrævende at oprette en ny proces, da der
kan være mange data fra forælderprocessen, som skal kopieres. Derfor
bruges der i Linux "copy-on-write"-teknikken. Tanken bag denne teknik
er, at et antal processer kan have adgang til den samme hukommelse, så
længe der ikke er nogen af processerne, der laver ændringer i data.
Således bliver de relevante pages af hukommelse ikke kopieret ved
systemkaldet <command>fork()</command>, men den fælles hukommelse bliver
skrivebeskyttet. Hvis en af processerne forsøger at skrive til hukommelsen,
bliver processen afbrudt, og kernen laver en kopi af den relevante
page. Herefter kan der tildeles en kopi til hver proces. Den store
fordel ved denne metode er, at data kun bliver kopieret hvis det er
nødvendigt.
</para>
</sect2>

<sect2 id="Proces-ID">
<title>Proces-ID</title>

<para>
Alle processer har deres eget ID-nummer (pid) og er i en gruppe og en
session. I Linux kan en proces være tilknyttet flere grupper.
</para>

<para>
Når en ny proces bliver genereret, får den et nyt pid-nummer, og
<command>fork()</command> returnerer 0 til barn-processen og 
barn-processens pid til forælder-processen. Derved kan de to processer se,
hvilken proces der er barn-proces, og hvilken der er forælder-proces.
</para>

<para>
For at kunne bestemme hvor en proces har adgang, har hver proces et
bruger-ID (userid = uid) og et gruppe-ID (gid). Disse ID-numre har 
børne-processerne arvet efter deres forældre-processer. Når en 
adgangskontrol skal foretages, er det dog den effektive bruger-ID (euid) 
og gruppe-ID (egid) der bliver brugt. Generelt er uid = euid og gid = egid,
undtagen for set-UID programmer.
</para>

<para>
 I disse programmer bliver euid og
egid sat til bruger-ID og gruppe-ID for ejeren af den kørbare fil.
På denne måde er det muligt for superuseren at give almindelige
brugere adgang til brug af systemadministrative programmer på en
kontrolleret måde. Et set-UID program er et program hvor
set-UID-bitten er sat. Af sikkerhedsårsager understøtter Linux kun
set-UID på binære filer, ikke på shell scripts.
</para>

</sect2>
</sect1>

<sect1 id="kerne-proc">
<title>proc-filsystemet</title>
<indexterm><primary>/proc</primary></indexterm>
<para>
Som systemadministrator (root) har man gode muligheder for at følge,
hvad Linux-kernen foretager sig. Prøv at skrive <command>mount</command>. En
af de linjer, som kommer frem er
</para>

<programlisting>
none on /proc type proc (rw)
</programlisting>

<indexterm>
 <primary>ls -l</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>ls -l</secondary>
</indexterm>
<para>
I modsætning til de almindelige filsystemer, som er monteret
(f.eks. <filename>/dev/hda1</filename>, <filename>/dev/hda2</filename>
osv.), så er <filename>/proc</filename> meget speciel. Prøv
f.eks. som det første eksperiment at se følgende fil.
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>ls -l /proc/kcore</userinput>
-r--------    1 root     root     134156288 jan 22 23:18 /proc/kcore   
</screen>

<para>
Betyder dette, at der ligger en ca. 128 Mb stor fil? Nej &ndash; alt hvad
der ligger under <filename>/proc</filename> er virtuelt. Det er
Linux-kernen som på en elegant måde giver adgang til en række nyttige
kerne-informationer. I eksemplet er <filename>/proc/kcore</filename>
en adgang til hele den fysiske RAM i maskinen. Lad os se mere på hvad
der sker i <filename>/proc</filename>
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ls -l /proc/</userinput>
1/     1150/  529/ 741/  9725/ 9794/       fs/        partitions
10023/ 15656/ 539/ 765/  9726/ 9795/       ide/       pci
10030/ 15657/ 554/ 809/  9727/ 9797/       interrupts rtc
10043/ 15658/ 570/ 825/  9765/ 9798/       ioports    scsi/
1017/  17917/ 571/ 961/  9767/ 9800/       kcore      self@
10313/ 17931/ 581/ 965/  9769/ 984/        kmsg       slabinfo
10317/ 17964/ 596/ 966/  9771/ 9950/       ksyms      sound
1051/  18243/ 6/   967/  9776/ 9958/       loadavg    stat
1052/  18246/ 61/  968/  9777/ apm         locks      swaps
1053/  18250/ 698/ 969/  9780/ bus/        mdstat     sys/
1054/  18524/ 701/ 970/  9782/ cmdline     meminfo    tty/
1055/  2/     702/ 971/  9784/ cpuinfo     misc       uptime
10571/ 3/     703/ 9717/ 9786/ devices     modules    version
10723/ 307/   704/ 972/  9788/ dma         mounts
1083/  4/     717/ 9722/ 9789/ fb          mtrr
11294/ 5/     732/ 9723/ 9791/ filesystems net/                          
</screen>

<para>
<indexterm><primary>PID</primary></indexterm>
<indexterm><primary>Proces-ID</primary></indexterm>
<indexterm>
 <primary>ps</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>ps</secondary>
</indexterm>
<indexterm>
 <primary>ls</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>ls</secondary>
</indexterm>
Som det kan ses, er der en
mængde kataloger med numre. Der er et katalog for hver proces på
maskinen. Lad os se på et af katalogerne mere detaljeret. Der kører
netop nu en <command>emacs</command> på maskinen med pid=18243 (PID
betyder proces-ID). Dette findes ved brug af
<filename>ps</filename>. Tilsvarende kan vi se hvad kataloget i
<filename>/proc/18243</filename> indeholder.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ps aux | grep emacs</userinput>
pto  18243  0.1  4.7  8940 6076 pts/1   S  22:11  0:09 emacs kerne.sgml 
<prompt>[tyge@hven ~]$ </prompt><userinput>ls /proc/18243</userinput>
cmdline  cwd   environ  exe    fd  maps  
mem      root  stat     statm  status       
</screen>

<para>
Det første underlige er, at filerne har filstørrelse nul. Det skal man
ikke lade sig snyde af. Alt er virtuelt her &ndash; og nogle gange kan filer
i <filename>/proc</filename> have indhold. Prøv selv at køre
<command>more /proc/PID/cmdline</command>, hvor PID er en 
proces-ID på din maskine, f.eks. for en editor, du har startet på 
kommando-linjen.
</para>

<para>
Via <filename>/proc/PID/cwd</filename> er der direkte adgang til det
katalog, som programmet blev startet op i. Filerne
<filename>/proc/PID/stat*</filename> (tre filer) fortæller mere om
f.eks. hukommelsesforbrug og andre status-parametre.
</para>

<para>
Nu har vi set på hvad der gemmes for den enkelte proces. Lad 
os nu se på hvad der ellers kan findes i <filename>/proc</filename>. 
</para>

<para>
Belastning af maskinen (load) &ndash; eller rettere &ndash; hvor mange processer,
der prøver at tilgå kernen i snit, kan ses direkte ud fra
<filename>/proc/loadavg</filename>. Det er samme tal som
<command>uptime</command> har til sidst &ndash; belastning det sidste minut,
sidste 5 minutter, og endelig de sidste 15 minutter.
<indexterm><primary>uptime</primary></indexterm>
<indexterm><primary>load</primary></indexterm>
</para>

<para>
Vil du vide mere om, hvor meget hukommelse der er brugt, så kan du få
dette fra kommandoen <command>free</command>, men en endnu mere
detaljeret visning kan hentes fra filen
<filename>/proc/meminfo</filename>.
</para>

<indexterm><primary>free</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>free</secondary>
</indexterm>
<indexterm><primary>more</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>more</secondary>
</indexterm>
<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>free </userinput>
             total   used  free shared buffers cached
Mem:        127760 124336  3424 135860    4684  52104
-/+ buffers/cache:  67548 60212
Swap:        68504   7120 61384       
<prompt>[tyge@hven ~]$ </prompt><userinput>more /proc/meminfo</userinput>
        total:    used:    free:  shared: buffers:  cached:
Mem:  130826240 127242240  3584000 139255808  4788224 53280768
Swap: 70148096  7290880 62857216
MemTotal:    127760 kB
MemFree:       3500 kB
MemShared:   135992 kB
Buffers:       4676 kB
Cached:       52032 kB
BigTotal:         0 kB
BigFree:          0 kB
SwapTotal:    68504 kB
SwapFree:     61384 kB
</screen>

<para>
I <filename>/proc/net/</filename> er der en masse nyttig information om
hvordan netværket ser ud lige nu. De fleste filer er direkte læsbare for
alle, mens f.eks. firewall-filerne (for kerne 2.2)
<filename>/proc/net/ip_fwchains</filename> (med firewall-opsætningen) og
<filename>/proc/net/ip_fwnames</filename> kun kan læses af root (sikkerhed).
</para>
</sect1>

<!-- Devfs skrevet af Rasmus Laursen dsl13480@vip.cybercity.dk -->
<sect1 id="devfs">
<title>Devfs</title>

<indexterm><primary>Devfs</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>ls-la</secondary>
</indexterm>
<para>
En af de nye ting i kerne 2.4.x er devfs, som er et godt alternativ
til <filename>/dev</filename>-katalog-systemet.
</para>

<sect2 id="hvad-er-dev">
 <title>Hvad er /dev</title>

 <indexterm>
  <primary>/dev</primary>
 </indexterm>

 <indexterm><primary>ls -la</primary></indexterm> 
<para>
<filename>/dev</filename>'s funktion er at strukturere
alle mulige (og umulige) enheder, som <emphasis>filer</emphasis>. Hver
enkelt <emphasis>fil</emphasis> definerer en enkelt enhed vha. 2
pointere (også kaldet major & minor number). Major angiver enhedens type
(f.eks: disk-, terminal-, seriel-enhed), minor angiver den
enkelte enhed indenfor den enkelte type (f.eks: tty1, tty2,..., hda1,
hda2). Disse 2 pointere benytter kernen til at "slå op" i en
drivertabel, for at finde den rigtige driver til en given enhed:

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>ls -la /dev/hda*</userinput>
brw------- 1 root root 3, 0 jan 1 1970 /dev/hda
brw------- 1 root root 3, 1 jan 1 1970 /dev/hda1
.
.
<prompt>[root@linus /root]#</prompt> <userinput>ls -la /dev/tty?</userinput>
crw------- 1 root root 4, 1 maj 24 05:38 tty0
crw------- 1 root root 4, 2 maj 24 05:38 tty1
.
.
</screen>

Hvor 1. nummer efter gruppe er Major og 2. nummer er Minor.
</para>

<para>
For at være sikker på at en given enhed vil virke, skal der altså
være en enhedsfil i <filename>/dev</filename>. Da der
er mange forskellige (typer) enheder, skal der også være mange
filer. Og for at mindske administrationen, er de oprettet på forhånd.
I et typisk system, som f.eks. Red Hat 7.0, er der godt 12000 filer. Og
det er nok de færreste filer, det enkelte system har brug for. Det er
ikke fordi de fylder noget (omkring 300 kb i alt), men de optager hver
en inode (se f.eks. <ulink url="http://e2fsprogs.sourceforge.net/ext2intro.html">http://e2fsprogs.sourceforge.net/ext2intro.html</ulink>).
Hvis enhedsfilen for en bestemt enhed nu ikke lige er oprettet, kan
man benytte programmet <command>/dev/MAKEDEV</command> som kender til
(næsten) alle enheder og deres respektive major- og minor-numre.
</para>

<para>
Hvorfor denne redundans, kan man så spørge? At både 
<filename>/dev</filename>, <command>MAKEDEV</command>-programmet
og kernen skal have alle disse informationer? Det har nok været den
mest indlysende og overskuelige måde at designe det på i tidernes
morgen. Men som antallet af enheder stiger, bliver det mere og mere
uoverskueligt og tidskrævende at administrere, og det kan Devfs gøre
noget ved.
</para>
</sect2>

<sect2 id="hvad-er-devfs">
<title>Hvad er Devfs</title> 
<para>
Devfs er et virtuelt filsystem, som har
samme funktion som <filename>/dev</filename>, men som
ikke ligger fysisk på harddisken. Umiddelbart vil det ligne <filename>/dev</filename>, da man tilgår enhederfiler igennem
kataloget <filename>/dev</filename>. Linket går bare
ikke ned på disken, men direkte ind i kernen (efter samme princip som 
<filename>/proc</filename>).
Dermed er man fri for administrationen og redundans, da filerne altid
svarer til de enheder som kernen har fundet.
</para>

<sect3 id="installation-af-devfs">
<title>Installation af Devfs</title>
<para>
Devfs kræver en Linux-kerne oversat med parametrene CONFIG_DEVFS_FS og
CONFIG_DEVFS_MOUNT, og user-space-dæmonen <command>devfsd</command>
fra <ulink
url="ftp://ftp.atnf.csiro.au/pub/people/rgooch/linux/daemons/devfsd/">Richard
Goochs FTP-server</ulink>. Se i øvrigt <xref linkend="kernelcompile"/>.
</para>

<para>
Udpak devfs-daemonen et sted og kør følgende:
</para>
<indexterm>
 <primary>make</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>make</secondary>
</indexterm>
<indexterm>
 <primary>make install</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>make install</secondary>
</indexterm>
<screen>
<prompt>[root@linus devfs]#</prompt> <userinput>make</userinput>
<prompt>[root@linus devfs]#</prompt> <userinput>make install</userinput>
</screen>

<para>
Som default vil <command>devfsd</command> ligge i
<filename>/sbin</filename>.
</para>

<para>
For at et system kan gøre brug af devfs, er det noget af det første
<command>init</command> skal starte. Det er rimeligt system-specifikt
hvor opstart af devfsd skal ske, da systemfilerne (se <xref
linkend="etcrcdfilen"/> er forskellige. I System V-baserede systemer er
det <command>/etc/rc.d/rc.sysinit</command>, hvor det i BSD-baserede
er i <command>/etc/rc</command>. Men under alle omstændigheder skal
den første linje i disse filer være:
</para>

<programlisting>
/sbin/devfsd /dev
</programlisting>

<para>
Bemærk: Fra og med Red Hat 7.0 er følgende linje allerede indsat i
<command>/etc/rc.d/rc.sysinit</command>:
</para>

<programlisting>
[ -e /dev/.devfsd -a -x /sbin/devfsd ] &amp;&amp; /sbin/devfsd /dev

</programlisting>

<indexterm><primary>touch</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>touch</secondary>
</indexterm>
<para>
Lidt forklaring: Hvis der ligger en fil ved navn
<filename>.devfs</filename> i <filename>/dev</filename> og en
kørbar fil ved navn <command>devfsd</command> i
<filename>/sbin</filename>, så start devfs-daemonen. Så det eneste
man behøver for at aktivere devfs på et Red Hat-system er at køre
følgende kommando:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>touch /dev/.devfsd</userinput>
</screen>

<para>
Og så er det bare at reboote. Så enkelt er det.
</para>
</sect3>

<sect3 id="problemer-med-devfs">
<title>Problemer med Devfs</title>
<para>
Forhåbentlig skulle der ikke opstå problemer, men det kan være at der
i enkelte tilfælde er device-drivere som ikke er understøttet af Devfs
endnu. Her er der 2 løsninger. Den ene er at hvis det kun drejer sig om
nogle få enhedsfiler, kan de oprettes under opstart
vha. <command>mknod</command>-programmet. Den anden er at pakke alle
de ikke-devfs-kompatible enhedsfiler ind i en tar-fil, som pakkes ud
i <filename>/dev</filename> under opstart.
</para>

<para>
Man kan også komme ud for at programmer benytter
<emphasis>letforståelige</emphasis> links til enhedsfiler. Som
f.eks. museprogrammet <command>gpm</command>. <command>gpm</command>
benytter som standard enhedsfilen <filename>/dev/mouse</filename>. I
dette tilfælde vil det være en god idé at sørge for at
<command>gpm</command> gør brug af <filename>/dev/psaux</filename>
direkte (eller en anden "rigtig" enhedsfil for mus). Da der ikke er en
opsætningsfil til <command>gpm</command> bliver man nødt til at gå
direkte ind i scriptet for startup-scriptet til <command>gpm</command>
(se <xref linkend="etcrcdfilen"/>) og tilføje parameteren:
"<parameter>-m /dev/psaux</parameter>". Red Hat 7.1 og senere versioner 
har forbedret det
lidt, ved at man kan specificere en enhed i
<filename>/etc/sysconfig/gpm</filename>. Opstartsprogrammet
<filename>/etc/rc.d/init/gpm</filename> indeholder dog en fejl som
gør at enheden altid vil være <filename>/dev/mouse</filename>. Ændr
derfor følgende i <filename>/etc/rc.d/init/gpm</filename>:
</para>

<programlisting>
if [ -n "$DEVICE" ]; then
        device="/dev/mouse"
fi
</programlisting>

<para>
til:
</para>

<programlisting>
if [ -z "$DEVICE" ]; then
        device="/dev/mouse"
fi
</programlisting>

<para>
som tester om miljøvariablen "DEVICE" er tom. Hvis den er det,
er der ikke angivet nogen enhed i
<filename>/etc/sysconfig/gpm</filename>, og "DEVICE" sættes til
<filename>/dev/mouse</filename>.
</para>

<para>
Vil du vide mere om Devfs, så kan vi anbefale 
Richard Gooch's Linux Devfs (Device File System) FAQ, som findes på <ulink url="http://www.atnf.csiro.au/~rgooch/linux/docs/devfs.html">http://www.atnf.csiro.au/~rgooch/linux/docs/devfs.html</ulink>.
</para>
</sect3>
</sect2>
</sect1>

<sect1 id="kernelcompile">
<title>Omkonfigurere Linux-kernen</title>
<indexterm><primary>Linux</primary><secondary>kernen</secondary></indexterm>
<indexterm><primary>Kerne, omkonfigurering</primary></indexterm>

<para>
Kernen er det program, der styrer computeren. Den består af en
række forskellige funktioner, og vi vil i dette afsnit diskutere,
hvordan du kan omkonfigurere kernen, så den kommer til at passe bedre til
din computer. Sagen er nemlig den, at den kerne, som følger med
f.eks. Red Hat, indeholder en række funktioner, som du måske 
ikke har brug for. 
Ved at omkonfigurere kernen slipper du for at spilde en
masse hukommelse (og måske tid). Du kan måske også mangle understøttelse for
en hardware-del, f.eks. USB (Universal Serial Bus). USB er for
nylig kommet med i Linux-kernen, hvorfor du kan blive nødt til at
lave en ny Linux-kerne. 
</para>


<para>
Et par bemærkninger omkring drivere til Linux er på sin
plads. Drivere kan eksistere på to måder under Linux: Som
en del af kernen eller som et modul. Hvis driveren er en
del af kernen, ligger den fast i hukommelsen hele tiden, men et modul
indlæses først i det øjeblik, der er brug for det &ndash; ja,
faktisk kan et modul også fjernes fra hukommelsen, når der ikke
er brug for det længere (se <xref linkend="kerne-moduler"/>). Det er
klart en fordel at benytte moduler, hvis man ikke har megen hukommelse.
</para>

<sect2 id="kernelklar">
<title>Bliv klar til at oversætte kernen</title>
<indexterm>
<primary>Kerne</primary>
<secondary>oversætte</secondary>
</indexterm>
<indexterm>
<primary>Oversætte</primary>
<secondary>Linux kernen</secondary>
</indexterm>

<para>
Første trin til at lave din egen kerne er at se, om du fik installeret
hele kildeteksten til Linux-kernen. Der er to muligheder; enten fra den
installations-cd-rom du har, eller fra en helt ny kildetekst. Du skal bruge
ca. 150 MB diskplads.
</para>

<para>
Hvis du vil installere kildeteksten til kernen, så skriv:
</para>

<indexterm>
 <primary>rpm</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>rpm</secondary>
</indexterm>

<screen>
<prompt>[root@linus /root]# </prompt> <userinput>rpm -ivh /cdrom/RedHat/RPMS/kernel-headers-2.2.5-15.i386.rpm</userinput>
<prompt>[root@linus /root]# </prompt> <userinput>rpm -ivh /cdrom/RedHat/RPMS/kernel-source-2.2.5-15.i386.rpm</userinput>
</screen>

<para>
Dette gør, at kildeteksten lægges ind i <filename>/usr/src/linux</filename>.
</para>

<indexterm>
 <primary>ls -l</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>ls -l</secondary>
</indexterm> 

<para>
I øvrigt kan det tilrådes at lade <filename>/usr/src/linux</filename> være et
symbolsk link til et versionsafhængigt underkatalog:
</para>

<screen>
<prompt>[root@linus /root]# </prompt> <userinput>ls -l /usr/src/linux</userinput>
lrwxrwxrwx   1 root root   11 Jan 31 12:01 linux -> linux-2.2.5
drwxr-xr-x  17 root root 1024 Jan 25 21:22 linux-2.0.36
drwxr-xr-x  15 root root 1024 Jan 31 20:45 linux-2.2.5
</screen>


<para>
Antag, at du vil opgradere til kerne 2.3.1, som du henter hjem fra <ulink
url="http://www.kernel.org">http://www.kernel.org</ulink> (eller et
spejl &ndash; f.eks. <ulink url="ftp://ftp.sunsite.dk"></ulink>), dvs. nu
vil du installere kildeteksten selv (uden RPM). Typisk henter man 
kildeteksten i filformat tar-bzip, f.eks.
<filename>linux-2.4.17.tar.bz2</filename>.
</para>

<para>
Du behøver ikke at lægge kildeteksten ind som root &ndash; faktisk bør nu nok
hellere lade være, da du så ikke ødelægger noget i
<filename>/usr/src/linux</filename>. Pak filen ud et sted som passer dig 
og oversæt kernen der.
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>cd ~</userinput>
<prompt>[tyge@hven ~]$</prompt> <userinput>tar xjvf linux-2.4.17.tar.bz2</userinput>
...
</screen>

<para>
Gå (brug <command>cd</command>) ned til
<filename>linux</filename> og læs <filename>README</filename>
(med <command>less README</command>). I denne fil er det forklaret, hvordan du
oversætter kernen. Du bør også altid læse
<filename>linux/Documentation/Changes</filename>, som
beskriver, hvordan dit system bør være konfigureret, for at du kan
oversætte kernen.
</para>

</sect2>

<sect2 id="oversaet-kerne">
<title>Oversæt Linux-kernen</title>
<para>For det første skal du skifte til kataloget
<filename>linux</filename>, hvor kildeteksten til kernen er
placeret. Skriv nu <userinput>make xconfig</userinput>. Du vil nu se
et vindue som det nedenfor.
</para>

<figure id="kerne-conf-main" float="1">
<title>Hovedmenu for opsætning af Linux-kernen</title>
<graphic fileref="kerne-config-main.&magic;"  scale="50"></graphic>
</figure>

<para>Som du kan se, er der en række punkter, som du kan
konfigurere. Du kan nu trykke på "General Setup", og du vil få
et vindue som nedenfor. I langt de fleste punkter i menuen kan du
vælge mellem "y", "m" og "n". Vælges "y", bliver funktionen en
del af kernen, mens "n" betyder, at den ikke kommer med. Hvis du vælger
"m", bliver den ikke en del af kernen, men funktionen vil eksistere som
et modul. Som du også kan se, er der mulighed for at få en
forklaring ved at trykke på knappen "help". Når du har konfigureret
kernen, trykker du på "Save and exit".
</para>

<para> 
<emphasis>Tip:</emphasis> Til bogens eksempler på 
<ulink url="http://&linuxbogurl;/admin/eksempler">&linuxbogurl;/admin/eksempler</ulink>
kan der findes en <filename>.config</filename>-fil under
<filename>kerne/</filename>. Denne fil 
(<filename>linux/.config</filename>) dannes når man kører
<command>make xconfig</command> eller <command>make
menuconfig</command> (tekstbaseret). Filen vil tilsvarende anvendes når
man kører en af de to make-kommandoer. 
</para>


<figure id="kerne-conf-gs" float="1">
<title>"General Setup" menuen</title>
<graphic fileref="kerne-general-setup.&magic;"  scale="50"></graphic>
</figure>

<indexterm>
<primary>make</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>make</secondary>
</indexterm> 
<para>
Du er nu klar til at generere en ny kerne. Der er en række skridt, som
du bare skal følge. Først gennemgås alle afhængigheder i kernen
(<command>make dep</command>). Selve oversættelsen af kernen
(<command>make bzImage</command>) og moduler (<command>make
modules</command>) kan godt tage en rum tid afhængig af hvor meget
du har taget med, og hvor hurtig din maskine er.
</para>

<para>
Bemærk at det kun er ved selve installationen af eventuelle moduler 
til sidst at du bliver nødt til at være root.
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>cd linux</userinput>
<prompt>[tyge@hven ~/linux]$</prompt> <userinput>make clean</userinput>
<prompt>[tyge@hven ~/linux]$</prompt> <userinput>make dep</userinput>
<prompt>[tyge@hven ~/linux]$</prompt> <userinput>make bzImage</userinput>
<prompt>[tyge@hven ~/linux]$</prompt> <userinput>make modules</userinput>
<prompt>[tyge@hven ~/linux]$</prompt> <userinput>su root</userinput>
<prompt>[root@linus /home/tyge/linux]# </prompt> <userinput>make modules_install</userinput>
</screen>

<para> 
Bagefter kan du finde den nye Linux-kerne i
<filename>linux/arch/i386/boot/bzImage</filename> (hvis du
bruger en Intel-kompatibel maskine). Du kan teste den nye kerne ved at
kopiere den til en diskette og så starte fra denne. Brug <command>dd
if=linux/arch/i386/boot/bzImage of=/dev/fd0</command> for at
teste på denne måde. Er du tilfreds med den nye kerne, kan du kopiere
kernen til <filename>/boot</filename> og rette i LILO's
opsætningsfil (<filename>/etc/lilo.conf</filename>) og køre
<command>/sbin/lilo</command>, hvis du anvender LILO til at starte
maskinen.
</para>

<para>
Moduler laves til kernen svarende til kernens versionsnummer under
<filename>/lib/modules</filename>, dvs. for kerne 2.4.10 gemmes de i
<filename>/lib/modules/2.4.10</filename>. Nu spørger du måske om,
hvorfor man i det hele taget laver en kerne og så moduler. Dels kan
kernen blive mindre og derfor ofte hurtigere. Men er der fejl i et
modul, kan man hurtigt rette i modulets kildetekst, genoversætte
kildeteksten og starte modulet på ny &ndash; uden at genstarte maskinen!
</para>

<para>
<emphasis>Tip:</emphasis> Man kan også skrive <command>make
menuconfig</command> i stedet for <command>make xconfig</command>. 
Man får et hurtigere tekst-baseret program frem &ndash; og man 
har eksakt de samme muligheder for at styre opsætningen.
</para>

</sect2>


<sect2 id="kerne-opgradering">
<title>Opgradering af kernen</title>
<para>
Hvis man har lavet en god opsætning af Linux-kernen og noget tid
senere får brug for at opgradere til en ny kerne-version, så kan det
være irriterende at skulle afkrydse eksakt de samme valgmuligheder
igen med risiko for at noget bliver gjort forkert. En god procedure er
at kopiere den gamle <filename>.config</filename>-fil, som ligger i
dit <filename>linux</filename>-katalog over til et sted du vælger &ndash; og
det kan være klogt at gemme den under et navn som viser hvilken dato
og kerneversion, den passer med. F.eks. kan man køre <command>cp
~/linux/.config ~/kernecompile/kerne.config-DATO-KERNEVERSION</command>.
</para>

<para>
Start med at hente den nye kerne-kildetekst hjem (bemærk, at hvis du
henter et patch, så passer den typisk ikke til den Linux-version du
fik med din Linux-distribution). Hvis du hentede version 2.4.18, så
flyt eller slet eventuelle andre kerne-kataloger.
</para>

<para>
<indexterm>
 <primary>make mrproper</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>make mrproper</secondary>
</indexterm>
<indexterm>
 <primary>make oldconfig</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>make oldconfig</secondary>
</indexterm>
<indexterm>
 <primary>cd</primary>
</indexterm> 
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>cd</secondary>
</indexterm>
<indexterm>
 <primary>oversæt kerne</primary>
</indexterm> 

Gå nu til <filename>linux</filename> og kør følgende (I dette eksempel
er brugeren »root« &ndash; men det er ikke nødvendigt). Pak først den nye
kerne-kildetekst ud som vist lidt tidligere (<command>tar xjvf
KERNE.tar.bz2</command>).
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>cd linux</userinput>
<prompt>[root@linus linux]#</prompt> <userinput>make mrproper</userinput>
<prompt>[root@linus linux]#</prompt> <userinput>cp /root/kerne.config-DATO-KERNEVERSION .config</userinput>
</screen>

<para>
I den sidste linje anvender vi den forrige kernes parametre som grundsten for
den nye &ndash; sagen er at vi nu kører <command>make oldconfig</command>, hvor 
man kun skal svare på om de nye drivere skal være med i den nye kerne. 
Alt der er uændret spørges man ikke om.
</para>

<screen>
<prompt>[root@linus linux]#</prompt> <userinput>make oldconfig</userinput>
<prompt>[root@linus linux]#</prompt> <userinput>make dep</userinput>
<prompt>[root@linus linux]#</prompt> <userinput>make bzImage</userinput>
<prompt>[root@linus linux]#</prompt> <userinput>make modules</userinput>
<prompt>[root@linus linux]#</prompt> <userinput>make modules_install</userinput>
<prompt>[root@linus linux]#</prompt> <userinput>cp arch/i386/boot/bzImage /boot/vmlinuz-x.y.z</userinput>
</screen>

<para>
Endelig skal man rette <filename>/etc/lilo.conf</filename> til at pege på <filename>/boot/vmlinuz-x.y.z</filename> og køre <command>/sbin/lilo</command>.
</para>
</sect2>

<sect2 id="rescuedisk">

<title>Lav en redningsdiskette</title>

<indexterm>
<primary>Bootdisk</primary>
<secondary>mkbootdisk</secondary>
</indexterm>

<indexterm>
 <primary>mkbootdisk</primary>
</indexterm> 

<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mkbootdisk</secondary>
</indexterm>
<para>
Har du brug for at lave en redningsdiskette (eng. rescue disk), med
Linux-kernen på, som du
kan starte din Linux-maskine fra, så kan du gøre det med
<command>mkbootdisk</command>. Find først ud af hvilken
kerne der er på dit system. Kør f.eks. <command>ls
/lib/modules/</command>. Står der 2.2.12-20, så skal du &ndash; som root -
skrive 
<screen>
<prompt>[root@linus /root]# </prompt> <userinput>/sbin/mkbootdisk --device /dev/fd0 2.2.12-20</userinput>
</screen>

Disken har Linux-kernen, og du kan også bruge denne disk, hvis du skal
flytte rundt på dine harddiske (fra primær til sekundær osv).
</para>


</sect2>

</sect1>

<sect1 id="kerne-moduler">
<title>Moduler</title>
<indexterm>
 <primary>Linux</primary>
 <secondary>kerne-moduler</secondary>
</indexterm>
<indexterm>
<primary>Moduler</primary>
<secondary>Linux kerne-moduler</secondary>
</indexterm>
<para>
Moduler (eller mere korrekt: indlæsbare kerne-moduler) er en af de
mere smarte ting ved Linux. Kort fortalt er et modul en driver, som
systemadministratoren (root) kan indlæse og nedlægge, mens maskinen 
kører, dvs. du kan indlæse en driver uden at genstarte. I dette
afsnit vil vi introducere det mest basale omkring moduler.
</para>

<para>
Modul-systemet blev skrevet om til kerne-version 2.2 (som følger med
Red Hat 7.0 og SuSE 6.4). Vi vil antage, at du har en version 
2.2-kerne. Du kan evt. tjekke det ved at skrive <userinput>uname
-r</userinput>. For en standard-installation af Red Hat 6.2 vil din
maskine svare "2.2.14-20".
</para>

<sect2 id="lsmod">
<title>Hvad findes der allerede indlæst?</title>
<indexterm>
 <primary>lsmod</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>lsmod</secondary>
</indexterm>
<para>
Inden vi går i krig med at indlæse moduler, kan det være rart at vide,
hvilke der allerede er indlæst. For at finde ud af det, skal du bruge
kommandoen <command>lsmod</command>, som er en forkortelse for "list
modules". Kommandoen kan udføres af alle brugere, men vær opmærksom på,
at kommandoen ligger i kataloget <filename>/sbin</filename>, og at
almindelige brugere ikke har dette katalog med i deres søgesti. Derfor
skal du skrive <command>/sbin/lsmod</command>, hvis du ikke er logget
ind som systemadministrator (root).
</para>

<screen>
<prompt>[root@linus /root]# </prompt> <userinput>lsmod</userinput>
Module                  Size  Used by
ppp                    18316   0  (autoclean)
slhc                    4328   0  (autoclean) [ppp]
autofs                  9028   1  (autoclean)
nfs                    29944   1  (autoclean)
lockd                  30856   1  (autoclean) [nfs]
sunrpc                 52356   1  (autoclean) [nfs lockd]
nls_iso8859-1           2020   1  (autoclean)
nls_cp437               3548   1  (autoclean)
vfat                   11516   1  (autoclean)
fat                    25664   1  (autoclean) [vfat]
awe_wave              157804   0 
sb                     33204   0 
uart401                 5968   0  [sb]
sound                  57208   0  [awe_wave sb uart401]
soundlow                 300   0  [sound]
soundcore               2372   7  [sb sound]
</screen>

<para>
Tabellen, som <command>lsmod</command> producerer, indeholder navn på
modulet, hvor meget hukommelse det bruger, hvor mange programmer der
bruger modulet, samt om der er andre moduler, som bruger modulet. Tag
nu PPP-modulet: det fylder 18315 bytes, og ingen programmer eller andre 
moduler benytter det (logisk, idet forbindelsen til internet-udbyderen 
er lukket ned).
</para>
</sect2>

<sect2 id="modprobe">
<title>Indlæs et modul</title>
<indexterm><primary>modprobe</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>modprobe</secondary>
</indexterm>
<para>
Typisk ligger moduler i en undermappe til
<filename>/lib/modules</filename>. På en standard-installation af Red 
Hat 6.2 hedder undermappen <filename>2.2.14-5.0</filename> efter
kernen (husk svaret fra <command>uname</command>). Nede i
<filename>/lib/modules/2.2.14-5.0</filename> finder du en række
underkataloger. Alle modulerne er grupperet efter deres anvendelse,
f.eks. indeholder undermappen <filename>cdrom</filename> drivere
til cd-rom-drev (alle andre end ATAPI-drev). Til at indlæse et modul
bruger du kommandoen <command>modprobe</command>. 
Du kan kun indlæse moduler som
systemadministrator. Nedenfor viser vi, hvordan du kan indlæse en
driver til HPFS (OS/2's filsystem).
</para>

<screen>
<prompt>[root@linus /root]# </prompt> <userinput>modprobe hpfs</userinput>
</screen>

<para>
Det fine ved modul-systemet er, at du kun behøver at angive navnet på
modulet; <command>modprobe</command> finder selv ud af, hvor det er
placeret.
</para>

<para>
Det kan være, at du kommer til at angive det forkerte modul, dvs. du
forsøger at indlæse et modul til et stykke hardware, som du ikke
har. Nedenfor forsøger vi at indlæse driveren til et Intel
EtherExpress Pro/100-kort; et kort, som <emphasis>ikke</emphasis>
sidder i maskinen.
</para>

<screen>
<prompt>[root@linus /root]# </prompt> <userinput>modprobe eepro100</userinput>
/lib/modules/2.2.5-15/net/eepro100.o: init_module: Device or resource busy
</screen>
</sect2>

<sect2 id="modprobe-r">
<title>Nedlæg et modul</title>
<indexterm>
 <primary>modprobe</primary>
 <secondary>-r</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>modprobe -r</secondary>
</indexterm>
<para>
Det kan ske, at du bliver træt af et modul eller blot i længere tid
ikke har brug for det, og du derfor gerne vil nedlægge det igen. Der
er to måder, du kan gøre det på. Den første kræver simpel tålmodighed:
efter 60 sekunder vil ubrugte moduler automatisk blive nedlagt. Dette
sørger en daemon ved navn <command>kerneld</command> for. Den anden måde
er at gøre det selv. Til denne metode skal du bruge kommandoen
<command>modprobe -r</command> ("remove module").
</para>

<screen>
<prompt>[root@linus /root]# </prompt> <userinput>modprobe -r hpfs</userinput>
</screen>

<para>
Kigger du i mappen <filename>/lib/modules/2.2.14-5.0</filename>, ser
du filen <filename>modules.dep</filename>. Filen indeholder information
om, hvilke moduler et modul afhænger af. Filen er en tekstfil, så du
kan bladre i den ved hjælp af <command>less</command> eller
<command>more</command>. Filen skal du ikke pille ved &ndash; den bliver
automatisk genereret under opstart af Linux ved at <command>depmod
-a</command> køres. Næste gang din maskine starter, kan du se efter
linjen "Finding module dependencies" &ndash; på det tidspunkt genereres
filen. Derved sikrer man sig at der anvendes det rigtige modul, dette
er specielt vigtigt hvis man har flere kerneversioner installeret.
</para>
</sect2>

<sect2 id="modulopsaetning">
<title>Opsætning</title>
<para>
Når vi taler om moduler, findes der en meget vigtig fil, som
systemadministratoren kan rette i, nemlig
<filename>/etc/modules.conf</filename>. Det skal lige siges, at filen
bliver rettet af mange af de værktøjer, som vi omtaler i
dette kapitel, f.eks. <command>sndconfig</command>, så måske kommer du 
aldrig selv til at rette i den. Lad os se på indholdet af en ikke helt
ualmindelig <filename>modules.conf</filename>. 
</para>

<programlisting>
# /etc/modules.conf
alias parport_lowlevel parport_pc
pre-install pcmcia_core /etc/rc.d/init.d/pcmcia start
alias sound sb
pre-install sound modprobe sound dmabuf=1
options opl3 io=0x388
alias midi awe_wave
post-install awe_wave /bin/sfxload /etc/midi/GU11-ROM.SF2
options sb io=0x220 irq=5 dma=1 dma16=5 mpu_io=0x330
</programlisting>

<para>
Syntaksen for filen er som følger: først et nøgleord, derefter et navn
på et modul og til slut en række parametre.
</para>

<para>
Lad os begynde med det "lette" nøgleord først. Det lette nøgleord er
"alias". Et alias betyder simpelthen, at når systemet spørger efter et
modul, mener systemet i virkeligheden et andet. Det lyder lidt
mærkeligt, men det er meget nyttigt. Et alias som <userinput>alias
eth0 eepro100</userinput> vil betyde at når Linux forsøger at
initialisere ethernettet (eth0), skal driveren
<filename>eepro100</filename> bruges. Ofte kan Linux ikke automatisk
detektere udvidelseskort i gamle maskiner, og det kan derfor være nyttigt 
at fortælle Linux, hvilket netkort der sidder i maskinen. Har du et
gammelt kort, tilføjer du derfor en "alias"-linje som
passer til dit kort. Et andet eksempel kan være hvis du skal sætte dit 
3Com 90x-netkort i 10 Mbit-tilstand (og ikke 100 Mbit), så skal du
indsætte følgende linjer:
</para>

<programlisting>
alias eth0 3c90x
options 3c90x media_select=1
</programlisting> 


<para>
Et andet nøgleord er "options" (parametre). Her kan systemadministratoren
angive en række parametre til en driver/modul. I det ovenstående
eksempel på <filename>modules.conf</filename> står der
f.eks. <userinput>options sb io=0x220 irq=5 dma=1 dma16=5
mpu_io=0x330</userinput>. Denne linje fortæller modulet
<filename>sb</filename> en række ting &ndash; i dette tilfælde de relevante
oplysninger omkring et SoundBlaster-lydkort (f.eks. at I/O-adressen
er 220, og interruptet er 5).
</para>

<para>
Nøgleordet "pre-install" tillader at udføre kommandoerne efter modulnavnet
før modulet installeres. . F.eks. kald af "/etc/rc.d/init.d/pcmcia start" inden
pcmcia_core kan loades.
Alt hvad der kommer
efter modulets navn, tolkes som en kommando med tilhørende
parametre. Ligeledes findes "post-install", som angiver en kommando, der
skal udføres efter modulet er indlæst.
</para>
<!--
<para>
I Debian bør man ikke rette
<filename>/etc/conf.modules</filename> da programmet
<command>update-modules</command> vil overskrive filen. Programmet
henter opsætningen fra filerne i
<filename>/etc/modutils/</filename>, bl.a. stier, options 
og aliaser. Skal man lave rettelser bør det gøres i disse filer og
efterfølgende bør <command>update-modules</command> udføres.
</para>
-->
</sect2>
</sect1>


<sect1 id="kerne-2-4">
<title>Kerne 2.4</title>
<para>
Den seneste generation af Linux-kernen er 2.4, som udkom den 5. januar
2001. Linus Torvalds annoncerede i vittig og underspillet tone, at nu
var kerne 2.4.0 færdig:
</para>

<programlisting>
In a move unanimously hailed by the trade press and industry analysts as
being a sure sign of incipient braindamage, Linus Torvalds (also known as
the "father of Linux" or, more commonly, as "mush-for-brains") decided
that enough is enough, and that things don't get better from having the
same people test it over and over again. In short, 2.4.0 is out there.

Anxiously awaited for the last too many months, 2.4.0 brings to the table
many improvements, none of which come to mind to the exhausted release
manager right now. "It's better", was the only printable quote. Pressed
for details, Linus bared his teeth and hissed at reporters, most of which
suddenly remembered that they'd rather cover "Home and Gardening" than the
IT industry anyway.

Anyway, have fun. And don't bother reporting any bugs for the next few
days. I won't care anyway.

                Linus
</programlisting>

<para>
Hvad er det så kerne 2.4 har opnået i forhold til de meget anvendte
kerner fra 2.2-serien? Svaret er &ndash; mange ting.
</para>

<para>
For det første er antallet af platforme, der understøttes
øget. Således er der nu også understøttelse for S/390 (IBM
mainframe-system), nye 64-bit MIPS-processorer samt Intels kommende
Itanium. Specielt S/390 synes mange er spændende, idet det bringer
Linux ind på mainframe-markedet. F.eks. har Telia i december 2000 købt
en sådan maskine som erstatning for 70 Sun-computere. Desuden
udnytter 2.4 MMX-instruktioner og andre udvidelser til det klassiske
x86-instruktionssæt bedre end den gamle kerne.
</para>

<para>
En anden ting som er blevet klart forbedret i Linux-kernen er SMP, altså
muligheden for at anvende flere processorer i samme maskine. Hvor kerne
2.2 var fin med 2 processorer og endda 4, så var ydelsen ved 8 og 16
processorer ikke imponerende. Med kerne 2.4 er ydelsen på 8 og 16
processorer forbedret markant.
</para>

<para>
Kerne 2.4 skulle umiddelbart ikke kræve mere hukommelse end kerne
2.2-serien &ndash; men den understøtter meget mere hukommelse. En af de
ting, som nogle var utilfredse med i kerne 2.2-serien, var mængden af
hukommelse, som Linux-kernen kunne bruge. Når man konfigurerer
2.4-kernen, er der spørgsmål om hvor meget hukommelse man har. Tre
grænser kan man vælge &ndash; under 1 Gb (off), op til 4 Gb eller 64 Gb
RAM. Det er efter sigende en 5-6% mindre ydelse, hvis man vælger 64 Gb
hukommelse.
</para>

<para>
En ting som store firmaer har haft problemer med, er antallet af
brugere som kunne understøttes. Tidligere var grænsen på ca. 65000
brugere, mens den nu er 4,2 milliarder. Problemet var meget aktuelt
for f.eks. e-post-servere, som skulle have konti for alle firmaets
medarbejdere.
</para>

<para>
Med hardware kan man nu samtidig understøtte 16 Ethernet-kort, 10
IDE-controllere, og meget andet. Alt i alt har Linux taget et stort
spring fremad med hensyn til high-end Linux-markedet.
</para>

<para>
Ultra-DMA 66 eller 100 er nu med i kerne 2.4. Det er noget som har
været meget efterspurgt, da mange nye harddisk-controllere har været
af den type.
</para>

<para>
For en Linux-laptop, så var PCMCIA med kerne 2.2 ikke ret
smart. Skulle man oversætte en kerne, så skulle man have styr på sine
PCMCIA-drivere ud over selve kernen. De to ting var ikke integreret,
selvom de burde have været det. Med kerne 2.4 er PCMCIA en del af
Linux-kernen på linje med USB.
</para>

<para>
USB-understøttelse er ny i Linux-kernen. USB-tastatur og mus skulle
virke fint, men det kan godt være at din USB-skanner eller kamera ikke
virker, da USB-standarden stadig er under udvikling.
</para>

<para>
Ud over PCI plug-and-play (eller er det pray :-), så er der en
tilsvarende auto-detektion af enheder til ISA-bus.
</para>

<para>
En ting som netop er kommet med i kerne 2.4.0, er LVM "logical volume
management", som gør det muligt at kombinere harddiske til store
enheder (ligesom RAID-0), men med LVM kan man også ændre størrelsen af
de enkelte partitioner løbende. Det er en klar fordel i forhold til
tidligere, hvor man skulle bestemme størrelsen på partitionerne i
forvejen &ndash; og ofte ud fra mere eller mindre gode estimater for hvad
man skulle bruge. Læs mere om LVM på
<ulink url="http://www.linux-mag.com/2000-11/guru_01.html">http://www.linux-mag.com/2000-11/guru_01.html</ulink>.
</para>

<para>
Man kunne nemt lave en firewall med en kerne 2.2, idet kernen havde et
rimelig enkelt grænsesnit til formålet, kaldet
<emphasis>ipchains</emphasis>. Med <command>ipchains</command> kunne
man sætte regler op for hvilke pakker som kunne tillades igennem
firewall'en. I kerne 2.4 er hele firewall-kontrollen omskrevet til et
meget stærkere koncept kaldet <emphasis>netfilter</emphasis>, som kan
styre tilstandshåndterende firewalls. Dette er forklaret i bogen
"Linux &ndash; Friheden til sikkerhed på internettet", som kan findes på <ulink
url="http://&linuxbogurl;/">&linuxbogurl;</ulink>.
</para>

<para>
IPv6-understøttelsen, dvs. næste generation netværksstandard, er med
som eksperimentel. Man kan således ikke forvente, at dette er 100% ok.
</para>

<para>
Under <filename>/dev</filename> har man tidligere haft enheder,
dvs. indgange til hardware, såsom harddisk
<filename>/dev/hda</filename>. Med kerne 2.4 <emphasis>kan
man</emphasis> anvende DevFS, som er en total restrukturering af
<filename>/dev</filename>, så man ikke længere har ekstremt mange
filer i <filename>/dev</filename>, men i stedet får man en hierarkisk
opbygning med mange underkataloger. Som eksempel vil man ikke længere
kunne finde
<filename>/dev/hda1</filename>-<filename>/dev/hda16</filename>, men i
stedet have tilsvarende filer under <filename>/dev/ide0/</filename> -
altså et niveau længere nede.
</para>

<para>
For dem som laver hurtige web-servere er kHTTPd interessant. Man
kan accelerere web-servere kraftigt for statiske web-sider, dvs. ikke
for CGI-programmer eller PHP-løsninger, ved at kernen cacher sider 
intelligent. Det er også markeret som eksperimentel kildetekst.
</para>

<para>
Linux avancerer i mange retninger. En ny retning er telefoni. 
Linux-kernen har nu fået understøttelse af telefonkort til 
Voice-over-IP.
</para>

<para>
For dem som arbejder med video er der godt nyt. Både IEEE-1394- (Firewire)
og I2O-grænsesnit er med. Det er også ting som stadig er under udvikling.
HIPPI (gigabit-netkort) er der også blevet arbejdet meget med, så der nu er
fire forskellige understøttede kort.
</para>

<para>
For ADSL-brugere er kerne 2.4 (eller sene versioner af 2.3-serien)
et must. Der er lavet meget inden for ATM-understøttelsen.
</para>

<para>
Og på de mere interne linjer er store dele af kernen skrevet om,
så selve kildeteksten skulle være meget lettere at læse. Der er arbejdet
meget med at strukturen skulle forbedres, så man lettere kunne
inkorporere nye ting, som ikke tidligere var med.
</para>

<para>
Hvad der ikke kom med i kerne 2.4.0, men som er kommet med i kerne 2.4.1,
er et <emphasis>journaling filesystem</emphasis>. Det sidste år har
der været arbejdet meget hårdt på tre forskellige avancerede
filsystemer, som skriver data til disk på en meget sikker måde i
forhold til det gamle ext2-filsystem. I tilfælde af f.eks. strømsvigt
eller lign. vil de nye filsystemer være meget mere robuste. ReiserFS
vil være det første til at komme med i kernen, mens SGI's
XFS-filsystem og JFS, men endnu er det
uklart, hvornår de er produktionsklare. 
Filsystemet ext3 fra Red Hat er allerede i produktion som det primære 
filsystem i nyere Red Hat versioner.
En glimrende oversigtsartikel, der sammenligner det gamle ext2, det
nyere ext3, ReiserFS og endelige XFS kan læses på 
<ulink
url="http://www.linuxgazette.com/issue68/dellomodarme.html">http://www.linuxgazette.com/issue68/dellomodarme.html</ulink>.
</para>

<para>
En fremragende artikel (allerede en klassiker i Linux-kredse) om kerne
2.4 er Joe Pranevich: "Wonderful World of Linux 2.4", som kan findes
på 
<ulink url="http://linuxtoday.com/news_story.php3?ltsn=2001-01-05-007-04-NW-LF-KN">http://linuxtoday.com/news_story.php3?ltsn=2001-01-05-007-04-NW-LF-KN</ulink>.
Denne tager endnu flere aspekter op end dette afsnit har præsenteret.
</para>

<para> 
Endelig kan det nævnes at en interessant kerne-patch fra <ulink
url="http://www.tech9.net/rml/linux/">http://www.tech9.net/rml/linux/</ulink>
med fordel kan prøves, hvis man mener at Linux-kernen låser maskinen
lidt for lang tid, når der er meget load på maskinen (bl.a. ved start
af store programmer). En samling af artikler på området kan findes ud fra 
<ulink url="http://linuxtoday.com/news_story.php3?ltsn=2001-10-14-008-20-NW-KN">http://linuxtoday.com/news_story.php3?ltsn=2001-10-14-008-20-NW-KN</ulink>.
</para>

</sect1>
</chapter>
