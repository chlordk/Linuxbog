<!-- $Id$ -->
<chapter id="kerne">
<title>Linux-kernen</title>

<para>
I dette kapitel ser vi nærmere på Linux kernen. Først lidt teknisk om
hvordan kernen virker, dernæst mere om hvordan processer
håndteres. Det vises, hvordan kernen oversættes og moduler håndteres
og endeligt ser vi nærmere på kerne 2.4.
</para>

<!-- Lavet af Hanne Munkholm et al i "The Linux way" -->
<sect1 id="Hovedkarakteristika">
<title>Hovedkarakteristika ved Linux-kernen</title>

<itemizedlist mark="bullet">
<listitem>
 <para><emphasis>Multi-tasking</emphasis>
Linux understøtter ægte multi-tasking. Alle processer kører helt
uafhængigt af hinanden. Ingen processer behøver at tage højde for 
processor-tid til andre processer.
 </para>
</listitem>

<listitem> 
 <para><emphasis>Multi-bruger tilgang</emphasis>
Linux tillader flere brugere at benytte systemet samtidigt.
 </para>
</listitem>

<listitem> 
 <para>
  <emphasis>Demand load executables</emphasis> Kun de dele af et
program, som faktisk er påkrævet for eksekveringen, bliver hentet ind i
hukommelsen. Når en ny proces er skabt ved hjælp af
<command>fork()</command>, afsættes der ikke straks hukommelse, men i
stedet bruges hukommelsen fra forældre-processen af begge
processer. Hvis den nye proces så på et tidspunkt søger adgang til en
del af hukommelsen i "write mode", kopieres denne sektion før den
ændres. Dette koncept kendes som "copy-on-write"; det er med til at
øge hastigheden og sænke hukommelsesforbruget.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Paging</emphasis>
På trods af forsøg på at anvende fysisk hukommelse effektivt, kan det
ske, at den tilstedeværende hukommelse er brugt op. Linux ser så efter
4 kbyte hukommelses-pages, som kan frigives. Pages med deres indhold
lagret på harddisk (f.eks. koden for programfiler) frigives. Alle
andre pages kopieres ud på harddisken. Hvis der herefter søges adgang
til en af disse hukommelses-pages, hentes den igen. Denne procedure
kaldes paging. Den adskiller sig fra swapping, som anvendes i ældre
Unix-systemer, hvor hele hukommelsen for en proces skrives til
harddisken, hvilket er betydeligt mindre effektivt.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Dynamisk cache for harddisken</emphasis> Brugere af MS-DOS
og Windows er kendt med behovet for at reservere hukommelse af en
bestemt størrelse til harddisk-cache-programmer som SMARTDRIVE.  Linux
justerer dynamisk størrelsen af cache-hukommelse som bruges, for at
tilpasse sig den nuværende hukommelsessituation. Hvis der ikke er mere
hukommelse tilbage på et givent tidspunkt, reduceres størrelsen af
cachen for at frigive hukommelse. Når først hukommelse er frigivet,
øges cache-området igen.
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>Shared libraries</emphasis> Libraries (på dansk:
biblioteker) er samlinger af rutiner, som er nødvendige for
data-processing for et program. Linux har et antal standard libraries,
der bruges af flere processer ad gangen. Det er derfor fornuftigt at
indlæse programkoden for disse libraries i hukommelsen én gang for
alle. Dette muliggøres ved hjælp af <emphasis>shared
libraries</emphasis>. Da disse kun indlæses til programkoden når
processen eksekveres, kendes de også som dynamiske linkede biblioteker
(dll).
 </para>
</listitem>

<listitem> 
 <para>Understøttelse for <emphasis>POSIX 1003.1 standard</emphasis> 
og delvis <emphasis>System V</emphasis> og <command>BSD</command>.
POSIX 1003.1 definerer et minimum interface for et Unix-type
operativsystem. Dette interface er beskrevet i C-funktions
deklarationer. Denne standard understøttes nu af alle nyere og
relativt sofistikerede Unix-systemer. I dag understøtter Linux
tilnærmelsesvis POSIX 1003.1.
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>Forskellige formater for eksekverbare filer</emphasis>
Da det meste software i dag er skrevet til Microsoft Windows, er
det ønskværdigt at kunne køre programmer til disse systemmiljøer under
Linux. Derfor er emulatorer for MS-DOS og Microsoft Windows under udvikling.
Linux kan også eksekvere programmer fra andre Intel-baserede
Unix-systemer, som går under iBCS2 standard. Dette inkluderer f.eks.
mange kommercielle programmer brugt under SCO-Unix. iBCS2 emulering er
endnu ikke en del af standard-kernen, men den kan hentes fra
Internettet.
 </para>
</listitem>

<listitem> 
 <indexterm><primary>tastatur</primary><secondary>nationalt</secondary></indexterm>
 <indexterm><primary>nationalt tastatur</primary></indexterm>
 <indexterm><primary>dansk tastatur</primary></indexterm>

 <para>
 <emphasis>Understøttelse for nationale tastaturer og tegnsæt</emphasis>
Under Linux kan mange nationale tastaturer og tegnsæt anvendes.
ISO-standarden ISO-8859-1 definerer blandt andet Latin1-tegnsættet, som 
indeholder de europæiske specialtegn med mere.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Forskellige filsystemer</emphasis> Linux understøtter
forskellige filsystemer. Det mest almindeligt brugte filsystem er
Second Extended (ext2) File System. Dette understøtter filnavne op til
255 tegn, og har et antal træk der gør det mere sikkert end
almindelige Unix filsystemer. Det er dog ikke et <emphasis>Journaling
filesystem</emphasis>, som giver endnu større sikkerhed imod
datatab. Som noget nyt i kerne-version 2.4.1 understøttes det
journaliserende filsystem ReiserFS, som sikrer en hurtig reetablering
af systemet efter en ikke-planlagt nedlukning (f.eks. efter strømsvigt).
</para>

<para>
Oftest anvendes ext2-diskformat, men Linux kan læse og skrive et hav
af andre diskformater, FAT, vfat, NTFS (kun læse), UDF (DVD-format),
ISO 9600 (cdrom-format) og mange andre.
I netværk kan
man få adgang til filsystemet på andre systemer transparent ved hjælp
af NFS (Network File System) eller SMB (Windows filshare).
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>TCP/IP, SLIP og PPP understøttelse</emphasis>
Linux kan integreres i lokale Unix-netværk. I princippet kan alle
netværkstjenester som NFS og Remote Login bruges. SLIP og PPP
understøtter brugen af TCP/IP-protokollen over serielle linier. Det
betyder at link til Internettet via telefonnetværk ved hjælp af et modem er
muligt.
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>BSD-sockets</emphasis>
Netværkskommunikation kræver naturligvis midler til
interproces-kommunikation mellem forskellige computere. Interfaces
hertil er i BSD-sockets.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>System V IPC</emphasis>
Linux bruger dette til at lave 'message queues', semaforer og 'shared
memory'. Disse er klassiske varianter til interproces-kommunikation.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Virtuelle konsoller</emphasis>
Linux understøtter virtuelle konsoller. Tastekombinationen &lt;ALT&gt; +
&lt;Function key&gt; bruges til at skifte imellem dem.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Multiprocessing</emphasis> Fra kernel 2.0 understøtter
Linux symmetrisk multiprocessing - samtidig kørsel af processer på et
antal processorer - op til 16 processorer. I kerne 2.2-serien var man
i praksis begrænset til 4 processorer, mens man med kerne 2.4-serien
kan opnå skalerbar performance på 16 og 32 processorer.
 </para>
</listitem>
</itemizedlist>

</sect1>

<sect1 id="Linux-er-ikke">
<title>Linux er ikke</title>
<indexterm><primary>Realtids Linux</primary></indexterm>
<para>
Linux er ikke et real-time system. Bl.a. virtuel hukommelse gør det
umuligt for Linux at overholde kravene til et "hard" real-time system,
men det kan laves mere real-time end det er i dag, bl.a. ved at
arbejde med scheduling'en og optimere interruptene. Der er bl.a. et
projekt, RTLinux, som har lavet en overbygning på kernen til realtidsbrug.
</para>

<para>
Linux var tidligere (før kerne 2.0) en monolitisk kerne, mens man med
kerne 2.0 fik adgang til at lave kerne-moduler. Dette var en nødvendig
måde at kunne understøtte meget forskellig hardware på. To brugere med
forskelligt lydkort anvender hver sit kernemodul, og derfor har de to
brugere ikke unødvendig meget program-kode læst ind i hukommelsen.
</para>

<indexterm><primary>PVM</primary></indexterm>
<indexterm><primary>MPI</primary></indexterm>
<indexterm><primary>Parallel udførelse af
programmer</primary></indexterm>
<indexterm><primary>cluster</primary></indexterm>
<para>
Linux er ikke et distribueret operativsystem - alting foregår på én
maskine. Oven på Linux kan man så køre systemer såsom PVM og MPI til at
afvikle programmer på mange maskiner. Både PVM og MPI starter
processer på flere maskiner, udveksler data mellem maskinerne og
udnytter den store fælles datakapacitet til at køre programmerne i
parallel. Dette kræver dog at programmerne er skræddersyet til det.
Linux kan også snildt bruges til at lave et cluster af maskiner. Med
MOSIX <ulink url="http://www.mosix.org">http://www.mosix.org</ulink>
kan man binde en række maskiner sammen, så de udefra ser ud som én stor
maskine. MOSIX-clusteret fordeler selv programmerne efter laveste
belastning af de enkelte maskiner, og man kan transparent flytte
programmer fra en maskine til den næste. Det er særdeles elegant.
</para>


<para>
Linux er ikke sikret efter de strengeste sikkerhedsprincipper, men der
er indbygget en vis beskyttelse mod uforvarende at komme til at
ødelægge systemet. Brugeren har ikke adgang til alle system-filer, og
kan ikke slette andet end egne filer.
</para>
</sect1>

<sect1 id="proces-management">
<title>Proces management</title>

<para>
Unix-operativsystemer er multi-programming og multi-user systemer. Det
betyder at flere programmer kan køre på én computer samtidig, og
dermed også at flere personer kan bruge én computer som server
samtidig. For brugeren ser det ud som om programmerne kører parallelt,
og at flere processer dermed har CPU'en samtidig. Dette fungerer i
praksis ved, at hver proces har CPU'en i et bestemt tidsrum, hvorefter
den ryger bag i en kø og næste proces hentes ind (multi-tasking).
</para>

<para>
Linux understøtter, ligesom Unix, ægte multi-tasking. Alle processer
kører helt uafhængigt af hinanden, så ingen processer behøver at tage
højde for at give processor-tid til andre processer. Hver proces har
et hukommelses-område, som er beskyttet mod ændringer fra andre processer.
</para>

<sect2 id="Processtruktur">
<title>Processtruktur</title>
  
<para>
Det vigtigste og mest specielle ved et multi-tasking system er
processerne og proces-strukturen. En proces er et program, som er under
udførelse.
</para>

<para>
x86 arkitekturen understøtter 4 "privilege" modes (eller levels), hvor
mode 0 er den mest privilegerede, og 3 den mindst privilegerede. Et
kørende program vil altid være i en af disse modes.
</para>

<para>
Linux bruger kun 2 modes, nemlig kernel mode og user mode. Ved at
skelne mellem user mode og kernel mode kan man forhindre, at brugeren
har direkte adgang til de forskellige I/O-enheder.
</para>

<indexterm><primary>Kernel mode</primary></indexterm>
<para>
Der er kun adgang til disse fra kernel mode, og alle brugerprogrammer
kører i user mode. Brugerprogrammer har derved kun adgang til 
I/O-enheder igennem et på forhånd specificeret systemkald, som resulterer
i et skift fra user mode til kernel-system mode. Derved slipper
programmøren af brugerprogrammer for at bekymre sig om detaljerne
omkring f.eks. I/O. Hardwarens kompleksitet skjules derved for
brugeren og udvikleren.
</para>

<para>
Et brugerprogram kan således bruge operativsystemet til at få udført
forskellige instruktioner, ved at lave et systemkald. Et
brugerprogram, der kører under Linux, vil derfor se Linux-kernen som
en udbyder af servicefunktioner.
</para>

<para>
Når en proces kører i system mode, kan den være i en af følgende
tilstande:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
  <emphasis>Running</emphasis>
Running illustrerer et kørende program i user mode. Det
meste af tiden kører et program i user mode. En gang imellem er det
dog nødvendigt at gå i kernel mode. Dette kan kun ske ved et interrupt
eller et systemkald.
 </para>
</listitem>
<listitem> 
 <para>
 <emphasis>Interrupt-rutine</emphasis>
Interrupt-rutinen bliver aktiv, når der kommer et hardware-signal,
f.eks. nye inddata fra tastaturet.
 </para>
</listitem>
<listitem> 
 <para>
  <emphasis>Systemkald</emphasis> 
Systemkald aktiveres af software interrupts. Et
systemkald kan suspendere en proces, så den skal vente på en hændelse.
 </para>
</listitem>
<listitem> 
 <para>
  <emphasis>Waiting</emphasis>
Processen venter på en ekstern hændelse, og processen vil ikke
fortsætte, før denne hændelse indtræffer.
 </para>
</listitem>
<listitem> 
 <para>
 <emphasis>Retur fra systemkald</emphasis>
Denne tilstand opnås efter hvert systemkald og efter nogle interrupts.
Herfra kan scheduleren skifte processen til Ready og aktivere en anden
proces.
 </para>
</listitem>
<listitem> 
 <para>
 <emphasis>Ready</emphasis>
Processen konkurrerer om at komme til processoren, som er optaget af
en anden proces.
 </para>
</listitem>
</itemizedlist>

</sect2>
  
<sect2 id="Procesrelationer">
<title>Procesrelationer</title>

<para>
Proces-hierarkiet i Linux er et forælder-barn-hierarki. En ny proces
kan kun skabes med systemkaldet <command>fork()</command>. Den nye
proces bliver barn-proces til den proces, der udførte
<command>fork()</command>.  
</para>

<para>
Den nye proces bliver oprettet ved at lave en næsten identisk kopi af
den proces der kaldte <command>fork()</command>. Ofte er det første,
en ny proces gør, at udføre et execve-kald, som overskriver den
nedarvede kode, stak, registre mv., så den ikke længere er en kopi af
forælderprocessen, men en ny proces.
</para>

<para>
Det kan være meget ressourcekrævende at oprette en ny proces, da der
kan være mange data fra forælderprocessen, som skal kopieres. Derfor
bruges der i Linux "copy-on-write" teknikken. Tanken bag denne teknik
er, at et antal processer kan have adgang til den samme hukommelse, så
længe der ikke er nogen af processerne, der laver ændringer i data.
Således bliver de relevante pages af hukommelse ikke kopierede ved
systemkaldet <command>fork()</command>, men den fælles hukommelse bliver
skrivebeskyttet.  Hvis en af processerne forsøger at skrive til hukommelsen,
bliver processen afbrudt, og kernen laver en kopi af den relevante
page. Herefter kan der tildeles en kopi til hver proces. Den store
fordel ved denne metode er, at data kun bliver kopieret hvis det er
nødvendigt.
</para>
</sect2>

<sect2 id="Proces-ID">
<title>Proces-ID</title>

<para>
Alle processer har deres eget ID-nummer (pid) og er i en gruppe og en
session. I Linux kan en proces være tilknyttet flere grupper.
</para>

<para>
Når en ny proces bliver genereret, får den et nyt pid-nummer, og
<command>fork()</command> returnerer 0 til barn-processen og 
barn-processens pid til forælder-processen. Derved kan de to processer se,
hvilken proces der er barn-proces, og hvilken der er forælder-proces.
</para>

<para>
For at kunne bestemme hvor en proces har adgang, har hver proces et
bruger-ID (userid = uid) og et gruppe-ID (gid). Disse ID-numre har 
børne-processerne arvet efter deres forældre-processer. Når en 
adgangskontrol skal foretages, er det dog den effektive bruger-ID (euid) 
og gruppe-ID (egid) der bliver brugt. Generelt er uid = euid og gid = egid,
undtagen for set-UID programmer.
</para>

<para>
 I disse programmer bliver euid og
egid sat til bruger-ID og gruppe-ID for ejeren af den eksekver-bare fil.
På denne måde er det muligt for superuseren at give almindelige
brugere adgang til brug af systemadministrative programmer på en
kontrolleret måde. Et set-UID program er et program hvor
set-UID-bitten er sat. Af sikkerhedsårsager understøtter Linux kun
set-UID på binære filer, ikke på shell scripts.
</para>

</sect2>
</sect1>

<sect1 id="kerne-proc">
<title>proc-filsystemet</title>
<indexterm><primary>/proc</primary></indexterm>
<para>
Som systemadministrator (root) har man gode muligheder for at følge,
hvad Linux-kernen foretager sig. Prøv at skrive <command>mount</command>. En
af de linier, som kommer frem er
</para>

<screen>
none on /proc type proc (rw)
</screen>

<para>
I modsætning til de almindelige filsystemer, som er monteret
(f.eks. <filename>/dev/hda1</filename>, <filename>/dev/hda2</filename>
osv.), så er <filename>/proc</filename> meget speciel. Prøv
f.eks. som det første eksperiment at se følgende fil.
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>ls -l /proc/kcore</userinput>
-r--------    1 root     root     134156288 jan 22 23:18 /proc/kcore   
</screen>

<para>
Betyder dette, at der ligger en ca. 128 MB stor fil? Nej - alt hvad
der ligger under <filename>/proc</filename> er virtuelt. Det er
Linux-kernen som på en elegant måde giver adgang til en række nyttige
kerne-informationer. I eksemplet er <filename>/proc/kcore</filename>
en adgang til hele den fysiske RAM i maskinen. Lad os se mere på hvad
der sker i <filename>/proc</filename>
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>ls -l /proc/</userinput>
1/     1150/  529/ 741/  9725/ 9794/       fs/        partitions
10023/ 15656/ 539/ 765/  9726/ 9795/       ide/       pci
10030/ 15657/ 554/ 809/  9727/ 9797/       interrupts rtc
10043/ 15658/ 570/ 825/  9765/ 9798/       ioports    scsi/
1017/  17917/ 571/ 961/  9767/ 9800/       kcore      self@
10313/ 17931/ 581/ 965/  9769/ 984/        kmsg       slabinfo
10317/ 17964/ 596/ 966/  9771/ 9950/       ksyms      sound
1051/  18243/ 6/   967/  9776/ 9958/       loadavg    stat
1052/  18246/ 61/  968/  9777/ apm         locks      swaps
1053/  18250/ 698/ 969/  9780/ bus/        mdstat     sys/
1054/  18524/ 701/ 970/  9782/ cmdline     meminfo    tty/
1055/  2/     702/ 971/  9784/ cpuinfo     misc       uptime
10571/ 3/     703/ 9717/ 9786/ devices     modules    version
10723/ 307/   704/ 972/  9788/ dma         mounts
1083/  4/     717/ 9722/ 9789/ fb          mtrr
11294/ 5/     732/ 9723/ 9791/ filesystems net/                          
</screen>

<para>
<indexterm><primary>PID</primary></indexterm>
<indexterm><primary>Proces-ID</primary></indexterm>
<indexterm><primary>ps</primary></indexterm> 
Som det kan ses, er der en
mængde kataloger med numre. Der er et katalog for hver proces på
maskinen. Lad os se på et af katalogerne mere detaljeret. Der kører
netop nu en <command>emacs</command> på maskinen med PID=18243 (PID
betyder proces-ID). Dette findes ved brug af
<filename>ps</filename>. Tilsvarende kan vi se hvad kataloget i
<filename>/proc/18243</filename> indeholder.
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>ps aux | grep emacs</userinput>
pto  18243  0.1  4.7  8940 6076 pts/1   S  22:11  0:09 emacs kerne.sgml 
<prompt>[anne@linus ~]$ </prompt><userinput>ls /proc/18243</userinput>
cmdline  cwd   environ  exe    fd  maps  
mem      root  stat     statm  status       
</screen>

<para>
Det første underlige er, at filerne har filstørrelse nul. Det skal man
ikke lade sig snyde af. Alt er virtuelt her - og nogle gange kan filer
i <filename>/proc</filename> have indhold. Prøv selv at køre
<command>more /proc/PID/cmdline</command>, hvor PID er en 
proces-ID på din maskine, f.eks. for en editor, du har startet på 
kommando-linien.
</para>

<para>
Via <filename>/proc/PID/cwd</filename> er der direkte adgang til de
katalog, som programmet blev startet op i. Filerne
<filename>/proc/PID/stat*</filename> (tre filer) fortæller mere om
f.eks. hukommelsesforbrug og andre status-parametre.
</para>

<para>
Nu har vi set på hvad der gemmes for den enkelte proces. Lad 
os nu se på hvad der ellers kan findes i <filename>/proc</filename>. 
</para>

<para>
Belastning af maskinen (load) - eller rettere - hvor mange processer,
der prøver at tilgå kernen i snit, kan ses direkte ud fra
<filename>/proc/loadavg</filename>. Det er samme tal som
<command>uptime</command> har til sidst - belastning det sidste minut,
sidste 5 minutter, og endelig de sidste 15 minutter.
<indexterm><primary>uptime</primary></indexterm>
<indexterm><primary>load</primary></indexterm>
</para>

<para>
Vil du vide mere om, hvor meget hukommelse er brugt, så kan du få
dette fra kommandoen <command>free</command>, men en endnu mere
detaljeret visning kan hentes fra filen
<filename>/proc/meminfo</filename>.
</para>


<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>free </userinput>
             total   used  free shared buffers cached
Mem:        127760 124336  3424 135860    4684  52104
-/+ buffers/cache:  67548 60212
Swap:        68504   7120 61384       
<prompt>[anne@linus ~]$ </prompt><userinput>more /proc/meminfo</userinput>
        total:    used:    free:  shared: buffers:  cached:
Mem:  130826240 127242240  3584000 139255808  4788224 53280768
Swap: 70148096  7290880 62857216
MemTotal:    127760 kB
MemFree:       3500 kB
MemShared:   135992 kB
Buffers:       4676 kB
Cached:       52032 kB
BigTotal:         0 kB
BigFree:          0 kB
SwapTotal:    68504 kB
SwapFree:     61384 kB
</screen>

<para>
I <filename>/proc/net/</filename> er der en masse nyttig information om
hvordan netværket ser ud lige nu. De fleste filer er direkte læsbare for
alle, mens f.eks. firewallfilerne (for kerne 2.2)
<filename>/proc/net/ip_fwchains</filename> (med firewallopsætningen) og
<filename>/proc/net/ip_fwnames</filename> kun kan læses af root (sikkerhed).
</para>
</sect1>

<!-- Devfs skrevet af Rasmus Laursen dsl13480@vip.cybercity.dk -->
<sect1 id="devfs">
<title>Devfs</title>

<indexterm><primary>Devfs</primary></indexterm>

<para>
En af de nye ting i kerne 2.4.x er devfs, som er et godt alternativ
til <filename>/dev</filename>-katalog-systemet.
</para>

<sect2 id="hvad-er-dev">
<title>Hvad er /dev</title>
<para>
<filename>/dev</filename>'s funktion er at strukturere
alle mulige (og umulige) devices, som <emphasis>filer</emphasis>. Hver
enkelt <emphasis>fil</emphasis> definerer et enkelt device vha. 2
pointere (også kaldet major & minor number). Major angiver type af
device (f.eks: disk-, terminal-, seriel-enhed), minor angiver det
enkelte device, indenfor den enkelte type (f.eks: tty1, tty2,...hda1,
hda2). Disse 2 pointere benytter kernen til at "slå op" i en
device-driver tabel, for at finde den rigtige driver til et givent
device.
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>ls -la /dev/hda*</userinput>
brw------- 1 root root 3, 0 jan 1 1970 /dev/hda
brw------- 1 root root 3, 1 jan 1 1970 /dev/hda1
.
.
<prompt>[root@linus /root]#</prompt> <userinput>ls -la /dev/tty?</userinput>
crw------- 1 root root 4, 1 maj 24 05:38 tty0
crw------- 1 root root 4, 2 maj 24 05:38 tty1
.
.
</screen>

<para>
Hvor 1. nummer efter gruppe er Major og 2. nummer er Minor.
</para>

<para>
For at være sikker på at et givent device vil virke, skal der altså
være en device-fil i <filename class=directory>/dev</filename>. Da der
er mange forskellige (typer) devices, skal der også være mange
filer. Og for at mindske administrationen, er de oprettet på forhånd.
I et typisk system, som f.eks Redhat 7.0, er der godt 12000 filer. Og
det er nok de færreste filer, det enkelte system har brug for. Det er
ikke fordi de fylder noget (omkring 300kb ialt), men de optager hver
en <ulink
url="http://e2fsprogs.sourceforge.net/ext2intro.html">inode</ulink>.
Hvis device-filen for et bestemt device nu ikke lige er oprettet, kan
man benytte programmet <command>/dev/MAKEDEV</command> som kender til
(næsten) alle devices og deres respektive major og minor numre.
</para>

<para>
Hvorfor denne redundans, kan man så spørge? At både <filename
class=directory>/dev</filename>, <command>MAKEDEV</command> programmet
og kernen skal have alle disse informationer? Det har nok været den
mest indlysende og overskuelige måde at designe det på i tidernes
morgen. Men som antallet af devices stiger, bliver det mere og mere
uoverskueligt og tidskrævende at administrere.  Og det kan Devfs gøre
noget ved.
</para>
</sect2>

<sect2 id="hvad-er-devfs">
<title>Hvad er Devfs</title> 
<para>
Devfs er et virtuelt filsystem, som har
samme funktion som <filename class=directory>/dev</filename>, men som
ikke ligger fysisk på harddisken. Umiddelbart vil det ligne <filename
class=directory>/dev</filename>, da man tilgår device-filer igennem
kataloget <filename>/dev</filename>. Linket går bare
ikke ned på disken, men direkte ind i kernen (efter samme princip 
<filename>/proc</filename>.
Dermed er man fri for administrationen og redundans, da filerne altid
svarer til de devices som kernen har fundet.
</para>

<sect3 id="installation-af-devfs">
<title>Installation af Devfs</title>
<para>
Devfs kræver en Linux-kerne oversat med parametrene CONFIG_DEVFS_FS og
CONFIG_DEVFS_MOUNT, og user-space deamonen <command>devfsd</command>
fra <ulink
url="ftp://ftp.atnf.csiro.au/pub/people/rgooch/linux/daemons/devfsd/">Richard
Gooch's ftp site</ulink>. Se i øvrigt <xref linkend="kernelcompile">.
</para>

<para>
Udpak devfs deamonen et sted og kør følgende:
</para>

<screen>
<prompt>[root@linus devfs]#</prompt> <userinput>make</userinput>
<prompt>[root@linus devfs]#</prompt> <userinput>make install</userinput>
</screen>

<para>
Som default vil <command>devfsd</command> ligge i
<filename>/sbin</filename>.
</para>

<para>
For at et system kan gøre brug af devfs, er det noget af det første
<command>init</command> skal starte. Det er rimeligt system specifikt
hvor opstart af devfsd skal ske, da systemfilerne (se <xref
linkend="etcrcdfilen"> er forskellige. I System-V baserede systemer er
det <command>/etc/rc.d/rc.sysinit</command>, hvor det i BSD baserede
er i <command>/etc/rc</command>. Men under alle omstændigheder skal
den første linje i disse filer være:
</para>

<screen>
/sbin/devfsd /dev
</screen>

<para>
Bemærk: Fra og med Redhat 7.0 er følgende linje allerede indsat i
<command>/etc/rc.d/rc.sysinit</command>:
</para>

<screen>
[ -e /dev/.devfsd -a -x /sbin/devfsd ] &amp;&amp; /sbin/devfsd /dev

</screen>

<para>
Lidt forklaring. Hvis der ligger en fil ved navn
<filename>.devfs</filename> i <filename>/dev</filename> og en
eksekverbar fil ved navn <command>devfsd</command> i
<filename>/sbin</filename>, så start devfs deamonen. Så det eneste
man behøver for at aktivere devfs på Red Hat system er at eksekvere
følgende kommando:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>touch /dev/.devfsd</userinput>
</screen>

<para>
Også er det bare at reboote. Så enkelt er det.
</para>
</sect3>

<sect3 id="problemer-med-devfs">
<title>Problemer med Devfs</title>
<para>
Forhåbentligt skulle der ikke opstå problemer, men det kan være at der
i enkelte tilfælde er device-drivere som ikke er understøttet af Devfs
endnu. Her er der 2 løsniger. Den ene er at hvis det kun drejer sig om
nogle få device-filer, kan de oprettes under opstart
vha. <command>mknod</command> programmet. Den anden er at pakke alle
de ikke devfs kompatible device-filer ind i en tar fil, som pakkes ud
i <filename>/dev</filename> under opstart.
</para>

<para>
Man kan også komme ud for at programmer benytter
<emphasis>letforståelige</emphasis> links til device-filer. Som
f.eks. muse programmet <command>gpm</command>. <command>Gpm</command>
benytter som default device-filen <filename>/dev/mouse</filename>. I
dette tilfælde vil det være en god ide at sørge for at
<command>gpm</command> gør brug af <filename>/dev/psaux</filename>
direkte (eller anden "rigtig" device-fil for mus).  Da der ikke er en
konfigurationsfil til <command>gpm</command> bliver man nød til at gå
direkte ind i scriptet for startup scriptet til <command>gpm</command>
(se <xref linkend="etcrcdfilen">) og tilføje parametren:
"<parameter>-m /dev/psaux</parameter>".  Redhat 7.1 har forbedret det
lidt, ved at kunne specificere et device i
<filename>/etc/sysconfig/gpm</filename>.  Opstarts scriptet
<filename>/etc/rc.d/init/gpm</filename>, indeholder dog en fejl som
gør at devicet altid vil være <filename>/dev/mouse</filename>. Ændrer
derfor følgende i <filename>/etc/rc.d/init/gpm</filename>:
</para>

<screen>
if [ -n "$DEVICE" ]; then
        DEVICE="/dev/mouse"
fi
</screen>

<para>
til følgende:
</para>

<screen>
if [ -z "$DEVICE" ]; then
        DEVICE="/dev/mouse"
fi
</screen>

<para>
Som tester om miljø-variablen "DEVICE" er tom. Hvis den er det,
er der ikke angivet noget device i
<filename>/etc/sysconfig/gpm</filename>, og "DEVICE" sættes til
<filename>/dev/mouse</filename>.
</para>

<para>
Vi du vide mere om Devfs, så kan vi anbefale 
Richard Gooch's Linux Devfs (Device File System) FAQ, som findes på <ulink url="http://www.atnf.csiro.au/~rgooch/linux/docs/devfs.html">http://www.atnf.csiro.au/~rgooch/linux/docs/devfs.html</ulink>.
</para>
</sect3>
</sect2>
</sect1>

<SECT1 ID="kernelcompile">
<TITLE>Omkonfigurere Linux-kernen</TITLE>
<indexterm><primary>Linux</primary><secondary>kernen</secondary></indexterm>
<indexterm><primary>Kerne, omkonfigurering</primary></indexterm>

<PARA>
Kernen er det program, der styrer computeren. Den består af en
række forskellige funktioner, og vi vil i dette afsnit diskutere,
hvordan du kan omkonfigurere kernen, så den kommer til at passe bedre til
din computer. Sagen er nemlig den, at den kerne, som følger med
f.eks. Red Hat, indeholder en række funktioner, som du måske 
ikke har brug for. Ved at omkonfigurere kernen slipper du for at spilde en
masse hukommelse (og måske tid). Du kan måske også mangle understøttelse for
en hardware-del, f.eks. USB (Universal Serial Bus). USB er for
nylig kommet med i Linux-kernen, hvorfor du kan blive nødt til at
lave en ny Linux-kerne. 
</PARA>

<PARA>
Vores gennemgang af kernekonfiguration er overfladisk, dvs. vi vil
ikke gå i detaljer med, hvad de enkelte funktioner kan, men forklare
dig, hvordan en konfiguration foregår.  Du kan installere den
kernel HOWTO-guide som følger med flere af Linux-distributioner og
lære meget mere om kernen.
</PARA>

<PARA>Et par bemærkninger omkring drivere til Linux er på sin
plads. Drivere kan eksistere på to måder under Linux: Som
en del af kernen eller som et modul. Hvis driveren er en
del af kernen, ligger den fast i hukommelsen hele tiden, men et modul
indlæses først i det øjeblik, der er brug for det - ja,
faktisk kan et modul også fjernes fra hukommelsen, når der ikke
er brug for det længere (se <xref linkend="kerne-moduler">). Det er
klart en fordel at benytte moduler, hvis man ikke har megen hukommelse.
</PARA>

<sect2 id="kernelklar">
<title>Bliv klar til at oversætte kernen</title>
<indexterm><primary>Kerne</primary><secondary>oversætte</secondary></indexterm>
<indexterm><primary>Oversætte</primary><secondary>Linux kernen</secondary></indexterm>

<PARA>
Første trin til at lave din egen kerne er at se, om du fik installeret
hele kildekoden til Linux-kernen. Der er to muligheder; enten fra den
installations-cdrom du har, eller fra en helt ny kildetekst.
</PARA>

<para>
Hvis du vil installere kildekoden til kernen, så skriv

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>rpm -ivh /cdrom/RedHat/RPMS/kernel-headers-2.2.5-15.i386.rpm</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>rpm -ivh /cdrom/RedHat/RPMS/kernel-source-2.2.5-15.i386.rpm</USERINPUT>
</SCREEN>

Dette gør, at kildeteksten lægges ind i <filename>/usr/src/linux</filename>.
</para>

<para>
I øvrigt kan det tilrådes at lade <filename>/usr/src/linux</filename> være et
symbolsk link til et versionsafhængigt underkatalog:
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>ls -l /usr/src/linux</USERINPUT>
lrwxrwxrwx   1 root root   11 Jan 31 12:01 linux -> linux-2.2.5
drwxr-xr-x  17 root root 1024 Jan 25 21:22 linux-2.0.36
drwxr-xr-x  15 root root 1024 Jan 31 20:45 linux-2.2.5
</screen>

<para>
På denne måde er det nemt at teste forskellige versioner af
Linux-kernen. Antag, at du vil opgradere til kerne 2.3.1, som du
henter hjem fra <ulink
url="http://www.kernel.org">http://www.kernel.org</ulink> (eller et
mirror - f.eks. <ulink url="ftp://ftp.sunsite.dk"></ulink>), dvs. nu
vil du installere kildeteksten selv (uden RPM). Start med at lave en
ny mappe og et symbolsk link til den nye mappe (du skal være root).
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>rm /usr/src/linux</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>mkdir /usr/src/linux-2.3.1</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>ln -s /usr/src/linux-2.3.1 /usr/src/linux</USERINPUT>
</screen>

<para>
Gå (brug <command>cd</command>) ned til
<filename>/usr/src/linux</filename> og læs <filename>README</filename>
(med <command>less README</command>). I denne fil er forklaret, hvordan du
oversætter kernen. Du bør altid også læse
<filename>/usr/src/linux/Documentation/Changes</filename>, som
beskriver, hvordan dit system bør være konfigureret, for at du kan
oversætte kernen.
</para>

</sect2>

<sect2 id="oversaet-kerne">
<title>Oversæt Linux-kernen</title>
<PARA>For det første skal du skifte til kataloget
<FILENAME>/usr/src/linux</FILENAME>, hvor kildeteksten til kernen er
placeret. Skriv nu <userinput>make xconfig</userinput>. Du vil nu se
et vindue som det nedenfor.
</PARA>

<FIGURE ID="kerne-conf-main" FLOAT="1">
<TITLE>Hovedmenu for konfiguration af Linux-kernen</TITLE>
<GRAPHIC FILEREF="kerne-config-main.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<PARA>Som du kan se, er der en række punkter, som du kan
konfigurere. Du kan nu trykke på "General Setup", og du vil få
et vindue som nedenfor. I langt de fleste punkter i menuen kan du
vælge mellem "y", "m" og "n". Vælges "y", bliver funktionen en
del af kernen, mens "n" betyder, at den ikke kommer med. Hvis du vælger
"m", bliver den ikke en del af kernen, men funktionen vil eksistere som
et modul. Som du også kan se, er der mulighed for at få en
forklaring ved at trykke på knappen "help". Når du har konfigureret
kernen, trykker du på "Save and exit".
</PARA>

<FIGURE ID="kerne-conf-gs" FLOAT="1">
<TITLE>"General Setup" menuen</TITLE>
<GRAPHIC FILEREF="kerne-general-setup.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<PARA>
Du er nu klar til at generere en ny kerne. Der er en række skridt, som
du bare skal følge. Først gennemgås alle afhængigheder i kernen
(<command>make dep</command>).  Selve oversættelsen af kernen
(<command>make bzImage</command>) og moduler (<command>make
modules</command>) kan godt tage en rum tid afhængigt af, hvor meget
du har taget med, og hvor hurtig din maskine er.
</PARA>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>cd /usr/src/linux</USERINPUT>
<PROMPT>[root@linus linux]# </PROMPT> <USERINPUT>make dep</USERINPUT>
<PROMPT>[root@linus linux]# </PROMPT> <USERINPUT>make clean</USERINPUT>
<PROMPT>[root@linus linux]# </PROMPT> <USERINPUT>make bzImage</USERINPUT>
<PROMPT>[root@linus linux]# </PROMPT> <USERINPUT>make modules</USERINPUT>
<PROMPT>[root@linus linux]# </PROMPT> <USERINPUT>make modules_install</USERINPUT>
</SCREEN>

<para>
Bagefter kan du finde den nye Linux-kerne i
<filename>/usr/src/linux/arch/i386/boot/bzImage</filename>. Du kan
teste den nye kerne ved at kopiere den til en diskette og så starte
fra denne. Brug <command>dd if=/usr/src/linux/arch/i386/boot/bzImage
of=/dev/fd0</command> for at teste på denne måde. Er du tilfreds med
den nye kerne, kan du kopiere kernen til <filename>/boot</filename> og
rette i LILO's konfigurationsfil (<filename>/etc/lilo.conf</filename>)
og køre <command>/sbin/lilo</command>, hvis du anvender LILO til at
starte maskinen.
</para>

<para>
Moduler laves til kernen svarende til kernens versionsnummer under
<filename>/lib/modules</filename>, dvs. for kerne 2.3.1 gemmes de i
<filename>/lib/modules/2.3.1</filename>  Nu spørger du måske om,
hvorfor man i det hele taget laver en kerne og så moduler. Dels kan
kernen blive mindre og derfor ofte hurtigere. Men er der fejl i et
modul, kan man hurtigt rette i modulets kildetekst, genoversætte
koden og starte modulet på ny - uden at genstarte maskinen!
</para>

</sect2>

<sect2 id="rescuedisk">
<title>Lav en redningsdiskette</title>
<para>
Har du brug for at lave en redningsdiskette (eng. rescue-disk), med
Linux-kernen på, som du
kan starte din Linux-maskine fra, så kan du gøre dette med
<command>mkbootdisk</command>. Find først ud af, hvilken
kerne der er på dit system. Kør f.eks. <command>ls
/lib/modules/</command>. Står der 2.2.12-20, så skal du - som root -
skrive 
<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>/sbin/mkbootdisk --device /dev/fd0 2.2.12-20</USERINPUT>
</SCREEN>

Disken har Linux-kernen, og du kan også bruge denne disk, hvis du skal
flytte rundt på dine harddiske (fra primær til sekundær osv).
</para>


</sect2>

</SECT1>

<sect1 ID="kerne-moduler">
<title>Moduler</title>
<indexterm><primary>Linux</primary><secondary>kerne-moduler</secondary></indexterm>
<indexterm><primary>Moduler</primary><secondary>Linux kerne-moduler</secondary></indexterm>
<para>
Moduler (eller mere korrekt: indlæsbare kerne-moduler) er en af de
mere smarte ting ved Linux. Kort fortalt er et modul en driver, som
systemadministratoren (root) kan indlæse og nedlægge, mens maskinen 
kører, dvs. du kan indlæse en driver uden at genstarte. I dette
afsnit vil vi introducere det mest basale omkring moduler.
</para>

<para>
Modul-systemet blev skrevet om til kerne version 2.2 (som følger med
Red Hat 7.0 og SuSE 6.4). Vi vil antage, at du har en version 
2.2 kerne. Du kan evt. tjekke det ved at skrive <userinput>uname
-r</userinput>. For en standard-installation af Red Hat 6.2 vil din
maskine svare "2.2.14-20".
</para>

<sect2 id="lsmod">
<title>Hvad findes der allerede indlæst?</title>
<indexterm><primary>lsmod</primary></indexterm>
<para>
Inden vi går i krig med at indlæse moduler, kan det være rart at vide,
hvilke der allerede er indlæst. For at finde ud af det skal du bruge
kommandoen <command>lsmod</command>, som er en forkortelse for "list
modules". Kommandoen kan udføres af alle brugere, men vær opmærksom på,
at kommandoen ligger i kataloget <filename>/sbin</filename>, og at
almindelige bruger ikke har dette katalog med i deres søgesti. Derfor
skal du skrive <command>/sbin/lsmod</command>, hvis du ikke er logget
ind som systemadministrator (root).
</para>

<screen>
<prompt>[root@linus /root]# </prompt> <userinput>lsmod</userinput>
Module                  Size  Used by
ppp                    18316   0  (autoclean)
slhc                    4328   0  (autoclean) [ppp]
autofs                  9028   1  (autoclean)
nfs                    29944   1  (autoclean)
lockd                  30856   1  (autoclean) [nfs]
sunrpc                 52356   1  (autoclean) [nfs lockd]
nls_iso8859-1           2020   1  (autoclean)
nls_cp437               3548   1  (autoclean)
vfat                   11516   1  (autoclean)
fat                    25664   1  (autoclean) [vfat]
awe_wave              157804   0 
sb                     33204   0 
uart401                 5968   0  [sb]
sound                  57208   0  [awe_wave sb uart401]
soundlow                 300   0  [sound]
soundcore               2372   7  [sb sound]
</screen>

<para>
Tabellen, som <command>lsmod</command> producerer, indeholder navn på
modulet, hvor meget hukommelse det bruger, hvor mange programmer der
bruger modulet, samt om der er andre moduler, som bruger modulet. Tag
nu PPP-modulet: det fylder 18315 bytes, og ingen programmer eller andre 
moduler benytter det (logisk, idet forbindelsen til Internet-udbyderen 
er lukket ned).
</para>
</sect2>

<sect2 id="modprobe">
<title>Indlæs et modul</title>
<indexterm><primary>modprobe</primary></indexterm>
<para>
Typisk ligger moduler i en undermappe til
<filename>/lib/modules</filename>. På en standard-installation af Red 
Hat 6.2 hedder undermappen <filename>2.2.14-5.0</filename> efter
kernen (husk svaret fra <command>uname</command>). Nede i
<filename>/lib/modules/2.2.14-5.0</filename> finder du en række
underkataloger. Alle modulerne er grupperet efter deres anvendelse,
f.eks. indeholder undermappen <filename>cdrom</filename> drivere
til cdrom-drev (alle andre end ATAPI-drev). Til at indlæse et modul
bruger du kommandoen <command>modprobe</command>. 
Du kan kun indlæse moduler som
systemadministrator. Nedenfor viser vi, hvordan du kan indlæse en
driver til HPFS (OS/2's filsystem).
</para>

<screen>
<prompt>[root@linus /root]# </prompt> <userinput>modprobe hpfs</userinput>
</screen>

<para>
Det fine ved modul-systemet er, at du kun behøver at angive navnet på
modulet; <command>insmod</command> finder selv ud af, hvor det er
placeret.
</para>

<para>
Det kan være, at du kommer til at angive det forkerte modul, dvs. du
forsøger at indlæse et modul til et stykke hardware, som du ikke
har. Nedenfor forsøger vi at indlæse driveren til et Intel
EtherExpress Pro/100 kort; et kort, som <emphasis>ikke</emphasis>
sidder i maskinen.
</para>

<screen>
<prompt>[root@linus /root]# </prompt> <userinput>modprobe eepro100</userinput>
/lib/modules/2.2.5-15/net/eepro100.o: init_module: Device or resource busy
</screen>
</sect2>

<sect2 id="modprobe-r">
<title>Nedlæg et modul</title>
<indexterm><primary>modprobe</primary><secondary>-r</secondary></indexterm>
<para>
Det kan ske, at du bliver træt af et modul eller blot i længere tid
ikke har brug for det, og du derfor gerne vil nedlægge det igen. Der
er to måder, du kan gøre det på. Den første kræver simpel tålmodighed:
efter 60 sekunder vil ubrugte moduler automatisk blive nedlagt. Dette
sørger en dæmon ved navn <command>kerneld</command> for. Den anden måde
er at gøre det selv. Til denne metode skal du bruge kommandoen
<command>modprobe -r</command> ("remove module").
</para>

<screen>
<prompt>[root@linus /root]# </prompt> <userinput>modprobe -r hpfs</userinput>
</screen>

<para>
Kigger du i mappen <filename>/lib/modules/2.2.14-5.0</filename>, ser
du filen <filename>modules.dep</filename>. Filen indeholder information
om, hvilke moduler et modul afhænger af. Filen er en tekstfil, så du
kan bladre i den ved hjælp af <command>less</command> eller
<command>more</command>. Filen skal du ikke pille ved - den bliver
automatisk genereret under opstart af Linux ved at <command>depmod
-a</command> køres.  Næste gang din maskine starter, kan du se efter
linjen "Finding module dependencies" - på det tidspunkt genereres
filen.  Derved sikrer man sig at der anvendes det rigtige modul, dette
er specielt vigtigt hvis man har flere kerneversioner installeret.
</para>
</sect2>

<sect2 id="modulkonfiguration">
<title>Konfiguration</title>
<para>
Når vi taler om moduler, findes der en meget vigtig fil, som
systemadministratoren kan rette i, nemlig
<filename>/etc/modules.conf</filename>. Det skal lige siges, at filen
bliver rettet af mange af de værktøjer, som vi omtaler i
dette kapitel, f.eks. <command>sndconfig</command>, så måske kommer du 
aldrig selv til at rette i den. Lad os se på indholdet af en ikke helt
ualmindelig <filename>modules.conf</filename>. 
</para>

<screen>
# /etc/modules.conf
alias parport_lowlevel parport_pc
pre-install pcmcia_core /etc/rc.d/init.d/pcmcia start
alias sound sb
pre-install sound insmod sound dmabuf=1
options opl3 io=0x388
alias midi awe_wave
post-install awe_wave /bin/sfxload /etc/midi/GU11-ROM.SF2
options sb io=0x220 irq=5 dma=1 dma16=5 mpu_io=0x330
</screen>

<para>
Syntaksen for filen er som følger: først et nøgleord, derefter et navn
på et modul og til slut en række parametre.
</para>

<para>
Lad os begynde med det "lette" nøgleord først. Det lette nøgleord er
"alias". Et alias betyder simpelthen, at når systemet spørger efter et
modul, mener systemet i virkeligheden et andet. Det lyder lidt
mærkeligt, men det er meget nyttigt. Et alias som <userinput>alias
eth0 eepro100</userinput> vil betyde at når Linux forsøger at
initialisere ethernettet (eth0), skal driveren
<filename>eepro100</filename> bruges. Ofte kan Linux ikke automatisk
detektere udvidelseskort i gamle maskiner, og det kan derfor være nyttigt 
at fortælle Linux, hvilket netkort der sidder i maskinen. Har du et
gammelt kort, tilføjer du derfor en "alias"-linje som
passer til dit kort. Et andet eksempel kan være hvis du skal sætte dit 
3Com 90x netkort i 10 Mbit mode (og ikke 100 Mbit), så skal du
indsætte følgende linier
</para>

<screen>
alias eth0 3c90x
option 3c90x media_select=1
</screen>


<para>
Et andet nøgleord er "options" (parametre). Her kan systemadministratoren
angive en række parametre til en driver/modul. I det ovenstående
eksempel på <filename>modules.conf</filename> står der
f.eks. <userinput>options sb io=0x220 irq=5 dma=1 dma16=5
mpu_io=0x330</userinput>. Denne linje fortæller modulet
<filename>sb</filename> en række ting - i dette tilfælde de relevante
oplysninger omkring et SoundBlaster lydkort (f.eks. at I/O adressen
er 220, og interruptet er 5).
</para>

<para>
Nøgleordet "pre-install" fortæller modul-systemet, at før et modul
indlæses, skal et andet modul være indlæst. Alt hvad der kommer
efter modulets navn, tolkes som en kommando med tilhørende
parametre. Ligeledes findes "post-install", som angiver en kommando, der
skal udføres efter modulet er indlæst.
</para>

<para>
I Debian og Corel Linux bør man ikke rette
<filename>/etc/conf.modules</filename>/ da programmet
<command>update-modules</command> vil overskrive filen.  Programmet
henter konfigurationen fra filerne i
<filename>/etc/modutils/</filename> , bl.a. stier, options arhc/i386,
og aliaser.  Skal man lave rettelser bør det gøres i disse filer og
efterfølgende bør <command>update-modules</command> udføres.
</para>
</sect2>
</sect1>


<sect1 id="kerne-2-4">
<title>Kerne 2.4</title>
<para>
Den seneste generation af Linux-kernen er 2.4, som udkom den 5. januar
2001. Linus Torvalds annoncerede i vittig og underspillet tone, at nu
var kerne 2.4.0 færdig:
</para>

<screen>
In a move unanimously hailed by the trade press and industry analysts as
being a sure sign of incipient braindamage, Linus Torvalds (also known as
the "father of Linux" or, more commonly, as "mush-for-brains") decided
that enough is enough, and that things don't get better from having the
same people test it over and over again. In short, 2.4.0 is out there.

Anxiously awaited for the last too many months, 2.4.0 brings to the table
many improvements, none of which come to mind to the exhausted release
manager right now. "It's better", was the only printable quote. Pressed
for details, Linus bared his teeth and hissed at reporters, most of which
suddenly remembered that they'd rather cover "Home and Gardening" than the
IT industry anyway.

Anyway, have fun. And don't bother reporting any bugs for the next few
days. I won't care anyway.

                Linus
</screen>

<para>
Hvad er det så kerne 2.4 har opnået i forhold til de meget anvendte
kerner fra 2.2-serien? Svaret er - mange ting.
</para>

<para>
For det første er antallet af platforme, der understøttes
øget. Således er der nu også understøttelse for S/390 (IBM
mainframe-system), nye 64-bit MIPS-processorer samt Intels kommende
Itanium. Specielt S/390 synes mange er spændende, idet det bringer
Linux ind på mainframe- markedet. F.eks. har Telia i december 2000 købt
en sådan maskine som erstatning for 70 Sun-computere.  Desuden
udnytter 2.4 MMX instruktioner og andre udvidelser til det klassiske
x86 instruktionssæt bedre end den gamle kerne.
</para>

<para>
En anden ting som er blevet klart forbedret i Linux-kernen er SMP, altså
muligheden for at anvende flere processorer i samme maskine. Hvor kerne
2.2 var fin med 2 processorer og endda 4, så var ydelsen ved 8 og 16
processorer ikke imponerende. Med kerne 2.4 er ydelsen på 8 og 16
processorer forbedret markant.
</para>

<para>
Kerne 2.4 skulle umiddelbart ikke kræve mere hukommelse end kerne
2.2-serien - men den understøtter meget mere hukommelse.  En af de
ting, som nogle var utilfredse med i kerne 2.2-serien, var mængden af
hukommelse, som Linux-kernen kunne bruge. Når man konfigurerer
2.4-kernen, er der spørgsmål om hvor meget hukommelse man har. Tre
grænser kan man vælge - under 1 GB (off), op til 4 GB eller 64 GB
RAM. Det er efter sigende en 5-6% mindre ydelse, hvis man vælger 64 GB
hukommelse.
</para>

<para>
En ting som store firmaer har haft problemer med, er antallet af
brugere som kunne understøttes. Tidligere var grænsen på ca. 65000
brugere, mens den nu er 4,2 milliarder. Problemet var meget aktuelt
for f.eks. e-post-servere, som skulle have konti for alle firmaets
medarbejdere.
</para>

<para>
Med hardware kan man nu samtidigt understøtte 16 Ethernet-kort, 10
IDE-controllere, og meget andet. Alt i alt har Linux taget et stort
spring fremad med hensyn til high-end Linux-markedet.
</para>

<para>
Ultra-DMA 66 eller 100 er nu med i kerne 2.4. Det er noget som har
været meget efterspurgt, da mange nye harddisk-controllere har været
af den type.
</para>

<para>
For en Linux-laptop, så var PCMCIA med kerne 2.2 ikke ret
smart. Skulle man oversætte en kerne, så skulle man have styr på sine
PCMCIA drivere ud over selve kernen. De to ting var ikke integreret,
selvom de burde have været det. Med kerne 2.4 er PCMCIA en del af
Linux-kernen på linie med USB.
</para>

<para>
USB-understøttelse er ny i Linux-kernen. USB tastatur og mus skulle
virke fint, men det kan godt være at din USB skanner eller kamera ikke
virker, da USB standarden stadig er under udvikling.
</para>

<para>
Ud over PCI plug-and-play (eller er det pray :-), så er der en
tilsvarende auto-detektion af enheder til ISA-bus.
</para>

<para>
En ting som netop er kommet med i kerne 2.4.0, er LVM "logical volume
management", som gør det muligt at kombinere harddiske til store
enheder (ligesom RAID-0), men med LVM kan man også ændre størrelsen af
de enkelte partitioner løbende. Det er en klar fordel i forhold til
tidligere, hvor man skulle bestemme størrelsen på partitionerne i
forvejen - og ofte ud fra mere eller mindre gode estimater for hvad
man skulle bruge. Læs mere om LVM på
<ulink url="http://www.linux-mag.com/2000-11/guru_01.html">http://www.linux-mag.com/2000-11/guru_01.html</ulink>.
</para>

<para>
Man kunne nemt lave en firewall med en kerne 2.2, idet kernen havde et
rimeligt enkelt grænsesnit til formålet, kaldet
<emphasis>ipchains</emphasis>. Med <command>ipchains</command> kunne
man sætte regler op for hvilke pakker som kunne tillades igennem
firewallen.  I kerne 2.4 er hele firewall-kontrollen omskrevet til et
meget stærkere koncept kaldet <emphasis>netfilter</emphasis>, som kan
styre tilstandshåndterende firewalls. Dette er forklaret i bogen
"Linux - friheden til sikkerhed på Internet", som kan findes på <ulink
url="http://www.sslug.dk/linuxbog/">http://www.sslug.dk/linuxbog</ulink>.
</para>

<para>
IPv6-understøttelsen, dvs. næste generation netværksstandard, er med
som eksperimentel. Man kan således ikke forvente, at dette er 100% ok.
</para>

<para>
Under <filename>/dev</filename> har man tidligere haft enheder,
dvs. indgange til hardware, såsom harddisk
<filename>/dev/hda</filename>. Med kerne 2.4 <emphasis>kan
man</emphasis> anvende DevFS, som er en total restrukturering af
<filename>/dev</filename>, så man ikke længere har ekstremt mange
filer i <filename>/dev</filename>, men i stedet får man en hierarkisk
opbygning med mange underkataloger. Som eksempel vil man ikke længere
kunne finde
<filename>/dev/hda1</filename>-<filename>/dev/hda16</filename>, men i
stedet have tilsvarende filer under <filename>/dev/ide0/</filename> -
altså et niveau længere nede.
</para>

<para>
For dem som laver hurtige web-servere er kHTTPd interessant. Man
kan accelerere web-servere kraftigt for statiske web-sider, dvs. ikke
for CGI-programmer eller PHP-løsninger, ved at kernen cacher sider 
intelligent. Det er også markeret som eksperimentel kode.
</para>

<para>
Linux avancerer i mange retninger, en ny retning er telefoni. 
Linux-kernen har nu fået understøttelse for telefon-kort til 
Voice-over-IP.
</para>

<para>
For dem som arbejder med video er der godt nyt. Både IEEE-1394- (Firewire)
og I2O-grænsesnit er med. Det er også ting som stadig er under udvikling.
HIPPI (gigabit-netkort) er der også blevet arbejdet meget med, så der nu er
fire forskellige understøttede kort.
</para>

<para>
For ADSL-brugere er kerne 2.4 (eller sene versioner af 2.3-serien)
et must. Der er lavet meget inden for ATM-understøttelsen.
</para>

<para>
Og på de mere interne linier er store dele af kernen skrevet om,
så selve koden skulle være meget lettere at læse. Der er arbejdet
meget med at strukturen skulle forbedres, så man lettere kunne
inkorporere nye ting, som ikke tidligere var med.
</para>

<para>
Hvad der ikke kom med i kerne 2.4.0, men som er kommet med i kerne 2.4.1,
er et <emphasis>journaling filesystem</emphasis>. Det sidste år har
der været arbejdet meget hårdt på tre forskellige avancerede
filsystemer, som skriver data til disk på en meget sikker måde i
forhold til det gamle ext2-filsystem.  I tilfælde af f.eks. strømsvigt
eller lign. vil de nye filsystemer være meget mere robuste. ReiserFS
vil være det første til at komme med i kernen, mens SGI's
XFS-filsystem og ext3 fra Red Hat er stærkt på vej, men endnu er det
uklart, hvornår de er produktionsklare.
</para>

<para>
En fremragende artikel (allerede en klassiker i Linux-kredse) om kerne
2.4 er Joe Pranevich: "Wonderful World of Linux 2.4", som kan findes
på 
<ulink url="http://linuxtoday.com/news_story.php3?ltsn=2001-01-05-007-04-NW-LF-KN">http://linuxtoday.com/news_story.php3?ltsn=2001-01-05-007-04-NW-LF-KN</ulink>.
Denne tager endnu flere aspekter op end hvad dette afsnit har præsenteret.
</para>


</sect1>
</chapter>
