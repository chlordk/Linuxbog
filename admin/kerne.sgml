<chapter id="kerne">
<title>Linux kernen</title>

<sect1 id="Hovedkarakteristika">
<title>Hovedkarakteristika ved Linux kernen</title>

<itemizedlist mark="bullet">
<listitem>
 <para>
<emphasis>Multi-tasking</emphasis>
Linux understøtter ægte multi-tasking. Alle processer kører helt
uafhængigt af hinanden. Ingen processer behøver at tage højde for at
sørge for processor-tid til andre processer.
 </para>
</listitem>

<listitem> 
 <para>  
  <emphasis>Multi-user access</emphasis>
Linux tillader et antal brugere at benytte systemet samtidigt.
 </para>
</listitem>

<listitem> 
 <para>
  <emphasis>Demand load executables</emphasis>
Kun de dele af et program, som faktisk er påkrævet for eksekveringen
er load'et ind i hukommelsen. Når en ny proces er skabt ved hjælp af
fork(), afsættes der ikke straks hukommelse, men i stedet bruges
hukommelsen fra "parent" processen af begge processer. Hvis den nye
proces så på et tidspunkt søger adgang til en del af hukommelsen i
"write mode", kopieres denne sektion før den ændres. Dette koncept
kendes som "copy-on-write"; det er med til at øge hastigheden og sænke
hukommelsesforbruget.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Paging</emphasis>
På trods af forsøg på at anvende fysisk hukommelse effektivt, kan det
ske, at den tilstedeværende hukommelse er brugt op. Linux ser så efter
4 kbyte hukommelses-pages, som kan frigives. Pages med deres indhold
lagret på harddisk (f.eks. koden for program filer) frigives. Alle
andre pages kopieres ud på harddisken. Hvis der herefter søges adgang
til en af disse hukommelses-pages, load'es den igen. Denne procedure
kaldes paging. Den adskiller sig fra swapping, som anvendes i ældre
UNIX-systemer, hvor hele hukommelsen for en proces skrives til
harddisken, hvilket er betydeligt mindre effektivt.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Dynamisk cache for harddisken</emphasis>
Brugere af MS-DOS er kendt med behovet for at reservere hukommelse af
en bestemt størrelse til harddisk cache programmer som SMARTDRIVE.
Linux justerer dynamisk størrelsen af cache hukommelse som bruges, for
at tilpasse sig den nuværende hukommelsessituation. Hvis der ikke er
mere hukommelse tilbage på et givent tidspunkt, reduceres størrelsen
af cachen for at frigive hukommelse. Når først hukommelse er frigivet,
øges cache området igen.
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>Shared libraries</emphasis>  
Libraries er samlinger af rutiner, som er nødvendige for
data-processing for et program. Linux har et antal standard libraries,
der bruges af flere processer ad gangen. Det er derfor fornuftigt at
load'e programkoden for disse libraries ind i hukommelsen én gang for
alle. Dette muliggøres ved hjælp af shared libraries. Da disse kun
loades til programkoden når processen eksekveres, kendes de også som
dynamisk linked libraries (dll).
 </para>
</listitem>

<listitem> 
 <para>
Understøttelse for POSIX 1003.1 standard og delvis System V og BSD
POSIX 1003.1 definerer et minimum interface for et UNIX type
operativsystem. Dette interface er beskrevet i C-funktion
deklarationer. Denne standard understøttes nu af alle nyere og
relativt sofistikerede UNIX-systemer. Linux i dag  understøtter
tilnærmelsesvis POSIX 1003.1. Yderligere system-grænseflader for UNIX
udviklingsliner System V og BSD er også implementeret. 
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>Forskellige formater for eksekverbare filer</emphasis>
Da det meste software i dag er skrevet til MS-DOS eller MS-Windows, er
det ønskværdigt at kunne køre programmer til disse systemmiljøer under
Linux. Derfor er emulatorer for MS-DOS og MS-Windows under udvikling.
Linux kan også eksekvere programmer fra andre INTEL-baserede
UNIX-systemer, som går under iBCS2 standard. Dette inkluderer f.eks.
mange kommercielle programmer brugt under SCO UNIX. iBCS2 emulering er
endnu ikke del af standard kernen, men den kan download'es fra
Internettet.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Emulering af matematisk co-processorer i kernen</emphasis>
Linux kan emulere den matematiske co-processor i387, hvis den ikke
findes i systemet. Det vil sige, at programmer ikke behøver at checke,
om der er co-processor til stede. Hvis der ikke er, udføres de
relevante kommandoer i exception handle rutiner. Fra programmørens
side er tilstedeværelsen af en co-processor altså transparent.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Understøttelse for nationale keyboards og fonte</emphasis>
Under Linux kan mange nationale keyboards og fonte anvendes.
ISO-standarden definerer Latin1 sættet, som bl.a. også inkluderer
europæiske specialtegn.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Forskellige filsystemer</emphasis>
Linux understøtter forskellige filsystemer. Det mest almindeligt
brugte filsystem er Second Extended (Ext2) File System. Dette
understøtter filnavne op til 255 tegn, og har et antal træk der gør
det mere sikkert end almindelige UNIX filsystemer. Et andet filsystem,
som også er implementeret, er MS-DOS filsystemet FAT. Det betyder, at
man kan få adgang til data i en MS-DOS-partition på samme måde som i
en Linux-partition, men i MS-DOS systemet understøttes ejerskab kun
for hele filsystemet. Desuden understøtter Linux UMSDOS filsystemet,
som også tillader pseudofiler og UNIX access autorisationer inden for
et MS-DOS filsystem. Ved hjælp af ISO 9660 filsystemet kan brugeren få
adgang til data på CD-rom. I netværk kan man få adgang til filsystemet
på andre systemer transparent ved hjælp af NFS (Network File System).
Linux understøtter desuden VFAT systemet, som bruges af Windows 95 til
lange filnavne. Andre filsystemer, der understøttes er OS/2's HPFS
(read only) og System V filesystem. Grunden til at HPFS er read-only
er at dokumentationen for det ikke er tilgængelig. Ingen har turdet
tage ansvaret for at lave en implementering der måske kunne ødelægge
nogens filsystem. Linux kernel 2.0 understøtter ikke NTFS og FAT32,
men det er på vej i kernel 2.2.
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>TCP/IP, SLIP og PPP understøttelse</emphasis>
Linux kan integreres i lokale UNIX netværk. I princippet kan alle
netværk services som NFS og Remote Login bruges. SLIP og PPP
understøtter brugen af TCP/IP protokollen over serielle linier. Det
betyder at link til Internet via telefonnetværk ved hjælp af modem er
muligt.
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>BSD sockets</emphasis>
Netværkskommunikation kræver naturligvis midler til
interproces-kommunikation mellem forskellige computere. Interfaces
hertil er i BSD sockets.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>System V IPC</emphasis>
Linux bruger dette til at lave message queues, semaforer og shared
memory. Disse er klassiske varianter til interproces-kommunikation.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Virtuelle konsoller</emphasis>
Linux understøtter virtuelle konsoller. Tastekombinationen &lt;ALT&gt; +
&lt;Function key&gt; bruges til at skifte imellem dem.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Multiprocessing</emphasis>
Fra kernel 2.0 understøtter Linux symmetrisk multiprocessing -
samtidig kørsel af processer på et antal processorer - op til 16
processorer.
 </para>
</listitem>
</itemizedlist>

</sect1>

<sect1 id="Linux-er-ikke">
<title>Linux er ikke</title>
<para>
Linux er ikke et real-time system. Bl.a. virtual memory gør det
umuligt for Linux at overholde kravene til et "hard" real-time system,
men det kan laves mere real-time end det er i dag, bl.a. ved at
arbejde med scheduling'en og optimere interruptene. PTO
</para>

<para>
Linux er ikke en microkernel (minimal kerne med veldefinerede
grænseflader, så ydre dele nemt kan skiftes ud), men er opbygget som
en monolitisk kerne. PTO
</para>

<para>
Linux er ikke et distribueret operativsystem - alting foregår på én
maskine. MOSIX
</para>

<para>
Linux er ikke sikret efter de strengeste sikkerhedsprincipper, men der
er indbygget en vis beskyttelse mod uforvarende at komme til at
ødelægge systemet.
</para>

<para>
Linux kan ikke køre på en '286 eller ældre maskine, da den udnytter
'386's virtual memory faciliteter.
</para>

</sect1>

<sect1 id="proces-management">
<title>Proces management</title>

<para>
UNIX operativsystemer er multi-programming og multi-user systemer. Det
betyder at flere programmer kan kører på én computer samtidig, og
dermed også at flere personer kan bruge én computer som server
samtidig. For brugeren ser det ud som om programmerne kører parallelt
og at flere processer dermed har CPU'en samtidig. Dette fungerer i
praksis ved at hver proces har CPU'en i et bestemt tidsrum, hvorefter
den ryger bag i en kø og næste proces hentes ind (multi-tasking).
</para>

<para>
Linux understøtter, ligesom UNIX, ægte multi-tasking. Alle processer
kører helt uafhængigt af hinanden, så ingen processer behøver at tage
højde for at give processor-tid til andre processer. Hver proces har
et memory-område, som er beskyttet mod ændringer fra andre processer.
</para>

<para>
Linux i kerne version 2.0 eller senere understøtter multi-processing for
op til 16 processorer. Multiprocessing er samtidig kørsel af processer
på flere processorer. PTO
</para>

<para>
Der er gjort forsøg på at understøtte multi-threading. Threads er dele
af en proces, som i multi-threading systemer kan køre parallelt, som
regel i samarbejde om en fælles opgave. Multi-threading er nyttigt
fordi 2 threads har mere til fælles end 2 tilfældige processer, så det
tager ikke så langt tid at skifte mellem 2 threads som imellem 2
processer. Der er gjort forsøg på at implementere en slags threads i
Linux med systemkaldet clone. Dette er dog stadig på et niveau, hvor
det kan betragtes som et udokumenteret systemkald. Man kan således
endnu ikke sige, at Linux understøtter multi-threading, men måske
kommer det til det.
</para>

<sect2 id="Processtruktur">
<title>Processtruktur</title>
  
<para>
Det vigtigste og mest specielle ved et multi-tasking system er
processerne og processtrukturen. En proces er et program, som er under
udførelse.
</para>

<para>
x86 arkitekturen understøtter 4 privelege modes (eller levels), hvor
mode 0 er den mest privilegerede og 3 den mindst privilegerede. Et
kørende program vil altid være i en af disse modes.
</para>

<para>
Linux bruger kun 2 modes, nemlig kernel mode og user mode. Ved at
skelne mellem user mode og kernel mode kan man forhindre, at brugeren
har direkte adgang til de forskellige I/O devices.
</para>

<para>
Der er kun adgang til disse fra kernel mode, og alle brugerprogrammer
kører i user mode. Brugerprogrammer har derved kun adgang til I/O
devices igennem et på forhånd specificeret systemkald, som resulterer
i et skift fra user mode til kernel-system mode. Derved slipper
programmøren af brugerprogrammer for at bekymre sig om detaljerne
omkring f.eks. I/O. Hardwarens kompleksitet skjules derved for
brugeren.
</para>

<para>
Et brugerprogram kan således bruge operativsystemet til at få udført
forskellige instruktioner, ved at lave et systemkald. Et
brugerprogram, der kører under Linux, vil derfor se Linux-kernen som
en udbyder af servicefunktioner.
</para>

<para>
Når en proces kører i system mode kan den være i en af følgende
tilstande:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
  <emphasis>Running</emphasis>
Running illustrerer et kørende program i user mode. Det
meste af tiden kører et program i user mode. En gang imellem er det
dog nødvendigt at gå i kernel mode. Dette kan kun ske ved et interrupt
eller et systemkald.
 </para>
</listitem>
<listitem> 
 <para>
 <emphasis>Interrupt-rutine</emphasis>
Interrupt-rutinen bliver aktiv når der kommer et hardware signal,
f.eks. nye input fra keyboard.
 </para>
</listitem>
<listitem> 
 <para>
  <emphasis>Systemkald</emphasis> 
Systemkald aktiveres af software interrupts. Et
systemkald kan suspendere en proces, så den skal vente på en hændelse.
 </para>
</listitem>
<listitem> 
 <para>
  <emphasis>Waiting</emphasis>
Processen venter på en ekstern hændelse og processen vil ikke
forsætte, før denne hændelse indtræffer.
 </para>
</listitem>
<listitem> 
 <para>
 <emphasis>Retur fra systemkald</emphasis>
Denne tilstand opnås efter hvert systemkald og efter nogle interrupts.
Herfra kan scheduleren skifte processen til Ready og aktivere en anden
proces.
 </para>
</listitem>
<listitem> 
 <para>
 <emphasis>Ready</emphasis>
Processen konkurrerer om at komme til processoren, som er optaget af
en anden proces.
 </para>
</listitem>
</itemizedlist>

</sect2>
  
<sect2 id="Procesrelationer">
<title>Procesrelationer</title>

<para>
Proces-hierarkiet i Linux er et parent-child hierarki. En ny proces
kan kun skabes med systemkaldet <command>fork()</command>. Den nye
proces bliver child-proces til den proces, der udførte
<command>fork()</command>.  
</para>

<para>
Den nye proces bliver oprettet ved at lave en næsten identisk kopi af
den proces der kaldte <command>fork()</command>. Ofte er det første,
en ny proces gør, at udføre et execve kald, som overskriver den
nedarvede kode, stak, registre mv., så den ikke længere er en kopi af
parentprocessen, men en ny proces.
</para>

<para>
Det kan være meget ressourcekrævende at oprette en ny proces, da der
kan være mange data fra parent processen, som skal kopieres. Derfor
bruges der i Linux "copy-on-write" teknikken. Tanken bag denne teknik
er, at et antal af processer kan have adgang til den samme memory, så
længe der ikke er nogle af processerne der laver ændringer i data.
Således bliver de relevante pages af memory ikke kopierede ved
systemkaldet <command>fork()</command>, men den fælles memory bliver
write-protected.  Hvis en af processerne forsøger at skrive til memory
bliver processen interrupted, og kernen laver en kopi af den relevante
page. Herefter kan der tildeles en kopi til hver proces. Den store
fordel ved denne metode er, at data kun bliver kopieret hvis det er
nødvendigt.
</para>
</sect2>

<sect2 id="Proces-ID">
<title>Proces ID</title>

<para>
Alle processer har deres eget ID nummer (pid) og er i en gruppe og en
session. I Linux kan en proces være tilknyttet flere grupper.
</para>

<para>
Når en ny proces bliver genereret får den et nyt pid nummer, og
<command>fork()</command> returnerer 0 til child processen og child
processens pid til parent processen. Derved kan de to processer se,
hvilken proces der er child proces og hvilken der er parent proces.
</para>

<para>
For at kunne bestemme hvor en proces har adgang, har hver proces et
user ID (uid) og et gruppe ID (gid). Disse ID numre har child
processerne arvet efter deres parent processer. Når en adgangskontrol
skal foretages er det dog den effektive user ID (euid) og gruppe ID
(egid) der bliver brugt. Generelt er uid = euid og gid = egid,
undtagen for set-UID programmer. I disse programmer bliver euid og
egid sat til user ID og gruppe ID for ejeren af den eksekver-bare fil.
På denne måde er det muligt for superuseren at give almindelige
brugere adgang til programmer, der bruger superuser power, på en
kontrolleret måde. Et set-UID program er et program hvor
set-UID-bitten er sat. Af sikkerhedsårsager understøtter Linux kun
set-UID på binære filer, ikke på shell scripts.
</para>
</sect2>
</sect1>

<sect1 id="kerne-proc">
<title>proc-filsystemet</title>
<indexterm><primary>/proc</primary></indexterm>
<para>
Som systemadministrator (root) er der gode muligheder for at følge,
hvad Linux-kernen laver. Prøv at skrive <command>mount</command>. En
af de linier, som kommer frem er
</para>

<screen>
none on /proc type proc (rw)
</screen>

<para>
I modsætning til de almindelige filsystemer, som er monteret
(f.eks. <filename>/dev/hda1</filename>, <filename>/dev/hda2</filename>
osv.), så er <filename>/proc</filename> meget speciel. Prøv
f.eks. som det første eksperiment at se følgende fil.
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>ls -l /proc/kcore</userinput>
-r--------    1 root     root     134156288 jan 22 23:18 /proc/kcore   
</screen>

<para>
Betyder dette, at der ligger en ca. 128 MB stor fil? Nej - alt hvad
der ligger under <filename>/proc</filename> er virtuelt. Det er
Linux-kernen som på en elegant måde giver adgang til en række nyttige
kerne-informationer. I eksemplet er <filename>/proc/kcore</filename>
en adgang til hele den fysiske RAM i maskinen. Lad os se mere på hvad
der sker i <filename>/proc</filename>
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>ls -l /proc/</userinput>
1/     1150/  529/ 741/  9725/ 9794/       fs/        partitions
10023/ 15656/ 539/ 765/  9726/ 9795/       ide/       pci
10030/ 15657/ 554/ 809/  9727/ 9797/       interrupts rtc
10043/ 15658/ 570/ 825/  9765/ 9798/       ioports    scsi/
1017/  17917/ 571/ 961/  9767/ 9800/       kcore      self@
10313/ 17931/ 581/ 965/  9769/ 984/        kmsg       slabinfo
10317/ 17964/ 596/ 966/  9771/ 9950/       ksyms      sound
1051/  18243/ 6/   967/  9776/ 9958/       loadavg    stat
1052/  18246/ 61/  968/  9777/ apm         locks      swaps
1053/  18250/ 698/ 969/  9780/ bus/        mdstat     sys/
1054/  18524/ 701/ 970/  9782/ cmdline     meminfo    tty/
1055/  2/     702/ 971/  9784/ cpuinfo     misc       uptime
10571/ 3/     703/ 9717/ 9786/ devices     modules    version
10723/ 307/   704/ 972/  9788/ dma         mounts
1083/  4/     717/ 9722/ 9789/ fb          mtrr
11294/ 5/     732/ 9723/ 9791/ filesystems net/                          
</screen>

<para>
<indexterm><primary>PID</primary></indexterm>
<indexterm><primary>Proces-ID</primary></indexterm>
<indexterm><primary>ps</primary></indexterm> Som det kan ses er der en
mængde kataloger med numre. Der er et katalog for hver proces på
maskinen. Lad os se på et af katalogerne i større detalje. Der kører
netop nu en <command>emacs</command> på maskinen med PID=18243 (PID
betyder proces-ID). Dette findes ved brug af
<filename>ps</filename>. Tilsvarende kan vi se hvad kataloget i
<filename>/proc/18243</filename> indeholder.
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>ps aux | grep emacs</userinput>
pto  18243  0.1  4.7  8940 6076 pts/1   S  22:11  0:09 emacs kerne.sgml 
<prompt>[anne@linus ~]$ </prompt><userinput>ls -l /proc/18243</userinput>
totalt 0
dr-xr-xr-x  3 pto  www  0 jan 22 23:39 .
dr-xr-xr-x 98 root root 0 jan 21 03:19 ..
-r--r--r--  1 pto  www  0 jan 22 23:39 cmdline
lrwx------  1 pto  www  0 jan 22 23:39 cwd -> /home/pto/linuxbog/admin
-r--------  1 pto  www  0 jan 22 23:39 environ
lrwx------  1 pto  www  0 jan 22 23:39 exe -> /usr/bin/emacs
dr-x------  2 pto  www  0 jan 22 23:39 fd
pr--r--r--  1 pto  www  0 jan 22 23:39 maps
-rw-------  1 pto  www  0 jan 22 23:39 mem
lrwx------  1 pto  www  0 jan 22 23:39 root -> /
-r--r--r--  1 pto  www  0 jan 22 23:39 stat
-r--r--r--  1 pto  www  0 jan 22 23:39 statm
-r--r--r--  1 pto  www  0 jan 22 23:39 status      
</screen>

<para>
Det første underlige, er at filerne har filstørrelse nul. Det skal man
ikke lade sig snyde af. Alt er virtuelt her - og nogle gange kan filer
i <filename>/proc</filename> have indhold. Prøv selv at køre
<command>more /proc/PID/cmdline</command>, hvor PID er en af de
proces-ID på din maskine, f.eks. for en editor, du har startet på 
kommando-linien.
</para>

<para>
Via <filename>/proc/PID/cwd</filename> er der direkte adgang til de
katalog, som programmet blev startet op i. Filerne
<filename>/proc/PID/stat*</filename> (tre filer) fortæller mere om
f.eks. hukommelsesforbrug og andre status-parametre.
</para>

<para>
Nu har vi set på hvad der gemmes for den enkelte proces. Lad 
os nu se på hvad der ellers kan findes i <filename>/proc</filename>. 
</para>

<para>
Belastning af maskinen (load) - eller rettere - hvor mange processor
der prøver at tilgå kernen i snit, kan ses direkte ud fra
<filename>/proc/loadavg</filename>. Det er samme tal som
<command>uptime</command> har til sidst - belastning det sidste minut,
sidste 5 minutter, og endelig de sidste 15 minutter.
<indexterm><primary>uptime</primary></indexterm>
<indexterm><primary>load</primary></indexterm>
</para>

<para>
Vil du vide mere om hvor meget hukommelse, som er brugt, så kan du få
dette fra kommandoen <command>free</command>, men en endnu mere
detaljeret visning kan hentes fra filen
<filename>/proc/meminfo</filename>.
</para>


<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>free </userinput>
             total   used  free shared buffers cached
Mem:        127760 124336  3424 135860    4684  52104
-/+ buffers/cache:  67548 60212
Swap:        68504   7120 61384       
<prompt>[anne@linus ~]$ </prompt><userinput>more /proc/meminfo</userinput>
        total:    used:    free:  shared: buffers:  cached:
Mem:  130826240 127242240  3584000 139255808  4788224 53280768
Swap: 70148096  7290880 62857216
MemTotal:    127760 kB
MemFree:       3500 kB
MemShared:   135992 kB
Buffers:       4676 kB
Cached:       52032 kB
BigTotal:         0 kB
BigFree:          0 kB
SwapTotal:    68504 kB
SwapFree:     61384 kB
</screen>

<para>
I <filename>/proc/net/</filename> er der en masse nyttig information
om hvordan netværket ser ud lige nu. De fleste filer er direkte
læsbare for alle, mens f.eks. firewall-filerne (for kerne 2.2)
<filename>/proc/net/ip_fwchains</filename> (med firewall-konfigurationen) og 
<filename>/proc/net/ip_fwnames</filename> kun kan læses af root (sikkerhed).
</para>

</sect1>

<sect1 id="kerne-2-4">
<title>Kerne 2.4</title>
<para>
Den seneste generation af Linuxkernen er 2.4, som udkom i starten af
januar 2000. Linus Torvalds annoncerede diskret, at nu er kerne 2.4.0
færdig.
</para>

<para>
Hvad er det så kerne 2.4 har opnået i forhold til de meget anvendte
kerner fra 2.2-serien? Svaret er - mange ting.
</para>

<para>
For det første så er antallet af processorer som understøttes gået
meget i vejret. Nu understøttes hele spektret fra 386 til Pentium IV,
dvs. Intels nye Itanium-processor. Tilsvarende er AMD-processorerne
understøttet.  Selv den specielle Crusoe-processor er med.
</para>

<para>
En af de ting, som nogle var utilfreds med i kerne 2.2-serien var
mængden af hukommelse, som Linux-kernen kunne bruge. Når man
oversætter 2.4.0-kernen er der spørgsmål om man holder sig under
4 GB og tilsvarende er der næste grænse ved 64 GB RAM. Det skulle
være nok for de fleste - i hvert fald det næste års tid :-)
</para>

<para>
En anden ting som er blevet klart forbedret i Linux-kernen er SMP,
dvs. hvordan maskinen håndterer flere processorer. Hvor kerne 2.2 var
fin med 2 processorer og endda 4, så var ydelsen ved 8 og 16
processorer ikke imponerende. Med kerne 2.4 er ydelsen på 8 og 16
processorer forbedret markant.
</para>

<para>
For en Linux-laptop, så var PCMCIA med kerne 2.2 ikke ret
smart. Skulle man oversætte en kerne, så skulle man have styr på sin
PCMCIA drivere ud over selve kernen. De to ting var ikke integreret,
selvom de burde have været det. Med kerne 2.4 er PCMCIA en del af
Linux kernen på linie med USB.
</para>

<para>
USB understøttelse er ny i Linux-kernen. USB tastatur og mus skulle
virke fint, men der kan sikkert være specielle USB kameraer som ikke
virker. 
</para>

<para>
Ud over PCI plug-and-play (eller er det pray :-), så er der en
tilsvarende auto-detektion af enheder til ISA-bus.
</para>

<para>
En ting som netop er kommet med i kerne 2.4.0 er LVM "logical volume
management", som gør det muligt at kombinere harddiske til store
enheder (ligesom RAID-0), men med LVM kan man også ændre størrelsen af
de enkelte partitioner løbende. Det er en klar fordel i forhold til
tidligere, hvor man skulle bestemme størrelsen på partitionerne i
forvejen - og ofte ud fra mere eller mindre gode estimater for hvad
man skulle bruge.
</para>

<para>
Firewall kunne man nemt lave med en kerne 2.2, idet kernen have et
rimeligt enkelt firewall-interface, kaldet
<emphasis>ipchains</emphasis>. Med <command>ipchains</command> kunne
man sætte regler op for hvilke pakker som kunne tillades igennem
firewallen. I kerne 2.4 er hele firewall-delen omskrevet til er meget
stærkere koncept <emphasis>netfilter</emphasis>, som kan styre
firewalls med states. Dette er forklaret i bogen "Linux - friheden til
sikkerhed på Internet", som kan findes på 
<ulink url="http://www.sslug.dk/linuxbog">http://www.sslug.dk/linuxbog</ulink>.
</para>

<para>
IPv6 understøttelsen, dvs. næste generation netværksstandard, er med
som eksperimentel. Man kan således ikke forvente, at dette er 100% ok.
</para>

<para>
For dem som laver hurtige web-servere, så er kHTTPd interessant. Man
kan accellerere web-servere kraftigt for statiske web-sider, dvs. ikke
for CGI-programmer, ved at kernen casher sider intelligent. Det er
også markeret som eksperimentel kode.
</para>

<para>
Linux avancerer i mange retninger, en ny retning er telefoni. Linux
kernen har nu fået understøttelse for telefon-kort til Voice-over-IP.
</para>

<para>
For dem som arbejder med video, så er der godt nyt. Både Firewire og
I2O-interface er med. Det er også ting som stadig er under udvikling.
HIPPI, dvs. gigabit netkort er der også blevet arbejdet meget med, så 
der er fire forskellige kort, som understøttes nu.
</para>

<para>
For ADSL brugere, så er kerne 2.4 (eller sene versioner af 2.3-serien)
et must. Der er lavet meget indenfor ATM understøttelsen.
</para>

<para>
TV-kort er ved at være godt med nu.
</para>

<para>
Og på de mere interne linier, så er store dele af kernen skrevet om,
så selve koden skulle være meget lettere at læse. Der er arbejdet
meget med at strukturen skulle forbedres, så man lettere kunne
inkorporere nye ting, som ikke tidligere var med.
</para>

<para>
Hvad der ikke kom med i kerne 2.4.0, men efter alle tegn vil være med
i kerne 2.4.1, dvs. den næste del-udgave er et <emphasis>journaling
filesystem</emphasis>. Det sidste år har der været arbejdet meget
hårdt på tre forskellige avancerede filsystemer, som skriver data til
disk på en meget sikker måde i forhold til det gamle ext2-filsystem.
I tilfælde af f.eks. strømsvigt eller lign. vil de nye filssystemer
være meget mere robuste. ReiserFS vil være det første til at komme med
i kernen, mens SGI's XFS-filsystem og ext3 fra Red Hat er stærkt på
vej, men endnu er det uklart, hvornår de er produktionsklare.
</para>

</sect1>
</chapter>
