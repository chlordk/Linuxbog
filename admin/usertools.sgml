<!-- $Id$ -->
<chapter id="sysadm">
<title>Systemadministration</title>

<SECT1 ID="filsystem">
<TITLE>Opbygningen af filsystemet</TITLE>
<indexterm><primary>/etc/hosts</primary></indexterm>

<sect2 ID="filsystempaspaa">
<TITLE>Basalt systemarbejde</TITLE>

<PARA>
Linux-systemer er på mange måder meget standardiserede
forstået på den måde, at diverse kataloger bruges til det
samme. Vi fortalte mere om dette i installationskapitlet.
</para>

<para>
Kataloget <filename>/etc</filename> indeholder konfigurationsfiler til dit
Linux-system. Filerne er vitale for dit Linux-system, så vær derfor
forsigtig, når du ved hjælp af en teksteditor retter i filerne. Vi vil
foreslå, at du <emphasis>altid</emphasis> først laver en kopi af den
fil, du vil ændre, dvs.
</para>

<screen>
<PROMPT>[root@linus /etc]# </PROMPT><USERINPUT>cp hosts hosts.orig</USERINPUT>
<PROMPT>[root@linus /etc]# </PROMPT><USERINPUT>vi hosts</USERINPUT>
</screen>

<para>
Hvis der skulle gå noget galt, kan du altid bruge den oprindelige
udgave af filen.
</para>

<screen>
<PROMPT>[root@linus /etc]# </PROMPT><USERINPUT>cp hosts.orig hosts</USERINPUT>
</SCREEN>
</SECT2>



<sect2 id="filsystemer">
<title>Filsystemer</title>
<indexterm><primary>Filsystemer</primary></indexterm>
<para>
Linux bruger som standard et filsystem kaldet Ext2 (Extended file
system version 2), men kan også læse og skrive fra mange andre
filsystemer f.eks. FAT-baserede filsystemer der bruges af DOS og
Windows.
</para>

<para>
Generelt formateres et filsystem under Linux ved at benytte kommandoen 
<command>mkfs</command> (MaKe File System). Har du en uformateret partition 
(her <filename>/dev/hda5</filename>), som du ønsker at formatere, sker
formateringen ved at skrive (som root):
</para>

<para>
<screen>
  <prompt>[root@linus /root]#</prompt> <userinput>mkfs /dev/hda5</userinput>
  <prompt>[root@linus /root]#</prompt> 
</screen>
</para>

<para>
Programmet <command>mkfs</command> finder selv ud af hvilket filsystem,
du har valgt til den ønskede partition, idet denne oplysning findes i
partition-tabellen.
</para>

<para>
Når din computer går ned (ja, det sker, f.eks. når strømmen går), kan
du komme ud for at dine filsystemer er i en fejlhæftet tilstand. Dette
kan dog ofte reddes af programmet <command>fsck</command> (File
System ChecK). Faktisk
køres dette program altid ved opstart for at sikre at alle filsystemer
er i en god tilstand.
</para>

<sect3 id="reiserFS">
<title>ReiserFS</title>
<indexterm><primary>ReiserFS</primary></indexterm>

<indexterm><primary>Filsystemer</primary>
<secondary>ReiserFS</secondary></indexterm>
<indexterm><primary>Filsystemer</primary>
<secondary>ext2</secondary></indexterm>
<para>
ReiserFS er et af de nyere filsystemer til Linux. Faktisk er det så nyt,
at det endnu ikke er en del af den officielle kerne. Indtil kerne
2.4 vil det kun være det gamle velprøvede ext2-filsystem, som 
kernen understøtter officielt, men det er allerede bebudet at i kerne
2.4.1 vil ReiserFS være med.
</para>

<para>
ReiserFS er en anden type filsystem end den der kendes fra Linux's
Ext2, og DOS/Windows FAT-drev, idet ReiserFS er et journaliserende
filsystem. Det betyder, at alle filer til en hver tid er
opdaterede. Det betyder, at hvis din computer går ned pga. en
strømafbrydelse vil du ikke miste data. Endvidere betyder det, at de
partitioner som er formateret ved hjælp af ReiserFS ikke skal tjekkes
ved opstart. Hvis du har meget store harddiske vil det betyde at du
får en meget kortere opstartstid. Dette kan være vigtigt, hvis din
computer er server med f.eks. 100 GB harddisk (ikke ualmindelig i den
virkelige serververden).
</para>

<para>
Tidligere versioner af ReiserFS ville ikke virke med Lilo boot fra en
ReiserFS-partion.  Dette kunne løses ved at lægge
<filename>/boot</filename> på en ext2-partition, og hvis
<filename>/boot</filename> er en lille selvstændig partition, kan
<filename>/</filename>-partitionen være ReiserFS-formatteret.
I de nyeste versioner af ReiserFS (november 2000) bør denne
begrænsning være væk, blot man mounter boot-partitionen med et ekstra
flag; "notail":
</para>

<screen>
/dev/hda2 on / type reiserfs (rw,notail)
</screen>


<para>
ReiserFS følger med Mandrake (fra version 7.1) og SuSE (fra
6.4) og under disse distributioner er det let at vælge
formattering med ReiserFS istedet for ext2 under
installation.
Men selv under andre distributioner er det ikke
svært. Du skal sikre dig, at kernen understøtter ReiserFS som
filsystem. Måske skal du omkonfigurere din kerne (se også <xref
linkend="kernelcompile">). Det kan godt betale sig at få ReiserFS
oversat som et kernemodul. Modulsystemet vil typisk selv finde ud af,
at modulet skal bruges, dvs. når du begynder at bruge kommandoer som
involvere en ReiserFS-baseret partition, vil modulet automatisk blive
indlæst.
</para>

<para>
Først og fremmest skal du have en partition, som er tom. Du kan 
oprette en partition til formålet. Her kan du bruge programmer som 
<command>fdisk</command> og <command>cfdisk</command>. Når du har 
en partition klar, skal du formatere den. I eksemplet benytter vi
partitionen <filename>/dev/hda5</filename>, som vi antager allerede er 
oprettet.
</para>

<para>
<screen>
  <prompt>[root@linus root]#</prompt><userinput>mkreiserfs /dev/hda5</userinput>
<-----------MKREISERFS, 1999----------->
ReiserFS version 3.5.18
Block size 4096 bytes
Block count 325576
First 16 blocks skipped
Super block is in 16
Bitmap blocks are : 
	17, 32768, 65536, 98304, 131072, 163840, 196608, 229376, 262144, 294912
Journal size 8192 (blocks 18-8210 of device 0x3:0x5)
Root block 8211
Used 8221 blocks
ATTENTION: ALL DATA WILL BE LOST ON '/dev/hda5'! (y/n) <userinput>y</userinput>
Initializing journal - 0%....20%....40%....60%....80%....100%
Syncing..

ReiserFS core development sponsored by SuSE Labs (suse.com)

Journaling sponsored by MP3.com.

Item handlers sponsored by Ecila.com

To learn about the programmers and ReiserFS, please go to
http://www.devlinux.com/namesys

Have fun.
  <prompt>[root@linus ~]#</prompt>
</screen>
</para>

<para>
Du er nu klar til at montere din partition. Følgende vil montere partitionen
<filename>/dev/hda5</filename> som <filename>/home</filename>.
</para>

<para>
<screen>
  <prompt>[root@linus ~]#</prompt> <userinput>mount -t reiserfs /dev/hda5 /home</userinput>
Checking ReiserFS transaction log (device 03:35)  ...
Relayed 0 transaction in 0 seconds
ReiserFS version 3.5.18
  <prompt>[root@linus ~]#</prompt>
</screen>
</para>

<para>
Naturligvis kan du indsætte din nye partition i filen
<filename>/etc/fstab</filename> med typen
<emphasis>reiserfs</emphasis>. Derved vil partitionen blive monteret
under opstart.
</para>

</sect3>
</sect2>


<SECT2 ID="runlevel">
<TITLE>Hvad er et "runlevel"?</TITLE>
<indexterm><primary>Runlevels</primary></indexterm>
<indexterm><primary>/etc/rc.d</primary></indexterm>
<indexterm><primary>Start i grafisk tilstand</primary></indexterm>
<PARA>
Et runlevel er den tilstand, som systemet kører i. Computeren kan køre i
tilstande så som "ved at starte systemet", "enkelbruger system",
"flerbrugersystem", "genstarter system" og "slukker computeren". Hvis
man f.eks. vil kopiere <filename>/home</filename> kataloget over på en
større harddisk fordi ens brugere har for mange MP3 filer liggende. <!--Se
xref linkend="tar-flytning").--> Så er det nødvendigt, at sikre at
der ikke er nogen brugere, der har filer åbne, mens man kopierer, idet
der så kan opstå en fejl i kopieringen. Dette kan man sikre sig ved at
skifte til Enkelt bruger tilstand, der svarer lidt til fejlsikret
tilstand i Windows. Når man er færdig med system arbejdet, hopper man
tilbage til "flerbrugersystem" og folk har igen adgang til
computeren, og vil ikke bemærke at deres filer pludseligt ligger på et
andet drev.
</para>

<para>
Computeren kører en masse services for brugerne, dette kunne f.eks. være
netværksforbindelse (network) og forskellige netværks relaterede
services som f.eks. e-post (sendmail/routed/named/snmpd/portmap), adgang
til filsystemer på andre computere (nfsfs), mulighed for at udskrive
til printer (lpd) og lydkort (sound). Men mens Linux er ved at starte
har man ikke brug for at have adgang til printeren, så printer
servicen startes først når systemet går ind i "flerbrugersystem"
tilstanden.  Når man er ved at genstarte eller slukke computeren,
slukker man igen for printer forbindelsen. Når computeren skiftes fra
en tilstand til en anden tilstand, udføres en række scripts der
bestemmer hvad for services der skal tændes og slukkes. Hvilke
scripts, der kører ved skift til f.eks.  runlevel 3 (Flerbrugersystem),
bestemmes af, hvilke scripts der er placeret i kataloget
<filename>/etc/rc.d/rc3.d</filename> (Corel og Debian har tilsvarende
<filename>/etc/rc3.d</filename>).
</PARA>

<SCREEN>
<PROMPT>[anne@linus ~]$ </PROMPT><USERINPUT>ls /etc/rc.d/rc3.d</USERINPUT>
K30mcserv    K40snmpd	  K55routed    K75gated     K80random	 K95nfsfs
K96pcmcia    K97network   S01kerneld   S30syslog    S40atd	 S40crond
S40portmap   S50inet	  S55named     S60lpd	    S75keytable  S80sendmail
S85sound     S99local
</SCREEN>

<PARA>
Disse filer svarer til services der skal startes (dem der starter med
S) eller dræbes (starter med K for Kill) når systemets tilstand ændres
til tilstand 3 (Flerbrugersystem). Tallet bestemmer rækkefølgen
<filename>S01kerneld</filename> startes altså før
<filename>S30syslog</filename>, mens <filename>K96pcmcia</filename>
servicen dræbes efter <filename>K30mcserv</filename>. Hver fil i dette
katalog er i virkeligheden en lænke til et script i
<filename>/etc/rc.d/init.d/</filename> og "S50inet" betyder i
virkeligheden at "/etc/rd.d/init.d/inetd start" udføres, hvilke
starter alle internet services.
</PARA>

<PARA>
Det er ikke svært at finde ud af, hvilket runlevel din computer er
i. Nedenfor er vist hvordan.
</PARA>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>/sbin/runlevel</USERINPUT>
N 3
</SCREEN>

<PARA>
3-tallet viser dig, at din pc er i runlevel 3. Det er muligt
at skifte runlevel uden at lukke computeren ned, men N'et
viser, at der intet tidligere runlevel er, dvs. computeren har været i
runlevel 3, siden den blev tændt. Du skifter runlevel
med kommandoen <FILENAME>telinit</FILENAME>. Du bør altid synkronisere 
dine harddiske (tømme filsystemernes buffere) inden du skifter
runlevel, dvs. kør <command>sync</command> et par gange lige inden, du
skifter runlevel med <command>telinit</command>.
</PARA>

<PARA>
Runlevel 3 er det mest almindelige. Skemaet nedenfor viser
betydningen af de forskellige runlevels.
</PARA>

<TABLE frame="all">
  <TITLE>Runlevels</TITLE>
  <TGROUP COLS=2 ALIGN="char">
  <THEAD>
    <ROW>
      <ENTRY>Runlevel</ENTRY>
      <ENTRY>Betydning</ENTRY>
    </ROW>
  </THEAD>
  <TBODY>
    <ROW>
      <ENTRY>0</ENTRY>
      <ENTRY>Lukker systemet ned (<userinput>shutdown -h now</userinput>)</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>1</ENTRY>
      <ENTRY>Enkeltbrugertilstand (Single-user mode)</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>2</ENTRY>
      <ENTRY>Flerbrugertilstand uden NFS</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>3</ENTRY>
      <ENTRY>Flerbrugertilstand med NFS</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>4</ENTRY>
      <ENTRY>Bruges ikke</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>5</ENTRY>
      <ENTRY>Starter op i X11</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>6</ENTRY>
      <ENTRY>Genstart systemet (<userinput>reboot</userinput>)</ENTRY>
    </ROW>
  </TBODY>
</TGROUP>
</TABLE>

<PARA>
Som det fremgår af skemaet, er runlevel 6 det samme som at genstarte
systemet, dvs. når systemadministratoren genstarter systemet ved at
bruge kommandoen <command>reboot</command> (genstart), skiftes der til runlevel
6.
</PARA>

<PARA>
Enkeltbrugertilstand er et meget nyttigt runlevel. Hvis det sker, at du
kommer til at konfigurere et eller andet forkert en dag - ja, det vil ske
på et eller andet tidspunkt! - og din pc låser under
opstarten, kan du starte den op i Enkeltbrugertilstand og foretage diverse
rettelser.
</PARA>

<PARA>
I filen <FILENAME>/etc/inittab</FILENAME> angives hvilket
runlevel, der er den forvalgte runlevel. Vil du ændre at man f.eks. starter
i runlevel 5 og ikke 3, så skal du ændre linien
</para>

<screen>
id:3:initdefault:
</screen>

<para>
til
</para>
<screen>
id:5:initdefault:
</screen>

<para>
Se også <xref linkend="etcrcdfilen"> for detaljer om forskelle mellem
de forskellige Linux distributioner. <!-- xref
linkend="runlevel-editor" for mere om den grafiske måde at konfigure
de enkelte runlevels grafisk. Og -->
</para>

</SECT2>

<SECT2 ID="Nedlukning">
<TITLE>Nedlukning af Linux</TITLE>
<indexterm><primary>Nedlukning</primary></indexterm>
<indexterm><primary>Reboot</primary></indexterm>
<indexterm><primary>Genstart</primary></indexterm>
<indexterm><primary>Ctrl-Alt-Del</primary></indexterm>
<PARA>
En Linux maskine er, som du nok allerede har forstået, et meget stort
system med mange muligheder. Du skal også være meget opmærksom på, at
man ikke bare må slukke for en Linux maskine - den skal lukkes pænt
ned.
</PARA>

<PARA>
Som vi viste i <xref linkend="runlevel">, er runlevel 0 det samme som
at lukke ned. En generel, men lidt besværlig måde at lukke en UNIX-maskine
på, er at skifte til root og skrive <userinput>init 0</userinput>
eller <userinput>telinit 0</userinput>

<SCREEN>
<PROMPT>[anne@linus ~]$ </PROMPT><USERINPUT>su -</USERINPUT>
Passwd: <USERINPUT>hemlig</USERINPUT>
<PROMPT>[root@linus /root]# init 0</PROMPT>
</SCREEN>

Det er dog nemmere at stoppe den grafiske brugerflade med en
<command>exit</command> til tekst-login konsoller (evt. kan
"Ctrl-Alt-Backspace" bruges) og så trykke
"Ctrl-Alt-Delete", når du er i en tekstkonsol. 
</para>

<para>
Du skal dog en gang for alle lave en ændring, så "Ctrl-Alt-Delete"
kommer til at medføre at Linux lukkes ned. Ændres intet, genstarter
systemet (og du vil nok her synes, at det er sjovt, at det minder om
den mest kendte DOS kommando).  For at få maskinen til at stoppe (kaldes
Halt), skal du ændre i <FILENAME>/etc/inittab</FILENAME>

<SCREEN>
# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:/sbin/shutdown -t3 -r now
</SCREEN>

så der kommer til at stå

<SCREEN>
# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:/sbin/shutdown -t3 -h now
</SCREEN>

Du kan selvfølgelig være fræk, så maskinen slet ikke kan stoppes fra
tastaturet med "Ctrl-Alt-Delete", f.eks. kan du
ændre <FILENAME>/etc/inittab</FILENAME> til

<SCREEN>
# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:echo "No reboot for you my friend!\n"
</SCREEN>

Dette er uhyre praktisk, hvis din maskine står et sted, hvor der er
mange pilfingre, f.eks. edb-lokalet på en skole!
</PARA>
</sect2>

</SECT1>


<SECT1 id="linuxconf">
<title>linuxconf</title>
<indexterm><primary>linuxconf</primary></indexterm>
<para>
Programmet <command>linuxconf</command> køres af
<filename>root</filename>, og det bruges til at udføre 
systemadministration på Linux maskinen. Programmet er meget
omfattende, men nemt at bruge. Du kan konfigurere brugerkonti, grupper,
alt om netværk, e-post spam-filtrering, PPP og meget andet.
</para>

<FIGURE ID="linuxconf-billede1" FLOAT="1">
<TITLE>Systemadministration med <command>linuxconf</command></TITLE>
<GRAPHIC FILEREF="linuxconf.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<para>
Et smart trick med programmet er, at du kan køre det via en
webbrowser. Din systemadministrator kan således administrere din
maskine fra en anden vilkårlig maskine, som måske kører et helt andet
styresystem. Start <command>linuxconf</command> i en
<command>xterm</command>, og vælg [Config] -> [Networking] -> [Misc]
-> [Linuxconf network access], og "activate the changes". Nu kan du
via <filename>http://DINMASKINE:98</filename> administrere maskinen
(dette kræver ikke at Apache webserveren kører). Har du et lille
lukket netværk, er det smart, men du skal vide, at netværkstrafikken
kan aflyttes, og dine kodeord transmitteres i klar tekst via dit
netværk. Du må <emphasis>aldrig</emphasis> sende adgangskoder i klar
tekst for maskiner, der er direkte på Internettet. Det er alt for usikkert.
</para>

<FIGURE ID="linuxconf-billede2" FLOAT="1">
<TITLE>Systemadministration med <command>linuxconf</command> i en web-browser.</TITLE>
<GRAPHIC FILEREF="linuxconf-web.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

</sect1>


<sect1 id="crontab">
<title>Crontab</title>
<indexterm><primary>Cron</primary><secondary>crontab</secondary></indexterm>
<para>
Crontab er et smart system til automatisk at køre programmer på givne
tidspunkter, såsom daglig backup. Det er en standarddel af et UNIX
system og er derfor altid med i Linux.
</para>

<para>
Man kan få kørt vilkårlige programmer på vilkårlige tidspunkter,
f.eks. hvert minut, time, dag, ugedag eller månedsdag.  I filen
<filename>/etc/crontab</filename> retter man normalt ikke, men denne
fil viser, at der køres jobs hver time fra
<filename>/etc/cron.hourly</filename> til tilsvarende hver dag, uge og
måned via <filename>/etc/cron.daily</filename>,
<filename>/etc/cron.monthly</filename> og
<filename>/etc/cron.weekly</filename>.  For en almindelig bruger er
det normalt, at man føjer de kommandoer man vil have kørt på et givet
tidspunkt, til filen <filename>~/.crontab</filename> og kører
kommandoen <command>crontab ~/.crontab</command>.
</para>

<para>
Syntaksen for alle disse crontab filer er den samme: En kommando per linje
og i rækkefølge fra venstre mod højre, minut (0-59), time (0-23),
månedsdag (0-31), måned (0-12), ugedag (0-7, hvor 0 og 7 begge er søndag)
og endelig den kommando du vil have udført. Hvert felt adskilles af et
mellemrum, og hvis man vil have, at f.eks. alle dage køres
programmet, så indsæt en "*" for månedsdag og måned.</para>

<para> Vi giver nu et eksempel, hvor vi hver morgen kl. 7 fra mandag
til fredag sender brugeren "root" et brev med, hvor meget belastning 
der er på maskinen.
<screen>
0 7 * * 1-5 uptime | mail root
</screen>
Brug <command>man -a crontab</command> til at læse mere om
crontab. Skift til næste man-fil ved at trykke 'q'.
</para>
</sect1>

<sect1 id="Opstart">
<title>Opstart af Linux</title>
<sect2 ID="NTogLinux">
<title>Samtidig installation af Windows NT og Linux</title>
<indexterm><primary>Opstart af Linux</primary><secondary>NT</secondary></indexterm>
<indexterm><primary>Microsoft Windows</primary><secondary>NT</secondary></indexterm>
<indexterm><primary>Windows</primary><secondary>NT</secondary></indexterm>

<para>
Windows NT og Linux kan sagtens være installeret på samme maskine, det eneste
lidt problematiske er opstarts-proceduren. Du kan
vælge mellem at starte op i LILO's opstarter eller i NT's. 
Det helt ideelle vil være, at begge startprogrammer
kan starte begge systemer. Denne løsning kan man kalde
'den ideelle duét-opstartsløsning'.
</para>

<para>
Når Windows NT installeres, bliver "Master Boot Recorden" (MBR) på
harddisken altid overskrevet, således at NT's egen opstartsindlæser får
kontrol over opstarten af maskinen. Når Linux installeres, får du en
valgmulighed: du kan vælge at overskrive MBR med LILO, eller du kan
vælge at installere LILO på en harddiskpartition.
</para>

<para>
Det er netop det, vi skal udnytte til at duét-opstarte mellem
LILO og Windows NT's "OS Loader".  Vi er ikke interesserede i at miste
muligheden for at starte op i Linux ved hjælp af LILO, så det kan
betragtes som en forebyggende handling at acceptere tingenes
tilstand, det vil sige at placere  Windows NT's "OS Loader" i MBR og
at placere LILO på en passende
primær partition. Derfor skal du svare NEJ til at placere LILO i
"Master Boot Recorden" (MBR). LILO bør i stedet placeres på den primære
partition, Linux er installeret i.
</para>

<para>
Når du vælger at installere LILO på en harddiskpartition i stedet for
i "Master Boot Recorden" (MBR), er det nødvendigt at fremstille en
opstartsdiskette til Linux, enten som en del af installationen eller efter
installationen, men under alle omstændigheder <emphasis>før</emphasis>
Linux lukkes 
ned. Ellers får du svært ved at starte op i Linux igen! Opstartsdisketten
kan fremstilles efter installeringen med Linux-kommandoen
<command>mkbootdisk</command>. Husk at have en formateret diskette
parat. Disketten skal være formatteret 'unconditional', så der ikke
ligger information skjult på den, for eksempel 
<command>FORMAT A: /U</command> i en DOS-prompt eller Linux-kommandoen
<command>fdformat</command>. Det er vigtigt, at disketten er 100% fri for 
fysiske fejl!
</para>

<para>
Eksempel:
</para>

<screen>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>fdformat /dev/fd0H1440</USERINPUT>
Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.
Formatting ... done
Verifying ... done
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>ls -l /lib/modules</USERINPUT>
total 1
drwxr-xr-x 10 root root 1024 Dec 1 22:40 2.0.36-0.7
lrwxrwxrwx  1 root root   23 Dec 3 13:22 preferred -> /lib/modules/2.0.36-0.7
</screen>

<para>
<filename>preferred</filename> peger på kataloget 2.0.36-0.7. Det
benyttes i <command>mkbootdisk</command>-kommandoen:
</para>

<screen>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>mkbootdisk 2.0.36-0.7</USERINPUT>
Insert a disk in /dev/fd0. Any information on the disk will be lost.
Press &lt;Enter&gt; to continue or ^C to abort:
</screen>

<para>
Microsoft anbefaler, at C-drevet under Windows NT kører FAT. Det giver
muligheder for fejlfinding, der ikke eksisterer på et NTFS-drev.  En
uventet, men glædelig sideeffekt af dette er, at Linux kan montere
C-drevet. Det giver blandt andet mulighed for den ideelle
duét-opstartsløsning beskrevet i dette afsnit.
</para>

<para>
Standard-installationen af Red Hat-udgaven af Linux konfigurerer automatisk
duét-funktionen for Linux's opstarter, LILO. Det
eneste, du skal gøre, er at acceptere de to opstartsmuligheder 'dos' eller
'Linux'.  Når LILO starter, kan du trykke på TAB-tasten for at få en
oversigt over opstartsmulighederne. Typisk kan du vælge mellem 'Linux' og
'dos'. Når du vælger 'dos', starter LILO Windows NT's "OS Loader".
</para>

<para>
Det lidt mere omstændelige er konfigurering af Windows NT's "OS Loader", så
LILO kan startes fra Windows NT's "OS Loader". Windows NT's "OS Loader"
benytter sig af filreferencer i filen <filename>C:\BOOT.INI</filename>.
</para>

<para>
Eksempel på BOOT.INI:
</para>

<SCREEN>
[boot loader]
timeout=5
default=multi(0)disk(0)rdisk(0)partition(3)\WINNT
[operating systems]
multi(0)disk(0)rdisk(0)partition(3)\WINNT="NT Workstation 4.00 SP3"
multi(0)disk(0)rdisk(0)partition(3)\WINNT="NT Workstation 4.00 SP3 [VGA mode]" /basevideo /sos
C:\="Windows 95"
</screen>

<para>
Når NT-systemet med denne <filename>BOOT.INI</filename> startes op,
har brugeren fem sekunder til at fravælge standard-opstarten af WINNT.
</para>

<para>
Filen skal nu tilrettes, så Linux også bliver en valgmulighed.
</para>

<para>
Skriv i DOS/NT:
</para>

<screen>
C:
CD \
ATTRIB -s -r BOOT.INI
EDIT BOOT.INI
</screen>

<para>
Tilføj følgende linje:
</para>

<screen>
C:\BOOTSECT.LNX="Linux - Red Hat Distribution 6.x"
</screen>

<para>
Sæt derefter filens attributter igen:
</para>

<screen>
ATTRIB +s +r BOOT.INI
</screen>

<para>
Filen <filename>BOOTSECT.LNX</filename> skal fremstilles fra
Linux. Først skal vi finde 
frem til navnet på Linux-partitionen i Linux. Udfør kommandoen
<command>df</command>. Notér navnet på filsystemet for rod-disken
(<filename>"/"</filename>). I det følgende ses på et eksempel med to
SCSI diske (deraf <filename>sda</filename> og <filename>sdb</filename>).
</para>

<para>
Eksempel:
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>df</USERINPUT>
Filesystem         1024-blocks  Used Available Capacity Mounted on
/dev/sda2             692011  356539   299728     54%   /
/dev/sda1             618288  424384   193904     69%   /dos
/dev/sdb1             208592  196616    11976     94%   /dos2
/dev/sdb3             513808  426136    87672     83%   /dos3
</screen>

<para>
Navnet på Linux-partitionen er forskelligt fra system til system. I
eksemplet ovenfor er navnet på Linux-roddisken 
<filename>/dev/sda2</filename>.  Nu skal
<filename>BOOTSECT.LNX</filename> fremstilles. Dette gøres ved at
kopiere 512 byte fra starten af Linux-partitionen
<filename>/dev/sda2</filename> til filen
<filename>BOOTSECT.LNX</filename>.  Udfør kommandoerne:
</para>

<screen>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> dd if=/dev/sda2 of=/bootsect.lnx bs=512 count=1</userinput>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> mv /bootsect.lnx /dos/bootsect.lnx</userinput>
</screen>

<para>
Har du ikke adgang til den DOS-partition, hvor du starter op fra (eller er
det NTFS formatteret), kan du i stedet kopiere filen ud på en
diskette med brug af <command>mcopy</command>.
</para>

<screen>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> dd if=/dev/sda2 of=/bootsect.lnx bs=512 count=1</userinput>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> mcopy /bootsect.lnx a:</userinput>
</screen>


<para>
Genstart derefter din maskine. Hvis du vælger at geninstallere LILO i
Linux, skal du huske at fremstille en ny
<filename>BOOTSECT.LNX</filename>-fil. 
</para>


<para>
Nu kan Linux' opstarter startes fra Windows NT's "OS Loader", således at
du <emphasis>kan</emphasis> opnå valgfrihed - også med Windows NT!
</para>

<para>
Hvis du vil vide meget mere om MBR-placering, opstartere og
partitioner, kan det anbefales at læse HOWTO-guiden om LILO. På Red Hat
Linux-cd'en hedder filen <filename>/doc/HOWTO/mini/LILO</filename>
</para>
</sect2>
</sect1>

<sect1 id="software-raid">
<title>Software raid</title>
<indexterm><primary>raid</primary></indexterm>
<!-- Skrevet af peter_frederiksen@danbbs.dk -->
<!-- sprog rettet lidt til : pto -->

<sect2 id="hvad-er-raid">
<title>Hvad er raid?</title>
<para>
Raid er en metode til at slå flere diske sammen til en volume, det
kan gøres for at opnå et større brugerdrev eller for at højne
sikkerheden ved redundans.
</para>

<para>
Derfor er der flere måder at kombinere diske til et raid og man har
derfor vedtaget nogle raid-levels.
</para>
</sect2>

<sect2 id="hw-sw-raid">
<title>Forskel mellem hardware- og softwareraid</title>

<para>
Raidet kan lave hardwaremæssigt eller softwaremæssigt, det sikreste
er via. hardware eller med andre ord en raidkontroller.
</para>

<sect3 id="Hardwareraid">
<title>Hardwareraid</title>
<indexterm><primary>raid</primary><secondary>Hardware</secondary></indexterm>

<para>
Ved at lade hardwaren styre diskene og "narre" styresystemet til at
tro at der er tale om et eller flere logiske drev, behøver man ikke at
bekymre sig så meget om opsætning af linux, da hardwareproducenterne
som regel har en brugervenlig opsætningsmenu installeret i kortets
BIOS.
</para>

<para>
Ulempen er et disse kort som regel er dyre at anskaffe og ofte
benytter sig af de noget dyrere SCSI diske. Med andre ord en
raidkontroller er ofte "bare" en avanceret SCSI-kontroller.
</para>
</sect3>

<sect3 id="Softwareraid">
<title>Softwareraid</title>
<indexterm><primary>raid</primary><secondary>Software</secondary></indexterm>

<para>
Her lader man et stykke software styre raidet, hvilket sparer en
raid-controller og det er muligt at blande SCSI-diske med IDE eller kun
benytte sig af IDE.
</para>

<para>
Ulempen er at man så selv skal konfigurere raidet og på linux er
det lidt besværligt.
</para>
</sect3>
</sect2>


<sect2 id="spejlet-raid">
<title>Opsætning af spejlede diske.</title>
<indexterm><primary>raid</primary>
<secondary>spejling</secondary></indexterm>

<para>
Et disk spejl er hvis man ønsker 2 diske som en logisk enhed,
hvor begge diske indeholder samme data. Sikkerheden er her at hvis en
disk står af, så kører den anden videre.
</para>

<para>
Hvis man ønsker yderligere sikkerhed kan man benytte en ekstra
sparedisk som vil kunne erstatte en nedbrudt disk i spejlet, på den
måde undværer man kun sikkerheden i den tid som det tager
raidsoftwaren at opbygge et nyt spejl på sparedisken.
</para>

<sect3 id="spejlet-raid-howto">
<title>Fremgangsmåde</title>

<itemizedlist mark="bullet" spacing="compact">
<listitem><para>
  Start i singleusermode - (<command>linux s</command> ved opstart eller
  <command>init 1</command>)
</para></listitem>
<listitem><para>
  Opret partition med fdisk på begge diske, filsystemet skal være
  (Linux raid autodetect) og skriv devicenummeret ned.
</para></listitem>
<listitem><para>
  Opret en <filename>/etc/raidtab</filename> fil, men indhold som
  kunne se således ud:</para>
 <screen>
raiddev              /dev/md0
raid-level                  1
nr-raid-disks               2
chunk-size                  8
persistent-superblock       1
nr-spare-disks      	    0
    device           /dev/sdc1
    raid-disk     	    0
    device           /dev/sdd1
    raid-disk     	    1         
</screen>
</listitem>

<listitem><para>
  Opret raid device med kommandoen <command>mkraid /dev/md0</command>.
</para></listitem>

<listitem><para> 
 Opret filsystem til din logiske enhed
 <filename>/dev/md0</filename> med kommandoen <command>mkfs
 /dev/md0</command>.
</para></listitem>

<listitem><para> 
 Mount det logiske drev eks. <command>mount /dev/md0 /spejl</command>
</para></listitem>

<listitem><para> 
 Opret en linie i <filename>/etc/fstab</filename> svarende til det nye spejl.
</para>

<screen>
/dev/sda1  /           ext2    defaults        1 1
/dev/md0   /Spejl      ext2    defaults        1 2
/dev/sda5  /home       ext2    defaults        1 2
/dev/cdrom /mnt/cdrom  iso9660 noauto,owner,ro 0 0
/dev/sdb5  /vol2       ext2    defaults        1 2
/dev/sdb1  swap        swap    defaults        0 0
/dev/fd0   /mnt/floppy ext2    noauto,owner    0 0
none       /proc       proc    defaults        0 0
none       /dev/pts    devpts  gid=5,mode=620  0 0
</screen>

</listitem>
</itemizedlist>

<para>
Har du tidligere haft et raid system sat op på diskene, skal du bruge
<command>mkraid --really-force /dev/md0</command> til at initialisere 
diskene igen, også selvom de er slettede med fdisk. Husk dog at tage
backup (f.eks. <command>tar pcfz data.tar.gz /mount/data</command>, 
før du anvender 
<command>mkraid --really-force /dev/md0</command>, da raid-diskene slettes
derved.
</para>

</sect3>
</sect2>

<sect2 id="linear-raid">
<title>Opsætning af linear raid</title>
<indexterm><primary>linear raid</primary></indexterm>

<para>
Linear raid er når man ønsker at slå flere diske sammen til en logisk
enhed og udnytte den samlede kapacitet.  Eks. på 2 diske som slås
sammen <filename>/etc/raidtab</filename>
</para>


<screen>
raiddev              /dev/md0
raid-level                  linear
nr-raid-disks               2
chunk-size                  8
persistent-superblock       1
nr-spare-disks      	    0
    device           /dev/sdc1
    raid-disk     	    0
    device           /dev/sdd1
    raid-disk     	    1         
</screen>
</sect2>


<sect2 id="raidhotadd-remove">
<title>raidhotadd og raidhotremove</title>
<indexterm><primary>raid</primary>
<secondary>raidhotadd og raidhotremove</secondary></indexterm>
<para>
Det er muligt at tilføje og fjerne diske fra raidet medens systemet
kører. Det kan være en god ting, hvis filsystemet af en eller anden
grund er gået i stykker på den ene af diskene. Det kan ske
ske uden, at disken rent fysisk har fejlet.
</para>

<para> 
<emphasis>Fjern disk</emphasis>
</para>

<para>
eks. fjern disk <filename>/dev/hdd1</filename> fra raidet
</para>

<screen>
<PROMPT>[root@linus /etc]# </PROMPT><USERINPUT>raidhotremove -a /dev/md0 /dev/hdd1</USERINPUT>
</screen>

<para>
Nu kan man arbejde på disken med <command>fdisk</command>
</para>

<para> 
<emphasis>Tilføj disk</emphasis>
</para>

<para>
Disken som er blevet reparttioneret kan tages i brug således
</para>

<screen>
<PROMPT>[root@linus /etc]# </PROMPT><USERINPUT>raidhotadd -a /dev/md0 /dev/hdd1</USERINPUT>
</screen>

<para>
Raidet vil automatisk blive opdateret og et evt. spejl vil blive
genopbygget medens produktionen kører, performancenedgangen er lille
selv ved IDE diske.
</para>

</sect2>
</sect1>

<SECT1 ID="sikkopi">
<!-- Skrevet af Claus Sørensen "cs@klid.dk" -->

<TITLE>Sikkerhedskopiering</TITLE>
<indexterm>
 <primary>Sikkerhedkopiering</primary>
</indexterm>
<indexterm>
 <primary>Backup</primary>
</indexterm>

<para>
En vigtig del af systemadministration er sikkerhedskopiering, 
så man i tilfælde af nedbrud, harddiskcrash, brand 
eller andre uheld, kan fortsætte uden større tab af data.
</para>

<para>
Sikring af sine data kan ske på flere måder, hvilket selvfølgelig 
er afhængigt af den grad af sikkerhed man ønsker samt i hvilket 
omfang af data, som skal sikres.
</para>

<SECT2 ID="sikkopi-metoder">
<TITLE>Metoder for sikkerhedskopiering</TITLE>
<para>
Grundlæggende kan man dele sikkerhedskopiering op i lokal- 
og fjernkopiering, hvilket bestemmes af det omfang af 
sikring som ønskes samt de tekniske muligheder som 
forelægger eller investering i samme.
</para>

<sect3 id="sikkopi-lokal">
<TITLE>Lokal sikkerhedskopiering</TITLE>

<para>
Lokal sikkerhedkopiering sker ved at 
gemme kopier af sine data på samme lokation, som dataene 
er. Her benyttes oftest disketter, bånd, brændbare 
cdrommer eller udskiftelige harddiske som lagringsmedier.
</para>
</sect3>

<sect3 id="sikkopi-fjern">
<TITLE>Sikkerhedskopiering via Internettet</TITLE>

<para>
Fjernkopiering sker ved, at man aftaler med andre, om 
at de krypteret spejler ens data samtidig med, at man 
gør det samme med deres. Det kræver selvfølgelig en 
tro på dem, som man udveksler data med, selvom dataene 
er krypterede.
</para>

<para>
Fjernkopiering er blevet mere aktuel efter at 
højhastighedsforbindelser (ADSL m.v.) er kommet ned i et 
prisleje, hvor også private og mindre virksomheder kan 
være med.
</para>

<para>
Man nøjes med at kopiere de forskelle, som er sket siden 
sidst, så man belaster forbindelsen mest muligt. Hvis 
man ikke stoler blindt på den, som giver plads til ens 
sikkerhedskopi, kan man altid kryptere dataene med 
GnuPG eller lignende krypteringsværktøjer.
</para>
</sect3>

<sect3 id="sikkopi-hvad">
<TITLE>Hvad skal kopieres?</TITLE>


<para>
Generelt skal man gemme de data, som man ikke kan 
undvære og er umulige at fremskaffe på anden vis f.eks. 
via installation.
</para>

<para>
Dette kan være en af baggrundene for at dele sit Linux-system 
op i flere partitioner, da visse værktøjer netop 
sikkerhedskopiere efter partitioner. De vigtigste 
kataloger er 
<filename>/home</filename> (brugerdata), 
<filename>/var</filename> (serverdata)
og <filename>/etc</filename> (konfigurationsdata), 
som således også bør have sine egne partitioner.
</para>

</sect3>



</SECT2>

<SECT2 ID="sikkopiprog">
<TITLE>Værktøjer til sikkerhedskopiering</TITLE>
<indexterm>
 <primary>Sikkerhedkopiering</primary>
 <secondary>Værktøjer</secondary>
</indexterm>

<para>
Valget af værktøj til sikkerhedskopiering er afhængig 
af en lang række faktorer så som lagringsmedie, 
type af adgang til systemet, graden af automation 
og omfanget af data.
</para>

<para>
I de næste afsnit vil forskellige værktøjer kort blive 
gennemgået, hvor deres fordele og ulemper vil blive 
belyst. Listen er på ingen måde udtømmende, men kan 
benyttes som et meget hurtigt overblik over de muligheder, 
som findes til sikkerhedskopiering i et Linux-miljø.
</para>

<sect3 id="sikkopi-tar">
<TITLE>Sikkerhedskopiering med tar</TITLE>
<indexterm>
 <primary>tar</primary>
</indexterm>
<indexterm>
 <primary>Sikkerhedkopieringsværktøjer</primary>
 <secondary>tar</secondary>
</indexterm>
<para>
Den mest benyttede kommando til sikkerhedskopiering er 
<command>tar</command>, som er en forkortelse for Tape 
ARchive. <command>tar</command> samler blot filer og 
deres data sammen i en enkelt fil, som så kan gemmes 
på et medie til sikkerhedskopiering f.eks. et bånd.
</para>

<para>
Hvis du vil tage en sikkerhedskopi på disketter af 
alle filerne i kataloget <filename>/home</filename> 
gøres det således:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>tar -cMf /dev/fd0H1440 /home</userinput>
</screen>

<para>Hvor <command>-cMf</command> står for henholdsvis 
oprette (<command>c</command>reate), 
på flere medier (<command>m</command>ultiple) 
og viser hvilke filer (<command>f</command>iles).
</para>

<para> 
Når der ikke er mere plads på den første diskette, 
spørger den automatisk efter den næste.
</para>

<para>Hver gang man har fortaget en sikkerhedskopiering, 
skal man huske at kontrollere den, så man er sikker på, 
at man kan genskabe dataene fra sikkerhedskopien. Dette 
gøres således:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>tar -compare -verbose -f /dev/fd0H1440</userinput>
/home
/home/alle
/home/alle/annoncetekst.txt
....
</screen>

<para>
I stedet for de lange tilvalg kan benyttes de kortere
udgaver, hvilket kan ses af man-siden for 
<command>tar</command>.
</para>

<para>Skal man genskabe dataene igen, så er det lige 
til:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>tar -extract -same-permissions -verbose -file /dev/fd0H1440</userinput>
/home
/home/alle
/home/alle/annoncetekst.txt
....
</screen>


<para>
Se mere ved hjælp af man-siden 
(<command>man tar</command>) eller i afsnittet om 
sikkerhedskopiering i 
"The Linux System Administrators' Guide":
<ulink url="http://www.linuxdoc.org/LDP/sag/index.html">http://www.linuxdoc.org/LDP/sag/index.html</ulink>. 
</para>

</sect3>

<sect3 id="sikkopi-dump">
<TITLE>Sikkerhedskopiering med dump og restore</TITLE>
<indexterm>
 <primary>dump</primary>
</indexterm>

<indexterm>
 <primary>restore</primary>
</indexterm>

<indexterm>
<primary>Sikkerhedkopieringsværktøjer</primary>
 <secondary>dump</secondary>
</indexterm>

<indexterm>
<primary>Sikkerhedkopieringsværktøjer</primary>
 <secondary>restore</secondary>
</indexterm>

<para>
Hvis man benytter Linux-filsystemet ext2, kan man 
benytte kommandoen <command>dump</command> til at 
gemme sikkerhedskopier helt eller delvist af hele 
filsystemet. De genskabes igen med kommandoen 
<command>restore</command>.
</para>

<para>
Som standard gemmer den kun de forskelle, som er 
siden sidste sikkerhedskopiering, men kan sættes 
til at tage en kopiering af det hele. 
</para>

<para>
Første gang man gemmer (samt med betrykkende 
mellemrum) tages en sikkerhedskopi af alle filerne i 
en partition. Lad os sige at <filename>/home</filename> 
ligger på partition <filename>/dev/hda6</filename>, så 
ser det sådan ud:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>dump -u0 -f /dev/st0 /home</userinput>
</screen>

<para>
Genskabelsen af data sker ved, at man først genskaber 
filsystemet på den partition, som skal genskabes:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>mke2fs /dev/hda6</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>mount /dev/hda6 /mnt</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>cd /mnt</userinput>
</screen>

<para>
Så den bliver klar til at ganskabe de data, som 
ligger i sikkerhedskopien:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>restore rf /dev/st0</userinput>
</screen>

<para>
Efter genskabelsen skal <filename>/home</filename> 
mountes igen:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>mount /mnt/home</userinput>
</screen>


<para>
Se mere om <command>dump</command> og 
<command>restore</command> ved at bruge deres 
man-side.
</para>
</sect3>

<sect3 id="sikkopi-afio">
<TITLE>Sikkerhedskopiering med afio</TITLE>
<indexterm>
 <primary>Sikkerhedkopieringsværktøjer</primary>
 <secondary>afio</secondary>
</indexterm>

<para>
Hvis man gerne vil have adgang til filerne individuelt, 
efter sikkerhedskopieringen kan man benytte værktøjet 
<command>afio</command>, som blandt andet bliver 
benyttet af KBackup.
</para>

<para>
Læs mere med <command>man afio</command>.
</para>

</sect3>

<sect3 id="sikkopi-kbackup">
<TITLE>Sikkerhedskopiering med KBackup</TITLE>
<indexterm>
 <primary>Sikkerhedkopieringsværktøjer</primary>
 <secondary>KBackup</secondary>
</indexterm>

<para>
KBackup en alsidig applikation til håndtering af 
sikkerhedkopiering bygget oven på andre 
værktøjer blandt andet <command>tar</command> og 
<command>afio</command>.
</para>

<para>
Den menubaserede grænseflade er meget intuitiv 
at bruge, så man nemt for sat en god rutine op 
for sikkerhedskopiering af de data, man selv 
ønsker.
</para>

<para>
Flere informationer kan findes på KBackups 
hjemmeside: <ulink url="http://kbackup.sourceforge.net">http://kbackup.sourceforge.net</ulink>
</para>

</sect3>

<sect3 id="sikkopi-arkeia">
<TITLE>Sikkerhedskopiering med Arkeia</TITLE>
<indexterm>
 <primary>Sikkerhedkopieringsværktøjer</primary>
 <secondary>Arkeia</secondary>
</indexterm>

<para>
Arkeia er et meget professionelt grafisk værktøj 
til håndtering af sikkerhedskopiering. Det er 
desværre closed sourced, men gratis også for 
virksomheder at bruge til en server og to klienter.
</para>

<para>
Hent vejledningen og programmet fra deres 
hjemmeside:
<ulink url="http://www.arkeia.com/">http://www.arkeia.com/</ulink>
og installér det.
</para>
</sect3>

<sect3 id="sikkopi-windows">
<TITLE>Microsoft Windows-værktøjer via Samba</TITLE>
<indexterm>
 <primary>Sikkerhedkopieringsværktøjer</primary>
 <secondary>Til Microsoft Windows</secondary>
</indexterm>
<para>
Ligger ens data på en Samba-server, kan man i de fleste 
tilfælde bruge de Microsoft Windows-værktøjer, som 
følger med båndstation eller anden hardware til 
sikkerhedskopiering. Man skal så blot huske at oprette 
en sti til lagringsmediet i konfigurationsfilen til 
Samba (<filename>/etc/smb.conf</filename>).
</para>
</sect3>

</sect2>



</sect1>

<SECT1 ID="sysadm-afslutning">
<TITLE>Tips og tricks</TITLE>

<PARA>
Der er meget mere i systemadministration, end dette korte kapitel har
præsenteret. Til Linux findes der især to dokumenter, som er gode at
læse, nemlig "System Administrator's Guide" (SAG) og "Network
Administrator's Guide" (NAG) - begge kan hentes fra 
<ulink url="http://sunsite.auc.dk/ldp">http://sunsite.auc.dk/ldp</ulink> og
findes på din Red Hat cdrom. De er en del af "Linux
Documentation Project" (LDP). Red Hat's hjemmeside indeholder endvidere
en række gode tricks og nyttige oplysninger. De bedste bøger om UNIX
systemadministration er uden tvivl Æleen Frisch's "Essential System
Administration" udgivet af O'Reilly, og "UNIX System Administration
Handbook" (Evi Nemeth, Garth Snyder, Scott Seebass og Trent R. Hein) udgivet
af Prentice Hall PTR.
</PARA>

<para>
Vil du vide mere om sikkerhedskopiering 
under Linux, så kig i 
"The Linux System Administrators' Guide":
<ulink url="http://www.linuxdoc.org/LDP/sag/index.html">http://www.linuxdoc.org/LDP/sag/index.html</ulink>. 
</para>


<sect2 id="dansk">
<title>Dansk og Linux</title>
<indexterm>
 <primary>Dansk</primary>
 <secondary>Tegn og sprog</secondary>
</indexterm>

<para>
Anvender du Red Hat 6.1 (og tidligere) vil du mangle
danske bogstaver. Dette kan du rette op på ved at lave filen
<filename>/etc/sysconfig/i18n</filename> med følgende indhold
</para>

<screen>
LANG=da
LINGUAS=da
LC_ALL=da_DK
SYSFONT=lat0-sun16
SYSFONTACM=iso15
</screen>

<para>
I Red Hat 6.2 og senere virker dette perfekt.
</para>
</sect2>


<sect2 id="harddisk-tuning">
<title>Harddisk tuning</title>
<indexterm><primary>Harddisk tuning</primary></indexterm>
<para>
Har du brug for at få ekstra "tryk" på din IDE-harddisk
så kan du bruge <command>hdparm</command> til at tune hastigheden.
Her er givet de to vigtigste parametre (bruge DMA og lookahead), som
nærmest alle nyere diske understøtter. Der kan tunes endnu mere - have
fun :-)
</para>

<para>
Nå det virker fint, kan og bør du lægge kommandoerne ind i filer, der
køres når systemet startes op. I Red Hat f.eks. i bundet af <filename>/etc/rc.d/rc.local</filename>.
</para>

<screen>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>/sbin/hdparm -tT /dev/hda</userinput>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>/sbin/hdparm -d1 -A1 /dev/hda</userinput>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>/sbin/hdparm -tT /dev/hda</userinput>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>/sbin/hdparm -k1</userinput>
</screen>

<para>
Samme program kan bruges til at få harddisken til at spinne ned i
hastighed - f.eks. efter 5 sekunder. Dette betyder mere slid på
harddisken, men din maskine bliver stille.
</para>

<screen>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>/sbin/hdparm -S 1 /dev/hda</userinput>
</screen>

<para>
Hvis man har et eller flere programmer der jævnligt checker om nogle filer
er ændret skal disse filers access tid også opdateres jævnligt -- det
giver skrivninger til disken selvom filsystemets egtl. data ikke ændres
(kun dets metadata).  Det kan være en god ide at montere disken via <filename>/etc/fstab</filename> noget i stil med
</para>

<screen>
/dev/hda1  /  ext2  defaults,noatime  1 1
</screen>


<para>
Kernens IDE driver skal supportere det IDE chipsæt, der anvendes af
bundkortet, og ikke alle IDE chipsæt er supporteret med (U)DMA.  så
hvis en given funktion ikke tillades af <command>hdparm</command> så
kan det være forklaringen.
</para>

<para>
Hdparm har kun begrænset anvendelse med SCSI. Til SCSI skal man dels
se på driveren, dvs. tilføje eventuelle modulparametre.  Symbios
SCSI-driverne kan dog fintunes via <command>/proc/scsi</command> under
drift.  Et nyttigt grafisk værktøj til at tune SCSI diske er
<command>scsi-config</command>, selvom der normalt ikke er så meget at
"tune".
</para>

</sect2>

<sect2 id="hvad-laver-hvad">
<title>Hvilke filer har programmet åbne?</title>
<indexterm><primary>Fil</primary><secondary>åbne</secondary</indexterm>
<para>
Ofte vil dit program have filer åbne som du måske ikke lige
vidste. Med <command>lsof</command> kan du se hvad der sker. Vi kan
f.eks. se hvad programmet arbejder med. Som eksempel kan vi se hvad
der sker, når man har <command>ping</command> kørende. Først finder vi
den PID - proces ID - som <command>ping</command> kører med. Der er
mindst to muligheder, enten med <command>ps aux</command> eller
<command>pidof</command>.
</para>


<screen>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>ps aux | grep ping</userinput>
pto       9149  0.0  0.1  1264  228 pts/4    S    Apr29   0:00 ping eric
root      9418  0.0  0.4  1360  516 ttyp0    S    00:06   0:00 grep ping
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>pidof ping</userinput>
9149
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>lsof -p 9149</userinput>
COMMAND  PID USER   FD   TYPE DEVICE    SIZE   NODE NAME
ping    9149 root  cwd    DIR    3,7    4096  30919 /home/pto/tmp
ping    9149 root  rtd    DIR    3,5    4096      2 /
ping    9149 root  txt    REG    3,5   17968 114094 /bin/ping
ping    9149 root  mem    REG    3,5  340663  16023 /lib/ld-2.1.3.so
ping    9149 root  mem    REG    3,5  169720  16071 /lib/libresolv-2.1.3.so
ping    9149 root  mem    REG    3,5 4101324  16030 /lib/libc-2.1.3.so
ping    9149 root  mem    REG    3,5  246652  16061 /lib/libnss_files-2.1.3.so
ping    9149 root    0u   CHR  136,4              6 /dev/pts/4
ping    9149 root    1u   CHR  136,4              6 /dev/pts/4
ping    9149 root    2u   CHR  136,4              6 /dev/pts/4
ping    9149 root    3u   raw                 12743 0200A8C0:0001->00000000:0000 st=07
</screen>

<para>
Så man kan se at programmer har fat i mange filer.  Det skal nævnes at
<command>pidof</command> kræver SysVinit-pakken er installeret og
stien til <command>pidof</command> varierer desværre alt efter Linux
distribution. Det skal også nævnes, at <command>ps aux</command> bruges
på en Linux-maskine, mens mange andre UNIX varianter anvender 
<command>ps -ef</command>.
</para>

<para>
Tilsvarende kan man have stor glæde af at kunne se hvilke programmer,
der har filer åbne under et givet katalog i filtræet. Det er meget
relevant ved afmontering af f.eks. cdrom-drev. Prøv følgende:
</para>

<screen>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>lsof +D /var/spool</userinput>
COMMAND  PID USER   FD   TYPE DEVICE SIZE  NODE NAME
atd      459 root  cwd    DIR    3,5 4096 32594 /var/spool/at
crond    473 root  cwd    DIR    3,5 4096    12 /var/spool/
lpd     9299 root    4w   REG    3,5    5  4507 /var/spool/lpd/lpd.lock

</screen>

<para>
Eksemplet viser, at der er tre programmer <command>at</command>,
<command>crond</command> og <command>lpd</command> som pt. anvender
filer under <filename>/var/spool</filename>. Meget nyttige ting for en
systemadministrator.
</para>

</sect2>


<sect2 id="glemt-passwd">
<title>Har du glemt din adgangskode?</title>

<indexterm><primary>adgangskode</primary><secondary>glemt</secondary></indexterm>
<indexterm><primary>glemt password</primary></indexterm>
<indexterm><primary>Password</primary><secondary>glemt</secondary></indexterm>


<para>
Hvis du har dummet dig meget og glemt din root-adgangskode, så kan du 
få sat et nyt ind. 
</para>

<para>
I så fald booter du med "linux init=/bin/sh" . Så starter den en
shell som proces nr. 1. Herefter køres
</para>

<screen>
<PROMPT>[root@linus ~]# </PROMPT> <userinput>mount -n -o remount,rw /</userinput>     # re-mount / read-write
<PROMPT>[root@linus ~]# </PROMPT> <userinput>passwd</userinput>                       # skift adgangskode
<PROMPT>[root@linus ~]# </PROMPT> <userinput>mount -n -o remount,ro /</userinput>     # remount / read-only
<PROMPT>[root@linus ~]# </PROMPT> <userinput>exec /sbin/init 3 </userinput>           # start init i runlevel 3
</screen>

<para>
Dette lyder jo som et stort sikkerhedhul og det er det også, hvis man
har fysisk adgang til maskinen. Du kan dog undgå dette ved at tilføje 
linien "password=MIT_PASSWORD" til din
<filename>/etc/lilo.conf</filename>, men så skal du kunne huske
root-adgangskode og den adgangskode du har sat i <filename>/etc/lilo.conf</filename>.
</para>

</sect2>
</SECT1>
</chapter>
