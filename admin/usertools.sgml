<!-- $Id$ -->
<chapter id="sysadm">
 <title>Systemadministration</title>

 <para>
  I dette kapitel ser vi nærmere på nogle af de værktøjer og opgaver
  som systemadministratoren kommer ud for.
 </para>

 <sect1 id="tilfoeje-brugere">
  <title>Tilføje brugere</title>

  <indexterm><primary>Tilføje brugere</primary></indexterm>
  <indexterm><primary>useradd</primary></indexterm>

  <para>
   Ud over de grafiske programmer til at håndtere brugere, så kan det
   være praktisk at kunne addere brugere til systemet via en
   konsol. Skal man lave en konto til brugeren Peter Toft med
   brugernavn "pto", hjemmekatalog <filename>/home/pto</filename> og
   denne bruger skal være medlem af gruppen
   <literal>linuxbog</literal>, så køres følgende:
<screen>
<prompt>[root@linus ~]#</prompt> <userinput>/usr/sbin/useradd -c 'Peter Toft \
 pto@sslug.dk' -d /home/pto -g linuxbog -m -n pto</userinput>
</screen>
   Her er tegnet <command>\</command> anvendt til at kunne fortsætte
   kommandoen på næste linje.
  </para>

  <para>
   Peter Tofts e-post-adresse er også tilføjet for at have flere
   informationer gemt i <filename>/etc/passwd</filename>. Man kunne
   også have tilføjet telefon-nummer. <emphasis>HUSK</emphasis> at
   give brugeren en adgangskode:
<screen>
<prompt>[root@linus ~]#</prompt> <userinput>passwd pto</userinput>
</screen>
  </para>
 </sect1>

 <sect1 id="Erstatning-af-tekst">
  <title>Erstatning af tekst i flere filer</title>

  <para>
   Ofte kommer man ud for at skulle erstatte tekst i filer. Nogle
   gange er det nemmest at starte en emacs- eller vi-editor op og blot
   rette filen til. Andre gange skal man lave samme rettelse i mange
   filer, og så er det meget nyttigt at kunne en smule shell og Perl.
   Antag f.eks. at man i alle .txt-filer skal erstatte "Windows" med
   "Linux".  Det kan gøres med følgende lille script som kan udføres
   direkte i kommandofortolkeren.
<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>for I in *.txt
 do
   perl -pi.bak -e 's/Windows/Linux/g' $I
 done</userinput>
</screen>
  </para>

  <para>
   Denne operation efterlader en .bak-fil for hver fil du laver
   søg-og-erstat i (bare for en sikkerheds skyld).
  </para>
 </sect1>

 <sect1 id="glemt-passwd">
  <title>Har du glemt din adgangskode?</title>

  <indexterm><primary>adgangskode</primary><secondary>glemt</secondary></indexterm>
  <indexterm><primary>glemt password</primary></indexterm>
  <indexterm><primary>glemt adgangskode</primary></indexterm>
  <indexterm><primary>password</primary><secondary>glemt</secondary></indexterm>

  <para>
   Hvis du har dummet dig meget og glemt din root-adgangskode, så kan
   du få sat en ny ind.
  </para>

  <para>
   I så fald booter du med "linux init=/bin/sh" . Så starter den en
   shell som proces nr. 1. Herefter køres:

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>mount -n -o</secondary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>exec</secondary>
   </indexterm>

   <indexterm>
    <primary>mount -n -o</primary>
   </indexterm>

   <indexterm>
    <primary>exec</primary>
   </indexterm>

<screen>
<prompt>[root@linus ~]#</prompt> <userinput>mount -n -o remount,rw /</userinput>     # re-mount / read-write
<prompt>[root@linus ~]#</prompt> <userinput>passwd</userinput>                       # skift adgangskode
<prompt>[root@linus ~]#</prompt> <userinput>mount -n -o remount,ro /</userinput>     # remount / read-only
<prompt>[root@linus ~]#</prompt> <userinput>exec /sbin/init 3 </userinput>           # start init i runlevel 3
</screen>
  </para>

  <para>
   Dette lyder jo som et stort sikkerhedshul, og det er det også, hvis
   man har fysisk adgang til maskinen. Du kan dog undgå dette ved at
   tilføje linjen "password=MIN_ADGANGSKODE" til din
   <filename>/etc/lilo.conf</filename>, men så skal du kunne huske
   root-adgangskoden og den adgangskode, du har sat i
   <filename>/etc/lilo.conf</filename>.
  </para>
 </sect1>

 <sect1 id="Opstart">
  <title>Opstart af Linux</title>

  <sect2 id="NTogLinux">  <!-- ikke længere specifikt for NT Windows -->
   <title>Samtidig installation af Windows og Linux</title>

   <indexterm><primary>Opstart af Linux</primary>
         <secondary>Windows</secondary></indexterm>
   <indexterm><primary>Microsoft Windows</primary>
         <secondary>Windows</secondary></indexterm>
   <indexterm><primary>Dual Boot</primary>
         <secondary>Linux</secondary></indexterm>

   <para>
    Windows og Linux kan sagtens være installeret på samme
    computer. Ved at bruge et opstartsprogram kan man, når man starter
    computeren, vælge om den skal starte i Linux eller i Windows. Det
    er samtidig også muligt at have flere forskellige udgaver af Linux
    og/eller Windows installeret på samme maskine. Man kan dog kun
    køre én ad gangen (med mindre man bruger VMware).
   </para>

   <para>
    Når man starter en computer, der kun har Windows installeret
    indlæses der først et lille startprogram fra <emphasis>Master Boot
    Record</emphasis> (MBR), der ligger først på den første harddisk
    (<filename>/dev/hda</filename>) sammen med beskrivelsen af hvordan
    harddisken er opdelt (partitionstabellen).  Startprogrammet fra
    MBR indlæser et egentligt startprogram fra den første del af den
    første harddisk (<filename>/dev/hda1</filename>) og overfører
    kontrollen til det.  Hvis computeren kører Windows 95 eller 98 vil
    DOS blive startet, og DOS vil så automatisk starte Windows. Kører
    computeren Windows NT eller 2000 giver startprogrammet et valg
    mellem forskellige opsætninger af styresystemet.
   </para>

<!-- Flyt følgende para til FTAV begynder bogen? -->

   <para>
    Microsoft anbefaler, at C-drevet under Windows NT er formateret
    som et FAT-filsystem. Det giver flere muligheder for fejlfinding
    end hvis man bruger det nyere NTFS-filsystem. En praktisk
    sideeffekt af at bruge et FAT-filsystem er at Linux ikke har
    problemer med at læse fra og skrive til C-drevet. En anden fordel
    er at hvis man får en maskine hvor Windows fylder hele harddisken,
    så kan man bruge DOS-programmet <command>fips.exe</command> til at
    frigøre en del af Windows-partitionen til brug for Linux. Det er
    derimod ikke muligt at omstrukturere NTFS-filsystemer og det vil
    derfor være nødvendigt at slette og geninstallere Windows, hvis
    man har en harddisk der er fyldt op af et enkelt NTFS-filsystem.
   </para>

   <para>
    Når man starter en maskine, der kun har Linux installeret, startes
    <emphasis>LInux LOader</emphasis> (LILO), der ligesom Windows'
    startprogram ligger i MBR. Der findes også en række andre
    startprogrammer til Linux, men dem vil vi ignorere i denne
    omgang. LILO giver brugeren mulighed for at vælge hvilken udgave
    af kernen, der skal startes. Typisk vil man kun have én udgave
    liggende, men det giver let mulighed for at afprøve en nyoversat
    kerne. Hvis den ikke virker kan man bare genstarte, og vælge den
    gamle og velfungerende kerne i stedet for. Der er mere om LILO i
    bogen "Linux - Friheden til at vælge installation".
   </para>

   <para>
    Hvis det er Windows' startprogram der ligger i MBR, skal
    Windows-opsætningen ændres så det også kan starte Linux. Hvis det
    er Linux' startprogram (LILO) der ligger i MBR skal dets opsætning
    tilsvarende ændres, så det kan starte Windows. De følgende afsnit
    vil gennemgå begge muligheder.
   </para>

   <para>
    Bemærk at når Windows (gen)installeres, bliver MBR harddisken
    overskrevet!  Hvis LILO er installeret i MBR vil den derfor blive
    slettet, og man kan således ikke starte Linux. Det er derfor meget
    vigtigt at lave en startdiskette (eng. boot disk) til Linux, før
    man går i gang med at installere Windows på en maskine der
    allerede er Linux på. Det kan også være fornuftigt at lave en
    startdiskette før man begynder at eksperimentere med LILO. Så kan
    man altid redde sig ud af en uheldig opsætning af LILO.
   </para>

   <para>
    Startdisketten kan fremstilles efter installationen med
    Linux-kommandoen <command>mkbootdisk</command>. Husk at have en
    formateret diskette parat.  Det er vigtigt, at disketten er 100%
    fri for fysiske fejl!
   </para>

   <para>
    Eksempel:

<indexterm>
 <primary>Formatering af diskette [fdformat]</primary>
</indexterm>

<indexterm>
 <primary>fdformat</primary>
</indexterm>

<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>fdformat</secondary>
</indexterm>

<indexterm>
<primary>Bootdisk</primary>
<secondary>mkbootdisk</secondary>
</indexterm>

<indexterm>
 <primary>mkbootdisk</primary>
</indexterm>

<indexterm>
 <primary>Opstartsdiskette [mkbootdisk]</primary>
</indexterm>

<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mkbootdisk</secondary>
</indexterm>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>fdformat /dev/fd0H1440</userinput>
Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.
Formatting ... done
Verifying ... done
<prompt>[root@linus /root]#</prompt> <userinput>mkbootdisk `uname --release`</userinput>
Insert a disk in /dev/fd0. Any information on the disk will be lost.
Press &lt;Enter&gt; to continue or ^C to abort:
</screen>
   </para>

<!-- Eksemplet er noget simplificeret sammenlignet med det gamle,
 men kræver at kernen ligger i /boot -->

<para>
Det er også en smart idé at lave en startdiskette til Windows før du går
igang med LILO-eksperimenter. I Windows 95 og 98 kan man køre
<command>format a: /s</command> på kommandolinjen. I Windows NT og
2000 skal disketten formateres, da det medfører at de nødvendige
systemfiler bliver kopieret ud på disketten.
<!--
Dette opretter
en Windows boot sektor på disketten, og filerne 
<filename>ntldr</filename>,
<filename>Ntdetect.com</filename> og <filename>Boot.ini</filename>
kopieres
fra roden af C: drevet til disketten. Filerne er normalt mærket som
skjulte og system, så du skal muligvis ændre Explorers opsætning
for at finde dem.
-->
</para>

<sect3 id="LinuxiMBR">
<title>Linux styrer opstarten</title>

<para>
Den letteste løsning er at lade Linux styre opstarten af maskinen. Det ser
også mest blæret ud :-)
</para>

<para>
Under installationen af Red Hat gøres dette ved at vælge at lægge LILO i
MBR. Under Red Hat-installationen vil et eventuelt eksisterende
Windows-system automatisk blive tilføjet som en valgmulighed i LILO.
</para>

<para>
Har du allerede installeret Linux, kan et Windows-system føjes til LILO's
menu ved at føje følgende linjer til <filename>/etc/lilo.conf</filename>:
</para>

<programlisting>
other=/dev/hda1
        label=dos
        table=/dev/hda
</programlisting>

<para>
Husk, at hver gang opsætningen af LILO ændres skal du køre
<command>/sbin/lilo</command> som root. Det vil så
opdatere informationerne, der ligger i MBR.
</para>

<para>
Når LILO starter får du en oversigt over mulighederne. Typisk kan du vælge
mellem 'linux' og 'dos'. Når du vælger 'dos', kalder LILO Windows' "OS
Loader". Med ældre udgaver af LILO er det nødvendigt at trykke på
tabulatortasten for at blive præsenteret for valgmulighederne.
</para>
</sect3>

<sect3 id="WindowsiMBR">
<title>Windows styrer opstarten</title>

<para>
Dette afsnit gælder ikke for Windows 95 og Windows 98. Hvis du bruger et
af disse to systemer skal du lade Linux styre opstarten som beskrevet i
forrige afsnit. Opsætningen af Windows NT's og 2000's startprogram, "OS
Loader" findes i filen <filename>C:\Boot.ini</filename>.
</para>

<para>
Når Windows styrer opstarten skal LILO installeres i
<emphasis>boot</emphasis>-sektoren på rod- eller
<filename>/boot</filename>-filsystemet. For at kunne starte Linux fra
Windows skal <emphasis>boot</emphasis>-sektoren kopieres over i en fil,
overføres til C-drevet og føjes til <filename>C:\Boot.ini</filename>.
</para>

<para>
Først skal bootsektoren gemmes som en fil, for eksempel
<filename>bootsect.lnx</filename>. I <filename>/etc/lilo.conf</filename>
er der en linje "boot=...". Den fortæller hvor LILO's
<emphasis>boot</emphasis>-sektor findes.
</para>

<para>
Eksempel:
</para>
<indexterm>
 <primary>grep</primary>
</indexterm>

<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>grep</secondary>
</indexterm>

<indexterm>
 <primary>dd</primary>
</indexterm>

<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>dd</secondary>
</indexterm>

<screen>
<prompt>[root@linus /root]# </prompt><userinput>grep "^boot" /etc/lilo.conf</userinput>
boot=/dev/hda3
</screen>

<para>
Vi kan se at i eksemplet er LILO placeret i
<emphasis>boot</emphasis>-sektoren på <filename>/dev/hda3</filename>.
Vi kan nu kopiere <emphasis>boot</emphasis>-sektoren ud i filen
<filename>bootsect.lnx</filename> med kommandoen:
</para>

<screen>
<prompt>[root@linus /root]# </prompt><userinput> dd if=/dev/hda3
of=/bootsect.lnx bs=512 count=1</userinput>
</screen>

<para>
(kopiér den første blok à 512 bytes fra <filename>/dev/hda3</filename> til
<filename>bootsect.lnx</filename>)
</para>

<para>
<filename>bootsect.lnx</filename> skal nu kopieres til Windows' C-drev og
den følgende linje skal føjes til <filename>c:\Boot.ini</filename>:
</para>

<programlisting>
C:\bootsect.lnx="Linux - Red Hat"
</programlisting>

<para>
Denne linjer betyder at NT's startprogram kalder LILO - i filen
<filename>C:\bootsect.lnx</filename> - hvis du vælger Linux i NT's
opstartsmenu. Dette trick kan også laves med flere
<emphasis>boot</emphasis>-sektorer.
</para>

<indexterm>
 <primary>mkdir</primary>
</indexterm>
 <indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mkdir</secondary>
</indexterm>
<indexterm>
 <primary>Montere et fat filsystem [mount -t vfat]</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mount -t vfat</secondary>
</indexterm>
<indexterm>
 <primary>mv</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mv</secondary>
</indexterm>
<indexterm>
 <primary>echo</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>echo</secondary>
</indexterm>

<para>
Hvis C-drevet er i FAT-format, kan du montere det fra Linux (det er de to
første linjer nedenfor). De to sidste linjer kopierer
<emphasis>boot</emphasis>-sektorfilen til Windows-drevet, og føjer den til
"OS Loaderens" opsætningsfil. Bemærk at &gt;&gt; <emphasis>skal</emphasis>
bruges, da &gt; alene vil overskrive filen og ikke føje til den:

<screen>
<prompt>[root@linus /root]# </prompt><userinput> mkdir /dos</userinput>
<prompt>[root@linus /root]# </prompt><userinput> mount -t vfat /dev/hda1 /dos</userinput>
<prompt>[root@linus /root]# </prompt><userinput> mv /bootsect.lnx /dos/bootsect.lnx</userinput>
<prompt>[root@linus /root]# </prompt><userinput> echo 'C:\\bootsect.lnx="Linux - Red Hat 7.0"' &gt;&gt; /dos/BOOT.INI</userinput>
</screen>
</para>

<!-- er der en bedre måde at skrive echo på?? -->

<para>
Dette virker ikke hvis dit Windows-drev er NTFS-formateret. Har du adgang
til en FTP-server, kan du kopiere <filename>bootsect.lnx</filename> til en
FTP-server, genstarte maskinen i Windows og hente filen igen. Et
alternativ er at kopiere filen ud på en diskette med brug af
<command>mcopy</command>, som vist her:

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>mcopy /bootsect.lnx a:</userinput>
</screen>
</para>

<para>
Genstart derefter din maskine.
</para>

<para>
Eksempel på en komplet <filename>C:\Boot.ini</filename>:

<programlisting>
[boot loader]
timeout=5
default=multi(0)disk(0)rdisk(0)partition(3)\WINNT
[operating systems]
multi(0)disk(0)rdisk(0)partition(3)\winnt="NT Workstation 4.00 SP3"
multi(0)disk(0)rdisk(0)partition(3)\winnt="NT Workstation 4.00 SP3 [VGA
mode]" /basevideo /sos
C:\="Windows 95"
</programlisting>
</para>

<para>
Denne fil er Windows' startprograms opsætningsfil. Filen skal nu
tilrettes, så Linux også bliver en valgmulighed.
</para>

<para>
Skriv i DOS/NT:
</para>

<programlisting>
C:
CD \
ATTRIB -s -r BOOT.INI
EDIT BOOT.INI
</programlisting>

<para>
Tilføj følgende linje:
</para>

<programlisting>
C:\bootsect.lnx="Linux - Red Hat 7.0"
</programlisting>

<para>
Sæt derefter filens attributter igen:

<programlisting>
ATTRIB +s +r BOOT.INI
</programlisting>
</para>

<para>
Nu kan Windows' "OS Loader" kalde LILO og dermed starte Linux. Så du
<emphasis>kan</emphasis> opnå valgfrihed - også med Windows! Husk, at hvis du
ændrer opsætningen af LILO, skal du huske at fremstille en ny
<filename>bootsect.lnx</filename>-fil og kopiere den over på
Windows-filsystemet. 
</para>

<para>
Hvis du vil vide meget mere om MBR-placering, opstart og diskopdeling, kan
det anbefales at læse HOWTO-guiden om LILO. På Red Hat Linux-cd-rom'en
hedder filen <filename>/doc/HOWTO/mini/LILO</filename>.
</para>

<!-- Man kunne også referere til Mini HOWTO'en om NT windows og linux -->
</sect3>
 </sect2>
</sect1>


<sect1 id="runlevel">
<title>Hvad er et "runlevel"?</title>
<indexterm><primary>Runlevels</primary></indexterm>
<indexterm><primary>/etc/rc.d</primary></indexterm>
<indexterm><primary>Start i grafisk tilstand</primary></indexterm>
<para>
Et runlevel er den tilstand, som systemet kører i. Computeren kan køre
i tilstande såsom "opstarter systemet", "enkeltbrugersystem",
"flerbrugersystem", "genstarter systemet" og "slukker computeren". Hvis
man f.eks. vil kopiere <filename>/home</filename>-kataloget over på en
større harddisk fordi ens brugere har for mange MP3-filer liggende,
så er det nødvendigt at sikre, at der ikke er nogen brugere, der har
filer åbne, mens man kopierer, idet der så kan opstå en fejl i
kopieringen. Det kan man sikre sig ved at skifte til
enkeltbruger-tilstand, der svarer lidt til fejlsikret tilstand i
Windows. Når man er færdig med systemarbejdet, hopper man tilbage til
"flerbrugersystem" og folk har igen adgang til computeren, og vil ikke
bemærke at deres filer pludselig ligger på et andet drev.
</para>

<para>
Computeren kører en masse services for brugerne. Det kan
f.eks. være netværksforbindelse (network) og forskellige
netværksrelaterede services som f.eks. e-post
(sendmail/routed/named/snmpd/portmap), adgang til filsystemer på andre
computere (nfs), mulighed for at udskrive til printer (lpd) og
lydkort (sound). Men mens Linux er ved at starte, har man ikke brug
for at have adgang til printeren, så printer-servicen startes først
når systemet går ind i "flerbrugersystem"-tilstanden.  Når man er ved
at genstarte eller slukke computeren, slukker man igen for
printer-servicen.</para>

<para> Når computeren omstilles fra én tilstand til en anden tilstand,
udføres en række scripts, der bestemmer hvilke services der skal
tændes og slukkes. Hvilke scripts der kører ved skift til f.eks.
runlevel 3 (flerbrugersystem uden grafisk login), 
bestemmes af, hvilke scripts der er
placeret i kataloget <filename>/etc/rc.d/rc3.d</filename> (Corel,
Debian og nu også Red Hat har tilsvarende
<filename>/etc/rc3.d</filename>).
</para>

<indexterm>
 <primary>ls</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>ls</secondary>
</indexterm>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ls /etc/rc.d/rc3.d</userinput>
K30mcserv  K40snmpd   K55routed  K75gated  K80random   K95nfsfs
K96pcmcia  K97network S01kerneld S30syslog S40atd      S40crond
S40portmap S50inet    S55named   S60lpd    S75keytable S80sendmail
S85sound   S99local
</screen>

<para>
Disse filer svarer til services der skal startes (dem der starter med
S) eller dræbes (starter med K for Kill) når systemets tilstand ændres
til tilstand 3 (Flerbrugersystem). Tallet bestemmer rækkefølgen;
<filename>S01kerneld</filename> startes altså før
<filename>S30syslog</filename>, mens <filename>K96pcmcia</filename>-servicen
dræbes efter <filename>K30mcserv</filename>. Hver fil i dette
katalog er i virkeligheden et link til et script i
<filename>/etc/rc.d/init.d/</filename>, og "S80sendmail" betyder i
virkeligheden at "/etc/rc.d/init.d/sendmail start" udføres, hvilket
starter sendmail-dæmonen op.
</para>

<para>
Det er ikke svært at finde ud af, hvilket runlevel din computer er
i. Nedenfor er vist hvordan.
</para>

<screen>
<prompt>[root@linus /root]# </prompt><userinput>/sbin/runlevel</userinput>
N 3
</screen>

<para>
3-tallet viser dig, at din pc er i runlevel 3. Det er muligt
at skifte runlevel uden at lukke computeren ned, men N'et
viser, at der intet tidligere runlevel er, dvs. computeren har været i
runlevel 3, siden den blev tændt. Du skifter runlevel
med kommandoen <filename>telinit</filename>. Du bør altid synkronisere 
dine harddiske (tømme filsystemernes buffere) inden du skifter
runlevel, dvs. kør <command>sync</command> et par gange, lige inden du
skifter runlevel med <command>telinit</command>.
</para>

<para>
Runlevel 3 er det mest almindelige for servere, mens grafiske
arbejdsstationer og kontormaskiner typisk vil anvende runlevel 5. 
Skemaet nedenfor viser
betydningen af de forskellige runlevels.  </para>

<table frame="all">
  <title>Runlevels</title>
  <tgroup cols="2" align="char">
  <thead>
   <row>
      <entry>Runlevel</entry>
      <entry>Betydning</entry>
    </row>
  </thead>
  <tbody>
    <row>
      <entry>0</entry>
      <entry>Lukker systemet ned (<userinput>shutdown -h now</userinput>)</entry>
    </row>
    <row>
      <entry>1</entry>
      <entry>Enkeltbrugertilstand (eng. »single-user mode«)</entry>
    </row>
    <row>
      <entry>2</entry>
      <entry>Flerbrugertilstand typisk ret mange netværksservices startet</entry>
    </row>
    <row>
      <entry>3</entry>
      <entry>Flerbrugertilstand uden grafisk login</entry>
    </row>
    <row>
      <entry>4</entry>
      <entry>Bruges ikke</entry>
    </row>
    <row>
      <entry>5</entry>
      <entry>Flerbrugertilstand med grafisk login</entry>
    </row>
    <row>
      <entry>6</entry>
      <entry>Genstart systemet (<userinput>reboot</userinput>)</entry>
    </row>
  </tbody>
</tgroup>
</table>

<para>
Som det fremgår af skemaet, er runlevel 6 det samme som at genstarte
systemet. Dvs. at når systemadministratoren (root) genstarter systemet ved at
bruge kommandoen <command>reboot</command> (genstart), skiftes der til runlevel
6.
</para>

<para>
Enkeltbrugertilstand er et meget nyttigt runlevel. Hvis det sker, at du
kommer til at konfigurere et eller andet forkert en dag - ja, det vil ske
på et eller andet tidspunkt! - og din pc låser under
opstarten, kan du starte den op i enkeltbrugertilstand og foretage diverse
rettelser.
</para>

<indexterm><primary>/etc/inittab</primary></indexterm>
<indexterm><primary>runlevel</primary></indexterm>
<indexterm><primary>opstart af Linux</primary></indexterm>

<para>
I filen <filename>/etc/inittab</filename> angives, hvilket
runlevel der er det forvalgte runlevel. &Oslash;nsker man f.eks. at 
maskinen starter i runlevel 5 og ikke 3, så skal man ændre linjen
</para>

<programlisting>
id:3:initdefault:
</programlisting>

<para>
til
</para>
<programlisting>
id:5:initdefault:
</programlisting>

<para>
Se også <xref linkend="etcrcdfilen"/> for detaljer om forskelle mellem
de forskellige Linux-distributioner.
</para>

</sect1>

<sect1 id="Nedlukning">
<title>Nedlukning af Linux</title>
<indexterm><primary>Nedlukning</primary></indexterm>
<indexterm><primary>Reboot</primary></indexterm>
<indexterm><primary>Genstart</primary></indexterm>
<indexterm><primary>Ctrl-Alt-Del</primary></indexterm>
<para>
En Linux-maskine er, som du nok allerede har forstået, et meget stort
system med mange muligheder.  Du skal også være meget opmærksom på, at
man (ligesom med en Windows-maskine) ikke bare må slukke for en
Linux-maskine - den skal helst lukkes pænt ned.
</para>

<para>
Som vi viste i <xref linkend="runlevel"/>, er runlevel 0 det samme som
at lukke ned. En generel, men lidt besværlig måde at lukke en Unix-maskine
på, er at skifte til root og skrive <userinput>init 0</userinput>
eller <userinput>telinit 0</userinput>
</para>

<indexterm>
 <primary>su</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>su</secondary>
</indexterm>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>su -</userinput>
Passwd: <userinput>hemlig</userinput>
<prompt>[root@linus /root]# init 0</prompt>
</screen>

<indexterm><primary>Ctrl-Alt-Delete</primary></indexterm>

<para>
En hurtig nedlukning fås ved at trykke
"Ctrl-Alt-Delete", når du er i en tekstkonsol - f.eks. efter du
trykker "Ctrl-Alt-F1".
</para>

<para>
Du skal dog en gang for alle lave en ændring, så "Ctrl-Alt-Delete"
kommer til at medføre at Linux lukkes ned. Ændres intet, genstarter
systemet. For at få maskinen til at stoppe
kaldes <command>/sbin/halt</command>, og du skal så ændre i
<filename>/etc/inittab</filename>
</para>

<programlisting>
# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:/sbin/shutdown -t3 -r now
</programlisting>

<para>
så der kommer til at stå
</para>

<programlisting>
# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:/sbin/shutdown -t3 -h now
</programlisting>

<para>
Du kan selvfølgelig være fræk, så maskinen slet ikke kan stoppes fra
tastaturet med "Ctrl-Alt-Delete", f.eks. kan du
ændre <filename>/etc/inittab</filename> til
</para>

<programlisting>
# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:echo "No reboot for you my friend!\n"
</programlisting>

<para>
Dette er uhyre praktisk, hvis din maskine står et sted, hvor der er
mange pilfingre, f.eks. EDB-lokalet på en skole!
</para>
</sect1>


<sect1 id="crontab">
<title>Crontab</title>

<indexterm><primary>Cron</primary><secondary>crontab</secondary></indexterm>

<para>
Crontab er et smart system til automatisk at køre programmer på givne
tidspunkter, såsom daglig backup. Det er en standarddel af et
Unix-system og er derfor altid med i Linux.  Man kan få kørt
vilkårlige programmer på vilkårlige tidspunkter, f.eks. hvert minut,
hver time, hver dag, ugedag eller månedsdag.
</para>

<para>
Crontab-filerne omfatter <filename>/etc/crontab</filename>,
<filename>/etc/cron.daily</filename>, <filename>/etc/cron.hourly</filename>,
<filename>/etc/cron.monthly</filename> og
<filename>/etc/cron.weekly</filename>, samt cron-filer
til systemets brugere i <filename>/var/spool/cron/tabs</filename>.
</para>

<para>
Syntaksen for crontab-filerne er den samme: En kommando pr. linje og i
rækkefølge fra venstre mod højre, minut (0-59), time (0-23), månedsdag
(0-31), måned (0-12), ugedag (0-7, hvor 0 og 7 begge er søndag) og
endelig den kommando du vil have udført. Hvert felt adskilles af et
mellemrum, og hvis man vil have, at programmet køres alle dage, så indsæt
en "*" for månedsdag og måned. En kommando kan udføres f.eks. hvert
5. minut med "*/5 * * * *" og til et tids-interval bruges "-"  som "1-5"
for mandag til fredag. Flere tidspunkter adskilles med ",".
</para>

<para>
Ofte udløser en crontab-kommando en email til root. Det kan være uheldigt
med mange emails til root, som blot fortæller, at systemet opfører sig
normalt. Hvis linjen afsluttes med
<literal>&gt;/dev/null 2&gt;&amp;1</literal> sendes meddelelsen
i stedet ud i intetheden.
</para>

<para>
Vi giver nu et eksempel, hvor vi hver morgen kl. 7 fra mandag til fredag sender
brugeren "root" et brev med oplysninger om hvor meget belastning der er
på maskinen.
</para>

<programlisting>
0 7 * * 1-5 uptime | mail root
</programlisting>

<para>
Brug <command>man -a crontab</command> til at læse mere om
crontab. Skift til næste man-fil ved at trykke 'q'. Kommandoen
<command>man 1 crontab</command> fortæller om administration af
crontab-filer og <command>man 5 crontab</command> om indholdet i
crontab-filerne.
</para>

<sect2 id="etc-crontab">
<title>/etc/crontab</title>
<para>
Systemadministrator kan skrive kommandoer direkte i filen
<filename>/etc/crontab</filename>.  For at opretholde adskillelsen
imellem systemet og brugerne, bruger administrator normalt også en fil
i <filename>/var/spool/cron/tabs</filename>.
</para>

<para>
I /etc/crontab er defineret, hvordan der køres jobs hver time fra
<filename>/etc/cron.hourly</filename> til tilsvarende hver dag, uge og måned via
<filename>/etc/cron.daily</filename>,
<filename>/etc/cron.monthly</filename> og <filename>/etc/cron.weekly</filename>.
</para>

<para>
Skriver administrator kommandoer direkte i
<filename>/etc/crontab</filename>, skal brugernavnet, som kommandoen
skal udføres under, angives efter de 5 tidspunkts-kolonner og før
selve kommandoen.
</para>
</sect2>

<sect2 id="de-andre-crontab-filer">
<title>/etc/cron.daily, hourly, monthly, weekly</title>

<para>
I de 4 biblioteker under <filename>/etc</filename> kan
systemadministrator placere scripts, som skal udføres på givne
tidspunkter. Afviklingstidspunktet styres i
<filename>/etc/crontab</filename>, så selve scriptet skal ikke
indeholde oplysninger om tidspunkt, og da der er en fil til hver
opgave, må scriptet brede sig over flere linjer.
</para>
</sect2>

<sect2 id="bruger-crontab">
<title>Brugernes crontab-filer</title>
<para>
Den almindelige bruger har ikke adgang til
<filename>/etc/crontab</filename>.  Kommandoer, de vil have kørt på et
givet tidspunkt, lægges i filer med brugerens navn i
<filename>/var/spool/cron/tabs</filename>. Ofte bruger
systemadministrator også denne fil.
</para>

<para>
Med <command>crontab -e</command> kan brugeren skrive direkte i filen,
men bl.a. for at kunne bruge sin normale editor i stedet for at være
tvunget til at bruge <command>vi</command>, er det normalt at skrive
en kladde i en almindelig tekst-fil (oftest med navnet
<filename>.crontab</filename> i sit hjemmekatalog), og køre kommandoen
<command>crontab ~/.crontab</command>.
</para>

<para>
I stedet for de 5 tidsangivelser kan linjen starte med '@reboot',
hvorefter den udføres når systemet genstartes. Denne mulighed virker
ikke for kommandoer, som er skrevet direkte i
<filename>/etc/crontab</filename>.
</para>

</sect2>

<sect2 id="at">
<title>Kør ikke-gentagne jobs med at</title>
<para>
Som det er forklaret i de forrige afsnit så vil
<command>crontab</command> primært anvendes til at køre automatiske
scripts eller egentlige programmer på fastlagte tidspunkter gentaget
hver time, dag, uge eller måned.
</para>

<indexterm><primary>at</primary></indexterm>
<indexterm><primary>Køre jobs på givet tidspunkt</primary><secondary>at</secondary></indexterm>
<indexterm><primary>free</primary></indexterm>
<indexterm><primary>Fri hukommelse</primary><secondary>mængde af</secondary></indexterm>
<indexterm><primary>Hukommelse</primary><secondary>mængde af</secondary></indexterm>
<indexterm><primary>RAM</primary><secondary>forbrug af</secondary></indexterm>

<para>
Nogle gange har man desuden brug for at køre programmer en enkelt
gang, men man har måske ikke mulighed for selv at starte programmet på
det tidspunkt man ønsker. Det kunne være at man lige ville starte en
ekstra backup midt i den kommende nat.  Linux-maskinen har ligesom
andre UNIX-maskiner mulighed for at køre programmer når man selv
ønsker dette. Vil man køre en kompleks serie af kommandoer bør man
skrive kommandoerne ind i en fil, men ellers er den almindelige måde
at indskrive kommandoerne interaktivt. Hvis vi gerne vil vide hvem som
er logget ind på maskinen kl. 03:00 og hvor meget hukommelse der er
brugt på maskinen på det tidspunkt, dvs. man vil gerne køre
<command>who &gt; ~/login_info.txt</command> kl. 3 om natten og næste
morgen kan man lige gennemse filen <filename>~/login_info.txt</filename>.
Derudover vil man gerne lige køre <command>free</command>, der viser 
hvor meget af den fysiske hukommelse samt swap-filen der er brugt.
Dette gøres ved at køre kommandoen <command>free</command>. 
</para>

<para>
Kommandoerne indskrives efter at man skriver <command>at</command> og
tidspunktet. Antallet af kommandoer, som indskrives på de
efterfølgende linjer en for en, er ikke begrænset. Kommandoerne
afsluttes med <command>Ctrl-d</command> på en linje for sig.
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>at 3:00</userinput>
<prompt>at></prompt> <userinput>who &gt; ~/login_info.txt</userinput>
<prompt>at></prompt> <userinput>free &gt;&gt; ~/login_info.txt</userinput>
<prompt>at></prompt> <userinput>Ctrl-d</userinput>
</screen>

<para>
Næste morgen vil filen <command>~/login_info.txt</command> indeholde følgende:
</para>

<screen>
 3:00am  up 23:03,  8 users,  load average: 0.00, 0.04, 0.08
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU  WHAT
pto      :0       console          Sat 2pm   ?     0.00s   ?     -
pto      pts/0    -                Sat 2pm 14:03m  0.00s   ?     -
pto      pts/2    -                 2:17pm  2:57m  3.45s  0.56s  /bin/bash
pto      pts/3    -                 1:21pm  8:18m  0.10s  0.10s  /bin/bash
pto      pts/4    -                 2:26pm  8:06m  0.52s  0.07s  bash
pto      pts/5    -                10:36pm  1.00s  0.27s  0.27s  /bin/bash
pto      pts/6    -                10:37pm  2:07   1.61s  1.51s  pine
             total       used       free     shared    buffers     cached
Mem:        190896     185820       5076          0      37244      76432
-/+ buffers/cache:      72144     118752
Swap:       329324      19936     309388
</screen>

<para>
De sidste fire linjer kommer fra <command>free</command> og de første
kommer fra <command>who</command>. Eksemplet illustrerer at det er nemt at
anvende <command>at</command>, og det skal nævnes at hvis kommandoerne der
udføres bringer tekst til stdout (standard output - dvs. tekst til skærm), så
vil dette blive sendt som epost til brugeren.
</para>

<para>Dette kan udnyttes sammen med en af de andre gode ting ved
at. Hvis man gerne vil undgå at glemme den kaffe man lige har sat over,
kan man få <command>at</command> til at sende sig en besked om 10
minutter med:
<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>at now+10min</userinput>
<prompt>at></prompt> <userinput>echo Kaffen er klar.</userinput>
</screen>
Man kan selvfølgelig også finde på mere seriøse anvendelser.
</para>

<indexterm><primary>atq</primary></indexterm>
<indexterm><primary>atrm</primary></indexterm>
<indexterm><primary>batch</primary></indexterm>

<para>
Har man brug for at se hvilke kommandoer man har i
<command>at</command>-køen kan <command>atq</command> anvendes. Vil
man slette jobs, da gøres dette med <command>atrm</command>.  Endelig
kan det nævnes at Linux-maskiner også har en
<command>batch</command>-funktion, der fungerer som
<command>at</command>, men er designet til at køre jobs, når der er
ledig CPU-plads på maskinen. Det er efterhånden de færreste som
anvender dette.
</para>

</sect2>
</sect1>





<sect1 id="sikkopi">
<!-- Skrevet af Claus Sørensen "cs@klid.dk" -->

<title>Sikkerhedskopiering</title>
<indexterm>
 <primary>Sikkerheds-kopiering</primary>
</indexterm>
<indexterm>
 <primary>Backup</primary>
</indexterm>

<para>
En vigtig del af systemadministration er sikkerhedskopiering,
så man i tilfælde af nedbrud, harddiskcrash, brand
eller andre uheld kan fortsætte uden større tab af data.
</para>

<para>
Sikring af ens data kan ske på flere måder, hvilket selvfølgelig er
afhængigt af den grad af sikkerhed man ønsker, samt mængden af data,
som skal sikres.
</para>

<sect2 id="sikkopi-metoder">
<title>Metoder for sikkerhedskopiering</title>
<para>
Grundlæggende kan man dele sikkerhedskopiering op i lokal- 
og fjernkopiering, hvilket bestemmes af det omfang af 
sikring som ønskes samt de tekniske muligheder som 
forelægger eller investering i samme.
</para>

<sect3 id="sikkopi-lokal">
<title>Lokal sikkerhedskopiering</title>

<para>
Lokal sikkerhedskopiering sker ved at man
gemmer kopier af sine data på samme sted, som dataene
er på. Her benyttes oftest disketter, bånd, brændbare 
cd'er eller udskiftelige harddiske som lagringsmedier.
</para>
</sect3>

<sect3 id="sikkopi-fjern">
<title>Sikkerhedskopiering via internettet</title>

<para>
Fjernkopiering sker ved, at man aftaler med andre, 
at de krypteret spejler ens data samtidig med, at man 
gør det samme med deres. Det kræver selvfølgelig en 
tro på dem, som man udveksler data med, selvom dataene 
er krypterede.
</para>

<para>
Fjernkopiering er blevet mere aktuel efter at 
højhastighedsforbindelser (ADSL mv.) er kommet ned i et 
prisleje, hvor også private og mindre virksomheder kan 
være med.
</para>

<para>
Man nøjes med at kopiere de forskelle, som er sket siden 
sidst, så man belaster forbindelsen mindst muligt. Hvis 
man ikke stoler blindt på den, som giver plads til ens 
sikkerhedskopi, kan man altid kryptere dataene med 
GnuPG eller lignende krypteringsværktøjer.
</para>
</sect3>

<sect3 id="sikkopi-hvad">
<title>Hvad skal kopieres?</title>
<indexterm>
 <primary>Servere</primary>
 <secondary>Opsætningsfiler, sikkerhedskopiering</secondary>
</indexterm>

<para>
Generelt skal man gemme de data, som man ikke kan 
undvære, og som er umulige at fremskaffe på anden vis f.eks. 
via installation.
</para>

<para>
Dette kan være en af baggrundene for at dele et Linux-system op i
flere partitioner, da visse værktøjer netop sikkerhedskopierer efter
partitioner. De vigtigste kataloger er <filename>/home</filename>
(brugerdata), <filename>/var</filename> (serverdata) og
<filename>/etc</filename> (opsætningsdata), som således også bør
have deres egne partitioner.
</para>

</sect3>



</sect2>

<sect2 id="sikkopiprog">
<title>Værktøjer til sikkerhedskopiering</title>
<indexterm>
 <primary>Sikkerheds-kopiering</primary>
 <secondary>Værktøjer</secondary>
</indexterm>

<para>
Valget af værktøj til sikkerhedskopiering er afhængigt 
af en lang række faktorer så som lagringsmedie, 
type af adgang til systemet, graden af automation 
og omfanget af data.
</para>

<para>
I de næste afsnit vil forskellige værktøjer kort blive 
gennemgået, hvor deres fordele og ulemper vil blive 
belyst. Listen er på ingen måde udtømmende, men kan 
benyttes som et meget hurtigt overblik over de muligheder, 
som findes til sikkerhedskopiering i et Linux-miljø.
</para>

<sect3 id="sikkopi-tar">
<title>Sikkerhedskopiering med tar</title>
<indexterm>
 <primary>Servere</primary>
 <secondary>Sikkerhedskopiering</secondary>
</indexterm>
<indexterm>
 <primary>tar</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>tar</secondary>
</indexterm>
<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>tar</secondary>
</indexterm>
<para>
Den mest benyttede kommando til sikkerhedskopiering er 
<command>tar</command>, som er en forkortelse for Tape 
ARchive. <command>tar</command> samler blot filer og 
deres data sammen i en enkelt fil, som så kan gemmes 
på et medie til sikkerhedskopiering f.eks. et bånd.
</para>

<para>
Hvis du vil tage en sikkerhedskopi på disketter af 
alle filerne i kataloget <filename>/home</filename> 
gøres det således:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>tar -cMf /dev/fd0H1440 /home</userinput>
</screen>

<para>Hvor <command>-cMf</command> står for henholdsvis 
oprette (<command>c</command>reate), 
på flere medier (<command>m</command>ultiple) 
og viser hvilke filer (<command>f</command>iles), som
indgår i sikkerhedskopieringen.
</para>

<para> 
Når der ikke er mere plads på den første diskette, 
spørger programmet automatisk efter den næste.
</para>

<para>Hver gang man har foretaget en sikkerhedskopiering, 
skal man huske at kontrollere den, så man er sikker på, 
at man kan genskabe dataene fra sikkerhedskopien. Det 
gøres således:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>tar -compare -verbose -f /dev/fd0H1440</userinput>
/home
/home/alle
/home/alle/annoncetekst.txt
....
</screen>

<para>
I stedet for de lange tilvalg kan benyttes de kortere
udgaver, hvilket kan ses af man-siden for 
<command>tar</command>.
</para>

<para>Skal man genskabe dataene igen, så er det ligetil:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>tar -extract -same-permissions -verbose -file /dev/fd0H1440</userinput>
/home
/home/alle
/home/alle/annoncetekst.txt
....
</screen>


<para>
Se mere ved hjælp af man-siden 
(<command>man tar</command>) eller i afsnittet om 
sikkerhedskopiering i 
"The Linux System Administrators' Guide":
<ulink url="http://www.tldp.org/LDP/sag/html/">http://www.tldp.org/LDP/sag/html/</ulink>. 
</para>

</sect3>

<sect3 id="sikkopi-dump">
<title>Sikkerhedskopiering med dump og restore</title>
<indexterm>
 <primary>dump</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>dump</secondary>
</indexterm>
<indexterm>
 <primary>restore</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>restore</secondary>
</indexterm>
<indexterm>
<primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>dump</secondary>
</indexterm>
<indexterm>
<primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>restore</secondary>
</indexterm>

<para>
Hvis man benytter Linux-filsystemet ext2, kan man 
benytte kommandoen <command>dump</command> til at 
gemme sikkerhedskopier helt eller delvist af hele 
filsystemet. De genskabes igen med kommandoen 
<command>restore</command>.
</para>

<para>
Som standard gemmer den kun de forskelle, som er 
opstået siden sidste sikkerhedskopiering, men den kan sættes 
til at tage en kopiering af det hele. 
</para>

<para>
Første gang man gemmer (samt med betryggende 
mellemrum) tages en sikkerhedskopi af alle filerne i 
en partition. Lad os sige at <filename>/home</filename> 
ligger på partition <filename>/dev/hda6</filename>. Så 
ser det sådan ud:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>dump -u0 -f /dev/st0 /home</userinput>
</screen>

<para>
Genskabelsen af data sker ved, at man først genskaber 
filsystemet på den partition, som skal genskabes:
</para>

<indexterm>
 <primary>mke2fs</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mke2fs</secondary>
</indexterm>

<indexterm>
 <primary>cd</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>cd</secondary>
</indexterm>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>mke2fs /dev/hda6</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>mount /dev/hda6 /mnt</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>cd /mnt</userinput>
</screen>

<para>
Så den bliver klar til at genskabe de data, som 
ligger i sikkerhedskopien:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>restore rf /dev/st0</userinput>
</screen>

<para>
Efter genskabelsen skal <filename>/home</filename> 
monteres igen:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>mount /mnt/home</userinput>
</screen>


<para>
Se mere om <command>dump</command> og 
<command>restore</command> ved at bruge deres 
man-sider.
</para>
</sect3>

<sect3 id="sikkopi-afio">
<title>Sikkerhedskopiering med afio</title>
<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>afio</secondary>
</indexterm>

<para>
Hvis man gerne vil have adgang til filerne individuelt 
efter sikkerhedskopieringen, kan man benytte værktøjet 
<command>afio</command>, som blandt andet bliver 
benyttet af KBackup.
</para>

<para>
Læs mere med <command>man afio</command>.
</para>

</sect3>

<sect3 id="sikkopi-kbackup">
<title>Sikkerhedskopiering med KBackup</title>
<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>KBackup</secondary>
</indexterm>

<para>
KBackup en alsidig applikation til håndtering af 
sikkerhedskopiering bygget oven på andre 
værktøjer blandt andet <command>tar</command> og 
<command>afio</command>.
</para>

<para>
Den menubaserede grænseflade er meget intuitiv 
at bruge, så man nemt får sat en god rutine op 
for sikkerhedskopiering af de data, man selv 
ønsker.
</para>

<para>
Flere informationer kan findes på KBackups 
hjemmeside: <ulink url="http://kbackup.sourceforge.net">http://kbackup.sourceforge.net</ulink>
</para>

</sect3>

<sect3 id="sikkopi-arkeia">
<title>Sikkerhedskopiering med Arkeia</title>

<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>Arkeia</secondary>
</indexterm>

<para>
Arkeia er et meget professionelt grafisk værktøj 
til håndtering af sikkerhedskopiering. Det er 
desværre closed sourced, men gratis (også for 
virksomheder) at bruge til en server og to klienter.
</para>

<para>
Hent vejledningen og programmet fra deres 
hjemmeside:
<ulink url="http://www.arkeia.com/">http://www.arkeia.com/</ulink>
og installér det.
</para>
</sect3>

<sect3 id="sikkopi-windows">
<title>Microsoft Windows-værktøjer via Samba</title>

<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>Til Microsoft Windows</secondary>
</indexterm>

<para>
Ligger ens data på en Samba-server, kan man i de fleste 
tilfælde bruge de Microsoft Windows-værktøjer, som 
følger med båndstation eller anden hardware til 
sikkerhedskopiering. Man skal så blot huske at oprette 
en sti til lagringsmediet i opsætningsfilen til 
Samba (<filename>/etc/smb.conf</filename>).
</para>
</sect3>
</sect2>
</sect1>

<sect1 id="DPMS">
<title>DPMS - aktiv strømstyring</title>
<indexterm><primary>DPMS</primary></indexterm>
<indexterm><primary>Advanced Power Management BIOS support</primary></indexterm>
<indexterm><primary>Strømstyring</primary></indexterm>
<indexterm><primary>Skærm</primary><secondary>automatisk sluk</secondary></indexterm>
<indexterm><primary>Sluk for skærm</primary><secondary>automatisk</secondary></indexterm>

<para>
Dette afsnit handler om hvordan man kan få maskinen til at kunne slukke
skærmen automatisk og
generelt prøve at spare strøm.  For at få strømstyring til at virke
under X skal man tilføje  <literal>Option "DPMS"</literal>
til filen <filename>/etc/X11/XF86Config-4</filename>
</para> 

<programlisting>
Section "Monitor"
        Identifier   "Monitor0"
        VendorName   "Monitor Vendor"
        ModelName    "Monitor Model"
        HorizSync   30.0-64.0
        VertRefresh 50.0-110.0
        Option "DPMS"
...
</programlisting>

<para> 
I brugerens <filename>.tcshrc</filename>/<filename>.bashrc</filename>
eller <filename>/etc/bashrc</filename> tilføjes <literal>xset dpms 120
200 0</literal>.  Dermed får man skærmen til at blanke efter 120
sekunder (standby) og slukke (suspend) efter 200 - det sidste nul
skulle få maskinen til ikke at slukke.  
</para>

<para>
Du skal også have oversat din kerne, så den understøtter "Power Management".
</para>


<programlisting>
[*] Power Management support
[ ]   ACPI support
<*>   Advanced Power Management BIOS support
[ ]     Ignore USER SUSPEND
[*]     Enable PM at boot time
[ ]     Make CPU Idle calls when idle
[*]     Enable console blanking using APM
[*]     RTC stores time in GMT
[ ]     Allow interrupts during APM BIOS calls
[*]     Use real mode APM BIOS call to power off
</programlisting>

<para>
Her kan der være forskelle alt efter maskintype.
</para>

</sect1>


<!-- Skrevet af Anna Jonna Armannsdottir "aj@aka.dk.eu.org" og Peter Toft -->
<sect1 id="cpu-temperatur">
<title>Måling af CPU-temperatur</title>

<indexterm><primary>Måling af CPU-temperatur</primary></indexterm>
<indexterm>
 <primary>CPU-temperatur</primary>
 <secondary>Måling af</secondary>
</indexterm>
<indexterm><primary>lm_sensors</primary></indexterm>
<indexterm><primary>LM87</primary></indexterm>
<indexterm><primary>sensors</primary></indexterm>

<para>
Med Pentium II, III, AMD K6 II og lignende nyere processorer kan man direkte
måle temperatur på CPU'en samt holde styr på blæseren på CPU'en.
Det er noget som CPU'en skal have indbygget at det virker via en I2C
kanal.
</para>

<para>
Det første der skal gøres er at installere <filename>lm_sensors</filename>.
På Red Hat 7.2 gøres dette med <command>rpm -ivh lm_sensors*.rpm</command>
hvis man står i cd-rom'ens RPMS-katalog.
</para>

<para>
Dernæst skal man detektere maskinen ved at køre 
<command>/usr/sbin/sensors-detect</command>. 
Programmet er selvforklarende. Det første der gøres er at indlæse
de kerne-moduler der skal til at lave målingers f.eks. 
<filename>i2c-piix4</filename>. Programmet prøver at gætte dette
selv og man skal oftest bare trykke return et par gange.
</para>

<programlisting>
...
 I will now generate the commands needed to load the I2C modules.
 Sometimes, a chip is available both through the ISA bus and an I2C bus.
 ISA bus access is faster, but you need to load an additional driver module
 for it. If you have the choice, do you want to use the ISA bus or the
 I2C/SMBus (ISA/smbus)?

WARNING! If you have some things built into your kernel, the
below list will contain too many modules. Skip the appropriate ones!
To load everything that is needed, add this to some /etc/rc* file:

#----cut here----
# I2C adapter drivers
modprobe i2c-matroxfb
modprobe i2c-isa
# I2C chip drivers
modprobe eeprom
modprobe w83781d
#----cut here----

To make the sensors modules behave correctly, add these lines to either
/etc/modules.conf or /etc/conf.modules:

#----cut here----
# I2C module options
alias char-major-89 i2c-dev
#----cut here----
</programlisting>

<para>
Som det ses skal giver <command>sensors-detect</command>
et par linjer som skal indsættes i f.eks. <filename>/etc/rc.local</filename> (SuSE <filename>/etc/rc.d/boot.local</filename>) og
tilsvarende til
<filename>/etc/modules.conf</filename>
</para>

<para>
Når maskinen har været genstartet kan man med kommandoen 
<command>sensors</command> detektere temperatur osv. Dette kan se således ud.
</para>

<programlisting>
w83781d-i2c-0-2d
Adapter: SMBus PIIX4 adapter at 5000
Algorithm: Non-I2C SMBus adapter
VCore 1:   +1.98 V  (min =  +1.80 V, max =  +2.20 V)
VCore 2:   +1.47 V  (min =  +1.80 V, max =  +2.20 V)       ALARM
+3.3V:     +3.42 V  (min =  +2.97 V, max =  +3.63 V)
+5V:       +4.97 V  (min =  +4.50 V, max =  +5.48 V)
+12V:     +11.70 V  (min = +10.79 V, max = +13.11 V)
-12V:     -11.40 V  (min = -10.78 V, max = -13.18 V)
-5V:       -4.94 V  (min =  -4.50 V, max =  -5.48 V)
fan1:     4066 RPM  (min = 3000 RPM, div = 2)
fan2:        0 RPM  (min = 3000 RPM, div = 2)              ALARM
fan3:        0 RPM  (min = 3000 RPM, div = 2)              ALARM
temp1:    +31.0°C   (limit = +60°C, hysteresis = +50°C)
temp2:    +208.0°C   (limit = +60°C, hysteresis = +50°C)
temp3:    +25.0°C   (limit = +60°C, hysteresis = +50°C)
vid:      +2.00 V
alarms:   Chassis intrusion detection
beep_enable:
          Sound alarm disabled
</programlisting>

<para>
Man kan således se at CPU-blæseren kører 4066 omdrejninger per
minut og der er tre CPU-temperaturer. 
Desuden er der 3 falske alarmer. Derfor skal der foretages justeringer
i filen <filename>/etc/sensors.conf</filename> i sektionen om den chip
som blev fundet tidligere. Chippen w83781d deler data med flere andre 
chips. 
</para>

<programlisting>
chip "lm78-*" "lm78-j-*" "lm79-*" "w83781d-*"

    label in0 "VCore 1"
    label in1 "VCore 2"
    label in2 "+3.3V"
    label in3 "+5V"
    label in4 "+12V"
    label in5 "-12V"
    label in6 "-5V"

    set in0_min 2.8*0.95
    set in0_max 2.8*1.05
    set in1_min 2.8*0.95
    set in1_max 2.8*1.05
    set in2_min 3.3 * 0.95
    set in2_max 3.3 * 1.10
    set in3_min 5.0 * 0.95
    set in3_max 5.0 * 1.05
    set in4_min 12 * 0.95
    set in4_max 12 * 1.05
    set in5_min -12 * 0.93
    set in5_max -12 * 1.07
    set in6_min -5 * 0.95
    set in6_max -5 * 1.05

    ignore in1
    set fan2_min 0
    set fan3_min 0
</programlisting>

<para>
Hver af chippens interne måle-punkter (f.eks. in0) tildeles et 
navn som f.eks."VCore 1". Hvert måle-punkt skal holde sig indenfor et 
vist område, der som regel sættes til at være nominalværdien 
plus/minus 5%. Tolerancerne kan selvfølgelig tilpasses maskinen. 
Især måle-punkterne in0 og in1 bør konfigureres og tilpasses processoren. 
Man kan genstarte maskinen og kigge i dens BIOS og kigge især efter om
der måles "VCore". Hvis der kun måles en værdi, kan sensors 
indstilles som ovenfor, til at ignorere måle-punktet in1. 
</para>

<para>
Ændringer i filen <filename>/etc/sensors.conf</filename> må indlæses i
modulerne, ved at køre følgende som root
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>sensors -s</userinput>
</screen>

<para>
Resultatet kan straks undersøges med kommandoen 
<command>sensors w83781d-i2c-0-2d</command> eller bare med kommandoen 
<command>sensors</command> hvis man ønsker resultater fra alle konfigurerede 
chips.
</para>

<para>
Der er en masse forklarende kommentar i filen <filename>/etc/sensors.conf</filename>, 
så når man har bestemt hvilke chips (der kan nemlig være flere) 
der er i ens maskine, kan man fordybe sig i hvordan den skal konfigureres. 
</para>



<sect2 id="fejlfind-maskinel-overvaagning">
<title>Fejlfinding</title>
<indexterm><primary>i2c</primary></indexterm>

<para>
Overvågning af computerens maskinel, skal bruge 
passende moduler til maskinen samt i2c bus understøttelse. 
</para>

<para>
Når sensors modulerne er installeret i kernen, dannes filerne: 
<filename>/proc/sys/dev/sensors/*</filename> 
<filename>/proc/bus/i2c*</filename> . 
Hvis disse filer ikke er at finde, er sensors modulerne ikke 
installeret i kernen. 
</para>

<para>
Hvis i2c bus modulerne eller hardware modulerne findes på computeren kan de findes med kommandoerne
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>ls -l /lib/modules/`uname -r`/kernel/drivers/i2c/ </userinput>
<prompt>[root@linus /root]#</prompt> <userinput>ls -l /lib/modules/`uname -r`/kernel/drivers/sensors/ </userinput>
</screen>

<para>
Ovennævnte placering gælder for en specialbygget kerne i Debian 
unstable, men kan formodes at gælde for alle 2.4 kerner. 
</para>

<para>
Hvis maskinovervågningen giver forkerte oplysninger, kan der være flere årsager:
</para>

<itemizedlist mark="bullet">

<listitem> 
<para>
Opsætnings-programmet <command>sensors-detect</command> er ikke perfekt 
og det kan installere forkerte moduler. Det kan medføre udlæsning af 
forkerte oplysninger om maskinens tilstand. Der er eksempler på udlæsninger 
af for høj eller for lav CPU temperatur, blot fordi der var blevet 
installeret et modul der ikke passede til maskinen. 
</para>
</listitem>

<listitem>
 <para>
Nogle bundkort er sådan indrettet, at modulerne skal konfigureres med 
særlige parametre for at fungere korrekt. Opsætnings-programmet 
<command>sensors-detect</command> kan finde de fleste af disse parametre men 
ikke alle. I dette tilfælde kan man forsøge, at finde de korrekte parametre 
og derpå kan man indsende en fejl-rapport med de parametre man har fundet. 
Medfølgende med lm-sensors, er dokumentation om hvordan disse parametre 
bør være. Samme dokumentation findes på webadressen: 
<ulink url="http://www2.lm-sensors.nu/~lm78/docs.html">http://www2.lm-sensors.nu/~lm78/docs.html</ulink>
 </para>
</listitem>

<listitem>
 <para>
Der er fejl i selve modulets kilde-tekst. Hak den og indsend en fejl-rapport og 
en eventuel rettelse. 
 </para>
</listitem>
</itemizedlist>

</sect2>


<sect2 id="fejlrapport-maskinel-overvaagning">
<title>Indsamling af oplysninger til fejlrapport</title>
<indexterm><primary>isadump</primary></indexterm>
<indexterm><primary>i2cdump</primary></indexterm>
<indexterm><primary>lspci</primary></indexterm>
<indexterm>
 <primary>dump</primary>
 <secondary>i2c</secondary>
</indexterm>
<indexterm>
 <primary>i2c</primary>
 <secondary>dump</secondary>
</indexterm>

<para>
Hvis opsætnings-programmet danner en fejlagtig opsætning kan man 
overveje at indsende en fejl-rapport direkte til udviklings-holdet for 
lm-sensors på web adressen: 
<ulink url="http://www2.lm-sensors.nu/~lm78/">http://www2.lm-sensors.nu/~lm78/</ulink> 
Fejl-rapporten kan indeholde oplysninger om PCI bussen og en dump
udskrift af i2c bussen.  Der kan også laven en dump udskrift af ISA
bussen men der advares kraftigt imod at gøre det, idet områder i
hukommelsen kan blive overskrevet, som kan indeholde oplysninger der
er vitale for maskinens stabilitet. Hvis man absolut skal dumpe ISA
bussen, bør man genstarte maskinen i enkeltbrugertilstand fra diskette
eller cd-rom. På den måde er der mindst risiko for at miste oplysninger
eller endda et helt filsystem.
</para>

<para>
Oplysninger om PCI-bussen i en maskine med et Asus bundkort med Intel
TX chipsæt og Realtek 8139 netkort, kan se således ud:
</para>

<screen>
<prompt>[tyge@hven /]$</prompt> <userinput>/bin/lspci -n </userinput>
00:00.0 Class 0600: 8086:7100 (rev 01)
00:01.0 Class 0601: 8086:7110 (rev 01)
00:01.1 Class 0101: 8086:7111 (rev 01)
00:01.2 Class 0c03: 8086:7112 (rev 01)
00:01.3 Class 0680: 8086:7113 (rev 01)
00:09.0 Class 0200: 10ec:8139 (rev 10)
00:0c.0 Class 0100: 9004:5078 (rev 03)
</screen>

<indexterm>
 <primary>i2c</primary>
 <secondary>dev</secondary>
</indexterm>

<para>
Modulet i2c-dev skal være installeret før man kan dumpe i2c bussen. 
En dump udskrift af i2c bussen kan se således ud: 
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/usr/sbin/i2cdump 0 0x18</userinput>
Warning: no size specified (using byte-data access)
  WARNING! This program can confuse your I2C bus, cause data loss and worse!
  I will probe file /dev/i2c-0, address 0x18, mode byte
  You have five seconds to reconsider and press CTRL-C!

     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00: 20 00 04 3c 20 00 04 3c 20 00 04 3c 20 00 04 3c 
10: 20 00 04 3c 20 00 04 3c 20 00 04 3c 20 00 04 3c 
... 
</screen>

<para>
Parametrene til i2cdump kan man få ved at kigge på filnavnene i mappen 
<filename>/proc/sys/dev/sensors/</filename> hvor der tilfældigvis findes mappen
<filename>max1617-i2c-0-18</filename>. 
</para>

<para>
Desuden bør man medtage alle øvrige oplysninger der kan være af nytte ved opklaringen 
af problemet. 
</para>

</sect2>
</sect1>


<sect1 id="logfiler">
<title>Log-filer</title>
<indexterm><primary>logfiler</primary></indexterm>
<indexterm><primary>syslog</primary></indexterm>

<para>
En Linux-installation indeholder forskellige logfiler der registrerer
forskellige ting der sker med systemet. Den vigtigste logfil er
<filename>/var/log/messages</filename> der sammen med andre fortæller
systemets tilstand.
</para>

<sect2 id="varlogmessages">
<title>/var/log/messages</title>
<indexterm><primary>/var/log/messages</primary></indexterm>
<indexterm><primary>logfiler</primary><secondary>/var/log/messages</secondary></indexterm>
<indexterm><primary>syslog</primary></indexterm>

<para>
Tekstfilen <filename>/var/log/messages</filename> indeholder beskeder
fra kernen og andre programmer der rapporterer til syslogd.
Herunder er vist noget af det man kan se i logfilen:
</para>

<programlisting>
Jun 25 10:45:18 figus syslogd 1.4.1: restart (remote reception).
Jun 25 10:45:22 figus sshd: sshd startup succeeded
Jun 25 11:01:35 figus ntpdate[4053]: step time server 129.240.64.3 offset 26.235235 sec
Jun 25 14:05:42 figus su(pam_unix)[4454]: session opened for user root by (uid=506)
Jun 25 14:08:45 figus sshd[4521]: Failed password for root from 192.168.1.2 port 1050 ssh2
</programlisting>

<para>
Logfilen indeholder mange informationer fra mange programmer.
Disse kan være lidt svære at overskue, så det kræver noget træning
at hvad der er som det skal være, og hvad der ikke er.
I ovenstående eksempel er det maskinen med maskinnavnet <literal>figus</literal>
der ses i logfilen. Programmerne syslogd, sshd, ntpdate og su har skrevet i
logfilen.
Kun den sidste linje ser lidt mistænkelig ud, nogen prøvede at logge ind som
root fra IP-nummer 192.168.1.2. Mistænkelig er den dog ikke, for ham der
prøvede at logge ind havde ret til det, han havde bare glemt at root ikke kunne
logge ind direkte, men skal først logge ind som en almindelig bruger.
Så det kræver lidt træning at overskue denne logfil.
</para>

<para>
De typiske værktøjer man bruger til at se var på
<filename>/var/log/messages</filename> er: less, tail og grep.
Med <command>less</command> kan man med fordel taste 'G' for at gå
til bunden af filen, og 'F' for at følge hvad der kommer af nye beskeder.
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>less /var/log/messages</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>tail -f /var/log/messages</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>grep restart /var/log/messages | less</userinput>
</screen>

<para>
Se også "Friheden til sikkerhed på internettet" for mere information om
<filename>/var/log/messages</filename>.
</para>

<sect3 id="syslogremote">
<title>syslog remote</title>
<indexterm><primary>syslog</primary><secondary>remote</secondary></indexterm>
<indexterm><primary>/etc/sysconfig/syslog</primary></indexterm>
<indexterm><primary>/etc/syslog.conf</primary></indexterm>
<para>
Der kan være flere fordele ved at logge syslog kommandoer til en anden server.
En kunne være at samlet holde øje med flere servere, en anden kunne være
for at sikre sig at en cracker ikke går ind og sletter
<filename>/var/log/messages</filename> på den maskine der bliver kompromitteret
</para>
<para>
Først går man til den maskine der skal modtage syslog-beskeder fra andre maskiner.
Her ændres syslog til at starte med kommandoen '-r' (remote).
Dette kan enten gøre i <filename>/etc/sysconfig/syslog</filename>, eller
<filename>/etc/init.d/syslog</filename>, afhængigt af hvilken distribution
man kører.
</para>

<programlisting>
# Filnavn: /etc/sysconfig/syslog
SYSLOGD_options="-m 0 -r"
</programlisting>

<para>
På klienter der skal logge til syslog-serveren kan der så rettes
i <filename>/etc/syslog.conf</filename>.
Vil man logge alt fra klienten over til serveren
<filename>minlog.domain.dk</filename> skrives:
</para>

<programlisting>
*.*  @minlog.domain.dk
</programlisting>

<para>
Er det kun mail-log der skal sendes over kan man skrive:
</para>
<programlisting>
mail.*  @minlog.domain.dk
</programlisting>

<para>
Ovenstående ændringer kræver at
<command>/etc/init.d/syslog</command> bliver genstartet.
</para>
</sect3> <!-- id="syslogremote" -->

</sect2> <!-- id="varlogmessages" -->

<sect2 id="dmesg">
<title>dmesg</title>
<indexterm><primary>dmesg</primary></indexterm>
<indexterm><primary>Kerne</primary><secondary>logfil</secondary></indexterm>
<indexterm><primary>logfiler</primary><secondary>kerne</secondary></indexterm>

<para>
<command>dmesg</command> er ikke en logfil, men et program der udskriver
beskeder fra kernens ring-buffer.
Her står al den information kernen skriver under boot, og hvad der efterfølgende
sker af fejl i kernen.
Vil man vide noget om hvilke IDE-harddiske der er i systemet, kan man for eksempel bruge
kommandoen <command>dmesg | grep hd</command> og få et output der minder om:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>dmesg | grep hd</userinput>
ide0: BM-DMA at 0xfcf0-0xfcf7, BIOS settings: hda:pio, hdb:DMA
hda: FUJITSU MHM2200AT, ATA DISK drive
hdb: TOSHIBA DVD-ROM SD-C2502, ATAPI CD/DVD-ROM drive
hda: 39070080 sectors (20004 MB) w/2048KiB Cache, chs=2584/240/63, UDMA(33)
hdb: ATAPI 24X DVD-ROM drive, 128kB Cache, UDMA(33)
<!-- ups, der var vist også et par fejl der ikke behøves komme med /chlor
hdb: packet command error: status=0x51 { DriveReady SeekComplete Error }
hdb: packet command error: error=0x50
--></screen>

</sect2> <!-- id="dmesg" -->

<sect2 id="varlogmail">
<title>/var/log/mail/info</title>
<indexterm><primary>/var/log/mail/info</primary></indexterm>
<indexterm><primary>Postfix</primary><secondary>logfil</secondary></indexterm>
<indexterm><primary>logfiler</primary><secondary>/var/log/mail/info</secondary></indexterm>

<para>
<filename>/var/log/mail/info</filename> er logfilen for ind- og udgående mail.
Her står hvem der har modtaget filer, og hvem der er sendt filer til.
Typisk er det ved fejl at man kigger i denne fil, og i mere sjældne tilfælde
bruges den til at dokumenterer at en mail blevet sendt eller modtaget.
Filen ses typisk med <command>less</command>, <command>tail</command> eller
<command>grep</command>.
I det viste eksempel herunder, er det <command>fetchmail</command> der henter
mail fra en ISP, hvilket man ikke kan se, og afleverer denne mail til localhost.
Afsenderen er &lt;chlor@sslug.dk&gt;, og modtageren er &lt;chlor@localhost.w0.dk&gt;.
</para>

<programlisting>
Jun 26 07:44:44 figus postfix/smtpd[8079]: connect from localhost.localdomain[127.0.0.1]
Jun 26 07:44:44 figus postfix/smtpd[8079]: 09BEC1326AE: client=localhost.localdomain[127.0.0.1]
Jun 26 07:44:44 figus postfix/cleanup[8080]: 09BEC1326AE: message-id=&lt;20020626054426.20973.qmail@sslug.dk&gt;
Jun 26 07:44:44 figus postfix/qmgr[1665]: 09BEC1326AE: from=&lt;chlor@sslug.dk&gt;, size=804, nrcpt=1
  (queue active)Jun 26 07:44:44 figus postfix/local[8082]: 09BEC1326AE: to=&lt;chlor@localhost.w0.dk&gt;,
  relay=local, delay=0, status=sent ("|/usr/bin/procmail -Y -a $DOMAIN")
Jun 26 07:44:47 figus postfix/smtpd[8079]: disconnect from localhost.localdomain[127.0.0.1]
</programlisting>

</sect2> <!-- id="varlogmail" -->

</sect1>

<sect1 id="quota">
<title>Kontrol af diskforbrug med quota</title>

<indexterm>
 <primary>diskforbrug</primary>
</indexterm>
<indexterm>
 <primary>quota</primary>
</indexterm>
<indexterm>
 <primary>Servere</primary>
 <secondary>Kontrol af brugernes diskforbrug</secondary>
</indexterm>
<para>
Hvis man driver en server med mange brugere, sker det fra tid til
anden at en bruger bevidst eller ubevidst kommer til at fylde disken
op med filer. For at et sådant uheld ikke skal kunne påvirke de andre
brugere på systemet, så kan man installere quota. Quota gør det muligt
at sætte en disk forbrugs-grænse for den enkelte bruger eller evt. for
en gruppe. 
</para>

<para>
Systemet er så fleksibelt, at man yderligere kan sætte en ekstra-pulje
op, så brugeren i en fast tidsperiode (kaldet grace-perioden) godt må
"svine" med pladsen bare der ryddes op igen; f.eks. kan man have 10 MB
diskplads, men kan få lov til i en periode på to timer ekstra at bruge
yderligere 5 MB.
</para>

<para>
Både den almindelige kvote og den ekstra diskkvote virker ved at man
pludselig ikke kan gemme filer, når man er oppe på maksimum. Brugeren
må derefter selv slette filer.
</para>

<para>
Derfor er det vigtigt at systemadministratoren forklarer brugeren
hvilke grænser, der er sat og hvad man gør for at følge eget forbrug -
og endelig hvordan man rydder op.
</para>

<para>
Installation: Der skal være quota-understøttelse i Linux-kernen. 
Normalt vil en Linux-distribution have quota understøttet, ellers må 
du oversætte kernen på ny og da svare ja til "Quota Support" under 
"Filesystems" (CONFIG_quota=y).
</para>

<para>
I quota-tools pakken findes de værktøjer der skal være installeret for at du kan 
benytte diskkvoterne. Enten kan du benytte hvad der hører til din distribution, (fx. quota-3.01pre9-3.i386.rpm hos Red Hat 7.2) eller også hente og installere 
pakken <ulink url="http://prdownloads.sourceforge.net/linuxquota/quota-3.03.tar.gz">http://prdownloads.sourceforge.net/linuxquota/quota-3.03.tar.gz</ulink>
</para>

<para>
Quota sættes på de enkelte partitioner,
dvs. <filename>/etc/fstab</filename> skal redigeres, så man i
<literal>options</literal>-feltet tilføjer <literal>usrquota</literal>
til hver partition man ønsker at køre quota på.
</para>

<para>
F.eks. ændres linjen i <filename>/etc/fstab</filename> fra
</para>

<programlisting>
/dev/hda2   /home   ext2    defaults 1 1
</programlisting>
<para>
til
</para>
<programlisting>
/dev/hda2   /home   ext2    defaults,usrquota 1 1
</programlisting>

<para>
Til at starte quota skal der nu indekseres og quota-programmet skal startes. 
Kør følgende som root
</para>

<indexterm>
 <primary>mount</primary>
 <secondary>remount</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt </primary>
 <secondary>mount -o remount</secondary>
</indexterm>

<indexterm>
 <primary>/sbin/quotacheck -a -m </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt </primary>
 <secondary>/sbin/quotacheck -a -m </secondary>
</indexterm>

<indexterm>
 <primary>/sbin/quotaon -uv </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt </primary>
 <secondary>/sbin/quotaon -uv </secondary>
</indexterm>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/bin/mount -v -o remount /home </userinput> <-- for at gen-montere den ændrede partition
<prompt>[root@linus /root]#</prompt> <userinput>/sbin/quotacheck -a -m</userinput> <--- for at lave et index over brugernes forbrug
<prompt>[root@linus /root]#</prompt> <userinput>/sbin/quotaon -uv /home</userinput> <--- start quota
</screen>

<para>I den sidste kommando kan <command>/home</command> skiftes ud med
<command>-a</command>, i så fald gælder kommandoen alle filsystemer.
</para>

<para>
mount køres kun en gang for alle, for at få systemet til at genindlæse <filename>/etc/fstab</filename>.
</para>

<para>
<command>quotacheck</command> køres for at danne et indeks over brugernes diskforbrug.
Indekset gemmes på ældre systemer i <filename>/home/quota.user</filename> og i 
<filename>/home/aquota.user</filename>
på nyere.  
<command>quotacheck</command> skal køres igen hvis man har rettet fejl i 
filsystemet med fsck - typisk under opstart efter strømudfald. Det klares da 
ofte automatisk af ens initscripts ellers kan følgende indsættes, 
inden quotaon kaldes, i <filename>rc.sysinit</filename>:
</para>

<programlisting>
if [ -x /sbin/quotacheck ]; then
  echo "Undersøger kvoter på lokale filsystemer"  /sbin/quotacheck -v -a
fi
</programlisting>

<para>
<command>quotaon</command> skal køres hver gang maskinen startes op,
og kan automatiseres i med et par linjer i <filename>rc.sysinit</filename> 
eller <filename>rc.local</filename> (SuSE <filename>/etc/rc.d/boot.local</filename>):
</para>

<programlisting>
  if [ -x /sbin/quotaon ]; then
    echo "Starter kvotestyring for lokale filsystemer"
    /sbin/quotaon  -a
  fi
</programlisting>

<para>
Nu kan man redigere grænsen for en bruger - hvis man har mange
brugere, så opret en test-bruger "quotauser" og lave følgende som
skabelon og sidenhen kan man kopiere test-brugerens quota-opsætning
til alle andre brugere.
</para>

<para>
Grænser redigeres ved at køre edquota for brugeren. Grænser
for diskforbrug anføres i kbytes, dvs. 10000 betyder 10MB.
Hvis quota ikke sættes op er standard-indstillingen 
at der ingen grænse er (dette anføres som et nul i opsætningsfilen). 
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/usr/sbin/edquota -u quotauser</userinput>
Disk quotas for user tyge (uid 500):
Filesystem      blocks       soft       hard     inodes     soft   hard       
/dev/hda2       695879         0          0       6741        0      0
</screen>

<para>
Vi ser at brugeren tyge med uid 500 på filsystemet /dev/hda2, (hvor
<filename>/home</filename> mountes ifølge
<filename>/etc/fstab</filename>), i øjeblikket benytter 695879
filblokke (679MB) og 6741 filer, samt at der ikke er sat grænser for
hvor meget brugeren må benytte.
</para>

<para>
Ret nu tallene til det brugeren må. Det er vi-editoren som kommer frem, hvis 
du ikke har sat EDITOR variablen.
</para>
<itemizedlist mark="bullet">
<listitem>
 <para>
"soft" betyder grænse, som brugeren normalt forventes at holde sig under. 
Systemet tillader dog at denne grænse overstiges i kortere tid 
("grace"-perioden).
 </para>
</listitem>
<listitem> 
 <para>
"hard" betyder grænse, som brugeren aldrig kan overstige.
 </para>
</listitem>
</itemizedlist>

<para>
Til højre for de første soft/hard står der inodes og igen soft/hard - 
dette er antal filer man kan lave. Dette bruges kun sjældent. Hvis man 
ønsker at brugeren fast kan bruge 10 MB og 5 MB ekstra i grace-perioden,
samt et ubegrænset antal filer, skrives
</para>

<programlisting>
Disk quotas for user tyge (uid 500):
Filesystem      blocks       soft       hard     inodes     soft   hard       
/dev/hda2       695879       10000      15000     6741        0      0
</programlisting>

<indexterm>
 <primary>wq </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>wq </secondary>
</indexterm>

<indexterm>
 <primary>edquota -t </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>edquota -t </secondary>
</indexterm>

<para>
Afslut med at skrive <command>:wq!</command>
</para>

<para>
Hvis man derefter vil sætte "grace"-perioden hvor ekstra diskforbrug
tolereres, så kan dette indstilles ved at skrive
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/usr/sbin/edquota -t</userinput> 
Grace period before enforcing soft limits for users:
Time units may be: days, hours, minutes, or seconds
Filesystem      Block grace period      Inode grace period
/dev/hda2        7 days                    7days
</screen>

<para>
For illustrations skyld kan vi sætte en grace-periode helt ned til 
to timer ved at rette teksten til
</para>

<programlisting>
Grace period before enforcing soft limits for users:
Time units may be: days, hours, minutes, or seconds
Filesystem      Block grace period      Inode grace period
/dev/hda2        2hours                     2hours
</programlisting>

<para>
Afslut med at skrive <command>:wq!</command>
</para>

<para>
Tanken med at tildele en test-bruger "quotauser" er at man relativt 
nemt kan tildele samme quota til alle almindelige brugere ved at køre
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>edquota -p quotauser `awk -F: '$3 &gt; 499 {print $1} /etc/passwd`</userinput> 
</screen>

<para>
Tricket er her at man finder alle almindelige brugere ved
bruger-nummer på 500 eller større.
</para>

<indexterm>
 <primary>repquota -a </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>repquota -a </secondary>
</indexterm>

<indexterm>
 <primary>warnquota </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>warnquota </secondary>
</indexterm>

<para>
Andre interessante kommandoer:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
<command>repquota -a</command> <-- viser status på diskforbrug
 </para>
</listitem>
<listitem> 
 <para>
<command>warnquota</command> <-- bruges til at alarmere brugere som er over kvote
 </para>
</listitem>
</itemizedlist>

<para>
Til warnquota, der sender mail til brugere over kvota,  hører 
opsætningsfilerne /etc/quotatab og /etc/warnquota.conf. Disse benyttes 
især til at gøre meddelelserne til brugerne mere læse venlige. quota-tools
understøtter i øvrigt også GNU gettekst, så der er mulighed for at oversætte
værktøjerne til brugernes eget sprog (make pot && kbabel pot.po).
</para>

<para>
I /proc/sys/fs systemet findes dquot-nr og dquot-max, som viser antallet af 
cachede kvota forekomster, antallet af frie disk kvota forekomster samt øvre
grænse for antallet af disk kvota forekomster.
</para>

<para>
Med quota er det altså muligt at begrænse antallet af filer og deres
samlede størrelse pr. bruger. Systemet kan desuden konfigureres til at 
begrænse antallet af filer og deres samlede størrelse pr. gruppe.
</para>

<para>
Med quotastats kan man få lidt information om hvorledes selve kvota systemet
har det.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>/usr/sbin/quotastats</userinput>
Number of dquot lookups: 101289
Number of dquot drops: 101271
Number of still active inodes with quota : 18
Number of dquot reads: 93
Number of dquot writes: 2077
Number of quotafile syncs: 134518740
Number of dquot cache hits: 7391
Number of allocated dquots: 90
Number of free dquots: 2036
Number of in use dquot entries (user/group): -1946
</screen>

<para>
Flere informationer om quota kan findes på 
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
<ulink url="http://www.linuxdoc.org/HOWTO/mini/Quota.html">http://www.linuxdoc.org/HOWTO/mini/Quota.html</ulink>
 </para>
</listitem>
<listitem> 
 <para>
<ulink url="http://www.gnuskole.dk/bog/quota.html">http://www.gnuskole.dk/bog/quota.html</ulink>
 </para>
</listitem>
<listitem> 
 <para>
<ulink url="http://www.mvw.cistron.nl/quota.html">http://www.mvw.cistron.nl/quota.html</ulink>
 </para>
</listitem>
<listitem> 
 <para>
<ulink url="http://www.sf.net/projects/linuxquota/">http://www.sf.net/projects/linuxquota/</ulink>
 </para>
</listitem>
</itemizedlist>

<para>
Den medfølgende dokumentation er lidt spredt, men kan samles til HTML og
PostScript med følgende liner:
</para>

<programlisting>
for f in $(file *|grep troff|cut -d: -f-1)
do
  man2html $f >doc/$f.html
done
cd doc
sgml2html quotadoc.sgml
groff -Thtml -ms quotas.ms >quotas.html
ln -s quotas-1.eps quotas-1.ps
</programlisting>

</sect1>

<!-- Skrevet af Niels Elgaard Larsen elgaard(paa)diku.dk -->
<sect1 id="stille-maskine">
<title>Hvordan man får sin linuxmaskine til at holde op med at bruge harddisken</title>

<para>Jeg har en gammel bærbar i mit soveværelse. Den bliver brugt som
printserver og gateway til et trådløst (802.11) netværk. Den skal være stille;
især når jeg sover.
</para>


<para>Jeg har også en computer på arbejdet. Den er bl.a. FTP- og
webserver.  Mine kollegaer bryder sig ikke om at den larmer, når jeg
ikke er der.
</para>


<para>
Det er acceptabelt og stort set uundgåeligt at en maskine larmer når man
bruger selv den, for eksempel skriver ud til printeren, retter i dokumenter osv,
men så er man jo også vågen.
</para>

<para>
Målet er at få den til at være stille når den ikke laver noget, eller
kun laver simple ting (rutning, FTP af små filer osv.).
</para>

<para>
Det, man kan gøre noget ved, er larmen fra harddisken.
</para>

<para> Først skal man have sat spin-down tiden på harddisken (eller
harddiskene hvis der er mere end en). På nogle maskiner kan man gøre
det i BIOS'en.
</para>

<para> Fra Linux kan man gøre det med
<command>hdparm</command>-programmet.
Følgende kommando sætter den første IDE-harddisk
(<filename>/dev/hda</filename>) til at lukke ned efter et minut:
</para>

<screen>
<prompt>[root@linus ~]#</prompt> <userinput>hdparm -S 12 /dev/hda</userinput>
</screen>

<para>
For at køre kommandoen hver gang computeren startes, kan man komme den i en
opstartsfil, se <xref linkend="runlevel"/>.
</para>


<sect2 id="stille-programmer">
<title>Problematiske programmer</title>
<para>
Her er nogle af de programmer, der kan finde på at starte disken uden
at det er nødvendigt.
</para>


<itemizedlist mark="bullet">
<listitem>
 <para>
  <emphasis>syslog</emphasis>
  Skriver som default "-- MARK --" i log filerne hvert 20. minut.
  </para>
  <para>
  <emphasis>Løsning</emphasis>
  Start syslogd med <command>-m 0</command> optionen. Rettes i <filename>/etc/init.d/syslog</filename>
 </para>
</listitem>

<listitem> 
 <para>
  <emphasis>modprobe</emphasis>
  Kan finde på at lede i <filename>/lib/modules/kernerver/</filename> efter et
  ikke-eksisterende modul hvert minut.
  </para>

  <para>
  <emphasis>Løsning 1</emphasis>
  Se i <filename>/var/log/ksymoops/20020702.log</filename> (brug den
  rigtige dato).
  F.eks. fandt jeg: <literal>20020702 161032 start /sbin/modprobe -s -k -- char-major-6 safemode=1</literal>
</para>

  <para>
  Det var fordi jeg kørte <command>lpd</command> dæmonen uden en driver
  for parallelporten.
  </para>

  <para>
  <emphasis>Løsning 2</emphasis>
  Oversæt en kerne med alt hvad du skal bruge og lad være med at køre
  modprobe (modutils).
 </para>
</listitem>

<listitem> 
 <para>
  <emphasis>ntp</emphasis>
  Skriver som default i
  <filename>/var/lib/ntp/ntp.drift</filename> og
  <filename>/var/log/ntpstats/loopstats</filename>
  med få minutters mellemrum.
</para>

<para>
<emphasis>Løsning 1</emphasis>
Man kan minimere problemet ved at sætte tiden mellem opdateringer af uret til
det maksimale.
</para>

<para>
I <filename>/etc/ntp.conf</filename> sæt for hver server:
<command>server clock.server.com minpoll 16 maxpoll 17</command>
</para>

<para>
<emphasis>Løsning 2</emphasis>
Det er som regel ikke nødvendigt at bruge ntp.
Brug <command>ntpdate</command> i stedet.
</para>
</listitem>

<listitem> 
 <para>
  <emphasis>CUPS</emphasis>
Skriver et SSL-certifikat i
<filename>/etc/cups/ssl/server.crt</filename> hvert 5. minut.
Den læser <filename>/etc/groups</filename> hver gang, så det er ikke
nok at lave <filename>/etc/cups/certs</filename> til et link på en RAM-disk.
</para>

<para>
<emphasis>Løsning 1</emphasis>
Hent kildeteksten. I <filename>scheduler/main.c</filename> ret de 300 i 
<command>if ((time(NULL) - RootCertTime) >= 300)</command> til 
noget meget større, eller fjern helt if-sætningen.
</para>

<para>
<emphasis>Løsning 2</emphasis>
Fra og med CUPS version 1.1.16 kan man undgå skrivningen af 
certifikater at at indsætte kommandoen: "RootCertDuration 0" 
i filen <filename>/etc/cups/cupsd.conf</filename>
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>cron</emphasis>
Kører en masse jobs som ikke er nødvendige.
</para>

<para>
<emphasis>Løsning</emphasis>
Fjern alt hvad du ikke behøver fra 
<emphasis>/etc/cron.d</emphasis>, <filename>/etc/crontab</filename> og 
<filename>/etc/cron.daily</filename>. Se også om mail senere.
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>ftpd</emphasis>
FTP-servere tilgår typisk <filename>/etc/{passwd,hosts,group}</filename>,
hjemmekataloger osv.
</para>  


<para>
  <emphasis>Løsning: muddleftp og tmpfs</emphasis>
Lav en tmpfs partition, og brug muddleftpd. 
Sæt muddleftp op med <filename>/etc/muddleftpd.com</filename> på flg. måde:
</para>

<para>Sæt "logfile" og "scratch file" til filer i roden tmpfs partitionen.
Sæt "rdnstimeout 0" i sektionen "main" for at slå "reverse DNS lookup" fra.
Sæt "uid" og "gid" i sektionen "localusers" for at undgå brug af
<filename>/etc/passwd</filename> og <filename>/etc/group</filename>.
Sæt "authmethod internal" og "internal_passfile /fileontmpfs/"
i sektionen "localusers".
Brug mudpasswd til at lave password filen. 
Sæt root directory til noget på tmpfs partitionen.
Password filen skal kopieres til tmpfs filsystemet hver gang muddleftp startes. 
Det gøres i <filename>/etc/init.d/muddelftpd</filename> (Debian): 
</para>

<screen>
case "$1" in
    start)
    cp -a /home/bruger/mpw /tfs/
...
</screen>

<para>
<filename>muddleftpd.conf</filename> findes under kataloget <filename>eksempler</filename> til denne bog.
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>browsere</emphasis>
Netscape 4.7 skriver sit cache-indeks, selv når den ikke bliver brugt.
Den gratis version af Opera læser fra disken ca. hvert 5. minut for at
udskifte reklamen.
</para>

<para>
<emphasis>Løsning</emphasis>
Luk din browser, når du ikke bruger den.
</para>

<para>
Eller brug browsere, der ikke skriver på disken, når de ikke bruges.
Som erstatning for Opera på små computere kan "Dillo" anbefales.
</para>
</listitem>

<listitem> 
 <para>
  <emphasis>mail</emphasis>
  MTA'er (sendmail, exim, postfix, etc) køres ofte ca. hvert 15. minut
  fra <filename>/etc/cron.d/MTA</filename>,
  hvor <literal>MTA</literal> er navnet på din MTA
</para>

<para>
Tjek <filename>/etc/init.d/MTA</filename> for at se om en MTA, der
tjekker spool-filerne, startes med et fast interval.  Det gøres som
regel med en <command>-q time</command> (fx <command>-q 1h22m</command>) option.
</para>

<para>
  <emphasis>Løsning</emphasis>
Det er sjældent nødvendigt at tjekke spool-filerne med faste intervaller. Brugere kan sende
og modtage post uden dette.
</para>
<para>
Fjern <filename>/etc/cron.d/MTA</filename> filen og
<command>-q</command> parameteren i <filename>/etc/init.d/MTA</filename>.
 </para>
</listitem>

<listitem> 
 <para>
  <emphasis>updatedb</emphasis>
kører <command>find</command> mm. hver dag for at resultaterne af <command>locate</command> kommandoen er up-to-date.
</para>

<para>
  <emphasis>Løsning 1</emphasis>
Afinstallér <command>updatedb</command>.
</para>

<para>
  <emphasis>Løsning 2</emphasis>
Fjern <filename>/etc/cron.daily/find</filename>
</para>

<para>
Hvis man har brug for <command>locate</command> kommandoen kan man
altid manuelt køre <command>updatedb</command> som root.
</para>
</listitem>
</itemizedlist>

<sect3 id="stille-andre-vink">
<title>Andre vink</title>
<para>
<emphasis>Montér filsystemer med "noatime" optionen</emphasis>
Hvis man monterer et filsystem med "noatime", bliver
inode-access-tiden ikke opdateret.
Det betyder at hvis en fil eller et katalog, der er cached, bliver
læst, så startes disken ikke for at skrive filen eller katalogets
access-tid tilbage.
</para>

<para>
Skriv følgende i din <command>/etc/fstab</command> fil:
</para>

<screen>
/dev/hda3	/home ext2 defaults,noatime	0	0
</screen>
</sect3>

<sect3 id="stille-uskyld">
<title>Hvordan man finder de skyldige programmer</title>
<para>
Nogen gange starter disken bare, uden at man ved hvorfor. Det kan være ret frustrerende.
</para>

<para>
Som en del af <ulink url="http://www.diku.dk/teaching/2002f/336/">DIKU Linux
kerne kurset</ulink> blev en patch til 2.4.18 kernen udviklet.
</para>

<para>
Denne patch får kernen til at logge alle filoperationer. Det logger
PID, tid, programnavn, filnavn osv.
</para>

<para>
Få patchen <ulink url="http://www.agol.dk/quietlinux/noisylog.patch">her</ulink>.
</para>

<para>
Dette <ulink
url="http://www.agol.dk/quietlinux/do_noisy_logging.c">brugerprogram</ulink> slår
logging til og fra.
Oversæt det med <command>cc -o do_noisy_logging -I /usr/src/linux/include do_noisy_logging.c</command>.
</para>

<para>
Programmet køres som <command>./do_noisy_logging 0</command> eller
<command>./do_noisy_logging 1</command> for at slå logging fra
hhv. til.
</para>
</sect3>
</sect2>
</sect1>


<sect1 id="kickstart">
<title>Kickstart</title>
<indexterm><primary>Kickstart</primary></indexterm>
<para>
Kickstart er en smart måde at installere mange maskiner ens. Man kan ud fra 
en maskine gemme opsætningen i en fil og få KickStart systemet under Red Hat
og Mandrake til at installere den næste maskine med samme opsætning. Her er 
et par steder hvor man kan finde mere dokumentation om det:
</para>

<para>
Mark's Kickstart Examples
<ulink url="http://www.linuxgazette.com/issue43/nielsen.kickstart.html">http://www.linuxgazette.com/issue43/nielsen.kickstart.html</ulink>
</para>

<para>
Red Hat Linux 7.1: The Official Red Hat Linux
Customization Guide
<ulink url="http://ftp.linux.cz/pub/linux/redhat-cz/7.1/disks/disk2/doc/RH-DOC/rhl-cg-en-7.1/s1-kickstart2-options.html">http://ftp.linux.cz/pub/linux/redhat-cz/7.1/disks/disk2/doc/RH-DOC/rhl-cg-en-7.1/s1-kickstart2-options.html</ulink>
</para>

<para>
Red Hat Linux KickStart HOWTO
<ulink url="http://mirrors.sunsite.dk/ldp/HOWTO/KickStart-HOWTO.html">http://mirrors.sunsite.dk/ldp/HOWTO/KickStart-HOWTO.html</ulink>
</para>
</sect1>

 <sect1 id="saette-tid">
  <title>Sætte tiden</title>

  <indexterm><primary>date</primary></indexterm>
  <indexterm><primary>sætte dato</primary></indexterm>

  <para>
   Skal du sætte tiden på din maskine så kan du gøre dette med
   <command>date -s 13:45:00</command>, men det kan også betale sig at
   se på NTP-systemet i <xref linkend="ntp"/>, idet det giver en meget
   bedre kontrol over at alle maskiner viser ens tid.
  </para>
 </sect1>

 <sect1 id="sysadm-mknod">
  <title>Oprette enheder</title>

  <indexterm>
   <primary>oprette</primary>
   <secondary>enheder</secondary>
  </indexterm>

  <indexterm>
   <primary>enheder</primary>
   <secondary>oprette</secondary>
  </indexterm>

  <indexterm>
   <primary>/dev/null</primary>
   <secondary>redde</secondary>
  </indexterm>

  <indexterm>
   <primary>mknod</primary>
  </indexterm>

  <indexterm>
   <primary>Kommandooversigt</primary>
   <secondary>mknod</secondary>
  </indexterm>

  <para>
   Hvis man skal oprette en enhed (det kan for eksempel være hvis det
   er lykkedes for en fjollet systemadministrator at slette
   <filename>/dev/null</filename>) skal man bruge kommandoen
   <command>mknod</command>.  Hvis vi tager eksemplet med
   <filename>/dev/null</filename>, så kan vi på et fungerende system
   se at det er en tegn-enhed (eng.: character device) med
   primærnummeret 1 og sekundærnummeret 3:
<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ls -l /dev/null</userinput>
crw-rw-rw-    1 root     root       1,   3 jan 21 21:22 /dev/null
</screen>
   Det er c'et i første søjle der fortæller os at det er en
   tegn-enhed.  Alternativet er at det er en blok-enhed, hvilket
   markeres med et b i første søjle.  Vi kan nu ovre på systemet, hvor
   <filename>/dev/null</filename> er forsvundet genoprette enheden:
<screen>
<prompt>[root@saltholm ~]# </prompt><userinput>mknod /dev/null c 1 3</userinput>
<prompt>[root@saltholm ~]# </prompt><userinput>ls -l /dev/null</userinput>
crw-r--r--    1 root     root       1,   3 jan 21 21:25 /dev/null
</screen>
   Nu er enheden oprettet, men ikke med de helt rigtige rettigheder.
   Det kan vi rette op på med <command>chmod</command>:
<screen>
<prompt>[root@saltholm ~]# </prompt><userinput>chmod go+w /dev/null</userinput>
<prompt>[root@saltholm ~]# </prompt><userinput>ls -l /dev/null</userinput>
crw-rw-rw-    1 root     root       1,   3 jan 21 21:26 /dev/null
</screen>
  </para>
 </sect1>

 <sect1 id="sysadm-afslutning">
  <title>Tips og tricks</title>

  <para>
   Der er meget mere i systemadministration, end dette korte kapitel
   har præsenteret. Til Linux findes der især to dokumenter, som er
   gode at læse, nemlig "System Administrator's Guide" (SAG) og
   "Network Administrator's Guide" (NAG) - begge kan hentes fra <ulink
   url="http://sunsite.dk/ldp">http://sunsite.dk/ldp</ulink> og følger
   med Red Hat-distributionen. De er en del af "Linux Documentation
   Project" (LDP). Red Hat's hjemmeside indeholder endvidere en række
   gode tricks og nyttige oplysninger. De bedste bøger om Unix
   systemadministration er uden tvivl Æleen Frischs "Essential System
   Administration" udgivet af O'Reilly, og "UNIX System Administration
   Handbook" (Evi Nemeth, Garth Snyder, Scott Seebass og Trent
   R. Hein) udgivet af Prentice Hall PTR.
  </para>

  <para>
   Vil du vide mere om sikkerhedskopiering under Linux, så kig i "The
   Linux System Administrators' Guide": <ulink
   url="http://www.linuxdoc.org/LDP/sag/index.html">http://www.linuxdoc.org/LDP/sag/index.html</ulink>.
  </para>
 </sect1>
</chapter>
