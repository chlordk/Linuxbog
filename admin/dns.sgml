<!-- $Id$ -->
<chapter id="tcp-ip-dns">
<title>TCP/IP og DNS</title>
<indexterm><primary>DNS</primary><secondary>historisk</secondary></indexterm>
<!-- Skrevet af Christian Rasmussen "chr@egebjerg.com" -->

<para>
Det er i dag blevet meget almindeligt, også for privatbrugere, at
koble flere computere sammen i et netværk. For at computerne kan
"tale" sammen kræves en standard for hvorledes kommunikationen skal
foregå. En sådan standard kaldes en protokol.
</para>

<para>
En protokol består basalt set af nogle regler som blandt andet
forhindrer computerne i at "snakke i munden på hinanden". Samtidig er
det defineret hvor store portioner data som skal sendes ad gangen,
hvor lang tid computeren skal vente på at modparten svarer og
lignende.
</para>

<para> 
Gennem tiden er forskellige standarder inden for
datakommunikation blevet udviklet. En dominerende teknologi,
kompatibel med flertallet af computersystemer, har ikke eksisteret før
internettet for alvor brød igennem i 1990'erne.  
</para>

<para>
For at muliggøre kommunikation mellem vidt forskellige
computersystemer er talrige standarder blevet vedtaget &ndash; og bliver
løbende vedtaget. Kommunikation over internettet er bygget op om
protokollen "TCP/IP", Transmission Control Protocol/Internet
Protocol. Linux har i modsætning til andre styresystemer altid
indeholdt denne protokol, hvilket betyder at Linux er meget overlegen
når det gælder internet-kommunikation.
</para>

<indexterm><primary>DARPA</primary><secondary>DNS</secondary></indexterm>
<indexterm><primary>ARPANET</primary><secondary>DNS</secondary></indexterm>
<indexterm><primary>internettet</primary><secondary>ARPANET</secondary></indexterm>

<para> 
TCP/IP har rødder helt tilbage til slutningen af 1960'erne, hvor
den amerikanske militær-organisation DARPA (Defense Advanced Research
Projects Agency) startede et forskningsprojekt. Målet var at udvikle
en teknologi til sikker datakommunikation, som ikke var afhængig af en
central enhed, og kunne fungere selvom en stor del af netværket var
destrueret af fjender. Samtidig skulle teknologien kunne fungere på
vidt forskellige computersystemer og styresystemer. Teknologien kom
til at hedde ARPANET.  
</para>

<para>
ARPANET ekspanderede kraftigt, og delte sig i flere uafhængige men
forbundne netværk. Inden længe havde ARPANET bredt sig til mange
amerikanske universiteter og senere ud over USA's grænser, det blev
herefter til det som vi i dag kalder "internettet".
</para>

<para>
For at få det hele til at snakke sammen, eksisterer forskellige
organisationer, som hver har deres ansvarsområde. Disse består af
frivillige teknikere/ingeniører, som tager stilling til forskellige
forslag og diskuterer fremtiden for internettet. Debatten er meget åben;
før en standard bliver vedtaget, kommer den ud til "internet-befolkningen"
hvor enhver har mulighed for at kommentere. Herefter vil forslaget blive
vedtaget og gjort til en endelig standard som de individuelle firmaer
kan implementere i deres systemer.
</para>

<para>
Internettets historie er der skrevet mange bøger om, stort set hver
bog har sin egen version af historien. Der er ikke altid enighed om
hvornår hvilken begivenhed indtraf, eller hvem der stod bag. Men rent
faktisk er det kun filosofien, som datidens "internet" har til fælles med
nutidens internet.
</para>

<para>
Fordi du nu bruger Linux, kommer du til at have fingrene lidt
længere nede i netværksmaskineriet end med andre styresystemer. Derfor
er du nødt til at lære lidt mere om, hvordan det hele er skruet sammen,
i stedet for bare at skrive en stribe magiske tal i nogle dialogbokse.
</para>

<para>
Du kan i mange tilfælde teste tingene på din egen maskine uden at være
forbundet til et eksternt netværk, og dermed undgår du at genere andre. Vær
frem for alt ikke bange for at lege med tingene &ndash; du kan kun blive klogere af
det!
</para>




<sect1 id="ip-adresser">
<title>IP-adresser</title>
<indexterm><primary>IP-adresser</primary></indexterm>

<para>
Kommunikation på internettet foregår ved at hver enkelt computer tilkoblet
internettet, har et unikt nummer, kaldet en IP-adresse. IP-adresser
ses i det daglige som decimaltal, eksempelvis: 195.249.116.158.
</para>

<para>
Men rent faktisk behandler computere dem ikke i 10-talssystemet,
men derimod i  det binære talsystem. Det binære talsystem består af
bit. Dem skal der bruges 32 af for at have en IP-adresse. Hver bit
kan enten have værdien 1 eller 0, på hardwareniveau behandles 1 som
forbindelse mellem 2 kredsløb og 0 som ikke forbindelse.
</para>

<indexterm><primary>IP-adresser</primary><secondary>teknisk baggrund</secondary></indexterm>

<para>
I decimaltal er en IP-adresse delt ind i 4 felter adskilt af
punktum. For at sammenligne binær og decimal skal den binære version
derfor også opdeles i 4 felter; vi deler derfor de 32 bit med de 4
felter, og kan derved udlede at hvert felt skal bestå af 8 bit.
</para>

<para>
I binært talformat vil det første felt i ovenstående IP-adresse (195)
hedde: 11000011. Følgende metode benyttes for at omregne feltet til
decimaltal:
</para>

<table id="netv1">
<title> Omregn binær til decimal </title>
<tgroup cols="3" align="char">

<thead><row>
 <entry>Bit-nr: (talt bagfra)</entry>
 <entry>Repræsenteret værdi:</entry>
 <entry>Bit-værdi:</entry>
</row></thead>

<tbody>

<row>
 <entry>1</entry> 
 <entry>1</entry>
 <entry>1</entry> 
</row>

<row>
 <entry>2</entry> 
 <entry>2</entry>
 <entry>1</entry> 
</row>

<row>
 <entry>3</entry> 
 <entry>4</entry>
 <entry>0</entry> 
</row>

<row>
 <entry>4</entry> 
 <entry>8</entry>
 <entry>0</entry> 
</row>

<row>
 <entry>5</entry> 
 <entry>16</entry>
 <entry>0</entry> 
</row>

<row>
 <entry>6</entry> 
 <entry>32</entry>
 <entry>0</entry> 
</row>

<row>
 <entry>7</entry> 
 <entry>64</entry>
 <entry>1</entry> 
</row>

<row>
 <entry>8</entry> 
 <entry>128</entry>
 <entry>1</entry> 
</row>

</tbody>
</tgroup>
</table>

<para>
Hvis bitværdien er 1 betyder det blot at den repræsenterede værdi
skal medregnes, hvis den er 0, skal den springes over, det giver
følgende regnestykke: 1+2+64+128 = 195.
</para>

<para>
Dette regnestykke bruges for hvert af de 4 felter, og man kan på den
måde omregne en IP-adresse fra binær til decimal. Hvert felt kan
således antage en værdi mellem 0 og 255 (begge inklusive).
</para>


<para>
Har du brug for at regne om mellem binært, decimalt og hexadecimalt,
så har KDE er god lommeregner, <command>kcalc</command>, som gør dette nemt.
</para>
</sect1>

<sect1 id="netklasser">
<title>Netklasser</title>

<para>
For at kunne opdele IP-adresserne i portioner som kan delegeres til
firmaer/institutioner, er et system defineret til at inddele
IP-adresserne i net, også kaldet netklasser. Der eksisterer 3 typer af
netklasser: A, B og C. Hver klasse har et specifikt
adresseområde. Derudover afgør netklassen, hvor mange af felterne som
er variable; følgende skema giver en oversigt over de omtalte
netklasser:
</para>

<table id="tab-netklasser">
<title>Netklasser</title>
<tgroup cols="4" align="char">

<thead><row>
 <entry>Netklasse:</entry>
 <entry>A</entry>
 <entry>B</entry>
 <entry>C</entry>
</row></thead>

<tbody>

<row>
 <entry>Adresseområde:</entry> 
 <entry>0.*.*.* - 126.*.*.*</entry>
 <entry>128.*.*.* - 191.*.*.*</entry> 
 <entry>192.*.*.* - 223.*.*.*</entry> 
</row>

<row>
 <entry>Fast/Variabel:</entry> 
 <entry>Fast.*.*.*</entry>
 <entry>Fast.fast.*.*</entry> 
 <entry>Fast.fast.fast.*</entry> 
</row>

<row>
 <entry>Mulige klasser:</entry> 
 <entry>127</entry>
 <entry>16.383</entry>
 <entry>2.097.151</entry> 
</row>

<row>
 <entry>Mulige IP-adresser:</entry> 
 <entry>16.777.214</entry>
 <entry>65.534</entry> 
 <entry>254</entry> 
</row>

</tbody>
</tgroup>
</table>


<para>
* (stjerne) angiver at værdien kan være mellem 0 og 255 (begge
inklusiv).
</para>

<para>
Som det kan ses i "adresseområde"-feltet, er det udelukkende det
første felt i IP-adressen som afgør hvilken netklasse en IP-adresse
tilhører. Feltet "Fast/Variabel" viser hvilken del af IP-adressen man
selv kan bestemme når man får delegeret et net af den pågældende
klasse. Den faste del kaldes også for netværksnummeret mens den
variable del kaldes værtsnummer eller host-id. "Mulige klasser"
fortæller hvor mange klasser af de forskellige typer som kan
eksistere med de gældende standarder. Feltet "Mulige IP-adresser"
illustrerer hvor mange IP-adresser hver klasse kan indeholde.
</para>

<para>
Hvis man sammenligner vores test-IP-adresse: 195.249.116.158 med
ovenstående skema, fremgår følgende: Det første felt i IP-adressen,
"195" fortæller at IP-adressen tilhører et C-klasse-net, da tallet
"195" ligger i området 192-223. For C-klasse-net gælder det at de
første 3 felter er faste. Det er således kun det sidste felt man selv
kan råde over. Samtidig kan det ses at der i alt kan eksistere
2.097.151 C-klasse-net. Hvert C-klasse-net kan indeholde 254 IP-adresser.
</para>


<sect2 id="subnet-maske">
<title>Subnet-maske</title>
<indexterm>
 <primary>Subnet-maske</primary>
</indexterm>
<indexterm><primary>IP-adresser</primary><secondary>subnet-maske</secondary></indexterm>
<indexterm><primary>255.255.255.0</primary><secondary>subnet-maske</secondary></indexterm>

<para>
Når et IP-net bliver delegeret til et firma/en institution, får
firmaet tildelt et netværksnummer og skal derfra selv tildele
værtsnumre til de enkelte computere. Eftersom computerne sidder i et
lokalnetværk og derfor er fysisk koblet sammen, skal de formentlig
primært udveksle data indbyrdes. For at muliggøre dette kræves det at
en specifik subnet-maske sættes samtidig med den individuelle
IP-adresse.
</para>

<indexterm><primary>Klasse-C netværk</primary></indexterm>

<para>
Subnet-masker består ligesom IP-adresser af 32 bit, til et
C-klasse-net hedder subnet-masken i decimal 255.255.255.0. De
første 3 felter af en C-klasse IP-adresse er som bekendt faste. I
subnet-masken vises det ved at feltet har den maksimale værdi 255.
Mens det sidste felt, som er variabelt, har værdien 0, hvilket betyder
at dette felt i IP-adressen kan antage en hvilken som helst værdi
mellem 0 og 255 og stadig være inden for det givne IP-net. Med en
C-klasse-net subnet-maske skal de 3 første felter i en IP-adresse
altså være ens før 2 IP-adresser stammer fra samme IP-net.
</para>

<table id="test-ip">
<title>Test af IP-net</title>
<tgroup cols="2" align="char">

<thead><row>
 <entry>IP-adresse:</entry>
 <entry>Samme IP-net som 195.249.116.158?</entry>
</row></thead>

<tbody>

<row>
 <entry>212.112.128.10</entry> 
 <entry>Nej</entry> 
</row>

<row>
 <entry>195.125.13.2</entry> 
 <entry>Nej</entry>
</row>

<row>
 <entry>195.249.116.15</entry> 
 <entry>Ja!</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
Ovenstående skema viser med nogle eksempler hvordan man ser om
C-klasse IP-adressen 195.249.116.158 er i samme IP-net som en anden
adresse. Kriteriet er at de 3 første felter skal være ens, da vi har
at gøre med en C-klasse subnet-maske (255.255.255.0).
</para>

<para>
Det første felt i den første adresse (212) er ikke lig 195, og derfor
er de 2 adresser ikke i samme net. Ved den næste adresse matcher det
første felt, men det andet felt (125), er ikke lig det andet felt i
test-adressen (249). Den sidste adresse er på samme IP-net fordi de 3
første felter matcher.
</para>

<!--
<para>
Du kan også på 
<ulink url="http://www.ko.sdu.dk/~pen/netmasker/ip-net.htmlx">
http://www.ko.sdu.dk/~pen/netmasker/ip-net.htmlx</ulink>
læse mere om IP-adresser.
</para>
-->

</sect2>
</sect1>


<sect1 id="netsammenkobling">
<title>Sammenkobling af flere netværk</title>

<para>
En computer i et TCP/IP-netværk benytter altså subnet-masken til at
verificere om en anden computer som den skal kommunikere med, er på det
samme IP-net. Hvis det ikke skulle være tilfældet, skal computeren bruge
en "gateway". En gateway er et slags mellemled som fysisk er tilkoblet
flere netværk og samtidig har en IP-adresse for hvert netværk. På denne
måde kan data komme fra et netværk, passere igennem gateway'en, og ud på
et andet netværk til sin destination. Gateway'en er nærmere en funktion
end en enhed. Denne "funktion" kaldes routning og kan udføres af en
computer, en router eller en lignende hardware-enhed.
</para>

<para>
Et elementært eksempel kunne være en virksomhed bestående af en
salgsafdeling og en regnskabsafdeling, med hver deres lokalnetværk:
</para>

<figure id="net1" float="1">
<title>Netværks-eksempel</title>
<graphic fileref="net1.&magic;"  scale="60"></graphic>
</figure>

<indexterm><primary>Gateway</primary></indexterm>



<para>
Disse pc'er har hidtil kørt i 2 separate netværk, men skal nu forenes
således at pc'erne kan kommunikere på tværs af hinandens netværk.
</para>

<para>
Vi starter med at udnævne salgsafdelingens PC1 til at være gateway. Denne
skal have et ekstra netkort installeret som fysisk skal tilkobles
regnskabsafdelingens netværk. Dette ekstra netkort skal sættes til at
kommunikere med de øvrige pc'er på regnskabsafdelingens netværk. Derfor
tildeles dette netkort IP-adressen 192.168.20.10. Netværket ser herefter
således ud:
</para>


<figure id="net2" float="1">
<title>Netværk med gateway</title>
<graphic fileref="net2.&magic;"  scale="60"></graphic>
</figure>


<para>
Gateway er nu mellemledet som direkte kan kommunikere med samtlige
pc'er i virksomheden. De øvrige pc'er har fået en gateway sat op
(angivet som GW). For PC2 og PC3's vedkommende er denne adresse
gateways IP 1, mens de øvrige har gateway's IP 2.
</para>

<para> 
Ud fra ovenstående kan det konkluderes at en gateway er
nødvendig når en computer skal kommunikere med en anden computer som
ikke er inden for det samme IP-net. Det er derfor logisk at en gateway
vil være påkrævet når man eksempelvis skal benytte internettet, da
størstedelen af adresserne ligger uden for ens eget IP-net.
</para>
</sect1>




<sect1 id="Klasseloest-internet">
<title>Klasseløst internet</title>
<indexterm><primary>Klasseløst internet</primary></indexterm>

<para>
Igennem 1990'erne er antallet af brugere på internettet mildest talt
eksploderet, hvilket har udløst en akut mangel på IP-adresser. Som
følge deraf er internettet i dag rent faktisk blevet klasseløst, idet
man ikke længere har nok adresser tilbage til at delegere A-, B- eller
C-net til firmaer/institutioner. Man bliver derfor nødt til at uddele
IP-adresserne i meget mindre portioner. Følgende er en oversigt over
de nye og langt mindre net:
</para>


<table id="ip-nets">
<title>IP-net oversigt</title>
<tgroup cols="4" align="char">

<thead><row>
 <entry>Antal adresser:</entry>
 <entry>Netklasse:</entry>
 <entry>Subnet-maske:</entry>
 <entry>Bit:</entry>
</row></thead>

<tbody>

<row>
 <entry>1</entry> 
 <entry></entry>
 <entry>255.255.255.255</entry> 
 <entry>32</entry> 
</row>

<row>
 <entry>2</entry> 
 <entry></entry>
 <entry>255.255.255.254</entry> 
 <entry>31</entry> 
</row>

<row>
 <entry>4</entry> 
 <entry></entry>
 <entry>255.255.255.252</entry> 
 <entry>30</entry> 
</row>

<row>
 <entry>8</entry> 
 <entry></entry>
 <entry>255.255.255.248</entry> 
 <entry>29</entry> 
</row>

<row>
 <entry>16</entry> 
 <entry></entry>
 <entry>255.255.255.240</entry> 
 <entry>28</entry> 
</row>

<row>
 <entry>32</entry> 
 <entry></entry>
 <entry>255.255.255.224</entry> 
 <entry>27</entry> 
</row>

<row>
 <entry>64</entry> 
 <entry></entry>
 <entry>255.255.255.192</entry> 
 <entry>26</entry> 
</row>

<row>
 <entry>128</entry> 
 <entry></entry>
 <entry>255.255.255.128</entry> 
 <entry>25</entry> 
</row>

<row>
 <entry>256</entry> 
 <entry>C-Net</entry>
 <entry>255.255.255.0</entry> 
 <entry>24</entry> 
</row>

<row>
 <entry>65536</entry> 
 <entry>B-Net</entry>
 <entry>255.255.0.0</entry> 
 <entry>16</entry> 
</row>

<row>
 <entry>16777216</entry> 
 <entry>A-Net</entry>
 <entry>255.0.0.0</entry> 
 <entry>8</entry> 
</row>

</tbody>
</tgroup>
</table>

<para>
(Nettene mellem A-, B- og C-klasserne er ikke medtaget!)
</para>

<para>
Nettene benævnes på deres subnet-maske, eller subnet-maskens
bit. Tallet i kolonnen "Bit" fortæller hvor mange af de 32 bit som er
sat. Det første net med subnet-masken 255.255.255.255 har 32 bit sat
og kaldes derfor et "32-net".
</para>

<para>
Hvert IP-net indeholder en netværksadresse og en
broadcast-adresse. Netværksadressen er den første adresse i IP-nettet og
bruges til at definere nettet. Broadcast-adressen er den sidste adresse,
og benyttes til at kontakte samtlige andre adresser i IP-nettet på én
gang. Broadcast-adressen kan være nyttig hvis man eksempelvis vil pinge
(se om en computer er aktiv) samtlige computere på et IP-net, i stedet
for at pinge hver enkelt kan man blot pinge broadcast-adressen.
</para>

<para>
Den første og sidste adresse i et IP-net er derfor altid reserveret og
kan ikke tildeles andre enheder. Det mindste IP-net som kan bruges til
at tildele IP-adresser fra er derfor et 30 bit net som indeholder 4
IP-adresser. Efter netværksadressen og broadcast-adressen er talt fra,
er 2 adresser i overskud som kan tildeles computere.
</para>

<para>
IP-nettet som vores test-IP-adresse 195.249.116.158 tilhører, vil man
umiddelbart kalde 195.249.116.0/24, da IP-adressen tilhører et
C-klasse-net som jo netop består af 24 bit. Netværksadressen vil i
dette IP-net hedde 195.249.116.0 og Broadcast-adressen 195.249.116.255.
</para>
</sect1>

<sect1 id="eks-net">
<title>Eksempel på netværk tilkoblet internettet</title>
<indexterm><primary>DNS</primary>
<secondary>Eksempel på netværk tilkoblet internettet</secondary></indexterm>

<para>
Hvis man forestiller sig et firma som netop er blevet forbundet til
internettet via en fast forbindelse, og som af deres internetudbyder er
blevet tildelt IP-nettet 195.249.116.144/28, vil følgende
informationer gøre sig gældende:
</para>

<table id="ip-net-eksempel">
<title>IP-net eksempel</title>
<tgroup cols="2" align="char">

<tbody>

<row>
 <entry>Subnet-maske</entry> <entry>255.255.255.240</entry>
</row>
<row>
 <entry>Antal IP-adresser</entry> <entry>16</entry>
</row>
<row>
 <entry>Netværksadresse</entry> <entry>195.249.116.144</entry>
</row>
<row>
 <entry>Broadcast-adresse</entry> <entry>195.249.116.159</entry>
</row>
<row>
 <entry>Første tilgængelige adresse</entry> <entry>195.249.116.145</entry>
</row>
<row>
 <entry>Sidste tilgængelige adresse</entry> <entry>195.249.116.158</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
Internetudbyderen har samtidig leveret en router, som er blevet
fysisk tilkoblet netværket. Hensigten med denne er at den skal fungere
som gateway. Den har derfor fået tildelt den første af de tilgængelige
adresser.
</para>

<para>
Firmaet har 10 computere som er tilkoblet netværket. TCP/IP skal på
hver af disse sættes op til at bruge internettet ud fra nedenstående
oplysninger:
</para>

<figure id="net3" float="1">
<title>Netværk med internet</title>
<graphic fileref="net3.&magic;"  scale="60"></graphic>
</figure>


<para>
Ovenstående eksempel viser hvorledes de første 3 pc'er skal
sættes op, de resterende sættes op på samme måde.
</para>

<para>
Computerne vil nu være fuldt ud i stand til at kommunikere med brugere
på internettet, ligeså gælder den anden vej. Hver enkelt bruger på
internettet kan nu også kommunikere direkte med hver af computerne.
</para>

</sect1>

<sect1 id="private-ip">
<title>Private IP-adresser</title>
<indexterm><primary>Private IP-adresser</primary></indexterm>
<indexterm><primary>IP-adresser</primary><secondary>private</secondary></indexterm>

<para>
Der er fordele ved at gøre sine computere direkte tilgængelige over
internettet, men der bestemt også ulemper! For hackere er det et rent
slaraffenland; eftersom de kan kommunikere med samtlige adresser
direkte, er der ingen mellemled til at bremse deres indbrudsforsøg.
</para>

<para>
For at hindre direkte kommunikation mellem internettet og lokalnettet
benytter man såkaldte private IP-adresser som ikke kan nås fra
internettet.
</para>

<para>
Private IP-adresser er specielle adresseområder som man har valgt at
"frede", netop med det formål at firmaer/institutioner kan vælge et af
disse og benytte det på deres lokalnetværk. Private IP-adresser er
altså derfor modsætningen til offentlige IP-adresser, da private
adresser ikke er brugbare på internettet. De bliver simpelthen sorteret
fra når de forsøger at komme igennem en gateway. Følgende oversigt
viser de private IP-adresseområder:
</para>

<indexterm><primary>192.168.0.0</primary></indexterm>

<table id="private-ip-adresser">
<title>Private IP-adresser</title>
<tgroup cols="3" align="char">

<thead><row>
 <entry>Netklasse:</entry>
 <entry>Antal klasser:</entry>
 <entry>IP-adresser:</entry>
</row></thead>

<tbody>

<row>
 <entry>A</entry>
 <entry>1</entry> 
 <entry>10.*.*.*</entry> 
</row>

<row>
 <entry>B</entry>
 <entry>16</entry> 
 <entry>172.16.*.* op til 172.31.*.*</entry> 
</row>

<row>
 <entry>C</entry>
 <entry>256</entry> 
 <entry>192.168.*.*</entry> 
</row>


</tbody>
</tgroup>
</table>

<para>
I praksis fungerer et netværk med private adresser ikke meget
anderledes end et netværk med officielle adresser. Når de enkelte
computere skal kommunikere med en IP-adresse som er uden for deres eget
IP-net, og derfor kommunikerer via deres gateway, er denne
sat op til at "oversætte" deres adresse til en officiel adresse.
</para>

<para>
Basalt set fungerer det på den måde at de beder gateway'en om at
kommunikere med en given internet-computer på deres vegne.
internet-computeren "tror" at den udelukkende kommunikerer med gateway'en
- og kender derfor ikke til computerne bag ved gateway'en. Man kan
derfor også kalde det en slags "envejs-kommunikation", da det kun er
computeren med den private adresse der kan kontakte en computer på
internettet og ikke omvendt.
</para>

<indexterm><primary>NAT</primary><secondary>Network Address Translation</secondary></indexterm>
<indexterm><primary>ipchains</primary></indexterm>

<para>
Denne form for adresse-oversættelse kaldes også NAT, Network Address
Translation, hvilket er en slags udvidet routnings-funktion. Mange
routere kan udføre denne funktion. For at sætte Linux op med kerne
2.2 til det, skal programmet <command>ipchains</command> benyttes, og
med kerne 2.4 anvendes <command>netfilter</command>. Dette er
forklaret nøjere i bogen "Linux &ndash; Friheden til sikkerhed på internettet".
</para>

<para>
Det er meget vigtigt, at man sørger for at vælge private IP-adresser
når man kører med NAT som er inde for det tilladte område. Hvis man i
stedet vælger at benytte et IP-net som i forvejen er i brug, vil
konsekvensen være, at man ikke kan kommunikere med de enheder som
retmæssigt har fået tildelt IP-adresserne.
</para>

<para>
Det skyldes, at ens computere er sat op til at benytte en
gateway, når de skal kommunikere med enheder uden
for det lokale IP-net. Hvis IP-adressen derimod er inden for
det lokale IP-net vil de forsøge at kommunikere med den pc som har den
aktuelle IP-adresse, eftersom det er den forkerte pc, vil det
naturligvis mislykkes.
</para>

<para>
Hvis man alligevel forestillede sig at computerne kommunikerede via
gateway'en og kunne kontakte de rigtige enheder, ville der opstå en
konflikt idet der nu eksisterede flere enheder med samme IP-adresser.
Dette er ikke tilladt, og styresystemet vil straks advare om
problemet. Hvis IP-adresser ikke er unikke, kan computere ikke finde ud
af at bruge dem.
</para>

</sect1>

<sect1 id="eks-nat">
<title>Eksempel på netværk med NAT</title>
<indexterm><primary>Eksempel på netværk med NAT</primary></indexterm>
<indexterm><primary>NAT</primary></indexterm>
<indexterm><primary>Network Address Translation</primary></indexterm>

<para>
Vi bygger videre på det foregående eksempel og benytter derfor
informationerne fra <xref linkend="ip-net-eksempel"/> igen, men
denne gang vil vi benytte NAT. Primært for at øge sikkerheden, men
også for at øge fleksibiliteten, i og med at vi ikke behøver at kontakte
vores internetudbyder og ansøge om flere IP-adresser, hvis de 16
viser sig at være for få.
</para>

<para>
Der skal tages stilling til 2 ting: Hvilken enhed skal udføre
NAT-oversættelsen, og hvilket privat IP-net skal benyttes. Enten
vælger man at købe en internet-løsning med NAT, hvilket vil sige at den
router internetudbyderen leverer allerede er sat op med
NAT. Eller også sætter man en computer op til at køre NAT.
</para>

<para>
Valget af det private IP-net afhænger meget af ens behov, og hvor
stort antal computere man regner med at have på sit netværk inden for
en overskuelig årrække. I vores eksempel vælger vi 192.168.1.0/24:
</para>



<table id="privat-ip-net-eksempel">
<title>Privat IP-net eksempel</title>
<tgroup cols="2" align="char">

<tbody>

<row>
 <entry>Subnet-maske</entry> <entry>255.255.255.0</entry>
</row>
<row>
 <entry>Antal IP-adresser</entry> <entry>255</entry>
</row>
<row>
 <entry>Netværksadresse</entry> <entry>192.168.1.0</entry>
</row>
<row>
 <entry>Broadcast-adresse</entry> <entry>192.168.1.255</entry>
</row>
<row>
 <entry>Første tilgængelige adresse</entry> <entry>192.168.1.1</entry>
</row>
<row>
 <entry>Sidste tilgængelige adresse</entry> <entry>192.168.1.254</entry>
</row>

</tbody>
</tgroup>
</table>

<indexterm><primary>Routing</primary></indexterm>

<para>
Routeren skal bibeholde IP-adressen 195.249.116.145, mens der i næste
led skal placeres en enhed til at udføre NAT-oversættelsen. Denne skal
på "ydersiden" (mod routeren) have tildelt en officiel IP-adresse. Her
vælger vi den næste ledige, 195.249.116.146. Desuden skal den have
tildelt en privat IP-adresse på indersiden, her vælger vi den først
tilgængelige adresse, 192.168.1.1.
</para>


<figure id="net4" float="1">
<title>Netværk med NAT</title>
<graphic fileref="net4.&magic;"  scale="60"></graphic>
</figure>


<para>
Ovenstående eksempel illustrerer hvorledes netværket skal sammenkobles
hvis man vælger selv at sætte en enhed op til at udføre
NAT-oversættelsen. Routeren bliver fysisk tilkoblet NAT-enheden, som
samtidig via et sekundært netkort er tilkoblet det eksisterende netværk.
Denne vil herefter fungere som gateway for PC1-PC3.
</para>

<para>
Alternativt kan man, som omtalt, købe en løsning hvor routeren
indeholder NAT-opsætningen. I dette tilfælde vil internetudbyderen
foretage den nødvendige opsætning. I forhold til ovenstående figur
vil man kunne skippe NAT-enheden, idet routeren selv klarer opgaven.
Routeren vil i så fald få tildelt både en ekstern og en intern IP-adresse.
</para>

<para>
Hvis man senere ønsker at tilføje yderligere pc'er til denne opsætning,
kan det gøres problemfrit, indtil man har opbrugt de resterende
adresser i IP-nettet. Herefter vil det være nødvendigt at skifte
IP-net. En simpel løsning vil være blot at skifte subnet-maske,
eksempelvis til /16, hvilket vil betyde 255 gange flere IP-adresser.
</para>

</sect1>


<sect1 id="om-dns">
<title>Domain Name Service (DNS)</title>
<indexterm><primary>Domain Name Service</primary></indexterm>
<indexterm><primary>DNS</primary></indexterm>


<para>
På internettet ser man ofte adresser, som hedder noget i retning af
www.smartnavn.dk. De 3 w'er står for World Wide Web. Internettet er
verdensomspændende og nogle betragter det som værende et stort
spindelvæv.
</para>


<para>
Men faktisk gemmer der sig en IP-adresse bag hver enkelt af disse
web-adresser. Dette er dog ikke noget den normale bruger lægger mærke
til. Men faktisk er det således, at der slet ikke eksisterer egentlige
web-adresser. Det er udelukkende IP-adresser.
</para>

<para>
Når en bruger skriver en web-adresse i sin browser, anmoder hans
computer en DNS-server om IP-adressen på den pågældende web-adresse.
Det er kun IP-adresser, som er brugbare på et TCP/IP-netværk.
</para>

<para>
En DNS-server er en service som en server kan køre ved siden af de
almindelige services. Hvis der er meget belastning, kan man vælge at
have en DNS-server, som udelukkende kører DNS-service.
</para>

<para>
Hver gang DNS-serveren får en anmodning om en web-adresse, slår den
web-adressen op i sin database og finder den tilhørende IP-adresse.
</para>

<para>
For at dette kan virke over hele verden, er der et vist system i det.
Det går ud på, at hvert land har et domæne. Ligesom institutioner og
firmaer i det pågældende land har et "underdomæne/subdomæne". For
eksempel hedder SSLUG's domæne sslug.dk, hvilket er et subdomæne til
.dk-domænet. 'dk' angiver Danmark.
</para>

<para>
Hos SSLUG har man så tilføjet et yderligere subdomæne, www. Den
komplette adresse hedder således www.sslug.dk. Hvis man skriver denne
adresse i sin browser, vil computeren automatisk spørge sin DNS-server om
IP-adressen på domænet og herefter lave en webforespørgsel til
IP-adressen.
</para>

<para>
Det vil sige at domænenavne er hierarkisk opbygget. Landet er
øverst, derefter navnet på firmaet/institutionen (eventuelt i en
forkortet udgave), og til sidst subdomænet som "peger" på serveren
for domænet.
</para>

<indexterm><primary>TLD (Top Level Domain)</primary></indexterm>

<para>
De øverste domæner i hierarkiet kaldes også TLD (Top Level Domains =
Topniveau-domæner), og disse administreres af de såkaldte
root-servere. En root-server besvarer kun forespørgsler på TLD-niveau.
I dag eksisterer der på verdensplan 13 root-servere, som hver
besvarer cirka 200 millioner forespørgsler om dagen.
</para>

<para>
Almindelige computere kommunikerer ikke direkte med root-serverne. De
sender i stedet en web-adresse-forespørgsel til enten en lokal
DNS-server, eller DNS-serveren hos deres internetudbyder.
</para>

<para>
Hvis vi forestiller os at DNS-serveren ns.sslug.dk som er ansvarlig
for domænet sslug.dk, modtager en forespørgsel på subdomænet
www.sslug.dk, ser serveren med det samme at det er det domæne som den
selv er ansvarlig for, og kan derfor besvare denne forespørgsel uden
at skulle kontakte andre DNS-servere.
</para>

<para>
Hvis serveren i stedet modtog en forespørgsel på subdomænet
<filename>www.linux.dk</filename> ville den straks kunne se at det
ikke var et domæne den selv var ansvarlig for. Den ville derfor være
nødt til at starte med det øverste rent hierarkisk set. Serveren vil
derfor indlede med at spørge en root-server om topniveau-domænet
<filename>.dk</filename>, den vil af root-serveren blive bedt om at
kontakte DK-Hostmasters server, som er ansvarlig for det
domæne. DK-Hostmasters server vil henvise til serveren ns.linux.dk som
er ansvarlig for domænet <filename>linux.dk</filename>. Serveren vil
derfor ende med at få besvaret sit spørgsmål når den spørger
<filename>ns.linux.dk</filename>.
</para>

<para>
Man kan betragte en DNS-server som en telefonbog, hvor personerne er
web-adresser. Begge steder får man et nummer (telefonnummer/IP-adresse),
som systemet kan bruge til at lokalisere informationen/personen.
</para>

<para>
For at begrænse DNS-trafikken benytter DNS-servere sig af DNS-cache.
Her bliver de svar serveren har fået fra øvrige DNS-servere gemt.
Hvis man gentog ovenstående eksempel, ville serveren derfor ikke
starte forfra med at spørge alle serverne, men i stedet blot kigge på
det foregående svar.
</para>

<para>
Eftersom der dagligt bliver lavet ændringer på mange servere, er det
vigtigt at en DNS-server ikke tror den bare kan gemme sin cache
evigt. Hvis eksempelvis <filename>www.sslug.dk</filename> bliver
ændret til at pege på en anden webserver, vil det ikke være meget værd
hvis vores DNS-server stadig fortæller alle og enhver hvad den hed
førhen! Derfor har DNS-servere det man kalder en TTL (Time To Live),
hvilket simpelthen definerer hvor lang tid et svar må leve. Hvis vores
server igen modtager forespørgslen på
<filename>www.sslug.dk</filename>, og TTL'en er udløbet, vil serveren
være nødt til at starte forfra med at spørge de forskellige
DNS-servere.
</para>

<indexterm>
 <primary>nslookup</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>nslookup</secondary>
</indexterm>
<para>
Som et konkret eksempel på et DNS-opslag kan vi f.eks. bede om SSLUG's
IP-adresse. Til dette bruger vi kommandoen <command>nslookup</command>.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>nslookup www.sslug.dk</userinput>
Server:  danpost.uni-c.dk
Address:  129.142.6.64

Non-authoritative answer:
Name:    sslug.sslug.dk
Address:  130.228.2.150
Aliases:  www.sslug.dk
</screen>

<para>
Vi kan i eksemplet se, at vi beder
<filename>danpost.uni-c.dk</filename> med IP-adresse 129.142.6.64 om
adressen på SSLUG's webserver. SSLUG har IP-adressen 130.228.2.150, og maskinen
er åbenbart også kendt som <filename>sslug.sslug.dk</filename>. Svaret er
"Non-authoritative", idet danpost DNS-serveren ikke er herre over
sslug-domænet, men har fået informationen fra en anden navneserver.
</para>

<para>
DNS indeholder også andre informationer end IP-adresser. I DNS-sprog
sætter man et punktum bag navnene for at angive, at disse er
absolutte. Normalt kan man dog ignorere det sidste punktum.
</para>



<sect2 id="dns-zoner">
<title>DNS-zoner</title>
<indexterm><primary>DNS</primary><secondary>zoner</secondary></indexterm>
<indexterm><primary>Zone</primary><secondary>DNS</secondary></indexterm>
<para>
DNS er baseret på filer. Disse filer indeholder zone-data. I mange
tilfælde indeholder hver fil/zone ét domæne, i det følgende kan man
derfor blot betragte "zone" som et synonym for "domæne".
</para>

<para>
Navneserverne for en zone listes ved:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>host -t ns sslug.dk</userinput>
sslug.dk name server ns-soa.darenet.dk
sslug.dk name server ns.sslug.dk
sslug.dk name server ptah.dkuug.dk
</screen>

<indexterm>
 <primary>host</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>host</secondary>
</indexterm>

<para>
For at finde post-serverne for et domæne skal man kende en af
navneserverne for domænet. Derefter spørger man denne navneserver:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>host -t mx domæne.dk navneserver.for.domæne.dk</userinput>
</screen>

<para>
Den ansvarlige administrator for en zone findes i zonens SOA-record
(eng. Start Of Authority). SOA-recorden findes med:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>host -t soa domæne.dk navneserver.for.domæne.dk</userinput>
</screen>

<para>
Hvis SOA starter med:
<filename>sslug.dk.      IN      SOA     ns.sslug.dk. root.sslug.dk.  (</filename>
så er zonen <filename>sslug.dk</filename>, den primære navneserver <filename>ns.sslug.dk</filename> og den
ansvarlige administrators e-post-adresse <filename>root@sslug.dk</filename> (udskift første . med @).
</para>

<para>
Nogle navne er blot et alias for et andet navn: de har et kanonisk navn 
(eng: "canonical name"). Dette kan ses ved at spørge navneserveren for 
domænet om alt, hvad den ved om et givet navn:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>host -t any dette.navn.domæne.dk nameserver.for.domæne.dk</userinput>
</screen>

<para>
Til nogle domæner er knyttet tekstinformation. Denne kan kaldes frem med:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>host -t txt navn.med.info.domæne.dk</userinput>
</screen>

<para>
Hvis informationen er til stede, indeholder den ofte information om
hvem der bestyrer navn.med.info.domæne.dk
</para>

<para>
Da DNS ikke er helt simpelt at sætte op korrekt, kan de ovenstående
eksempler bruges, hvis du skal fejlfinde din egen DNS. De kan også
bruges til at finde ud af, hvorfor netværksfejl opstår eller til
at finde en ansvarlig for et domæne, som man har modtaget
reklamer fra.
</para>

<indexterm><primary>Caching nameserver</primary></indexterm>
<indexterm><primary>DNS</primary><secondary>caching nameserver</secondary></indexterm>

<para>
I forbindelse med installationen af Red Hat Linux kan
du vælge pakken "caching-nameserver". Pakken foretager en simpel
opsætning af navneserveren <command>bind</command>. Fra starten kender
den ikke selv svaret på navneopslag, men sender blot spørgsmålet
videre og husker svaret (som beskrevet ovenfor). Den glemmer desværre
alt, hvad den har lært, når maskinen lukkes ned, så du får mest glæde af
en caching navneserver, hvis den kører på en maskine, der er i gang altid -
f.eks. en server på et lille lokalnetværk. Den kan selvfølgelig
sagtens bruges som navneserver for Windows-pc'er på netværket.
</para>

<para>
Hvis du vil bruge Linux på en server i et mindre netværk, kan du have
glæde af at lade den fungere som navneserver for et lokalt domæne.
Opsætningen af dette er ikke det første Linux-eksperiment, du skal
starte med, så eventuelle interesserede henvises til den detaljerede
beskrivelse i DNS-HOWTO (under Red Hat, se
<filename>/usr/doc/HOWTO/DNS-HOWTO</filename>) og <ulink
url="http://www.sslug.dk/artikler/dnsbind.shtml">http://www.sslug.dk/artikler/dnsbind.shtml</ulink>
er sikkert også af interesse.
</para>
</sect2>
</sect1>

<sect1 id="dns-opsaetning">
<title>DNS-opsætning</title>
<indexterm><primary>DNS</primary>
<secondary>Opsætning af</secondary></indexterm>

<para>
DNS er interessant, når man har flere end f.eks. 5 maskiner på
netværket og hvis man ikke længere ønsker at kopiere
<filename>/etc/hosts</filename>-filer (Se <xref linkend="etc-hosts-filen"/>)
rundt til alle maskiner. Har du mange maskiner på netværket, kan
du i stedet have en fælles navneserver (eng. nameserver) til at kunne
håndtere navneopslag.
</para>

<para>
Som gennemgående eksempel antager vi her at vi har domænet "intranet"
med følgende maskiner. IP-adresserne her er private,
dvs. at maskinerne ikke er på internettet. Vi vælger derfor adresser fra
<xref linkend="private-ip-adresser"/> i <xref linkend="private-ip"/>.
</para>

<programlisting>
192.168.0.1      linus.intranet    linus
192.168.0.2      alan.intranet     alan
192.168.0.3      richard.intranet  richard
192.168.0.4      eric.intranet     eric
</programlisting>

<para>
Vi vedtager også at maskinen "linus" skal være DNS-server, og at samme
maskine også skal være kendt som "ns.intranet" eller i kort form blot "ns".
</para>
</sect1>

<sect1 id="Bind">
<title>Bind</title>
<indexterm><primary>DNS</primary>
<secondary>Bind</secondary></indexterm>
<para>
Dette afsnit vil gennemgå opsætningen af et registreret domæne på en
DNS-server. Strukturen fra BIND 8.x er benyttet, da dette er den
version de fleste DNS-servere anvender, modsætningen er den noget
ældre BIND 4.x. De følgende eksempler kører på BIND 8.1.2, men nye
versioner udvikles hele tiden. Opgraderinger kan hentes fra
<ulink url="http://www.isc.org">http://www.isc.org</ulink>.
</para>


<para>
Den overordnede opsætningsfil er
<filename>/etc/named.conf</filename>. I denne defineres hvilke zoner
(domæner) DNS-serveren administrerer og i hvilke filer de enkelte
zoner er defineret.
</para>

<para>
<indexterm><primary>DNS</primary>
<secondary>zone</secondary></indexterm>
Som standard vil man skulle definere 4 zoner for domænet "intranet"
med IP-adresser i intervallet 192.168.0.1-192.168.0.254 (ikke 255, da
dette er broadcast-adressen).
</para>

<itemizedlist mark="bullet" spacing="compact">
<listitem>
<para>
<filename>.</filename> (punktum) : Først og fremmest root,
denne zone henviser til root-serverne således at DNS-serveren kan
spørge disse om domæner den ikke selv er ansvarlig for, hvilket vil
sige at det er denne zone som DNS-serveren benytter når den modtager
forespørgsler om IP-adresser på et domæne, som den ikke selv er ansvarlig
for. Nedenfor er dette angivet i filen <filename>/var/named/root.cache</filename>.
</para>
</listitem>

<listitem>
<para>
<filename>0.0.127.in-addr.arpa</filename>: Reverse lookup betyder, at
man har en IP-adresse og gerne vil vide hvilket domæne denne
tilhører. For at DNS-serveren kan besvare denne slags forespørgsler,
kræves det at reverse-zonerne bliver defineret.  Reverse-zonen 127.0.0
refererer blot til DNS-serveren selv (filen
<filename>/var/named/127.0.0.rev</filename>), TCP/IP-software kræver i
nogle tilfælde at denne IP-adresse henviser til DNS-serveren selv.
Derfor skal denne zone altid medtages.
</para>
</listitem>

<listitem>
<para>
<filename>0.168.192.in-addr.arpa</filename>: Den anden (eller de
andre) reverse-zoner er de "rigtige" IP-adresser.  Hvis man for
eksempel råder over adresserne 192.168.0.1-192.168.0.254, laver man en
reverse-zone-fil til disse IP-numre. (De nævnte adresser er kun et
eksempel, de eksisterer ikke på internettet da de er nogle af de
"private" adresser). Denne zone gemmes i <filename>/var/named/192.168.0.rev</filename>.
</para>
</listitem>

<listitem>
<para>
<filename>intranet</filename>: Du skal også lave en fil, der kan
afbilde fra navn til IP-nummer for det domæne, du sætter op. I filen
<filename>/var/named/intranet</filename> kan du erklære navne og
aliaser for alle maskiner.
</para>
</listitem>
</itemizedlist>

<sect2 id="DNS-eks-etc-name-conf">
<title>/etc/named.conf</title>

<para>
Følgende er et eksempel på en
<filename>/etc/named.conf</filename> fil som indeholder ovenstående
grundlæggende opsætning:
</para>

<indexterm><primary>/etc/named.conf</primary></indexterm>

<programlisting>   
options {
  /* Hvor er filerne med DNS-opsætning */
  directory "/var/named";

  /* Indsaet 1-3 forwarder nameservere */
  /* Brug dem fra din ISP og indsaet IP-adresserne */
  /* i stedet for NNN.NNN.NNN.NNN og MMM.MMM.MMM.MMM */
  forwarders {
          NNN.NNN.NNN.NNN;
          MMM.MMM.MMM.MMM;
  };

  /* Lyt på DNS-forespørgsler til to IP-adresser */
  listen-on { 192.168.0.1; 127.0.0.1 ; };

  /* Udkommenter følgende linje hvis dit domæne 
     er kendt på internettet */
  notify no;
  
};

logging {
  category lame-servers { null; };
  category cname { null; };
};

zone "." in {
  type hint;
  file "root.cache";
};

zone "0.0.127.in-addr.arpa" in {
  type master;
  file "127.0.0.rev";
};

zone "0.168.192.in-addr.arpa" in {
  type master;
  file "192.168.0.rev";
};

zone "intranet" in {
  type master;
  file "intranet";
};
</programlisting>

<para>
De første linjer definer i hvilket bibliotek de senere omtalte filer
skal placeres. Standard er: <filename>/var/named</filename>, men du
kan også anvende f.eks. <filename>/etc/named</filename> eller andre steder.
</para>

<para>
Logging-linjen forhindrer at man får en masse unødigt i sin syslog.
(Log-funktionen er meget avanceret, en masse forskellige kriterier
kan defineres).
</para>

<para>
Næste linje er en zone-definition. Her gælder det root-zonen, selve
filen hentes fra 
<ulink url="ftp://ftp.internic.net">ftp://ftp.internic.net</ulink>. De
resterende linjer fortæller først hvilket domæne det handler om, og
derefter i hvilken fil selve domænet er defineret. Samtidig får
serveren af vide om den er "master" eller "slave" for det pågældende
domæne. I ovenstående tilfælde er DNS-serveren master for alle
zoner. For at kunne registrere et domæne kræves det at man har 2
DNS-servere til domænet, master og slave, eller primær og
sekundær. Følgende er et eksempel på en slave-zone:
</para>

<programlisting>   
zone "intranet" in {
  type slave;
  file "intranet";
  masters { 192.168.0.1; };
};
</programlisting>

<para>
Udover at der nu står slave i stedet for master, er en linje tilføjet
som fortæller hvilken server er master. Grunden til at
slave-serveren skal kende master-serveren er, at slave-serveren henter
zone-filerne fra master-serveren. Dette betyder at ændringer i et domæne
på master-serveren automatisk vil blive overført til slave-serveren.
</para>

</sect2>

<sect2 id="DNS-eks-root-cache">
<title>/var/named/root.cache</title>
<indexterm><primary>bind</primary><secondary>root.cache</secondary></indexterm>
<indexterm><primary>Zone</primary><secondary>eksempel</secondary></indexterm>
<para>
Vi kan f.eks. bruge følgende udgangspunkt for
<filename>/var/named/root.cache</filename> &ndash; dvs. root-zonen.
</para>

<programlisting>
;       This file holds the information on root name servers needed to
;       initialize cache of Internet domain name servers
;       (e.g. reference this file in the "cache  .  &lt;file&gt;"
;       configuration file of BIND domain name servers).
;
;       This file is made available by InterNIC registration services
;       under anonymous FTP as
;           file                /domain/named.root
;           on server           FTP.RS.INTERNIC.NET
;       -OR- under Gopher at    RS.INTERNIC.NET
;           under menu          InterNIC Registration Services (NSI)
;              submenu          InterNIC Registration Archives
;           file                named.root
;
;       last update:    Feb 28, 1997
;       related version of root zone:   1997022800
;
;
; formerly NS.INTERNIC.NET
;
.                        3600000  IN  NS    A.ROOT-SERVERS.NET.
A.ROOT-SERVERS.NET.      3600000      A     198.41.0.4
;
; formerly NS1.ISI.EDU
;
.                        3600000      NS    B.ROOT-SERVERS.NET.
B.ROOT-SERVERS.NET.      3600000      A     128.9.0.107
;
; formerly C.PSI.NET
;
.                        3600000      NS    C.ROOT-SERVERS.NET.
C.ROOT-SERVERS.NET.      3600000      A     192.33.4.12
;
; formerly TERP.UMD.EDU
;
.                        3600000      NS    D.ROOT-SERVERS.NET.
D.ROOT-SERVERS.NET.      3600000      A     128.8.10.90
;
; formerly NS.NASA.GOV
;
.                        3600000      NS    E.ROOT-SERVERS.NET.
E.ROOT-SERVERS.NET.      3600000      A     192.203.230.10
;
; formerly NS.ISC.ORG
;
.                        3600000      NS    F.ROOT-SERVERS.NET.
F.ROOT-SERVERS.NET.      3600000      A     192.5.5.241
;
; formerly NS.NIC.DDN.MIL
;
.                        3600000      NS    G.ROOT-SERVERS.NET.
G.ROOT-SERVERS.NET.      3600000      A     192.112.36.4
;
; formerly AOS.ARL.ARMY.MIL
;
.                        3600000      NS    H.ROOT-SERVERS.NET.
H.ROOT-SERVERS.NET.      3600000      A     128.63.2.53
;
; formerly NIC.NORDU.NET
;
.                        3600000      NS    I.ROOT-SERVERS.NET.
I.ROOT-SERVERS.NET.      3600000      A     192.36.148.17
;
; temporarily housed at NSI (InterNIC)
;
.                        3600000      NS    J.ROOT-SERVERS.NET.
J.ROOT-SERVERS.NET.      3600000      A     198.41.0.10
;
; temporarily housed at NSI (InterNIC)
;
.                        3600000      NS    K.ROOT-SERVERS.NET.
K.ROOT-SERVERS.NET.      3600000      A     193.0.14.129
;
; temporarily housed at ISI (IANA)
;
.                        3600000      NS    L.ROOT-SERVERS.NET.
L.ROOT-SERVERS.NET.      3600000      A     198.32.64.12
;
; temporarily housed at ISI (IANA)
;
.                        3600000      NS    M.ROOT-SERVERS.NET.
M.ROOT-SERVERS.NET.      3600000      A     202.12.27.33
; End of File
</programlisting>
</sect2>


<sect2 id="dns-eks-kongeh-dk">
<title>/var/named/intranet</title>
<indexterm><primary>Zone</primary><secondary>intranet</secondary></indexterm>
<indexterm><primary>Intranet</primary><secondary>zone-fil</secondary></indexterm>
<para>
Den næste fil er for maskinerne i 192.168.0.*-området:
</para>

<programlisting>
$TTL   1D
@   IN SOA ns.intranet. hostmaster.intranet. (
                                      1999102400 ; serial number
                                      60000      ; refresh (1 day)
                                      3600       ; retry (1 hour)
                                      2600000    ; expire (1 month)
                                      60000      ; minimum (1 day)
)

;
; NB: BRUG TABULATOR SOM MELLEMRUM
;

;
; Dette domænes DNS-servere:
;
      IN   NS   ns.intranet.

;
; Mailserveren for dette domæne:
;
      IN   MX   0   mail.intranet.

;
;  Standardhostnavne afbildet til IP-adresser:
;
localhost   IN   A   127.0.0.1
linus       IN   A   192.168.0.1

;
; Øvrige hostnavne afbildet til IP-adresser:
;
alan        IN   A   192.168.0.2
richard     IN   A   192.168.0.3
eric        IN   A   192.168.0.4

;
; Alias adresser:
;
ns          IN   CNAME   linus.intranet.
mail        IN   CNAME   linus.intranet.
</programlisting>

<para>
<emphasis>Husk: Den første linje $TTL - "Time to live"
skal med, og der anvendes tabulator til at adskille hvert felt, og der
må ikke anvendes mellemrum.</emphasis> 
Bemærk specielt, at der er punktum efter hvert maskin-navn i CNAME-linjerne.
</para>

<para>
Når en computer ude på nettet har spurgt vores server om noget på
vores zone vil den have modtaget noget data. Efter et par dage vil
det være muligt at disse data er forældet. Derfor kan man med
"TTL"-parameteren angive hvor lang tid en klient må beholde data som den har
fået fra en DNS-server.
</para>

<para>
Linje to til syv angiver diverse parametre for selve domænet. Det
er ikke så vigtigt at forstå ordenen i disse linjer, derimod er det
vigtigt at forstå betydningen. Det første tegn "@" er en variabel for
selve domænet. Her kunne altså i stedet stå "intranet.". Grunden til
at man i stedet sætter en variabel, er at man på den måde ikke behøver
ændre dette felt hvis man bruger denne zone-fil til at lave en anden
zone-fil.
</para>

<indexterm><primary>IN</primary><secondary>DNS</secondary></indexterm>
<para>
"IN" står for "INTERNET" og angiver den klasse data man benytter. I dag
bliver der meget sjældent benyttet andre klasser, så derfor er IN
default, og man behøver derfor ikke angive dette. SOA står som
tidligere skrevet for "Start Of Authority" og fortæller efterfølgende
hvilken navneserver der er ansvarlig for denne zone.
</para>

<para>
"ns.intranet." fortæller hvilket domæne navneserveren er ansvarlig
for, "hostmaster.intranet" er e-post-adressen til vedkommende som er
ansvarlig for domænet. Bemærk, at det første . (punktum) skal læses
som et @.
</para>

<indexterm><primary>Serial</primary><secondary>DNS</secondary></indexterm>
<para>
"Serial" er serienummeret for zonen. Hver gang man laver en ændring, skal
serienummeret opdateres. Eneste regel er at tallet skal blive mindst én
højere (inkrementeres). De fleste vælger at bruge dags dato sammen med
et 2-cifret tal. Det gør det muligt at vide hvornår sidste opdatering
blev foretaget. Grunden til at man har serienummeret, er at man kun
opdaterer sine zone-filer på sin master-server. Slave-serveren vil
derefter selv hente ændringerne, men den ved kun at der er foretaget
ændringer <emphasis>hvis</emphasis> serienummeret er blevet
inkrementeret.
</para>

<indexterm><primary>Refresh</primary><secondary>DNS</secondary></indexterm>

<para>
"Refresh" fortæller hvor tit slave-serveren skal spørge
master-serveren om serienummeret på det pågældende domæne og herved
beslutte om der skal foretages en overførsel.
</para>

<indexterm><primary>Retry</primary><secondary>DNS</secondary></indexterm>
<para>
Hvis slave-serveren ikke er i stand til at skabe kontakt til 
master-serveren i første forsøg, definerer man med "Retry" hvor lang tid den
skal vente før den prøver igen.
</para>

<indexterm><primary>expire</primary><secondary>DNS</secondary></indexterm>
<para>
I tilfælde af at slave-serveren slet ikke kan få kontakt til
master-serveren, vil det efter nogle dage kunne være sandsynligt at der
er foretaget ændringer på master-serveren som slave-serveren ikke
har. Hvilket vil sige at den primære og den sekundære server giver
modstridende oplysninger til deres klienter! For at undgå dette kan man
definere hvor lang tid slave-serveren skal tro på at dens zone-data er
gode nok. Dette gøres med "expire"-parameteren. Det skal forstås
således, at når slave-serveren ikke kan kontakte master-serveren og det
angivne tidsrum er udløbet, vil slave-serveren smide sine data om den
pågældende zone ud, og altså ikke besvare forespørgsler omkring denne
zone.
</para>

<para>
Ovenstående parametre som angives i tidsrum, kan skrives i S, M, H, D
(Sekunder, Minutter, Timer, Dage). De fleste vælger at angive dem
alle i sekunder, det gør dog ingen forskel, og det er rimelig
besværligt at skulle omregne eksempelvis 86400 sekunder (1 dag).
</para>

<para>
Der findes mange meninger om hvorledes ovenstående parametre skal
sættes. De 4 første handler udelukkende om DNS-serverne, og derfor er
det yderst begrænset hvor store fejl, der kan opstå ved at sætte nogle
af disse 4 parametre "forkert", hvis man selv administrerer både master
og slave. Derimod er det mindre hensigtsmæssigt at sætte TTL helt
forkert. Resultatet kan eksempelvis blive at man ikke kan modtage post i
en uges tid, hvis man er kommet til at angive en forkert IP-adresse til
mail-serveren, og TTL er sat til en uge.
</para>

<para>
Resten af zone-filen er selve "records". Den første kolonne fortæller
hvilket navn man vil omsætte. Eksempelvis kunne der stå
"mail.intranet" for at fortælle hvad "mail.intranet" skulle
referere til. Hvis man ikke angiver noget i den første kolonne, vil
selve zonen være default, altså "intranet."
</para>

<para>
En vigtig ting som altid gælder når man angiver navne: Hvis man ikke
afslutter med et "." (punktum) vil serveren automatisk tilføje det
pågældende domæne til navnet. "mail.intranet" vil derfor blive til
"mail.intranet.intranet".
</para>

<para>
Herefter skal der angives hvilken klasse man arbejder med &ndash; her er "IN"
igen default. Derpå skal man fortælle hvilken type record man vil
angive (de mest brugte vil blive gennemgået i det efterfølgende). Det
sidste der skal angives, er hvilket navn eller hvilken IP-adresse
DNS-serveren skal svare tilbage med, når den bliver spurgt om denne
record.
</para>

<indexterm><primary>DNS</primary><secondary>NS</secondary></indexterm>
<para>
Den først record er af typen "NS" (Name Server), her angiver man
navnet på DNS-serveren, først den primære, herefter den sekundære.
</para>

<indexterm><primary>DNS</primary><secondary>MX</secondary></indexterm>
<para>
Den næste record er af typen "MX" (Mail eXchanger), her angives
navnet på post-serveren.
</para>

<indexterm><primary>DNS</primary><secondary>A</secondary></indexterm>
<para>
Herefter kommer en stribe standard "A"-records (A = Address). Denne
record angiver hvilket IP-nummer den omtalte host har.
</para>

<indexterm><primary>DNS</primary><secondary>CNAME</secondary></indexterm>
<para>
"CNAME" står for Canonical name og betyder alias. Denne record-type
bruges til at have flere navne til at referere til en IP-adresse.
</para>
</sect2>


<sect2 id="DNS-eks-127-0-0-rev">
<title>/var/named/127.0.0.rev</title>
<para>
Den første "reverse"-fil er for "localhost", som vi i
<filename>/etc/named.conf</filename> valgte at gemme i
<filename>/var/named/127.0.0.rev</filename>.
</para>

<programlisting>
$TTL    1D
@ IN  SOA   ns.intranet. hostmaster.intranet. (
                                      1999102400 ; serial number
                                      60000     ; refresh (1 day)
                                      3600       ; retry (1 hour)
                                      2600000    ; expire (1 month)
                                      60000     ; minimum (1 day)
)

;
; NB: BRUG TABULATOR SOM MELLEMRUM
;

;
; DNS-serveren for denne zone:
;
IN   NS    ns.intranet.

;
; Reverse mappings:
;
1   IN   PTR   localhost.
</programlisting>

<para>
<emphasis>Husk den første linje $TTL - "Time to live" - skal med, og
der anvendes tabulator til at adskille hvert felt.</emphasis> Bemærk
specielt, at der er punktum efter hvert maskin-navn.
</para>

<para>
Igen har vi SOA-recorden (fra linje 2 til 7). Det er en fordel at
have en generel SOA-record for alle sine zoner, dog kan man
naturligvis have behov for forskelle nogle steder, men rent
administrativt er det langt mere overskueligt med samme parametre.
</para>

<para>
Grunden til at der kun er angivet en DNS-server, er at denne zone
udelukkende er for 127.0.0 som altså kun kan være den lokale server,
hvilket ikke har noget at gøre med den/de andre DNS-servere.
</para>

<para>
Reverse records er af typen PTR. Da forespørgsler til reverse-zoner skal
besvares med et navn i stedet for en IP-adresse er strukturen i disse
zoner også anderledes. Der er simpelthen byttet om på navnet og
IP-adressen. Derfor står IP-adressen først, i det her tilfælde 1 (1 +
zone-navnet (127.0.0) = 127.0.0.1), herefter klassen (IN), record-typen
(PTR) og til sidst navnet (localhost).
</para>
</sect2>


<sect2 id="DNS-eks-192-168-0-rev">
<title>/var/named/192.168.0.rev</title>
<para>
Den næste "reverse"-fil er for maskinerne i 192.168.0.*-området:
</para>

<programlisting>
$TTL   1D
@ IN SOA   ns.intranet. hostmaster.intranet. (
                                      1999102400 ; serial number
                                      60000      ; refresh (1 day)
                                      3600       ; retry (1 hour)
                                      2600000    ; expire (1 month)
                                      60000      ; minimum (1 day)
)

;
; NB: BRUG TABULATOR SOM MELLEMRUM
;

;
; Name Servers for this reverse zone:
;
IN   NS    ns.intranet.

;
; Reverse mappings:
;
1   IN   PTR   linus.intranet.
2   IN   PTR   alan.intranet.
3   IN   PTR   richard.intranet.
4   IN   PTR   eric.intranet.
</programlisting>

<para>
Ovenstående er reverse zone-filen for zonen 192.168.0.*.  Nok en gang
- den første linje $TTL - "Time to live" skal med, og der anvendes
tabulator til at adskille hvert felt.  Bemærk igen, at der er punktum
efter hvert maskin-navn.
</para>

<para>   
Her gælder de samme regler som for 127.0.0 zonen. 4 reverse records
er defineret fra 1 til 4 svarende til 192.168.0.1-192.168.0.4, dvs. 
vores fire maskiner. Har du brug for et andet eksempel på opsætning af
DNS, så kan du se i <ulink url="http://www.sslug.dk/artikler/dnsbind.shtml">http://www.sslug.dk/artikler/dnsbind.shtml</ulink>.
</para>
</sect2>
</sect1>

<sect1 id="start-named">
<title>Start named</title>
<indexterm><primary>DNS</primary><secondary>start server</secondary></indexterm>
<para>
Efter at have redigeret navneserver-filerne færdig er du klar til
at starte <command>named</command>. Kører du Red Hat, er det nemt. Du
skal installere <command>bind</command>-pakken og køre
</para>
<indexterm>
 <primary>/sbin/chkconfig</primary>
</indexterm>
<indexterm>
 <primary>chkconfig</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>chkconfig</secondary>
</indexterm>
<screen>
<prompt>[root@linus /root]# </prompt> <userinput>/sbin/chkconfig --level 345 named on</userinput>
</screen>

<para>
Dette er en smart måde at få startet
<filename>/etc/rc.d/init.d/named</filename> i run-levels 3, 4 og 5. 
Du kan nu eksperimentere og se om din opsætning er i orden. 
Start en xterm og skriv <command>tail -f
/var/log/messages</command>. I en anden xterm skriver du 
<command>/etc/rc.d/init.d/named start</command>. Kommer der ikke fejl
ud, er du igennem første syntakstjek. Dernæst kan du starte med at
spørge din lokale DNS, f.eks.:
</para>
<indexterm>
 <primary>nslookup </primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>nslookup </secondary>
</indexterm>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>nslookup linus linus</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>nslookup alan linus</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>nslookup 192.168.0.3 linus</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>nslookup localhost localhost</userinput>
</screen>

<para>
Tjek både på IP-adresser og maskinnavne. Går alt glat, skal dine
Unix-maskiner nu have <filename>/etc/resolv.conf</filename> med
indhold for at bruge din nye DNS-server.
</para>

<programlisting>
search intranet
nameserver 192.168.0.1
</programlisting>

<para>
Endelig skal det nævnes, at der i tidens løb har været en del
sikkerhedsfejl i DNS-serveren BIND, og det kan kraftigt anbefales at
følge sikkerhedslisterne på internettet.
</para>


<itemizedlist mark="bullet">
    <listitem><para>Bugtraq <ulink url="http://www.securityfocus.com">http://www.securityfocus.com</ulink>
      bør du følge med på for at læse om de nyeste afsløringer af 
      sikkerhedsbrister (exploits).
    </para></listitem>
    <listitem><para>Root Shell <ulink url="http://www.rootshell.com">http://www.rootshell.com</ulink>
      har alt indenfor diskussion af sikkerhed.
    </para></listitem>
    <listitem><para>Linux Today <ulink url="http://linuxtoday.com">http://linuxtoday.com</ulink> bringer
      også sikkerhedsbrister frem sammen med andre nyheder. Det er muligt 
      at tilpasse hvilke nyheder man får, f.eks. nyheder om sikkerhed.
    </para></listitem>
    <listitem><para><ulink url="http://www.securityportal.com/">http://www.securityportal.com/</ulink>
      er et andet interessant sted for folk, som interesserer sig for sikkerhed.
    </para></listitem>
    <listitem><para><ulink url="http://lwn.net/">http://lwn.net/</ulink>
      er Linux Weekly News. Der er hver torsdag en ny udgave, hvor der
      er et afsnit om sikkerhed.
    </para></listitem>
  </itemizedlist>

<para>
Du kan finde et mindre eksempel på DNS-filerne under 'Eksempler' til
denne bog på hjemmesiden <ulink url="http://&linuxbogurl;/">&linuxbogurl;/</ulink>.
</para>

</sect1>

<!-- skrevet af Anne Jonna Armannsdottir -->
<sect1 id="chroot-dns">
<title>Sikret-DNS</title>

<!-- 
Rettelser som jeg stadig har til gode: s/chroot/sikret og sikkert
en hel masse andre ting som jeg ikke har fået øje på. 
-->

<indexterm><primary>BIND</primary></indexterm>
<indexterm><primary>BIND9</primary></indexterm>
<indexterm>
 <primary>chroot</primary>
 <secondary>DNS</secondary>
</indexterm>
<indexterm>
 <primary>DNS</primary>
 <secondary>chroot</secondary>
</indexterm>

<para>
Hvis en angriber har held med et angreb på en DNS server og 
kan udføre root kommandoer på systemet, kan konsekvenserne 
blive uoverskuelige. 
Der findes en sikkerhedsteknik til begrænsning af de skader 
en angriber kan forvolde samt til at gøre det umuligt at bruge den 
til at bryde ind i det øvrige system den kører på. Teknikken går ud på, at
afspærre angrebet i en isoleret del af filsystemet, det såkaldte 
"chroot-jail". 
For at opnå uautoriseret adgang 
kan angriberen bruge forskellige svagheder i programmer som 
har suid/sgid bitten sat. Den største fordel ved denne teknik er 
begrænsningen af adgang til sådanne programmer. I denne vejledning har
DNS-processen ingen adgang til programmer og den sættes op til at køre
som en upriviligeret bruger. Denne kombination gør livet 
<emphasis>meget</emphasis> besværligt for den eventuelle angriber. 
Når en proces køres på denne måde kan den ikke se det øvrige 
filsystem der er udenfor afgrænsningen og den vil ikke kunne
tilgå det øvrige filsystem. Dem der har brugt et ftp program for at
koble op til en ftp-server, har sandsynligvis set et "chroot-jail"
som det ser ud indenfra. 
</para>

<para>
Man skal dog huske at denne teknik ikke løser alle sikkerhedsproblemer
men blot en del af dem. Der findes sågar rapporter og vejledninger om
hvordan man som angriber bryder ud af isolationen for at tilgå 
servers virkelige filsystem. Forudsætningen for at dette lykkes er at
angriberen først skal opnå root-privilegier inden han/hun kan bryde ud
fra den isolerede del af filsystemet. For en uddybning af dette se
afsnit 3.8 i "Running Services in a chroot Environment": 
<ulink url="http://www.nic.com/~dave/SecurityAdminGuide/SecurityAdminGuide-3.html">
http://www.nic.com/~dave/SecurityAdminGuide/SecurityAdminGuide-3.html
</ulink>
Samt: 
<ulink url="http://www.linuxgazette.com/issue30/tag_chroot.html">
http://www.linuxgazette.com/issue30/tag_chroot.html
</ulink>
Denne teknik kan feks. ikke forhindre en cracker i at forespørge
dns-serveren om oplysninger til brug i forbindelse med andre angreb på
computeren. 
</para>

<para>
Den følgende vejledning gælder kun for BIND version 9 og opefter men 
noget kan dog bruges til tidligere versioner. 
Denne vejledning tager udgangspunkt i opsætningsfilerne for en
fungerende DNS-server og derfor er det oftest unødvendigt at ændre dem.
Hvis DNS-serveren køres som upriviligeret bruger og beskyttes samtidig
af en meget restriktiv dørvøgter kan man dog alligevel være nødt til
at lave en lille ændring i opsætningsfilen. Dette forklares i 
<xref linkend="dns-upriviligeret"/>.
</para>

<para>
I disse afsnit bruges variablen <filename>$JAIL</filename>
hyppigt. F.eks. skal kommandoen <command>echo $JAIL</command>
bogstaveligt skrives sådan. 
</para>

<sect2 id="opsaetning-foer-chroot">
<title>
  Indsamling af oplysninger om serverens opsætning før "chroot".
</title>

<para>
Der findes flere distributioner og de placerer filer på hver sin
måde. Det ville være for snævert hvis denne vejledning, var lavet 
således at den kun kan bruges til én af disse distributioner. 
For at sætte serveren op skal man kende navnet og placeringen på de
relevante filer i hver distribution. Vi nøjes med 4 forskellige
distributioner i håb om at det rammer tilstrækkelig bredt.
</para>

<para>
Vi skal bruge stinavnet på opstartsfilen der anvendes til at starte og
stoppe processen. 
</para>

  <itemizedlist mark="bullet" spacing="compact">
    <listitem>
      <para>
        Red Hat: <filename>/etc/rc.d/init.d/named</filename>
      </para>
    </listitem>
    <listitem>
      <para>
        Debian: <filename>/etc/init.d/bind9</filename>
      </para>
    </listitem>
    <listitem>
      <para>
        Mandrake: <filename>/etc/rc.d/init.d/named</filename>
      </para>
    </listitem>
    <listitem>
      <para>
        SuSE: <filename>/etc/init.d/named</filename>
      </para>
    </listitem>
  </itemizedlist>

<para>
Placeringen af den overordnede opsætningsfil. 
Variablen <filename>KONFIL</filename> sættes lig med denne mappe,
dog uden det første skråstreg. 
</para>
  <itemizedlist mark="bullet" spacing="compact">
    <listitem>
      <para>
         <filename>konfil=</filename>
      </para>
    </listitem>
    <listitem>
      <para>
        Red Hat, Mandrake og SuSE: <filename>etc/named.conf</filename>
      </para>
    </listitem>
    <listitem>
      <para>
        Debian: <filename>etc/bind/named.conf</filename>
      </para>
    </listitem>
  </itemizedlist>

<para>
Serverens forvalgte placering af zone filer.
Denne mappe nævnes som regel i den overordnede opsætningsfil ( se
eksemplet i <xref linkend="DNS-eks-etc-name-conf"/>) og den er angivet
som <filename>var/named</filename> i det følgende eksempel:
</para>

<programlisting>
 options { directory "/var/named";} 
</programlisting>

<para>
Variablen <filename>OPTDIR</filename> sættes lig med denne mappe,
dog uden det første skråstreg. 
</para>

  <itemizedlist mark="bullet" spacing="compact">
    <listitem>
      <para>
         <filename>optdir=</filename>
      </para>
    </listitem>
    <listitem>
      <para>
        Red Hat, Mandrake og SuSE: <filename>var/named</filename>
      </para>
    </listitem>
    <listitem>
      <para>
        Debian: <filename>var/cache/bind</filename>
      </para>
    </listitem>
  </itemizedlist>

<para>
En mappe hvor masterzone filer normalt placeres.
Denne mappe nævnes som regel i den overordnede 
opsætningsfil og den er angivet
som <filename>etc/bind</filename> i det følgende eksempel:
</para>

<programlisting>
zone "127.in-addr.arpa" {
	type master;
	file "/etc/bind/db.127";
};
</programlisting>

<para>
Variablen <filename>MASTERZD</filename> sættes lig med denne mappe,
dog uden det første skråstreg. 
</para>

  <itemizedlist mark="bullet" spacing="compact">
    <listitem>
      <para>
        <filename>masterzd=</filename>
      </para>
    </listitem>
    <listitem>
      <para>
        Red Hat, Mandrake og SuSE: <filename>var/named</filename>
      </para>
    </listitem>
    <listitem>
      <para>
        Debian: <filename>etc/bind</filename>
      </para>
    </listitem>
  </itemizedlist>

<para>
Det er et potentielt sikkerhedshul at lægge sine "master zone"-filer i
mapper som selve processen har skriverettigheder til idet en angriber
derved kunne ændre dem. 
</para>
<para>
En mappe hvor processen har skriveadgang og hvor der normalt placeres slave-zone-filer. 
Denne mappe nævnes undtagelsesvis i den overordnede opsætningsfil og den er angivet
som <filename>etc/named/slave</filename> i det følgende eksempel:
</para>

<programlisting>
  zone "intranet" in {
  type slave;
  file "/etc/named/slave/intranet";
  masters { 192.168.0.1; };
</programlisting>

<para>
Den forvalgte mappe kan sagtens bruges her hvis master filerne lægges
i en anden mappe. 
Variablen <filename>SLAVEZD</filename> sættes lig med denne mappe,
dog uden det første skråstreg. 
</para>

  <itemizedlist mark="bullet" spacing="compact">
    <listitem>
      <para>
        <filename>slavezd=</filename>
      </para>
    </listitem>
    <listitem>
      <para>
        Red Hat, Mandrake og SuSE: <filename>var/named</filename>
      </para>
    </listitem>
    <listitem>
      <para>
        Debian: <filename>var/cache/bind</filename>
      </para>
    </listitem>
  </itemizedlist>

<para>
  For at få variabler med fornuftige værdier skal man køre det
  følgende som passer for den enkelte distribution. 
</para>

<para>
   I Red Hat, Mandrake og SuSE: 
</para>

<programlisting>
<userinput>
export konfil=etc/named.conf
export optdir=var/named
export masterzd=var/named
export slavezd=var/named/slave 
</userinput>
</programlisting>

<para>
I  Debian: 
</para>

<programlisting>
<userinput>
export konfil=etc/bind/named.conf
export optdir=var/cache/bind
export masterzd=etc/bind
export slavezd=var/cache/bind
</userinput>
</programlisting>

<para>
Der kan opstå forvirring vedrørende placeringer af filer og mapper
hvilket nok ikke er særlig underligt idet der grundlæggende set er
tale om 3 forskellige filsystemrødder, nemlig systemets egentlige
rod <filename>/</filename> , den nye rod der etableres ved "chroot" og
som er angivet ved variablen <filename>$JAIL</filename> samt
DNS-serverens forvalgte mappe angivet bl.a. ved variablen 
<filename>$OPTDIR</filename>. 
</para>

<para>
Det kan forøge forvirringen at DNS-serveren fortolker
<emphasis>relative</emphasis> filnavne i forhold til serverens forvalgte
mappe mens <emphasis>absolutte</emphasis> filnavne fortolkes i forhold
til den nye rod der etableres ved "chroot".
</para>

<para>
Variablerne <filename>OPTDIR</filename> ,
<filename>MASTERZD</filename> samt <filename>SLAVEZD</filename> skal
allesammen fortolkes i forhold til filsystemets rod, nemlig 
<filename>/</filename> eller <filename>$JAIL</filename>. 
</para>

<para>
Et fiktivt eksempel hvor variablen <filename>SLAVEZD</filename> er
forskellig fra værdien i den overordnede opsætningsfil. 
<programlisting>
<userinput>
export slavezd=var/named/slave
</userinput>
</programlisting>
Mens der i den overordnede opsætningsfil bl.a. står: 
<programlisting>
  options { directory "/var/named";
  };
  zone "intranet" in {
  type slave;
  file "slave/intranet";
  masters { 192.168.0.1; };
};
</programlisting>
</para>

<para>
Variablerne <filename>$OPTDIR</filename> ,
<filename>MASTERZD</filename> samt <filename>SLAVEZD</filename> skal
allesammen fortolkes i forhold til filsystemets rod
<filename>/</filename> eller <filename>$JAIL</filename>. 
</para>


</sect2>


<sect2 id="dns-brugernavn">
<title>DNS-serverens brugernavn</title>

<indexterm>
 <primary>DNS</primary>
 <secondary>brugernavn</secondary>
</indexterm>

<para>
Nogle distributioner opretter automatisk en bruger der svarer til
DNS-serveren. Et hurtigt blik på <filename>/etc/passwd</filename> kan
afsløre en bruger der hedder f.eks. named, bind eller dns og så kan
man lave de nødvendige rettelser i kommandoerne. Her antages
at brugeren hedder <command>named</command> samt at gruppen hedder
ligeledes <command>named</command>. 
</para>

<para>
Hvis denne bruger ikke findes i forvejen, kan
den i Debian oprettes med den følgende kommando:  
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>adduser --system --group --home /opt/chroot/named named</userinput>
Adding system user named...
Adding new group named (116).
Adding new user named (116) with group named.
Creating home directory /opt/chroot/named.
</screen>

</sect2>

<sect2 id="chroot-dns-mount">
<title>Tilføjelse til filsystemtabellen</title>

<indexterm>
 <primary>mount</primary>
 <secondary>bind</secondary>
</indexterm>

<para>
DNS-serveren bruger 3 /dev filer. Disse er <filename>log</filename>, 
<filename>null</filename>, og <filename>random</filename>. 
For hver af disse /dev filer skal der oprettes en forbindelse til de 
tilsvarende filer i den isolerede del af filsystemet. Når det er gjort 
kan serveren skrive til syslog. 
</para>
<para>
Tidligere er der lavet forskellige krumspring for at DNS-serveren 
kan skrive til syslog. Med version 2.4 af kernen kom muligheden for
at løse dette let og elegant med kommandoen 
<command>mount</command>.
</para>
<para>
I det følgende er der givet 2 forskellige metoder for at opnå
forbindelse til filerne i den isolerede del af filsystemet. I den første
metode bruges en <command>mount</command> kommando for hver af 
disse <filename>/dev</filename> filer. Den første metode giver
mulighed for at afprøve opsætningen men den vil være tabt ved genstart
af computeren.
</para>

<programlisting>
<userinput>
mount --bind /dev/log $JAIL/dev/log
mount --bind /dev/random $JAIL/dev/random
mount --bind /dev/null $JAIL/dev/null
</userinput>
</programlisting>

<para>
Erfarne brugere vil vide at mount kommandoen også kan bruges i
forbindelse med filsystemtabellen <filename>/etc/fstab</filename> og
derved kan man opnå en varig opsætning af disse filer. Der tilføjes 
nogle linjer til filsystemtabellen (derfor er det tilrådeligt at man
lige tager en kopi af denne fil idet den er meget vigtig for 
systemet). Dette gøres lettest med de følgende kommandoer:  
</para>

<programlisting>
<userinput>
export jail=/opt/chroot/named &amp;&amp;
cd /etc &amp;&amp;
cp --backup=t fstab fstab.orig &amp;&amp;
echo -e '/dev/log\t'$JAIL'/dev/log\tnone \t rw,bind \t 0 0' >>fstab &amp;&amp;
echo -e '/dev/null\t'$JAIL'/dev/null\tnone \t rw,bind \t 0 0' >>fstab &amp;&amp;
echo -e '/dev/random\t'$JAIL'/dev/random\tnone \t rw,bind \t 0 0' >>fstab
</userinput>
</programlisting>

<para>
Ovenstående kommandoer er nok til at sætte computeren op så
ændringerne er varige også ved genstart. 
</para>

<para>
Hvis mappestrukturen er blevet opsat 
(Se <xref linkend="chroot-dns-mappestruktur"/>) , kan man med følgende
kommando afprøve om dette fungerer som det skal:
<screen>
<prompt>[root@linus /root]# </prompt> <userinput>
mount --all
</userinput>
</screen>
</para>

<para>
Derpå vil kommandoen <command>mount</command> afsløre de interne 
forbindelser i kernen. 
</para>

<screen>
<prompt>[root@linus /root]# </prompt> <userinput>mount</userinput>
</screen>
<programlisting>
/dev/log on /opt/chroot/named/dev/log type none (rw,bind)
/dev/null on /opt/chroot/named/dev/null type none (rw,bind)
/dev/random on /opt/chroot/named/dev/random type none (rw,bind)
</programlisting>

</sect2>

<sect2 id="chroot-dns-mappestruktur">
<title>Oprettelse af mappestruktur</title>

<para>
Der oprettes en  mappestruktur, til DNS-serveren hvori den skal 
køre isoleret. Set fra DNS-serveren vil denne mappestruktur udgøre 
hele serverens filsystem, og den vil således ikke kunne se 
den resterende del af filsystemet. Dette vil således også 
gælde for en eventuel angriber der har haft held med at tage
kontrollen over DNS-processen. 
</para>

<indexterm>
 <primary>FHS</primary>
</indexterm>
<para>
I nedenstående eksempel oprettes mappestrukturen med roden 
<filename>/opt/chroot/named</filename> hvilket er i overensstemmelse 
med standarden for filhierarki i Linux ( for flere oplysninger om FHS se: 
<ulink url="http://www.pathname.com/fhs/">
http://www.pathname.com/fhs/</ulink>). 
Hvis man ønsker en anden rod (feks. <filename>/chroot/named</filename>
kan man blot ændre variablen <filename>$JAIL</filename> i starten af
 kommandoerne. Ligeledes kan man rette brugernavnet i kommandoerne så
 det svarer til det brugernavn DNS-processen skal køre som. De følgende
 kommandoer kan klippes og klistres med et par museklik ind i et
 terminalvindue hvor root allerede har logget ind: 

<screen>
<userinput>
export jail=/opt/chroot/named &amp;&amp;
export piddir=var/run &amp;&amp;
export lokaltid=etc/localtime &amp;&amp;
export unamed=named &amp;&amp;
export gnamed=named &amp;&amp;
mkdir -p $JAIL &amp;&amp;
cd $JAIL &amp;&amp;
mkdir -p dev $OPTDIR $PIDDIR $MASTERZD $SLAVEZD &amp;&amp;
cd / 
cp $LOKALTID $JAIL/$LOKALTID  &amp;&amp;
cd $JAIL/dev &amp;&amp;
touch log null random &amp;&amp;
mount --all &amp;&amp;
cd / &amp;&amp;
cp $KONFIL $JAIL/$KONFIL &amp;&amp;
cd $MASTERZD &amp;&amp;
find . | cpio -pm  $JAIL/$MASTERZD &amp;&amp;
cd $JAIL &amp;&amp;
chown $UNAMED.$GNAMED .  $PIDDIR $SLAVEZD &amp;&amp;
chmod 700 . .. &amp;&amp;
chattr +i  dev etc var $LOKALTID
</userinput>
</screen>
</para>

<para>
Kommandoen i femte nederste linje, kopierer hele DNS-serverens 
opsætning til mappen  $JAIL/$MASTERZD . Den tredje øverste linje sætter
DNS-serveren som ejer af bl.a. mappen <filename>$JAIL</filename> ,
hvilket jo også er meget passende idé det jo er dens hjemmekatalog (det
burde det i hvertfald være hvis alting gik godt i 
<xref linkend="dns-brugernavn"/>). 
Den næstnederste linje siger adgang forbudt for uvedkommende. Den
allersidste er kommandoen <command>chattr</command> der på et Linux
filsystem (ext2, ext3 og evt. andre) kan sætte "immutable"-bitten på
bestemte filer. Filer med denne bit sat, kan ikke ændres, omdøbes
eller slettes. Dette er nødvendigt idet <literal>named</literal>
brugeren ejer mappen <filename>$JAIL</filename> og har dermed ret til
at omdøbe og slette enhver fil i denne mappe, uanset hvem ejer dem. 
Denne bit vil altså forhindre <literal>named</literal>
brugeren i at omdøbe feks. <filename>etc</filename> mappen til noget
andet og oprette en ny <filename>etc</filename> mappe med falske eller 
ændrede domæner. Dette kan named brugeren gøre 
uden videre hvis denne bit ikke er sat. Hvis en angriber opdager at
denne bit ikke er sat, kan han/hun juble ligesom Benny i "The
Julekalender" da han havde eksperimenteret med nissernes magiske bog
og udbrød i ekstase: "Sikke muligheder man! Sikke muligheder!" 
Hvis man er i gang med at eksperimentere med denne opsætning,
gør man dog klogest i at undgå denne bit idet den forbyder selv
root-brugeren at slette eller ændre hele <filename>$JAIL</filename> 
mappen. Denne bit ("immutable"-bitten) skal resettes med kommandoen
<command>chattr -i</command> før root kan ændre eller slette filer
hvor den er sat. Så er folk blevet advaret. 
</para>

<para>
Hvis der har været fejl i opsætningen eller kommandoerne kan man
fjerne mappestrukturen med nogle eller alle af de følgende kommandoer
og derpå kan man prøve endnu en gang at installere
mappestrukturen. Som den Linuxkyndige læser vil se, er der sat to små 
sikkerhedsventiler på kommandoen <command>rm -rf</command> for det
tilfælde at variablen <filename>&amp;JAIL</filename> ikke findes. 
</para>

<programlisting>
<userinput>
umount $JAIL/dev/* &amp;&amp;
cd $JAIL &amp;&amp;
chattr -i  dev etc var $LOKALTID &amp;&amp;
cd /tmp &amp;&amp;
rm -rf $JAIL findesikke 
</userinput>
</programlisting>

</sect2>


<sect2 id="chroot-dns-pars">
<title>Parametre til bind-processen.</title>

<indexterm>
 <primary>bind</primary>
 <secondary>parametre</secondary>
</indexterm>

<para>
Hvis det er lykkedes at oprette mappestrukturen samt montere
<filename>/dev</filename> filerne i foregående afsnit, er filsystemet
klart til at isolere DNS-serveren og dermed også isolere en eventuel
angriber. 
</para>

<para>
Det eneste der mangler nu er at fortælle DNS-serveren at den skal 
isoleres i denne del af filsystemet og køre som en bestemt bruger. 
Tidligere versioner af DNS-serveren måtte genoversættes 
til formålet, men BIND version 9 kan bruges uden videre ved 
at tilføje nogle parametre til kommandolinjen. Disse parametre er: 
</para>

<itemizedlist mark="bullet">
<listitem> 
 <para>
<filename>-u named</filename> processen skal køre som brugeren named i
stedet for root. 
 </para>
</listitem>

<listitem> 
 <para>
<filename>-t /opt/chroot/named</filename> processen skal isoleres i
 "chroot-jail" der er blevet klargjort.
 </para>
</listitem>
</itemizedlist>

<para>
Der tilføjes nogle linjer til opstartsfilerne: 
</para>

<programlisting>
opts="-u named -t /opt/chroot/named" &amp;&amp;
/usr/sbin/named $OPTS 
</programlisting>

<para>
For at gøre opsætningen varig, kan ovenstående sættes ind i opstartsfilen. 
</para>

<para>
I Red Hat ser opstartsfilen således ud med ovenstående ændringer: 
</para>

<programlisting>
   #!/bin/sh
   #
   # named           This shell script takes care of starting and stopping
   #                 named (BIND DNS server).
   #
   # chkconfig: - 55 45
   # description: named (BIND) is a Domain Name Server (DNS) \
   # that is used to resolve host names to IP addresses.
   # probe: true

   # Source function library.
   . /etc/rc.d/init.d/functions

   # Source networking configuration.
   . /etc/sysconfig/network

   # Check that networking is up.
   [ ${NETWORKING} = "no" ] &amp;&amp; exit 0

   [ -f /usr/sbin/named ] || exit 0

   [ -f /etc/named.conf ] || exit 0

   retval=0

   # See how we were called.
   case "$1" in
   start)
   # Start daemons.
   echo -n "Starting named: "
# *** De foelgende linjer er udkommenteret for chroot
#   daemon named 
# *** De foelgende linjer er indsat for chroot
opts="-u named -t /opt/chroot/named"
daemon named $OPTS
# *** De ovenstaaende linjer er indsat for chroot
   retval=$?
   [ $RETVAL -eq 0 ] &amp;&amp; touch /var/lock/subsys/named
   echo
   ;;
   stop)
   # Stop daemons.
   echo -n "Shutting down named: "
   killproc named
   retval=$?
   [ $RETVAL -eq 0 ] &amp;&amp; rm -f /var/lock/subsys/named
   echo
   ;;
   status)
   /usr/sbin/ndc status
   exit $?
   ;;
   restart)
   $0 stop
   $0 start
   ;;
   reload)
   /usr/sbin/ndc reload
   exit $?
   ;; 
   probe)
   # named knows how to reload intelligently; we don't want linuxconf
   # to offer to restart every time
   /usr/sbin/ndc reload &gt;/dev/null 2&gt;&1 || echo start
   exit 0
   ;;

   *)
   echo "Usage: named {start|stop|status|restart}"
   exit 1
   esac

   exit $RETVAL
</programlisting>

<para>
I Debian ser opstartsfilen således ud for bind version 9: 
</para>

<programlisting>
#!/bin/sh

path=/sbin:/bin:/usr/sbin:/usr/bin
# for a chrooted server: "-u nobody -t /var/lib/named"
opts="-u named -t /chroot/named"

test -x /usr/sbin/named || exit 0

case "$1" in
    start)
        echo -n "Starting domain name service: named"
        start-stop-daemon --start --quiet --exec \
        /usr/sbin/named -- $OPTS
        echo "."
    ;;

    stop)
        echo -n "Stopping domain name service: named"
        start-stop-daemon --stop --quiet  \
            --pidfile /var/run/named.pid --exec /usr/sbin/named
        echo "."
    ;;

    reload)
        /usr/sbin/rndc reload
    ;;

    restart|force-reload)
        $0 stop
        sleep 2
        $0 start
    ;;
    
    *)
        echo "Usage: /etc/init.d/bind {start|stop|reload|restart|force-reload}" >&2
        exit 1
    ;;
esac
exit 0
</programlisting>

<para>
Med ovenstående opstartsfil kan serveren køre efter genstart, 
uden indgreb fra administrator. 
</para>
</sect2>


<sect2 id="chroot-dns-start">
<title>Afprøvning af DNS-serveren</title>

<para>
For at starte DNS-processen uden at genstart maskinen, giver man
følgende kommando i henholdsvis Red Hat og Debian (den er desuden pyntet med lidt &amp;&amp;
krusiduller og Co. for at man kan se hvordan opstarten går): 
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/etc/rc.d/init.d/named start &amp;&amp; tail -f /var/log/messages  
</userinput>
</screen>

<screen>
<prompt>[root@linus /root]# </prompt> <userinput>/etc/init.d/bind9 start &amp;&amp; tail -f /var/log/daemon.log 
</userinput>
</screen>

<programlisting>
Jun  8 14:29:28 nse named[308]: starting BIND 9.2.0 -u named -t /opt/chroot/named \ 
-c /etc/bind/named.conf
Jun  8 14:29:28 ns named[308]: using 1 CPU
Jun  8 14:29:29 ns named[311]: loading configuration from '/etc/bind/named.conf'
Jun  8 14:29:29 ns named[311]: listening on IPv4 interface eth0, 192.168.8.1#53
Jun  8 14:29:29 ns named[311]: command channel listening on 127.0.0.1#953
Jun  8 14:29:29 ns named[311]: zone 0.in-addr.arpa/IN: loaded serial 1
Jun  8 14:29:29 ns named[311]: zone 127.in-addr.arpa/IN: loaded serial 1
Jun  8 14:29:29 ns named[311]: zone 168.192.in-addr.arpa/IN: loaded serial 2000111605
Jun  8 14:29:29 ns named[311]: zone 255.in-addr.arpa/IN: loaded serial 1
Jun  8 14:29:29 ns named[311]: zone localhost/IN: loaded serial 1
</programlisting>

<para>
Hvis alting er som det skal være, udskrives noget der ligner det
ovenstående. 
</para>

<para>
Opsætningen kan desuden afprøves ved at 
se om bind virkelig kører samt kigge i logfiler. 
 Hvis bind kører, vil kommandoen 
<command>ps aux | grep named</command> vise en eller flere 
linjer som den følgende: 
</para>

<programlisting>
named 2043 0.0  2.8 10396 1432 ?  S  03:11 0:00 /usr/sbin/named \
  -u named -t /opt/chroot/named -c /etc/bind/named.conf
</programlisting>

<para>
Ovenstående linje bekræfter at BIND kører som den upriviligerede bruger 
<filename>named</filename> og at den er isoleret i
<filename>/opt/chroot/named</filename> som hensigten var.
</para>

<para>
Den afgørende bekræftelse af opsætningen får man hvis serveren svarer
når den forepørges om forskellige domæner. Hvid den er
authoritativ/primær DNS-server for et domæne bør man selvfølgelig
forespørge DNS-serveren om dette domæne. Man kan konkludere at
"chroot" opsætningen er korrekt hvis serveren svarer. 
</para>

<para>
Hvis der er noget i vejen, kan man få  yderligere  oplysninger kan
findes i logfilen med kommandoen <command>tail
/var/log/daemon.log</command> eller <command>tail
/var/log/messages</command>. 
</para>

<para>
Hvis serveren ikke kører, bør man kigge nærmere efter om alle filer og mapper er
placeret som de skal og om der er manglende sammenhæng mellem de
filnavne der er angivet i opsætningsfilerne og de filnavne og
mappenavne der blev oprettet. 
</para>

<para>
Alle øvrige problmemer med DNS-serveren har at gøre med den generelle
opsætning i opsætningsfilerne. Yderligere oplysninger om opsætning
og test af DNS, findes i <xref linkend="om-dns"/>.
</para>

</sect2>


<sect2 id="dns-upriviligeret">
<title>DNS-serveren som upriviligeret bruger</title>
<indexterm>
 <primary>DNS</primary>
</indexterm>

<!-- 
Dette afsnit skal flyttes til nogle af de foregående afsnit idet det 
handler egentlig ikke om chroot. Jeg vil dog vente lidt med det indtil
vi har set hvordan alle disse ændringer fungerer sammen. 
--> 

<para>
Dette afsnit handler hovedsagelig om hvordan DNS-serveren 
BIND 9 opfører sig når den kører som upriviligeret bruger. 
Selve opsætningen omhandles i foregående afsnit. 
</para>

<para>
Traditionelt set, tilhører alle porte lavere end 1024 til 
root eller daemoner der kører som root. Når BIND køres som 
en upriviligeret bruger, har den ikke rettigheder til at 
sende førespørgsler til andre servere fra port 53. 
Som udgangspunkt vil den vælge et tilfældigt upriviligeret 
port at sende fra. Hvis netværket beskyttes af en dørvogter 
der udtrykkeligt specificerer hvilket port DNS-serveren 
kan sende fra, vil forespørgslerne ikke kunne komme forbi
dørvogteren. For at afhjælpe dette kan man vælge en bestemt
upriviligeret port,  f.eks. 1053 og 
sætte BIND op til kun at bruge denne port som afsenderport. 
I den overordnede opsætningsfil til BIND 
bør den nederste af de følgende linjer tilføjes i sektionen options {}:
</para>

<programlisting>
<userinput>
        listen-on port 53 { 192.168.8.1; };
        query-source address * port 1053;
</userinput>
</programlisting>

<para>
<!-- Det følgende skal skrives sammen med de foregående afsnit når
afsnittene om sikret-dns har vist sit værd --> 
I eksemplet ovenfor, har serveren IP-nummeret 
192.168.8.1 på trods af at det er en offentlig 
DNS server. Forklaringen er, at serveren ikke har fået 
tildelt et offentligt IP-nummer, men trafik til den bliver 
dirigeret til den gennem en dørvogter. 
Dørvogteren skal blot ændres så den tillader udgående trafik 
med dette source port. 
Dermed kan BIND fortsætte med at fungere bag selv den mest 
restriktive dørvogter. 
</para>
</sect2>

  <sect2 id="dns-upriviligeret-test">
   <title>Testkørsel af DNS serveren.</title>

   <!-- Dette afsnit skal flyttes til nogle af de foregående afsnit i
        det det handler egentlig ikke om chroot. Jeg vil dog vente
        lidt med det indtil vi har set hvordan alle disse ændringer
        fungerer sammen.  -->

   <indexterm>
    <primary>kommandooversigt</primary>
    <secondary>dig</secondary>
   </indexterm>

   <para>
    Hvis serveren kører, bør den kunne svare på forespørgsler. Der
    findes flere værktøj til dette men her skal nævnes det nu snart
    forældede "<command>nslookup</command>" samt
    "<command>dig</command>". Man kan bede "<command>dig</command>" om
    at forespørge en vilkårlig DNS server ved blot at angive dens
    IP-nummer med parameteren <literal>@</literal>.  I det følgende
    eksempel, skal den nyopsatte DNS-server give os oplysninger om
    domænet "sslug.dk".

<screen>
<prompt>[tyge@hven tyge]$ </prompt><userinput>dig @192.168.8.1 sslug.dk</userinput>
; &lt;&lt;&gt;&gt; DiG 9.2.0  &lt;&lt;&gt;&gt; @192.168.8.1 sslug.dk
;; global options:  printcmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;- opcode: QUERY, status: NOERROR, id: 45711
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 3, ADDITIONAL: 3

;; QUESTION SECTION:
;sslug.dk.                      IN      A

;; ANSWER SECTION:
sslug.dk.               86400   IN      A       130.228.2.150

;; AUTHORITY SECTION:
sslug.dk.               86400   IN      NS      ns.sslug.dk.
sslug.dk.               86400   IN      NS      ptah.dkuug.dk.
sslug.dk.               86400   IN      NS      ns-soa.darenet.dk.

;; ADDITIONAL SECTION:
ns.sslug.dk.            86400   IN      A       130.228.2.150
ptah.dkuug.dk.          71539   IN      A       195.215.30.66
ns-soa.darenet.dk.      71539   IN      A       130.226.1.4

;; Query time: 237 msec
;; SERVER: 192.168.8.1#53(192.168.8.1)
;; WHEN: Sat Apr 13 18:11:17 2002
;; MSG SIZE  rcvd: 161
</screen>
   </para>

   <para>
    Sådan kan man afprøve serveren ved at pege den på forskellige
    domæner. Hvid den er authoritativ/primær DNS-server for et domæne
    bør man selvfølgelig forespørge DNS-serveren om dette domæne. Man
    kan konkludere at "chroot" opsætningen er korrekt hvis serveren
    svarer.
   </para>

   <para>
    En af de ting der gør <command>dig</command> interessant
    sammenlignet med <command>nslookup</command> er at man let kan få
    fat i alle de forskellige oplysninger der ligger i DNS.  Til
    gengæld giver <command>dig</command> også en masse oplysninger man
    normalt ikke er interesseret i, så det kan være nødvendigt at
    filtrere programmets uddata lidt.
   </para>

   <para>
    Hvis man vil vide hvor post til en bestemt maskine afleveres giver
    man, udover maskinens navn, <command>dig</command> argumentet
    <literal>MX</literal>:

<screen>
<prompt>[tyge@hven tyge]$ </prompt><userinput>dig kaoslx07.nbi.dk MX</userinput>

;; &lt;&lt;&gt;&gt; DiG 9.2.1 &lt;&lt;&gt;&gt; kaoslx07.nbi.dk MX
;; global options:  printcmd
;; Got answer:
;; ->>HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 28989
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 3, ADDITIONAL: 3

;; QUESTION SECTION:
;kaoslx07.nbi.dk.               IN      MX

;; ANSWER SECTION:
kaoslx07.nbi.dk.        86400   IN      MX      10 alf.nbi.dk.

;; AUTHORITY SECTION:
nbi.dk.                 86400   IN      NS      alf.nbi.dk.
nbi.dk.                 86400   IN      NS      garm.adm.ku.dk.
nbi.dk.                 86400   IN      NS      sarastro.nbi.dk.

;; ADDITIONAL SECTION:
alf.nbi.dk.             86400   IN      A       130.225.212.55
garm.adm.ku.dk.         8272    IN      A       130.225.127.34
sarastro.nbi.dk.        86400   IN      A       130.225.212.46

;; Query time: 24 msec
;; SERVER: 130.225.212.46#53(130.225.212.46)
;; WHEN: Thu Sep  5 11:36:33 2002
;; MSG SIZE  rcvd: 164

</screen>

    Der kommer altså en hel masse data, hvoraf det eneste vi egentlig
    er interesserede i er "ANSWER SECTION".  Med tilvalget
    <literal>+short</literal> kan vi få <command>dig</command> til kun
    at give os det egentlige svar:

<screen>
<prompt>[tyge@hven tyge]$ </prompt><userinput>dig kaoslx07.nbi.dk MX +short</userinput>
10 alf.nbi.dk.
</screen>
   </para>

   <para>
    Man kan også bruge <command>dig</command> til at få oplysninger
    som maskinens IP-adresse:

<screen>
<prompt>[tyge@hven tyge]$ </prompt><userinput>dig kaoslx07.nbi.dk A +short</userinput>
130.225.212.98
</screen>

    Hvilke maskiner der står for et domænes navnetjeneste:

<screen>
<prompt>[tyge@hven tyge]$ </prompt><userinput>dig linuxlab.dk NS +short</userinput>
www.itu.dk.
ns-soa.darenet.dk.
</screen>

    Eventuelt også lidt oplysninger om selve isenkrammet:

<screen>
<prompt>[tyge@hven tyge]$ </prompt><userinput>dig kaoslx07.nbi.dk HINFO +short</userinput>
"Pentium 4/1.5GHz" "Linux 7.3/2.4.18"
</screen>

    Endelig kan man også få lidt løse uformaterede oplysninger om
    domænet:

<screen>
<prompt>[tyge@hven tyge]$ </prompt><userinput>dig nbi.dk TXT +short</userinput>
"Niels Bohr Institute, Copenhagen University"
</screen>
   </para>
  </sect2>
 </sect1>
</chapter>
