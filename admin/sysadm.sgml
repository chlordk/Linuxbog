<!-- $Id$ -->
<chapter id="systemarbejde">
<title>Systemarbejde</title>
<indexterm><primary>linuxconf</primary></indexterm>
<indexterm><primary>IP-adresser</primary><secondary>konfiguration</secondary></indexterm>
<indexterm><primary>Brugere, oprettelse</primary></indexterm>

<para>
De fleste har nok lidt svært ved, at forstå og bruge Linux'
tekstkonfigurationsfiler når de lige er startet med at bruge Linux.
Dette kan - som oftest - volde problemer, da mange mennesker jo netop
installerer Linux for at bruge de medfølgende funktioner til fil- og
printer-deling; eksempelvis på et kollegie, eller i en virksomhed.
</para>

<para>
Det kan imidlertid godt være svært, da funktionerne til
brugerstyring, netværksopsætning, indstilling af tiden osv. ofte ikke
er lige nemme at gå til. Men fortvivl ikke - der er flere grafiske
programmer, som kan hjælpe hvis du ikke vil gøre det tekstbaseret. 
</para>

<para>
I dette kapitel ser vi først nærmere på de pakkeformater, som mange
programmer distribueres i. Dernæst ser vi nærmere på de grafiske værktøjer, som nu
findes til at administrere brugere, diske, netværk, og programpakker.
</para>

<sect1 id="pakker">
<title>Pakker af data</title>

<indexterm><primary>zip</primary></indexterm>
<indexterm><primary>unzip</primary></indexterm>
<indexterm><primary>compress</primary></indexterm>
<indexterm><primary>uncompress</primary></indexterm>

<para>Linux har glimrende muligheder for at pakke programmer og
datafiler sammen svarende til zip-formatet kendt fra Windows-verdenen. 
Faktisk kan du med <command>unzip</command> udpakke
zip-filer. Du skal blot installere unzip-pakken først - se <xref
linkend="RPM">. Tilsvarende kan du have brug for at kunne udpakke en
selvudpakkende zip-fil (som kommer som en exe-fil fra Windows). Til
det kan du bruge <command>unzipsfx</command>.
</para>

<para>
Du kan teoretisk set stadig komme ud for programpakker i Z-format. De
skal udpakkes med <command>uncompress</command> (og de laves med
<command>compress</command>). På grund af bedre pakke-effektivitet
anvendes kombinationen af <command>tar</command> og
<command>gzip</command> eller <command>bzip2</command>. Dette er
nærmere omtalt i <xref linkend="tar">. Et andet alternativ som
efterhånden er en stærk standard for udbredelse af Linux-programmer i
binær form er RPM, som er omtalt i <xref linkend="RPM">.
</para>

<para>
Det kan nævnes, at <command>tar</command> historisk set er et program, man
bruger til at lime datafiler sammen, så de kan lægges ud på bånd -
deraf navnet tar som står for Tape ARchive.
</para>

<sect2 id="tar">
<title>Pakning af data med tar og gzip/bzip2</title>

<para>
I Linux/Unix-verdenen anvendes oftest tar-formatet til at samle mange
filer i én pakkefil. Denne er ikke komprimeret, men alene en samling
af filerne i én pakkefil. Har du filerne
<filename>oversigt.txt</filename>, <filename>tekstA.txt</filename> op
til <filename>tekstD.txt</filename>, som du vil pakke sammen i filen
<filename>tekster.tar</filename>, så gøres dette med:
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><USERINPUT>tar cvf tekster.tar oversigt.txt tekst[A-D].txt</USERINPUT>
oversigt.txt
tekstA.txt
tekstB.txt
tekstC.txt
tekstD.txt
<prompt>[anne@linus ~]$ </prompt><USERINPUT>ls -l oversigt.txt tekst[A-Z].txt tekster.tar</USERINPUT>
-rw-r--r-- 1 anne anne  400   mar  3 17:41 oversigt.txt
-rw-r--r-- 1 anne anne  1024  mar  3 17:41 tekstA.txt
-rw-r--r-- 1 anne anne  1024  mar  3 17:41 tekstB.txt
-rw-r--r-- 1 anne anne  1024  mar  3 17:41 tekstC.txt
-rw-r--r-- 1 anne anne  1024  mar  3 17:41 tekstD.txt
-rw-r--r-- 1 anne anne  10240 mar  3 17:41 tekster.tar
</screen>

<para>
Du kan således give alle de filnavne, der skal pakkes som det sidste
argument, og giver du et katalognavn i listen vil dette katalog - med
alle underkataloger - også blive pakket med. Som det ses af eksemplet
vil programmet <command>tar</command> vise filnavne på de filer, der
pakkes. Ønsker du ikke at se dette, skal du blot udelade option
<filename>v</filename>, dvs. brug <command>tar cf TARFILNAVN.tar
LISTE_AF_FILER</command> i stedet.
</para>

<para>
Hvis de filer du ville gemme er almindelige tekstfiler vil du i
<filename>tekster.tar</filename> direkte kunne læse dig til de enkelte
filer, som skulle lægges i pakken. Derfor vil tar-filen fylde lidt
mere end summen af de filer, der skulle gemmes. For små filer vil der
være en del ekstra fyld.
</para>

<para>
Ofte ønsker man nu at komprimere tar-filen, så den fylder
mindre. Oftest vinder man en faktor 2, men både langt mere eller noget
mindre er set i praksis. Der er flere muligheder for at komprimere,
hvor <command>gzip</command> er langt det mest udbredte.
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><USERINPUT>gzip tekster.tar</USERINPUT>
tekster.tar:               93.3% -- replaced with tekster.tar.gz     
<prompt>[anne@linus ~]$ </prompt><USERINPUT>ls -l tekster.tar.gz</USERINPUT>
-rw-r--r-- 1 anne anne  706 mar  3 17:41 tekster.tar.gz
</screen>


<para>
Programmet <command>gzip</command> fortæller at filen
<filename>tekster.tar.gz</filename> er komprimeret med 93.3% og vi ser
at filen nu kun fylder 706 bytes. Ofte vil man se at gzippede
tar-filer ikke hedder <filename>.tar.gz</filename> men den kortere
form <filename>.tgz</filename>, og de to fil-endelser betyder det
samme. 
</para>

<para>
Bemærk, at originalfilen <filename>tekster.tar</filename> nu er
væk. Kun den pakkede fil er tilbage efter <command>gzip</command>.
</para>


<para>
Ofte laver man ikke tar-filen, men springer direkte til
<filename>.tgz</filename>-formatet ved at danne pakkefilen med 
<command>z</command> (for zip) tilføjet optionerne.
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><USERINPUT>tar cvzf tekster.tgz oversigt.txt tekst[A-D].txt</USERINPUT>
oversigt.txt
tekstA.txt
tekstB.txt
tekstC.txt
tekstD.txt
93.3%
<prompt>[anne@linus ~]$ </prompt><USERINPUT>ls -l tekster.tgz</USERINPUT>
-rw-r--r-- 1 anne anne  706 mar  3 17:41 tekster.tgz
</screen>

<para>
Vi skal nu se på hvordan du udpakker dine filer igen fra pakkefilen.
Først ser vi hvad der er inde i pakken (t-option), og når vi er sikre
på hvad der vil ske, bliver filerne udpakket (x-option). Antag at vi
har placeret pakkefilen i et katalog, hvor der ikke er andre filer
end pakkefilen.
</para>
<screen>
<prompt>[anne@linus ~]$ </prompt><USERINPUT>tar tvzf tekster.tgz </USERINPUT>
-rw-r--r-- 1 anne anne  400   mar  3 17:41 oversigt.txt
-rw-r--r-- 1 anne anne  1024  mar  3 17:41 tekstA.txt
-rw-r--r-- 1 anne anne  1024  mar  3 17:41 tekstB.txt
-rw-r--r-- 1 anne anne  1024  mar  3 17:41 tekstC.txt
-rw-r--r-- 1 anne anne  1024  mar  3 17:41 tekstD.txt
<prompt>[anne@linus ~]$ </prompt><USERINPUT>tar xvzf tekster.tgz</USERINPUT>
oversigt.txt
tekstA.txt
tekstB.txt
tekstC.txt
tekstD.txt
</screen>

<para>
Igen kan v-option udelades, hvis du ikke vil have helt så meget
information præsenteret på skærmen. Det skal nævnes, at
<command>tar</command> har en stor mængde options, som kan læres lidt
efter lidt. Brug <command>man tar</command> til at komme videre. En
option du måske allerede nu kan lære er <command>-C DIR</command>, som
bruges til at pakke pakkefilen ud, svarende til at du står i kataloget 
<filename>DIR</filename> og pakker ud.
</para>


<para>
Du kan også komme ud for at folk bruger <command>bzip2</command> til
at komprimere data med i stedet for <command>gzip</command>. En fil der
ender på <filename>.bz2</filename> kan du udpakke med <command>bunzip
FILNAVN.bz2</command>. Er det en tar-fil som er pakket med
<command>bzip2</command>, kan du med en nyere version af
<command>tar</command> udpakke direkte med <command>tar xvIf
FILNAVN.tar.bz2</command>, mens man med en ældre version af
<command>tar</command> må tage den i to omgange: <command>bunzip2
FILNAVN.tar.bz2</command> og derefter <command>tar xvf
FILNAVN.tar</command>. Dog ser det ud til at man har ændret kommandoen
(i Red Hat 7.1) så man skal bruge <command>tar xvjf
FILNAVN.tar.bz2</command> ('I' erstattes af 'j').

</para>


<sect3 id="tar-flytning">
<title>Flytning af data ved brug af tar</title>
<indexterm><primary>mke2fs</primary></indexterm>
<indexterm><primary>Formatere disk</primary></indexterm>
<para>
<emphasis>Tip:</emphasis> Lad os lige tage et avanceret eksempel. Det
kan jo ske, at du løber tør for plads på din harddisk og køber en
ekstra disk. Du beslutter nu, at du vil flytte
<filename>/home</filename> over på den nye disk
(<filename>/dev/hdb1</filename>) og vil køre videre med Linux-systemet
på den gamle disk. Lad os antage, at du har partitioneret
<filename>/dev/hdb</filename> med <command>fdisk /dev/hdb</command> og
kørt <command>/sbin/mke2fs /dev/hdb1</command> for at formatere
disken.
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>mkdir /mnt/nydisk</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>mount /dev/hdb1 /mnt/nydisk</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>cd /home</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>tar cvf - . | (cd /mnt/nydisk; tar xpf -)</userinput>
</screen>

<para>
De to første linjer er blot forberedelse, så vi har den nye disk til
rådighed på <filename>/mnt/nydisk</filename>. Dernæst stiller vi os
der hvor sikkerhedskopieringen skal startes fra (gør at dette er "."). I den sidste
kommando laver vi en sikkerhedskopi til "-" dvs. til stdout, som kanaliseres videre til en
modtage-tar-kommando, der startes under
<filename>/mnt/nydisk</filename>. Denne gang tilføjes p-option for at
de udpakkede filer får samme rettigheder og ejerforhold som de oprindelige.
</para>

<para>
Først når du <emphasis>har</emphasis> tjekket at alle dine filer er
genskabt under <filename>/mnt/nydisk</filename> kan du slette dine
filer og skabe kontakt med den nye disk med
<filename>/home</filename>-filerne. Redigér
<filename>/etc/fstab</filename> så den nye disk er med:
</para>

<screen>
/dev/hdb1  /home   ext2    defaults        1 1
</screen>

<para>
Bruger du en anden partition end <filename>/dev/hdb1</filename> til
den nye disk, så skal du naturligvis erstatte dette i
<filename>/etc/fstab</filename>
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>mv /home /oldhome</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>umount /mnt/nydisk</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>mount /home</userinput>
</screen>

<para>
Hvis du kan se at alt fungerer, kan du slette den gamle
<filename>/home</filename> som nu endte på
<filename>/oldhome</filename>. Brug <command>rm -rf /oldhome</command>,
når du er helt sikker.
</para>

<para>
Det der kan gå galt her er, at man har links, som ikke peger på de
rigtige steder efter flytningen. Med <filename>/home</filename> er dette
normalt ikke tilfældet, men er det <filename>/usr</filename> du
flytter, så skal du være meget forsigtig og altid lave disse
operationer i single-user-mode (dvs. brug <command>init 1</command>).
</para>
</sect3>
</sect2>


<sect2 id="RPM">
<title>Installation af RPM-programpakker</title>
<indexterm><primary>RPM</primary></indexterm>
<para>
Gennem mange år har Unix-systemadministratoren skullet hente nye
programmer hjem med kildetekst og derefter oversætte og installere.
Det gik oftest nemt, men kunne fra tid til anden være meget svært. 
Hvad værre var, man kunne typisk ikke afinstallere programmer uden at
have 100 pct. styr på installationsfasen og styr på at andre programmer ikke
anvendte samme biblioteker. Alt i alt ganske problematisk og uden reel
mulighed for at kunne opgradere systemet løbende.
</para>

<para>
Firmaet Red Hat og andre er i de senere år gået over til at
oversætte programmer én gang for alle og så distribuere
programpakker, som indeholder binær kode, biblioteker, manualsider og
andet. Fordelen ved disse programpakker er, at systemet kan holde
styr på præcis hvad der er installeret.  Alle pakker undersøges for
afhængigheder og du kan afinstallere pakker igen, hvis andre pakker
ikke påvirkes af det. Red Hats format for programpakker kaldes RPM,
som er en forkortelse for "Red Hat Package Management", hvilket vil sige
Red Hats pakkehåndtering.
</para>

<table>
<title>Miniguide i at anvende rpm-programmet.</title>
<tgroup cols=2 align="char">
<thead>
<row>
<entry>Kommando
</entry>

<entry>
Forklaring
</entry>

</row>
</thead>

<tbody>

<row>
<entry> <userinput>rpm -i pakke_version.rpm</userinput> </entry>
<entry> Installér pakken</entry>
</row>

<row>
<entry> <userinput>rpm -ivh pakke_version.rpm</userinput> </entry>
<entry>  Installér pakken med status vist. Tilføj option --nodeps hvis
pakken skal installere uden at tjekke for manglende støttepakker.</entry>
</row>

<row>
<entry> <userinput>rpm -qip pakke_version.rpm</userinput></entry>
<entry> Viser information om den pakke, som kan installeres.</entry>
</row>

<row>
<entry> <userinput>rpm -e pakke</userinput> </entry>
<entry> Afinstallér den installerede pakke.</entry>
</row>

<row>
<entry> <userinput>rpm -q PAKKE</userinput> </entry>
<entry> Viser version af den installerede pakke.</entry>
</row>

<row>
<entry> <userinput>rpm -qi PAKKE</userinput> </entry>
<entry> Viser information om den installerede pakke.</entry>
</row>

<row>
<entry> <userinput>rpm -qf filnavn</userinput> </entry>
<entry> Viser hvilken RPM-pakke filnavnet kom fra.</entry>
</row>

<row>
<entry> <userinput>rpm -ql PAKKE</userinput> </entry>
<entry> Viser hvilke filer der blev installeret med RPM-pakken.</entry>
</row>

<row>
<entry> <userinput>rpm -qlp PAKKE.rpm</userinput> </entry>
<entry> Viser hvilke filer der er med i RPM-pakken.</entry>
</row>

<row>
<entry> <userinput>rpm -qa</userinput> </entry>
<entry> Viser alle installerede RPM-pakker.</entry>
</row>


<row>
<entry> <userinput>rpm -ql PAKKE</userinput> </entry>
<entry> Viser alle filnavne indeholdt i pakken.</entry>
</row>

<row>
<entry> <userinput>rpm -Va</userinput> </entry>
<entry> Tjek alle RPM-installerede filer for ændringer siden
installation af pakkerne.
</entry>
</row>
</tbody>
</tgroup>
</table>


<para>
Lad os illustrere styrken i RPM-programmet: Du sidder på en maskine
som systemadministrator og opdaterer alle Linux-maskinerne i dit 
netværk med én kommando - og endda med krypteret
transmission, så ingen kan lytte med. Det er simpelthen
administratorens drøm af et system. Nemt, sikkert og stabilt. Hvis
alle maskiner, der skal opgraderes, er nævnt i filen
<filename>/etc/serverlist</filename>, vil nedenstående magiske linje
(ja, det er avanceret - men sejt, ikke sandt?) opgradere vim-pakken, som
hentes fra ftp-serveren <filename>SERVER</filename>. Alle
maskiner bliver lige opgraderet i ét hug!

<screen>
<prompt>[root@linux /root]# </prompt><USERINPUT>cat /etc/serverlist | \
    xargs -l1 -i= -r ssh = rpm -U ftp://SERVER/vim-4.6-4.i386.rpm</USERINPUT>
</screen>

</para>


<para>
<indexterm><primary>rpmfind</primary></indexterm>
<indexterm><primary>Mangler filer</primary></indexterm>

<emphasis>Tip:</emphasis> Under installationen eller opgraderingen af
en RPM-pakke sker det at den klager over at man mangler nogle filer.
Det skyldes at RPM-pakken, som man er ved at installere, afhænger af
andre RPM-pakker for at fungere, dvs. RPM-pakker som man enten mangler
eller som man har, men af for gammel version. Et godt trick er at gå ind
på <ulink url="http://www.rpmfind.net/linux/RPM/">http://www.rpmfind.net/linux/RPM/</ulink>. Her
kan du søge efter RPM-pakker, men også efter filnavne og derved
oftest finde hvilke RPM-pakker du mangler.
</para>
</sect2>

<sect2 id="rpm-build">
<title>RPM for programmøren</title>
<indexterm><primary>RPM</primary><secondary>Bygge selv</secondary></indexterm>

<para>
RPM-filer opstår selvfølgelig ikke "af sig selv". Der skal
bruges et værktøj til at lave dem - nemlig det samme
<command>rpm</command>-program, som man bruger til alle de
andre RPM-funktioner.
</para>

<para>
<command>rpm</command>-programmet har en 
<emphasis>build</emphasis>-funktion, som bruges når
man skal lave sine egne rpm-filer. En 'build' består af flere
faser
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
<emphasis>prep</emphasis> - udpakning af source-filer
 </para>
</listitem>
<listitem> 
 <para>
<emphasis>setup</emphasis> - installation af patches og 
konfiguration af softwaren</para>
</listitem>
<listitem> 
 <para>
<emphasis>build</emphasis> - kompilering af softwaren</para>
</listitem>
<listitem> 
 <para>
<emphasis>install</emphasis> - installation af program-, dokumentations- og konfigurations-filer i de korrekte kataloger.
 </para>
</listitem>
<listitem> 
 <para>
<emphasis>packaging</emphasis> - sammenpakning af source og binary rpm-filer
 </para>
</listitem>
<listitem> 
 <para>
<emphasis>clean</emphasis> - oprydning
 </para>
</listitem>
</itemizedlist>

<para>
Hver af disse faser kan kontrolleres fuldt ud gennem en konfigurationsfil,
som rpm-programmet bruger til hele build-processen. Denne konfigurationsfil
kaldes en <emphasis>spec</emphasis>-fil, og er den vigtigste fil at forstå, når
man skal lave sine rpm-pakker.
</para>

<sect3 id="rpm-build-katalog-struktur">
<title>Katalogstruktur</title>

<para>
Normalt bruger rpm-programmet en katalogstruktur under
<command>/usr/src/redhat</command> til at generere rpm-filer. Man kan
bruge et andet toplevel-katalog, men /usr/src/redhat er default.
</para>

<para>Herunder er der et antal underkataloger:</para>


<itemizedlist mark="bullet">
  <listitem>

<para><command>SOURCES&nbsp;</command> - indeholder alle de kildefiler 
og patches, der bruges til build af en rpm-pakke</para>
</listitem>

  <listitem>

<para><command>SPECS</command> - her ligger spec-filen</para>

</listitem>

  <listitem>

<para><command>BUILD</command> - er et 'arbejdskatalog' hvor 
kildefilerne pakkes ud,
og selve oversættelsen finder sted</para>
</listitem>

  <listitem> 
<para><command>RPMS</command> - er der hvor de færdige
binære rpm-filer placeres.  Dette katalog har mindst to
underkataloger: <command>i386</command> til rpm-filer, der er rettet
mod i386-platformen og <command>noarch</command> til rpm-filer, der
ikke er platformsafhængige.</para>
</listitem>

  <listitem>
<para><command>SRPMS</command> - er der hvor de færdige source 
rpm-filer placeres.</para>
</listitem>
</itemizedlist>

<para>
Inden man går i gang med at lave en rpm-fil, skal man sørge
for at have source-filerne lagt ned i kataloget SOURCES og en spec-fil
i kataloget SPECS. Det kan man f.eks. gøre ved at installere en
source rpm-fil.
</para>
</sect3>    <!--   Katalog struktur -->

<sect3>
  <title>En spec-fil til ssh (Secure Shell)</title>
<para>
Der har været en del skriveri om <command>ssh</command> på sslug
mailing-listen, og for nylig er der skrevet en god webside om hvordan man bruger
dette program. ssh findes ikke i rpm-format, så det kunne være
nyttigt at bruge det som eksempel på, hvordan
man laver en spec-fil og bruger den til at lave rpm-pakker.
</para>

<para>Hele spec-filen <filename>ssh.spec</filename> ligger i 
underkataloget <filename>rpm</filename> til bogens eksempler på <ulink url="http://www.sslug.dk/linuxbog">http://www.sslug.dk/linuxbog</ulink>,
men lad os kigge på den i nogle mindre
bidder.
</para>

<screen>
Summary: Secure Shell - secure network communications
Name: ssh
Version: 1.2.25
Release: 2
Copyright: GPL
Group: Utilities/Networking
Source: ftp://sunsite.auc.dk/pub/security/ssh/ssh-1.2.25.tar.gz
Patch: ssh-1.2.25-Makefile.patch
URL: http://www.cs.hut.fi/ssh/
BuildRoot: /tmp/ssh-build

%description
Secure Shell enables you to communicate securely across on unsafe
network such as the Internet. Communication is transparently 
encrypted, and thus secured against eavesdropping. The package 
includes drop-in replacements for telnet, rlogin, rsh, rcp and
other standard networking tools.
</screen>

<para>
Starten på sådan en spec-fil er ret standardiseret. Der
er en stribe <emphasis>tags</emphasis> som man skal angive - 
det er bl.a. al den
information om pakken, som <command>rpm -i</command> kommandoen skal levere.
</para>

<para>
Rækkefølgen af de enkelte tags er ligegyldig, bare de er
der.
</para>
<itemizedlist mark="bullet">
  <listitem>

<para><emphasis>Name:</emphasis> Pakkens navn</para>

</listitem>

  <listitem>
<para><emphasis>Summary:</emphasis> En kort beskrivelse (under en linje) 
af, hvad pakken indeholder</para>

</listitem>

  <listitem>

<para><emphasis>Version:</emphasis> Programmets versionsnummer.</para>

</listitem>

  <listitem>

<para><emphasis>Release:</emphasis> RPM-pakkens 'build-nummer'
- det er uafhængigt
af selve programmets versionsnummer og bruges blot til at holde rede på
forskellige versioner af denne rpm-pakke med samme udgave af programmet
i.</para>

</listitem>

  <listitem>

<para><emphasis>Copyright:</emphasis> Hvilken copyright programmet 
er underlagt. Det er naturligvis
vigtigt at skrive, hvis programmet ikke kan distribueres frit.</para>
</listitem>

<listitem>
<para><emphasis>URL:</emphasis> Hvis der er en webside om pakken, 
kan man skrive dens URL her.</para>
</listitem>

<listitem>

<para><emphasis>Group:</emphasis> Red Hat bruger dette felt til at 
gruppere pakkerne - f.eks.
"Games", "Development tools" o.lign.
</para>
</listitem>

<listitem>

<para><emphasis>Description:</emphasis> 
Det er den lange beskrivelse af softwaren, og strækker
sig derfor over flere linjer - faktisk så mange man har lyst til,
indtil der kommer en linje som begynder med et procenttegn.</para>
</listitem>
</itemizedlist>

<para>
 <emphasis>Source</emphasis>-tag'en er vigtig - her fortæller man, hvor man har
fundet den oprindelige source-fil til programmet, gerne med en URL. Det
er en dårlig idé kun at skrive filnavnet - så ved man ikke,
hvor man skal gå hen for at finde eventuelle nyere versioner af programmet.
Bemærk: Filnavnet der står her, <emphasis>skal</emphasis> matche det filnavn,
der ligger i <filename>SOURCES</filename>-kataloget. 
Så med eksemplet, skal <filename>SOURCES</filename>-kataloget indeholde 
filen <filename>ssh-1.2.25.tar.gz</filename>.
</para>

<para> <emphasis>Patch</emphasis>-tag'en
er også vigtig - det er ændringer til
de oprindelige sources (i form af patches) som skal installeres inden 
programmet kan oversættes. Disse skal også ligge i 
<filename>SOURCES</filename>-kataloget.
I eksemplet er der kun én patch; hvis man har flere, skal de nummereres,
og så lister man dem en ad gangen (en patch uden nummer er automatisk
nummer nul):
</para>

<screen>
 Patch: foo-Makefile.patch
 Patch1: foo-glibc.patch
 Patch2: foo-wtmpfix.patch
</screen>

<para> 
<emphasis>BuildRoot</emphasis>-tag'en er ikke krævet, men anbefales. Det er
<emphasis>ikke</emphasis> det katalog, hvori programmerne bliver oversat, men derimod
det toplevel-katalog, hvori de oversatte programmer og øvrige
filer placeres i installationsfasen, inden de pakkes sammen i rpm-filerne.
Hvis ikke man bruger en BuildRoot-tag er default at filerne placeres i
de "rigtige" kataloger - <filename>/usr/bin</filename>, <filename>/etc</filename>, <filename>/usr/lib</filename> osv. Det gør
måske ikke noget, men hvis der er konfigurationsfiler involveret
er det en rigtig god idé at bruge BuildRoot-tag'en; ellers kan man nemt
risikere at komme til at overskrive sine egne omhyggeligt tilpassede konfigurationsfiler
undervejs i build-processen, eller (måske endnu værre) komme
til at inkludere sine egne konfigurationsfiler i rpm-pakken, som downloades
af tusindvis af brugere. (F.eks. havde jeg en overgang password-filerne
til min ISP liggende på ftp.sslug.dk, i en ppp-RPM-pakke). BuildRoot-tag'en
er dog ofte lidt besværlig, da man næsten altid skal
rette i programmets 'Makefile' eller installationsscript, for at de kan
finde ud af at installere pakkerne et andet sted end det normale. Men det
er ulejligheden værd.
</para>
</sect3>    <!--   En spec-fil til ssh (Secure Shell) -->

<sect3 id="prep-fasen">
  <title>prep-fasen</title>
<para>
<emphasis>prep</emphasis> (prepare) fasen består almindeligvis blot i udpakning
af source-filerne til et underkatalog under BUILD. rpm's build-funktion
kan automatisk håndtere tar-arkiver (også komprimerede), så
normalt kan man blot nøjes med at skrive:
</para>

<screen>
 %prep
</screen>

<para>
i spec-filen, og så går det af sig selv.
</para>
</sect3>    <!--   prep-fasen -->

<sect3 id="setup-fasen">
  <title>setup-fasen</title>
<para>
<emphasis>setup</emphasis>-fasen er der hvor der begynder at ske noget.
</para>

<screen>
 %setup 
 %patch -p1 
 ./configure --prefix=/usr 
</screen>

<para>
Denne fase skal gøre programmet klart til at blive oversat. Typisk
skal der først installeres de forskellige <emphasis>patches</emphasis> som man
har listet, og dernæst skal programmet måske konfigureres.
</para>

<para>
De linjer der står efter <literal>%setup</literal> 
er i virkeligheden almindelige
shell-kommandoer. Dog er der defineret nogle makroer, som rpm's build-funktion
håndterer, inden de overgives til kommandofortolkeren - en af makroerne
er <literal>%patch</literal>. 
Denne makro kører <command>patch</command>-programmet, med
patch nummer nul som input. For at apply'e patch nummer 1 skriver man <literal>%patch1</literal>,
patch nummer 2 er <literal>%patch2</literal> osv. Rækkefølgen af de
forskellige patches er ligegyldig, så længe patch-programmet
kan finde ud af det. Man kan også sagtens springe patches over, f.eks.
hvis de ikke er relevante for den platform man builder til.
</para>

<para>Inden kommandoerne i setup-fasen afvikles, sættes default-kataloget
til <filename>/usr/src/redhat/BUILD/</filename><emphasis>pakkenavn-version</emphasis>, dvs. <filename>/usr/src/redhat/BUILD/ssh-1.2.25</filename>
i eksemplet. Hvis source-arkivet ikke er blevet pakket ud til det katalognavn
(f.eks. bruger nogle source-arkiver en underscore i stedet for en
bindestreg), så angiver man det rigtige katalognavn
på <literal>%setup</literal>-linjen, f.eks.:
</para>

<screen> 
 %setup -n foobar_1.17
</screen>

<para>
hvis source-filerne er havnet i 
<filename>/usr/src/redhat/BUILD/foobar_1.17</filename>
</para>

<para>
Default-kataloget er også vigtigt at kende, når man vælger
hvilke options man giver til patch-programmet. I eksemplet kaldes patch
med <command>-p1</command>-option, fordi patch-filen indeholder <literal>ssh_1.2.25</literal> som
første element i filnavnet. Men da default-kataloget allerede er
nede i ssh-1.2.25, bruges -p1-option for at fjerne det første katalog-element
fra filnavnet, inden patch leder efter de filer den skal ændre.
</para>

<para> Konfiguration af programmet kan ske på mange måder - her er det
et configure-script, som kaldes med en option om, at filerne skal
bruge <command>/usr</command> som præfiks (default er ofte
<filename>/usr/local</filename>, som jeg foretrækker at reservere til
ikke-rpm-styrede programmer). Andre programpakker konfigureres via en
headerfil eller ved at ændre i Makefile - så må man lave en patch
mellem den oprindelige fil og den rettede, og installere den som en
patch i patch-listen.
</para>

<para>
Kommandoen <command>rpm -bp specfile</command>
vil afvikle prep- og setup-fasen,
og kan bruges til at "teste" om alle ens patches nu også kan installeres
uden problemer.
</para>
</sect3>    <!--   setup fasen -->

<sect3 id="build-fasen">
  <title>build-fasen</title>
<para>
<emphasis>build</emphasis>-fasen er der, hvor programmerne oversættes, og ofte
er det blot at køre make. Ligesom ved setup-fasen, er default-kataloget
sat til der hvor source-filerne blev pakket ud - hvis man
brugte <command>-n</command>-optionen til setup-fasen, så bliver det "husket" så man ikke
skal skrive den igen.
</para>

<screen>
 %build 
 make CFLAGS="$RPM_OPT_FLAGS" LDFLAGS="-s" 
</screen>

<para>
Her er der dog givet nogle parametre til make-kommandoen. 
CFLAGS bliver
sat til $RPM_OPT_FLAGS - det er en miljøvariabel som rpm's build-funktion
giver med til alle kommandoerne i build-fasen og som indeholder standard
"optimizer"-indstillingerne for programmer, som oversættes med rpm.
Default er det <literal>-O2 -m486 -fno-strength-reduce</literal> på 
i386-platformen.
</para>

<para>
Kommandoen <command>rpm -bc specfile</command> vil først afvikle prep- og
setup-faserne og dernæst build-fasen. Hvis man har travlt og allerede
har brugt <command>rpm -bp</command> til at afvikle prep og setup, 
kan man bruge
<command>rpm -bc --short-circuit specfile</command> for bare at køre build-fasen.
</para>

<para>Det er typisk under build-fasen, at man ramler ind i de fleste problemer.
Her kan det være nyttigt at glemme rpm et øjeblik og i stedet
gå ned i build-kataloget og køre build-kommandoerne manuelt,
indtil man har fået rettet det hele og programmet kan oversættes.
Så laver man en patch-fil med sine ændringer, tilføjer
den til spec-filen (husk at få den med i <literal>%setup</literal>-fasen!),
og går så tilbage til at builde med rpm.
</para>
</sect3>    <!--   build fasen -->

<sect3 id="install-fasen">
  <title>install fasen</title>
<para>
<emphasis>install</emphasis>-fasen
sørger for at installere de nu oversatte programmer
på de rigtige steder i katalogstrukturen. Oftest sker det med
kommandoen 'make install', da de fleste pakker heldigvis selv kan finde
ud af at installere sig selv. Men ellers må man selv skrive de kommandoer
der skal til - enten <command>cp</command>, <command>install</command> eller hvad man nu foretrækker.
</para>

<para>Det er også vigtigt, at man sørger for at de installerede
filer får korrekt ejer/gruppe-attributter og permissions.
</para>

<para>
ssh spec-filen er lidt mere kompliceret end normalt:
</para>

<screen>
 %install 
 rm -rf $RPM_BUILD_ROOT 
 mkdir -p $RPM_BUILD_ROOT 
 make install 

 %post 
 if [ ! -f /etc/ssh_host_key ]; then 
    echo "Generating ssh host key" 
    umask 022 
    /usr/bin/ssh-keygen -b 1024 -f /etc/ssh_host_key -N '' 
 fi 
</screen>

<para>
En del af kompleksiteten skyldes brugen af 
<literal>BuildRoot</literal>-tag'en -
inden filerne kan installeres, skal det sikres at det katalog vi installerer
i er tomt. Derfor slettes det først, og oprettes så bagefter
igen, hvorefter <command>make install</command> klarer resten.
Det er dog ikke sket uden at jeg måtte ændre i Makefile - men det blev
gjort med den patch, der blev installeret helt tilbage i setup-fasen.
</para>

<para> Normalt vil <command>make install</command> til ssh sørge for
at generere filen <emphasis>/etc/ssh_host_key</emphasis>, som er en
del af ssh's krypteringsnøglesæt.  Men det vil jo ikke være smart at
inkludere den fil i rpm-pakken; så ville alle som brugte rpm-pakken jo
have denne nøgle til fælles. Derfor er denne del af installationen
fjernet fra Makefile'n, og i stedet lagt ud som et <emphasis>post-install
script</emphasis> - det står under <literal>%post.</literal>
</para>

<para>
Disse kommandoer vil blive afviklet <emphasis>når brugeren installerer den
færdige rpm-pakke</emphasis>, dvs. hver eneste gang ssh-pakken
bliver installeret på en PC. Derved får hver enkelt PC sin egen
nøgle-fil.
</para>

<para><literal>%post</literal> bruges også til andre ting - hvis man laver en
rpm-pakke med et shared library i, er det en god idé at køre 
<command>/sbin/ldconfig</command>
i et post-install script; derved opdaterer man den dynamiske linkers tabel
over hvilke biblioteker der er installeret, og det kan så bruges
med det samme (uden at man skal reboote systemet).
</para>

<para>
Der er andre af sådanne scripts, som man kan definere: 
<literal>%post-un</literal>
afvikles når man afinstallerer en rpm-pakke, og der er også
pre-install (<literal>%pre</literal>) og pre-uninstall (<literal>%pre-un</literal>) scripts.&nbsp;
De kan selvfølgelig kombineres.
</para>

<para>
Install-fasen køres med kommandoen <command>rpm -bi specfile</command>
- man kan også her bruge <literal>--short-circuit</literal> 
for kun at afvikle denne fase.
</para>
</sect3>    <!--   install-fasen -->

<sect3 id="files-sektionen">
  <title>sektionen files</title>
<para>
Når filerne er blevet installeret, så er det eneste der mangler
at pakke dem sammen i en binær rpm-fil. For at kunne gøre
det, er det nødvendigt at opremse alle de filer, der er en del af
pakken - det sker i sektionen <literal>%files</literal>.
</para>

<screen>
 %files 
 /usr/bin/make-ssh-known-hosts 
 /usr/bin/ssh 
 /usr/bin/ssh-add 
 
 %config /etc/ssh_config 
 %config /etc/sshd_config 
 
 %doc COPYING INSTALL OVERVIEW TODO 
 %doc README README.CIPHERS README.SECURERPC README.SECURID README.TIS RFC TODO
</screen>

<para> 
Filerne listes blot med deres fulde path-navn (man ser bort fra
evt. <emphasis>BuildRoot</emphasis> her). Hvis en fil er en
konfigurationsfil, <emphasis>skal</emphasis> man skrive
<literal>%config</literal> før filnavnet; det fortæller
rpm-programmet, at denne fil ikke må slettes eller overskrives når man
opdaterer pakken, men skal gemmes som en <filename>.rpmsave</filename>-fil.
</para>

<para>
Dokumentationsfiler listes med <literal>%doc</literal> - og dem behøver
man ikke at bekymre sig om at skulle installere. De kopieres automatisk
fra det katalog, hvor source-arkivet er blevet udpakket. Dokumentationsfiler
placeres i <filename>/usr/doc/</filename><emphasis>pakkenavn-version</emphasis>-kataloget. Hvilke
filer man tager med som dokumentationsfiler er selvfølgelig et
skøn, men hellere lidt for mange end for få. (Når man
installerer en rpm-pakke kan man bede om ikke at få dokumentationsfilerne
med - ved at bruge <literal>--excludedocs</literal>-optionen).
</para>

<para>Bemærk, at man-pages 
<emphasis>ikke</emphasis> regnes under dokumentation -
de betragtes som en essentiel del af pakken, på lige fod med selve
programmet.
</para>

<para>Det er selvfølgelig vigtigt, at man får alle filerne med,
som hører til pakken. Det kan være nyttigt at køre
<command>make -n install</command> 
for bare at se hvad pakken foretager sig under installationen,
og holde øje med hvilke filer der kommer hvorhen.
</para>

<para>
Hvis en pakke indeholder så mange filer, at de har deres eget
underkatalog, kan man nøjes med at specificere kataloget - så
følger alle filerne deri automatisk med. Det <emphasis>skal</emphasis> dog være
et katalog, der kun bruges af den pågældende pakke - ellers
kan man få sig nogle overraskelser.
</para>

<para>Det er også muligt at angive, at et tomt katalog er en del af
pakken - det vil typisk være et katalog til f.eks. log-filer, som
der jo ikke er nogen af når man laver rpm-filen, men som skal findes
for at programmet kan køre. Det skal opremses i sektionen 
<literal>%files</literal> som
</para>

<screen>
 %dir /var/log/foobar 
</screen>

</sect3>    <!--   files-sektionen -->

<sect3 id="ultimativ-build">
  <title>Den ultimative build-kommando</title>
<para>
Når man har en spec-fil, som er helt på plads, kan man bruge
en enkelt rpm-kommando til at køre gennem hele build-fasen og generere
rpm-filerne:
</para>

<screen>
<prompt>[anne@linus ssh]$ </prompt><USERINPUT>rpm -ba --clean specfile</USERINPUT>
</screen>

<para>
Den kommando klarer det hele: Udpakning af sources, installation af
patches, konfiguration af programmet, oversættelse, installation,
sammenpakning i rpm-filer og oprydning bagefter så BUILD-kataloget
er pænt og ryddeligt.
</para>    <!--   Den ultimative build-kommando -->
</sect3>

<sect3 id="rpm-besvaer">
  <title>Sikke et besvær!</title>
<para>
Det er selvfølgelig lidt mere omstændeligt at lave en rpm-fil,
end bare at hælde et program igennem en compiler og ned i 
<filename>/usr/local</filename>.
Nogle gange kan det være frustrerende små detaljer i spec-filen,
som gør at en build fejler - og det er som regel først efter,
at din PC har tygget et par timer på at oversætte programmet...
</para>

<para>
Men min erfaring er, at den tid man bruger på at nørkle en ordentlig
spec-fil sammen, er godt givet ud. Det er <emphasis>meget</emphasis>
nemmere at holde styr på sin software, når man med en enkelt kommando
kan få en oversigt over, hvad der er installeret og hvilke filer hver
pakke indeholder.
</para>

<para>
For nogle år siden opgraderede jeg mit system fra Red Hat 4.2 til 5.1. Det var
en større opgradering, bl.a. fordi der skiftes fra de gamle
libc (version 5) til det nye glibc (version 6). Red Hats installationsprogram
klarede det meste af opgraderingen uden problemer, men jeg havde en del
software-pakker, som jeg selv havde lavet i rpm-format. Nu var det nemt
at finde dem frem - jeg kunne bruge
</para>

<screen>
 rpm -qia | grep -v Manhattan
</screen>

<para>
til at liste alle pakker på mit system og filtrere Red Hats nye
pakker fra. Det blev til en liste på 10-15 pakker, som jeg selv måtte
stå for at opdatere til glibc - og fordi jeg havde installeret dem
liggende som RPM-pakker, kunne jeg nemt gentage build-processen, og rette
de småting der skulle til for at de kunne oversættes med glibc.
Selv programmer, jeg sidst havde haft fat i for 2 år siden kunne
nemt genoversættes - fordi spec-filen indeholdt alle de oplysninger,
der skulle til for at lave programmet. Jeg behøvede ikke at granske
hukommelsen for at komme i tanke om, hvordan det nu var jeg havde konfigureret
programmet sidst.
</para>

<para>
Så bare klø på - det lønner sig.
</para>
</sect3>    <!--   Sikke et besvær! -->
</sect2>    <!--   RPM for programmøren -->


<sect2 id="bygge-rpm-fra-src-rpm">
<title>Bygge RPM ud fra SRPM</title>
<indexterm><primary>RPM</primary><secondary>Bygge ud fra .src.rpm</secondary></indexterm>
<para>
I dette afsnit ser vi på hvordan man bygger en RPM-pakke ud fra 
kilde-RPM-filen, dvs. en <filename>.src.rpm</filename>-fil. 
Man behøver faktisk ikke at være root for at bygge en RPM-fil. 
Du skal blot gøre følgende:
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><USERINPUT>cd</USERINPUT>
<prompt>[anne@linus ~]$ </prompt><USERINPUT>mkdir rpm</USERINPUT>
<prompt>[anne@linus ~]$ </prompt><USERINPUT>cd rpm</USERINPUT>
<prompt>[anne@linus rpm]$ </prompt><USERINPUT>mkdir BUILD  RPMS  SOURCES  SPECS  SRPMS</USERINPUT>
<prompt>[anne@linus rpm]$ </prompt><USERINPUT>mkdir RPMS/i386</USERINPUT>
<prompt>[anne@linus rpm]$ </prompt><USERINPUT>cd</USERINPUT>
<prompt>[anne@linus ~]$ </prompt><USERINPUT>echo "%_topdir    $HOME/rpm" > .rpmmacros</USERINPUT>
</screen>

<para>
Når du så har hentet en <filename>.src.rpm</filename>-fil, f.eks. 
<filename>dos2unix-3.1-3.src.rpm</filename>, så kan du skrive
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><USERINPUT>rpm --rebuild  dos2unix-3.1-3.src.rpm</USERINPUT>
dos2unix-3.1-3.src.rpm
Installerer dos2unix-3.1-3.src.rpm
Udfører(%prep): /bin/sh -e /var/tmp/rpm-tmp.61717
+ umask 022
+ cd /home/pto/rpm/BUILD
+ cd /home/pto/rpm/BUILD
+ rm -rf dos2unix-3.1
+ /bin/gzip -dc /home/pto/rpm/SOURCES/dos2unix-3.1.tar.gz
/home/pto/rpm/SOURCES/dos2unix-3.1.tar.gz:      + tar -xvvf -
...
</screen>

<para>
og en masse flere linjer.
</para>

<para>
Hvis alt går godt ender din 
<filename>din-nyligt-downloadede.i386.rpm</filename> i
<filename>$HOME/rpm/RPMS/i386/</filename> og du kan nu installere 
(som root) med <command>rpm -Uvh 
$HOME/rpmRPMS/i386/din-nyligt-downloadede.i386.rpm</command>.
Har du en Alpha og ikke en PC, da kommer pakken ikke til at hedde
<literal>i386</literal> men <literal>alpha</literal>
</para>
</sect2>

<sect2 id="chkconfig">
<title>chkconfig</title>

<indexterm><primary>chkconfig</primary></indexterm>

<para>
<command>chkconfig</command> er et nyttigt lille værktøj til ændringer i
services i et runlevel. Værktøjet følger med Red Hat og Mandrake.
</para>

<para>
Antag, at du har en service <command>foo</command>, som du ønsker at 
tilføje til runlevel 3. Du har installeret (måske gennem 
<command>rpm</command>) et script i kataloget 
<filename>/etc/rc.d/init.d</filename>, som følger de gængse retningslinjer
for service-scripts (dvs. at en service startes op vha. <command>foo start</command>
og lukkes ned vha. <command>foo stop</command>). Nedenfor ser du hvordan
den nye service tilføjes. Bemærk, at der er to minus-tegn foran "level"
</para>

<screen>
<prompt>[root@linus root]#</prompt> <userinput>chkconfig --level 3 foo on</userinput>
</screen>



<para>
Bliver du træt af servicen <command>foo</command> kan du naturligvis
fjerne den.  Du udskifter blot <emphasis>on</emphasis> med
<emphasis>off</emphasis>. Du kan også bruge
<command>chkconfig</command> til at tjekke hvilke runlevels en service
bliver startet op under. Nedenfor tjekker vi <command>named</command>.
Bemærk igen, at der er to minus-tegn foran "list".
</para>

<para>
<screen>
<prompt>[root@linus root]#</prompt> <userinput>chkconfig --list named</userinput>
named 0:off 1:off 2:off 3:off 4:off 5:off 6:off
</screen>
</para>
</sect2>

<sect2 id="dpkg">
<title>Installation af DEB-programpakker</title>
<indexterm><primary>dpkg</primary></indexterm>
<indexterm><primary>DEB-pakker</primary></indexterm>

<para>
Skal du installere programmer på Debian eller Corel Linux, skal du
være root. Med Corel Linux er det meningen at man skal anvende
"Applications"-&gt;"System"-&gt;"update". Der anvendes et program der hedder
<command>get_it</command>.  Her kan man sætte cd-rom, ftp- eller
http-adresser hvor updates hentes fra. Som standard er Corels ftp-update
adresse medtaget.  Man kan jo prøve at tilføje <ulink
url="ftp://ftp.dk.debian.org/debian">ftp://ftp.dk.debian.org/debian</ulink>
for at få adgang til alle Debian-pakkerne.
</para>

<para>
Du kan dog også være interesseret i at kunne styre installationen selv
fra kommandolinjen.  Nyttige kommandoer er:

<itemizedlist mark="bullet" spacing="compact">
<listitem>
  <para><command>dpkg -i PAKKE.deb</command> - installerer pakken.
 </para> 
</listitem>
<listitem>
  <para><command>dpkg -r PAKKE</command> - fjerner pakken igen.
 </para> 
</listitem>
<listitem>
  <para><command>dpkg -s PAKKE</command> - viser status for pakken.
 </para> 
</listitem>
<listitem>
  <para><command>dpkg -L PAKKE</command> - viser hvilke filer, der er i pakken.
 </para> 
</listitem>
<listitem>
  <para><command>dpkg -S FILNAVN</command> - viser hvilke pakker, 
                 som FILNAVN stammer fra.
 </para> 
</listitem>
<listitem>
  <para><command>dpkg --help</command> - viser hjælp.
 </para> 
</listitem>
</itemizedlist>
</para>

<para>
For at konfigurere pakker til dit system skal du køre kommandoen
<command>dpkg --pending --configure</command>. Det gør, at man får sat
de enkelte programmer op til maskinen efter, at pakkerne er blevet
installeret.
</para>

</sect2>
</sect1>

<sect1 id="quota">
<title>Kontrol af diskforbrug med quota</title>
<indexterm><primary>diskforbrug</primary></indexterm>
<indexterm><primary>quota</primary></indexterm>

<para>
Hvis man driver en server med mange brugere, sker det fra tid til
anden at en bruger bevidst eller ubevidst kommer til at fylde disken
op med filer. For at et sådant uheld ikke skal kunne påvirke de andre
brugere på systemet, så kan man installere quota. Quota gør det muligt
at sætte en disk forbrugs-grænse for den enkelte bruger eller evt. for
en gruppe. 
</para>

<para>
Systemet er så fleksibelt, så man yderligere kan sætte en ekstra-pulje
op, så brugeren i en fast tidsperiode (kaldet grace-perioden) godt må
"svine" med pladsen bare der ryddes op igen; f.eks. kan man have 10 MB
diskplads, men kan få lov til i en periode på to timer ekstra at bruge
yderligere 10 MB.
</para>

<para>
Både den almindelige kvote og den ekstra diskkvote virker ved at man
pludselig ikke kan gemme filer, når man er oppe på maksimum. Brugeren
må derefter selv slette filer.
</para>

<para>
Derfor er det vigtigt at systemadministratoren forklarer brugeren
hvilke grænser, der er sat og hvad man gør for at følge eget forbrug -
og endelig hvordan man rydder op.
</para>

<para>
Installation: Der skal være quota-understøttelse i Linux-kernen og
quota-pakken skal være installeret. Normalt vil en Linuxdistribution
have quota understøttet. 
</para>

<para>
Quota sættes på de enkelte partitioner,
dvs. <filename>/etc/fstab</filename> skal redigeres, så man i
<literal>options</literal>-feltet tilføjer <literal>usrquota</literal>
til hver partition man ønsker at køre quota på.
</para>

<para>
F.eks. ændres linien i <filename>/etc/fstab</filename> fra
</para>

<screen>
/dev/hda2   /home   ext2    defaults 1 1
</screen>
<para>
til
</para>
<screen>
/dev/hda2   /home   ext2    defaults,usrquota 1 1
</screen>

<para>
Til at starte quota skal der nu indekseres og quota-programmet skal startes. 
Kør følgende som root
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/bin/mount -v -o remount /home </userinput> <-- for at gen-montere den ændrede partition
<prompt>[root@linus /root]#</prompt> <userinput>/sbin/quotacheck -a -m</userinput> <--- for at lave et index over brugernes forbrug
<prompt>[root@linus /root]#</prompt> <userinput>/sbin/quotaon -uv</userinput> <--- start quota
</screen>

<para>
De to første kommandoer skal blot køres en gang for alle, og den sidste
kommando skal køres hver gang maskinen startes op (indsæt kommandoen i 
<filename>/etc/rc.local</filename> eller lign).
</para>

<para>
Nu kan man redigere grænsen for en bruger - hvis man har mange
brugere, så opret en test-bruger "quotauser" og lave følgende som
skabelon og sidenhen kan man kopiere test-brugerens quota-opsætning
til alle andre brugere.
</para>

<para>
Grænser redigeres ved at køre edquota for brugeren. Grænser
for diskforbrug anføres i kbytes, dvs. 10000 er 10MB.
Hvis quota ikke sættes op er standard-indstillingen 
at der ingen grænse er (dette anføres som et nul i opsætningsfilen). 
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/usr/sbin/edquota -u quotauser</userinput>
Disk quotas for user petoft (uid 500):
Filesystem      blocks       soft       hard     inodes     soft   hard       
/dev/hda2       695879         0          0       6741        0      0
</screen>

<para>
Ret nu tallene til det brugeren må. Det er vi-editoren som kommer frem.
</para>
<itemizedlist mark="bullet">
<listitem>
 <para>
"soft" betyder antal kilobytes som brugeren må bruge indenfor 
"grace"-perioden, hvis man ønsker at tillade dette ekstraforbrug.
 </para>
</listitem>
<listitem> 
 <para>
"hard" betyder maksimum forbrug.
 </para>
</listitem>
</itemizedlist>

<para>
Til højre for de første soft/hard står der inodes og igen soft/hard - 
dette er antal filer man kan lave. Dette bruges kun sjældent. Hvis man 
ønsker at brugeren fast kan bruge 10 MB og 10 MB ekstra under grace-perioden 
skrives
</para>

<screen>
Disk quotas for user petoft (uid 500):
Filesystem      blocks       soft       hard     inodes     soft   hard       
/dev/hda2       695879       20000      10000     6741        0      0
</screen>

<para>
Afslut med at skrive <command>:wq!</command>
</para>

<para>
Hvis man derefter vil sætte "grace"-perioden hvor ekstra diskforbrug er
tolereret, så kan dette indstilles ved at skrive
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>/usr/sbin/edquota -t</userinput> 
Grace period before enforcing soft limits for users:
Time units may be: days, hours, minutes, or seconds
Filesystem      Block grace period      Inode grace period
/dev/hda2        7 days                    7days
</screen>

<para>
For illustrations skyld kan vi sætte en grace-periode helt ned til 
to timer ved at rette teksten til
</para>

<screen>
Grace period before enforcing soft limits for users:
Time units may be: days, hours, minutes, or seconds
Filesystem      Block grace period      Inode grace period
/dev/hda2        2hours                     2hours
</screen>

<para>
Afslut med at skrive <command>:wq!</command>
</para>

<para>
Tanken med at tildele en test-bruger "quotauser" er at man relativt 
nemt kan tildele samme quota til alle almindelige brugere ved at køre
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>edquota -p quotauser `awk -F: '$3 &gt; 499 {print $1} /etc/passwd`</userinput> 
</screen>

<para>
Tricket er her at man finder alle almindelige brugere ved
bruger-nummer på 500 eller større.
</para>

<para>
Andre interessante kommandoer:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
<command>repquota -a</command> <-- viser status på diskforbrug
 </para>
</listitem>
<listitem> 
 <para>
<command>warnquota</command> <-- bruges til at alarmere brugere som er over kvote
 </para>
</listitem>
</itemizedlist>

<para>
Flere information om quota kan findes på 
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
<ulink url="http://www.linuxdoc.org/HOWTO/mini/Quota.html">http://www.linuxdoc.org/HOWTO/mini/Quota.html</ulink>
 </para>
</listitem>
<listitem> 
 <para>
<ulink url="http://www.gnuskole.dk/bog/quota.html">http://www.gnuskole.dk/bog/quota.html</ulink>
 </para>
</listitem>
</itemizedlist>

</sect1>

</chapter>


