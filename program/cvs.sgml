<!-- $Id$ -->
<chapter id="version">
<title>Versioner af software</title>

<para>
I dette kapitel vil vi se nærmere på kontrol af forskellige versioner
af software. Når der er hastig Open Source programudvikling, så vil
der findes forskellige versioner af en fil, som programmøren skal
kunne sammenligne, flette sammen og finde forskelligheder.
</para>

<sect1 id="diff">
<title>diff og patch</title>
<indexterm><primary>diff</primary></indexterm>
<indexterm><primary>forskelle mellem filer, finde</primary></indexterm>
<para>
Ofte vil programmøren skulle se hvad der er ændret mellem to versioner
af en fil. Er der måske 2000 linier kode er dette ofte umuligt at gøre
manuelt, og derfor bør du se nærmere på et par værktøjer, der kan
hjælpe dig meget. Lad os tage et eksempel på hvordan dette gøres:
</para>

<example id="ex-diff">
<title>Anvendelse af diff</title>

<para>
Først ser vi på en program-stump, vi kan kalde <filename>A_org.c</filename>.
</para>

<programlisting>
typedef struct {
  unsigned int R;
  unsigned int G;
  unsigned int B;
} RGB_Image;

typedef struct {
  int *m,*n;
  int No;
} pixar;
</programlisting>

<para>
Denne skal vi sammenligne med <filename>A.c</filename>, der ser
således ud:
</para>

<programlisting>
typedef struct {
  unsigned int R;
  unsigned int G;
  unsigned int B;
} RGB_Image;

typedef struct {
  int *m,*p;
  int No;
} pixar;

int a,b,c;
</programlisting>

<para>
De ser jo meget ens ud, de to stumper kode. For at se forskelle kører vi
</para>

<screen>
<prompt>[anne@linus ~]$  </prompt><userinput>diff A_org.c A.c</userinput>
8c8
&lt;   int *m,*n;
---
&gt;   int *m,*p;       
10a11,13
&gt;
&gt; int a,b,c;
</screen>

<para>
Vi kan se at linie 8 er ændret (8c8 betyder at linie 8 i
<filename>A_org.c</filename>er ændret i forhold til linie 8 i
<filename>A.c</filename>). Næste information (10a11,13) er at linie 11
til 13 i <filename>A.c</filename> er appended, dvs. tilføjet, i
forhold til linie 10 i <filename>A_org.c</filename>.
</para>

<para>
En lille huske-regel mht. &gt; og &lt;, så er &lt; filen til venste i
argumentlisten til <command>diff</command> og tilsvarende er &gt; filen
til højre (2. argument).
</para>

<para>
Det skal også nævnes, at man ofte laver en "unified diff", med
</para>

<screen>
<prompt>[anne@linus ~]$  </prompt><userinput>diff -u A_org.c A.c</userinput>
--- A_org.c     Tue Dec 19 21:56:30 2000
+++ A.c Tue Dec 19 21:56:43 2000
@@ -5,6 +5,8 @@
 } RGB_Image;
 
 typedef struct {
-  int *m,*n;
+  int *m,*p;
   int No;
 } pixar;
+
+int a,b,c;      
</screen>

<para>
Her er samme information gemt, men med en anden syntaks. Med - og +
vises hvilke linier som er ændret men også et par af de foregående og
efterfølgende linier kommer også med. Det gør det lidt nemmere at
finde stedet for ændringer efterfølgende.
</para>
</example>

<para>
<indexterm><primary>patches</primary></indexterm>
Ofte er der kun små ændringer mellem to versioner af en fil, og derfor
ses det ofte, at man distribuerer kildekode til en basisversion og
derefter en eller flere "patches" til programmet, som er filer som
dannes ved at køre diff mellem basisversionen og den nye version af
filen. Lad os se dette i et eksempel.
</para>

<example id="ex-patch">
<title>Anvendelse af patch</title>

<para>
Normalt anvendes patches til at sende
ændringer/opdateringer fra programmøren til andre der programmerer på samme
fil(er). Derfor er filnavne 
<filename>A_org.c</filename> og <filename>A.c</filename>, som var
anvendt i eksemplet ovenfor normalt anvendt som den originale fil i
forhold til den nye. Ofte har programmøren to fil-strukturer liggende
- den originale og den nye med ændringer.
</para>

<para>
Først lader vi programmøren af programmet danne en patch mellem
filerne <filename>A_org.c</filename> og <filename>A.c</filename>, hvor
de to filer er nævnt ovenfor:
</para>

<screen>
<prompt>[anne@linus ~]$  </prompt><userinput>diff -u A_org.c A.c &gt; A_patch</userinput>
</screen>

<para>
Bemærk at jeg her vender de to filer, som den nye er sidst!
</para>

<para>
Nu kan programmøreren sende patch-filen <filename>A_patch</filename>
til andre programmører, som kan opdatere deres
<filename>A.c</filename>.  Lad os prøve dette. Vi antager nu, at vi er
brugeren "tyge", som har en fil <filename>A.c</filename>, som er lig med
programmørens fil <filename>A_org.c</filename>
</para>

<screen>
<prompt>[tyge@linus ~]$  </prompt><userinput>patch < A_patch</userinput>
patching file A.c  
</screen>

<para>
Så nemt er det at opgrade til den opdaterede version. Ofte kan en
patch-fil indeholde rettelser til mange filer, som så automatisk opdateres.
</para>
</example>
</sect1>

<sect1 id="emacs-diff">
<title>Emacs og forskellige versioner af filer</title>
<indexterm>
 <primary>Emacs</primary>
 <secondary>forskellige versioner af filer</secondary>
</indexterm>

<para>
Som programmør (eller
skribent af Linux-bøger), sker det ofte at en person sender en ny og
opdateret version af en eller flere filer og det er så programmøren,
der skal læse rettelserne igennem og vurdere hvilke, som skal
accepteres til næste udgivelse af kildekoden.
</para>

<para>
Hvis man skal sammenligne forskellige versioner af filer, så er
tekst-editoren <command>emacs</command> eller
<command>xemacs</command> et program som virkelig er godt. Det er bare
svært at forstå som en nybegynder. Men hæng i - det betaler sig. Lad
os tage et eksempel. Start <command>emacs A_org.c A.c</command> - som
er de to filer, som blev vist ovenfor. Resultatet er vist på 
<xref linkend="emacsdiff-fig">.
</para>

<para>
Vælg nu menuen <command>Tools-&gt;Compare-&gt;Two Buffers...</command>
og accepter at buffer A er <filename>A_org.c</filename> og buffer B er
<filename>A.c</filename>. Der kommer nu en lille menu-boks frem. Prøv
at trykke <command>?</command> i denne (før musen hen til boksen -
tryk venstre mus, hvis boksen ikke er valgt - derefter
<command>?</command>). Her er alle kommandoer man kan anvende - se
dette på <xref linkend="emacsdiff2-fig">. Tryk <command>?</command>
igen for at komme tilbage til den lille ramme.  Vi skal nu blive her i
den lille ramme og kun anvende det store emacs-vindue til at se hvad
der sker.
</para>

<FIGURE ID="emacsdiff-fig" FLOAT="1">
<TITLE>Emacs med to filer indlæst</TITLE>
<GRAPHIC FILEREF="emacsdiff.&magic;"  SCALE="60"></GRAPHIC>
</FIGURE>

<FIGURE ID="emacsdiff2-fig" FLOAT="1">
<TITLE>Emacs diff kommandoer</TITLE>
<GRAPHIC FILEREF="emacsdiff2.&magic;"  SCALE="60"></GRAPHIC>
</FIGURE>

<para>
Lad os komme igang med at se hvordan vores
<filename>A_org.c</filename> kan opdateres med rettelserne i
<filename>A.c</filename>. Tryk <command>n</command> for at gå til
første rettelse. Som det kan ses på <xref linkend="emacsdiff3-fig">,
så er der et "n" fra <filename>A_org.c</filename> som er ændret til 
et "p" i <filename>A.c</filename>. Hvis man nu vil acceptere denne
rettelse og føre den fra <filename>A.c</filename> til
<filename>A_org.c</filename> så trykker vi "<command>b</command>" for at
føre rettelsen fra buffer B til buffer A. (Modsat så anvendes
"<command>a</command>" for at kopiere fra A til B). Tryk
"<command>n</command>" for næste rettelse og "<command>p</command>" for
forrige (previous). Man kan også trykke "<command>!</command>" løbende
for at opdatere tælleren i den lille boks med antal forskelle. Skriv
til sidst "<command>q</command>" for at slutte denne
sammenlignings-session. Svar dernæst "<command>y</command>" i bunden
af det store Emacs vindue. Gem filerne passende og du er færdig.
</para>

<FIGURE ID="emacsdiff3-fig" FLOAT="1">
<TITLE>Emacs viser første rettelse</TITLE>
<GRAPHIC FILEREF="emacsdiff3.&magic;"  SCALE="60"></GRAPHIC>
</FIGURE>
</sect1>

<sect1 id="xxdiff">
<title>xxdiff</title>

<para>
Hvis man ikke bruger emacs, kan man få samme funktionalitet ved at at bruge
programmet <command>xxdiff</command>	<ulink url="http://xxdiff.sourceforge.net/">http://xxdiff.sourceforge.net/</ulink>.
</para>

<para>
Programmet startes med <command>xxdiff A_org.c A.c</command>.
</para>

<FIGURE ID="xxdiff1-fig" FLOAT="1">
<TITLE>xxdiff med to filer indlæst</TITLE>
<GRAPHIC FILEREF="xxdiff1.&magic;"  SCALE="60"></GRAPHIC>
</FIGURE>


<para>
For at gå til den første forskel trykkes <command>"n"</command>.
Hvis man vil bruge udgaven til venstre trykker man 
<command>"h"</command>, og hvis man vil bruge den til højre trykker
man <command>"k"</command>. Bemærk at man har en grafisk oversigt
over sine valg i hele filen ude i højre margen.
</para>

<FIGURE ID="xxdiff2-fig" FLOAT="1">
<TITLE>Den venstre version er valgt ved første forskel</TITLE>
<GRAPHIC FILEREF="xxdiff2.&magic;"  SCALE="60"></GRAPHIC>
</FIGURE>

<para>
For at komme til næste forskel trykkes <command>"n"</command>, og
for den forrige <command>"p"</command>.
</para>

<para>
Når man er færdig med at vælge, skal man huske at gemme filen.
</para>
</sect1>


<sect1 id="Revisionskontrolsystemer">
<title>Revisionskontrolsystemer</title>
<indexterm><primary>Revisionskontrolsystemer</primary></indexterm>
<indexterm><primary>cvs</primary></indexterm>
<indexterm><primary>Versionsstyring</primary></indexterm>

 <para>
  I dette afsnit ses nærmere på revisions- og konfigurationskontrolsystemer.
  Emnet er helt nødvendigt for udviklingsprojekter der er spredt rundt omkring
  i verden - en af grundpillerne i udviklingen af Linux. Antag, at et firma
  eller universitet har behov for at kunne arbejde med udvikling af programmer
  på kryds og tværs af geografi, hvor al kommunikation skal ske via
  internettet. To spørgsmål melder sig
hurtigt til systemadministratoren: Hvad med sikkerheden og hvordan kan man
styre softwareudviklingsprocessen, når der er mange mennesker involveret,
på en sådan måde at man kan lave releases som altid kan genskabes (til
serviceformål), mens man samtidigt videreudvikler, og dermed har behov for
at kunne bakke tilbage i revisionerne i tilfælde af fejl.
</para>

<para>
De fleste danske og udenlandske softwarefirmaer har foretaget deres
udvikling baseret på udvikling i lokale netværk. Med den fortsatte
ekspansion af udviklingen af internettet og med den fortsatte udvikling,
hvor begreber som "hjemmearbejdsplads" og "distancearbejde" dukker op
oftere og oftere, må det forventes at softwareudviklingsfirmaer allerede er
igang med og i endnu højere grad vil foretage udviklingen af software
baseret på utroligt mange computere bundet sammen af internettet. Dette
stiller store krav til de revisions- og konfigurationskontrolsystemer, der
benyttes.
</para>

<para>
Styring af softwareprojekter er svært! Specielt svært bliver det når
mange arbejder på den samme kode, og hvor samtidigt kommunikationen mellem
projektdeltagerne er ringe eller besværlig. De krav, der må stilles til
revisionskontrolsystemerne i sådanne projekter er, at alle ændringer let
skal kunne tilgå andre på projektet, alle ændringer skal kunne hives ud af
koden igen, og man skal kunne se hvem der har lavet hvad på hvilket
tidspunkt.
</para>

<para>
Når man en gang har prøvet at være to eller flere som fysisk retter i
samme kode, uden af man bruger et revisionskontrolsystem, er det
indlysende at denne form for samarbejde er uproduktiv. På sådanne præmisser
er megen kommunikation og dermed megen uproduktiv tid nødvendig, hvis det
skal være muligt at opnå et tilfredsstillende resultat. En
mulighed for at øge produktiviteten er at gøre brug af et
revisionskontrolsystem.
</para>

<sect2 id="rcs-cvs-og"
<title>Baggrund for CVS</title>

<para>
Der findes mange forskellige revisionskontrolsystemer i brug idag. I
Unix verden har de mest anvendte været RCS (Revision Control System) og
SCCS (Software Configuration Control System) som enten begge eller den ene
af disse er del af standard softwaren på kommercielle Unix-systemer.
Indenfor Windows 3.11, Windows 95 og Windows NT-verdenen findes der endnu
flere, hvor en af de mest kendte er Microsoft Visual Source Safe (VSS).
Disse revisionskontrolsystemer opfylder de fleste krav til den ønskede
funktionalitet af et revisionskontrolsystem.
</para>

<para>
RCS og SCCS er bedst når man gennem flere år har fundet en arbejdsgang
og har opbygget et bibliotek af kommandofortolkerprogrammer så den valgte arbejdsgang er
implementeret igennem dette bibliotek. RCS og SCCS i sig selv nærmer
sig assemblerprogrammering i sammenligning med CVS og nogle af de
kommercielle produkter der findes. RCS og SCCS må samtidigt siges at høre
Unix verden til og er beregnet til brug ved udvikling i et lokalt miljø
hvor diske kan monteres uden sikkerhedsmæssige problemer. RCS findes vist også
til Windows.
</para>

<para>
For VSS er sagen en ganske anden. VSS er et fuldt moderne
revisionskontrolsystem og fås også til diverse Unix platforme. VSS kan også
benyttes til revisionshåndtering over store netværk (læs internettet). Det
bør dog bemærkes, at VSS er rimeligt dyrt til Windows-platformen, og endnu
dyrere til Unix-systemerne.
</para>

 <para>
  Et godt alternativ til de ikke tidssvarende Unix-revisionskontrolsystemer
  og så Windows-systemer er CVS (Concurrent Versions System). CVS er et
  multi-platform revisionskontrolsystem som har alt det man kan ønske sig af
  et sådant system.
  <!--  Også låsning af filer?  -->
  CVS er et af de systemer der er frit tilgængeligt under GNU-licensen (GPL).
  CVS findes som oversatte programmer til de mest gængse Unix-systemer på 
  <ulink url="http://prep.ai.mit.edu/pub/gnu">http://prep.ai.mit.edu/pub/gnu</ulink>
  (og afspejlinger), samt til Windows-platformen (se <ulink
  url="http://www.cygnus.com/misc/gnu-win32">http://www.cygnus.com/misc/gnu-win32</ulink>).
  Du kan for eksempel læse mere om CVS på <ulink
  url="http://www.sourcegear.com/CVS">http://www.sourcegear.com/CVS</ulink>.
 </para>

<para>
CVS er et nyere revisionskontrolsystem som oprindeligt er opstået som en
række kommandofortolkerprogrammer baseret på RCS. Personen der havde
denne store samling, Dick Grune, offentliggjorde den på nyhedsgruppen
<ulink url="news:comp.sources.unix">comp.sources.unix</ulink> engang
tilbage i 1986. Idag er hele CVS bygget op fra bunden i C, men det er
stadig Dick Grunes idé omkring konfliktløsning der er en af hjørnestenene i
CVS.
</para>

<para>
Rygterne vil vide, at Thinking Machine Coorporation (kendt for massivt
parallelle supercomputere) benyttede CVS til revisionshåndtering. Thinking
Machine Coorporation var aktive i udviklingen af CVS og den FAQ der findes
idag er stadig et levn fra den tid.
</para>

<para>
Designet og implementeringen af CVS er blev udført af Brian Berliner i
nogle tilfælde sammen med andre.
</para>
</sect2>

<sect2 id="cvs-funktionalitet">
<title>Funktionaliteten af CVS</title>

<para>
Versionskontrolsystemer bruges til at gemme den historie som ens
kildetekster (af den ene eller den anden slags) gennemløber. De fleste
versionskontrolsystemer giver endvidere mulighed for at pakke (komprimere)
kildekoden i versionskontrolsystemets database (repositorie). Endvidere
benytter langt de fleste systemer sig af at kun gemme forskelle mellem
versionerne.
</para>

<para>
Grundprincippet i CVS er, at alle brugere har deres egen version af
koden, som kan modificeres uafhængigt af andre brugere. Dette kan ske med
brugere på samme maskine eller på maskiner placeret vilkårligt langt fra
hinanden. Når ens personlige distribution af koden er stabil kan
distributionen med ændringerne lægges ind i CVS-databasen eller
sammensmeltes med de ændringer andre har lavet siden man pakkede
distributionen af koden ud. På denne måde kan man uden at begrænse andre i
deres arbejde, udføre meget arbejde (lang tids arbejde og/eller mange
ændringer) på distributionen af koden, uden at der opstår problemer med
sammensmeltningen af de lokale distributioner af koden.
</para>

<para>
CVS understøtter at databasen (samlingen af revisionskontrolsystemets
informationer inklusivt kildetekster) kan lægges på nettet uden at man
behøver at montere diske fra andre maskiner. Almindeligvis anvendes
<command>rsh</command> eller <command>ssh</command> til udveksling af
data mellem maskinerne.
</para>

<para>
CVS udmærker sig ved at have et intuitivt let forståeligt sæt af
kommandoer til at pakke distributionen ud, at opdatere ens egen
distribution med andres ændringer, at lægge ens egne ændringer i
repositoriet, at lave sideløbende grene af udviklingen af produktet, at
samle sideløbende grene af udviklingen, at hente information om historien
af ændringer osv.
</para>

<para>
Det CVS mangler i forhold til nogle af de kommercielle er en "slick"
multi-platform GUI. Et stort plus er dog, at Emacs automatisk vil genkende,
at filerne er lagt ind i CVS, og en ekstra menu giver langt de fleste af de
daglige funktioner. Fra Emacs kan man bl.a. lægge filer ind i CVS, hente
senere version af de enkelte filer, og få step-vis sammenligning af to
versioner af kildekoden.
</para>
</sect2>

<sect2 id="brug-af-cvs">
<title>Daglig brug af CVS</title>
<para>
Antag at CVS er sat op og koden er lagt ind i CVS (hvordan dette gøres
vises i <xref linkend="opsaet-cvs">). Koden kan være lagt i et
bibliotek eller mange. Hyppigt vil man anvende flere biblioteker under
et fælles start punkt, men dette er ikke nødvendigt. Til at starte
laves
</para>

<indexterm><primary>cvs</primary><secondary>checkout</secondary></indexterm>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs checkout REPOSITORYNAME</userinput>
</screen>

<para>
hvor "REPOSITORYNAME" er et navn som man selv har given den samling
kode, f.eks. signaltoolbox eller lignende. Man vil se, at alle biblioteker
som CVS kontrollerer har et nyt underbibliotek med navnet CVS, som
indeholder en smule databaseinformation, men ellers er der intet specielt
med koden.
</para>

<para>
Antag at man laver en ændring af koden som så skal kunne tilgå de andre på
projektet. Dette gøres ved at skrive
</para>

<indexterm><primary>cvs</primary><secondary>commit</secondary></indexterm>


<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs commit FILNAVN</userinput>
</screen>

<para>
hvor "FILNAVN" er den fil man har rettet i. Dette starter automatisk
brugerens default teksteditor, hvor man kort skriver, hvad der er blevet
ændret, og denne log information gemmes med filen. Hvis filnavnet undlades
vil CVS lægge alle ændrede filer ind i CVS. Nu kan de andre på projektet få
den nye kode ved at skrive
</para>

<indexterm><primary>cvs</primary><secondary>update</secondary></indexterm>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs update FILNAVN</userinput>
</screen>

<para>
Og igen kan FILNAVN udelades og de filer som ikke er ajour, vil blive
opdateret. Bemærk, at dette ikke sker automatisk, men først når man selv vil
det. På denne måde gøres det til en særskilt operation at få opgraderes
koden, hvor man må lægge mærke til hvilke ændringer som er foretaget.
CVS kan også automatisk sende en email ud til projekt gruppen når filer
bliver opdateret, så man ved hvornår dette sker (brug
<command>cvs watch</command>). Se også <xref linkend="logmails-cvs">.
</para>

<para>
Hvis der er konflikter mellem den lokale kode og den kode som er senest
i CVS-databasen, må den som har konflikten løse den (måske med hjælp fra
den som lavede ændringen) og lægge endnu en version ind hvor problemet er
løst. Faktisk foregår denne proces langt mere smidigt end man skulle tro,
og med en smule styring af hvem der laver hvad, så vil man finde meget få
problemer med projektstyringen. Hvis koden er blevet meget ødelagt ved
f.eks. en helt forkert kodeændring, så er der mulighed for at bakke tilbage
til en ældre version af koden (cvs update -r REVISIONNUMBER FILNAVN),
hvorfra der arbejdes videre.
</para>

<para>
Enhver kan og bør checke status for den enkelte fil før koden skal
lægges ind i CVS-databasen. Dete gøres med
</para>

<indexterm><primary>cvs</primary><secondary>status</secondary></indexterm>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs status FILNAVN</userinput>
</screen>

<para>
Dette vil vise versionsnummer på egen fil og det versionsnummer som
 CVS har. Et felt for hver fil vil vise om andre har committet kode, eller om
filen lokalt er ændret i forhold til CVS-databasen.
Nye filer lægges ind i CVS med to operationer, først
</para>

<indexterm><primary>cvs</primary><secondary>add</secondary></indexterm>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs add FILNAVN</userinput>
</screen>

<para>
efterfulgt af
</para>


<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs commit FILNAVN</userinput>
</screen>

<para>
På denne måde er der en ekstra sikring imod at forkerte filer kommer i
CVS-databasen. Tilsvarende kan filer fjernes fra CVS-databasen med
</para>

<indexterm><primary>cvs</primary><secondary>remove</secondary></indexterm>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs remove FILNAVN</userinput>
</screen>

<para>
efterfulgt af
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs commit FILNAVN</userinput>
</screen>

<para>
Hver af disse "cvs commit" ordrer vil starte en editor op, hvor brugeren
skal skrive (kortfattet) hvilke ændringer der er lavet siden sidst. Dette
skaber en log historie for hver fil som er guld værd, hvis man er lidt væk
fra koden og skal arbejde videre senere. Du kan også angive disse
log-beskeder direkte
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs commit -m "log-besked skrives her" FILNAVN</userinput>
</screen>

<indexterm><primary>cvs</primary><secondary>commit -m</secondary></indexterm>

<para>
For at se alle beskeder for en fil i loggen anvendes
</para>

<indexterm><primary>cvs</primary><secondary>log</secondary></indexterm>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs log FILNAVN</userinput>
</screen>

<para>
hvilket vil vise, hvem der har lavet de enkelte versioner og hvad der
i korte træk er sket. Selve kode ændringerne vises ikke her. Disse fås
ved at skrive
</para>

<indexterm><primary>cvs</primary><secondary>diff</secondary></indexterm>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs diff FILNAVN</userinput>
</screen>

<para>
og her kan et revisionsnummer tilføjes, så man kan se, hvordan den
lokale kode afviger fra koden med den valgte revision. 
</para>
</sect2>

<sect2 id="opsaet-cvs">
<title>Opsætning af CVS</title>
<indexterm><primary>cvs</primary><secondary>opsætning</secondary></indexterm>
<para>
Endelig skal nævnes hvordan man lægger et kodetræ ind i CVS-databasen
og hvordan man starter databasen.
</para>

<para>
Er det dig som skal starte CVS-databasen op for første gang, så find
et katalog (kaldet <literal>CVSROOT</literal>) som du vil anvende til CVS,
f.eks. <filename>/usr/local/CVSROOT</filename>. Sørg for at du og de
andre som skal bruge det katalog har læse og skriverettighed til det.
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>export CVSROOT=/usr/local/CVSROOT</userinput>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs init</userinput>
</screen>

<para>
og tilsvarende for tcsh/csh:
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>setenv CVSROOT /usr/local/CVSROOT</userinput>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs init</userinput>
</screen>


<para>
 Hver af brugerne skal selv føje variablen <literal>CVSROOT</literal> til
 deres <filename>~/.bashrc</filename> eller <filename>~/.profile</filename>
med syntaksen <filename>BRUGER@CVS-SERVER:KATALOG</filename>. Variablen
<literal>CVSROOT</literal> er sat når man starter en ny
kommandofortolker. Check dette ved at skrive

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>bash</userinput>
<prompt>[anne@linus ~]$</prompt> <userinput>env | grep CVS</userinput>
CVS_RSH=ssh
CVSROOT=anne@cvs.sslug.dk:/usr/local/CVSROOT
</screen>
</para>

<para>
tilsvarende skal <command>tcsh</command>-brugere åbne en nyt terminal-vindue eller
skrive <command>tcsh</command> for at checke.
</para>

<para>
I eksemplet kan man se at maskinen <filename>cvs.sslug.dk</filename>
er CVS-server og CVS-databasen (repositoriet) ligger på den maskine i
<filename>/usr/local/CVSROOT</filename>. Brugernavnet
<filename>anne@</filename> svarer til det bruger-navn, som man har på
den CVS-server (ikke nødvendigvis det samme på på egen maskine).
</para>

<para>
Da vi anvendte <command>grep</command> på alt der startede med "CVS",
fik vi også en anden variabel med <filename>CVS_RSH</filename>, som
angiver hvordan man kommunikerer med CVS-serveren. Er det en og samme
maskine udelades den variabel, og er det en anden maskine anvendes
enten secure shell (<command>ssh</command>) eller remote shell
(<command>rsh</command>). Se mere om <command>ssh</command> i bogen
"Linux - friheden til sikkerhed på internettet").
</para>

<para>
Lad os komme videre. For at du kan lægge dine filer i CVS for første
gang skal du flytte dig til hovedbiblioteket for koden. Derfra laves
</para>

<indexterm><primary>cvs</primary><secondary>import</secondary></indexterm>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cd mitsoftwareprojekt</userinput>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs import mitsoftwareprojekt VENDORTAG RELEASETAG</userinput>
</screen>

<para>
hvor <filename>mitsoftwareprojekt</filename> (se checkout) er et
beskrivende navn for kode samlingen. VENDORTAG er en streng som
beskriver den som koden kom fra og RELEASETAG er en streng som
beskriver koden status nu. Tit har disse ikke stor betydning og kan
begge sættes til f.eks. "start".
</para>

<para>
Når koden er lagt ind i CVS-databasen skal den fjernes (ja fjernes) og
der laves en <command>cvs checkout</command> for at få gendannet
kodetræet incl. de ekstra CVS-biblioteker som skal være der.
</para>

<para>
Det kan også nævnes at en række ekstra værktøjer fås til CVS, se
<ulink url="http://freshmeat.net">http://freshmeat.net</ulink> under
CVS. Et af disse er cvs2html, der findes fra <ulink
url="http://cvs.sslug.dk/cvs2html">http://cvs.sslug.dk/cvs2html</ulink>.
cvs2html anvendes til at reformattere den log information, der er
skrevet ind for hver fil ved "cvs commit", til HTML-filer. For
internetbaserede samarbejdsprojekter er dette virkeligt smart.
</para>

<para>
Det tager et par timer at komme ind i denne måde at arbejde på, men alle
kodearbejder med mere end en person vil CVS tjene dette overhead ind i
hundredefold.
</para>

<sect3 id="logmails-cvs">
<title>Få emails med log-meddelelser ved cvs commit</title>
<para>
Når flere folk arbejder sammen på et software-projekt er det
nødvendigt at man nemt kan se hvad andre personer har ændret i
filerne. Med <command>cvs watch add FILNAVN</command> vil du modtage
emails når andre laver <command>cvs commit FILNAVN</command>, men her
vil du ikke se hvad de har ændret. Du kan få en bedre føling med
ændringerne ved at bruge en lille program <filename>log</filename>,
der følger med cvs. Med det program kan du få en email med hvilke
filer, som er ændret og du få også i emailen besked om den
log-meddelelse som brugeren skrev. Hvis man indenfor projektet holder
en god stil med at skrive ordentlige log-meddelelser, så er dette super.
</para>

<para>
Lad os se på opsætningen af dette. Først skal du 
lave en fil i $CVSROOT, som dit projekt kan læse og skrive. 
</para>

<para>
<emphasis>I det følgende skal du erstatte STIL_TIL_CVS_RODEN med den fulde sti
til dit CVSROOT-katalog.</emphasis>.
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>touch STIL_TIL_CVS_RODEN/CVSROOT/commitlog</userinput>
<prompt>[anne@linus ~]$</prompt> <userinput>chgrp MINFÆLLESGRUPPE STIL_TIL_CVS_RODEN/CVSROOT/commitlog</userinput>
<prompt>[anne@linus ~]$</prompt> <userinput>chmod g+rw STIL_TIL_CVS_RODEN/CVSROOT/commitlog</userinput>
</screen>

<para>
Dernæst skal vi rode i noget af de "helligste" af cvs-opsætningen.
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs checkout CVSROOT</userinput>
<prompt>[anne@linus ~]$</prompt> <userinput>vi CVSROOT/loginfo</userinput>
</screen>

<para>
Indsæt følgende linie til sidst hvis <filename>pto@sslug.dk</filename>
skal modtage emails. Er der flere som skal modtage emails så tilføj
gerne flere <filename>-m modtager@email-adresse</filename> efter hinanden.
</para>

<screen>
DEFAULT /usr/lib/cvs/contrib/log -m pto@sslug.dk -f STIL_TIL_CVS_RODEN/CVSROOT/commitlog
</screen>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs commit -m "Jubi - det virker med log-mails" CVSROOT/loginfo</userinput>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs release -d CVSROOT</userinput>
</screen>

<para>
De sidste linier vil regenerere CVSROOT (sted hvor CVS-opsætningen er
gemt), og derefter sletter man den CVSROOT-kopi man har checket ud.
</para>

</sect3>


<sect3 id="misc-med-cvs">
<title>Diverse med CVS</title>

<para>
Det kan nævnes, at hvis Emacs indlæser en fil, der er koblet
ind i CVS, vil Emacs automatisk genkende dette og indsætte en ekstra
menu, hvorfra du på enkel vis kan sende tilføjelser til den fælles
database (selve ændringerne skal du ikke selv styre - det klarer Emacs
og CVS).
</para>


<para>
Skal man anvende en "export" version til distribution, eller blot ikke
ønsker at lave en "checkout", så er <command>cvs export
PROJEKT</command> også en mulighed. Den henter kun filerne, men ikke
CVS-informationsfilerne. Meget praktisk til at skelne mellem
udgivelse af filer ("export") i forhold til udvikler-version med fuld
CVS-information ("checkout").
</para>

<para>
Vi har tidligere vist, at projekt/kildetekst hentes med:
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs checkout projektnavn</userinput>
</screen>
 
<para>
Men for folk, der deltager i mange projekter er det interessant at man
faktisk også kan angive variablen <literal>CVSROOT</literal> som argument på
kommandolinien:
  
<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs -d USER@tux.hjemme:/usr/local/CVSROOT checkout projektnavn</userinput>
</screen>
</para>

<para>
og det skal bemærkes at man faktisk ikke anvender <literal>CVSROOT</literal>
efter at man har kørt <command>cvs checkout</command>. Hvis man ser
efter i <filename>projekt-katalog/CVS</filename>, så finder man der
tre filer, som tilhører CVS.
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
 <filename>Repository</filename> indeholder projekt-navn på CVS-serveren.
 </para>
</listitem>
<listitem> 
 <para>
<filename>Root</filename> indeholder <literal>CVSROOT</literal> for det
pågældende projekt.
 </para>
</listitem>
<listitem> 
 <para>
<filename>Entries</filename> indeholder listen over de filer og
kataloger som er registreret i CVS.
 </para>
</listitem>
</itemizedlist>

<para>
Næste trick er for dem som anvender SSH til at kommunikere med CVS.
Man kan få ssh til at understøtte komprimering i
<filename>~/.ssh/config</filename> :
</para>

<screen> 
Compression yes
CompressionLevel 6
</screen>

<para>
Men vær opmærksom på at visse servere ikke kan finde ud af at anvende
kompression, så er der uforklarlige problemer med at få forbindelse,
så slå det fra. 
</para>
                          

</sect3>
</sect2>

</sect1>
</chapter>




