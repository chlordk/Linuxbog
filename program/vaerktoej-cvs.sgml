<?xml encoding="ISO-8859-1" ?>

<sect1 id="vaerktoej-cvs">
 <title>Concurrent versioning system (CVS)</title>

 <indexterm>
  <primary>revisionskontrolsystemer</primary>
  <secondary>CVS</secondary>
 </indexterm>

 <indexterm>
  <primary>CVS</primary>
 </indexterm>

 <indexterm>
  <primary>Concurrent versioning system</primary>
 </indexterm>

 <indexterm>
  <primary>versionsstyring</primary>
  <secondary>med CVS</secondary>
 </indexterm>

 <para>
  <emphasis>Concurrent versioning system</emphasis> (CVS) er et
  versionsstyringssystem.  Dette er godt nok en programmeringsbog, men
  i virkeligheden bør man bruge et versionsstyringssystem til alle
  projekter der varer længere end et par dage eller har flere end en
  enkelt deltagende forfattere.  Versionsstyringssystemets opgave er
  at holde styr på de forskellige udgaver en fil har eksisteret i,
  hvilke ændringer der er foretaget, hvorfor, og af hvem.  Der holdes
  styr på dette i et centralt fælles <emphasis>CVS-arkiv</emphasis>,
  hvor alle ændringer registreres.  En af de ting der gør CVS til
  noget særligt blandt versionsstyringssystemer, er at det tillader at
  flere forfattere samtidig arbejder på de samme filer.  Så længe der
  ikke er flere der retter i de samme linjer, vil CVS flette de
  forskellige ændringer sammen efterhånden som de bliver lagt ind i
  det fælles arkiv.
 </para>

 <para>
  Versionsstyringssystemer som CVS er en nødvendighed for
  udviklingsprojekter der - som for eksempel Linux - foregår spredt
  rundt omkring i verden.  Antag at et firma eller universitet har
  behov for at kunne arbejde med udvikling af programmer på kryds og
  tværs af geografi hvor al kommunikation skal ske via internettet.
  To spørgsmål melder sig hurtigt til systemadministratoren: Hvad med
  sikkerheden, og hvordan kan man styre softwareudviklingsprocessen,
  når der er mange mennesker involveret, på en sådan måde at man kan
  lave udgivelser som altid kan genskabes (til serviceformål), mens
  man samtidigt videreudvikler, og dermed har behov for at kunne bakke
  tilbage gennem opdateringerne i tilfælde af fejl.
 </para>

 <para>
  De fleste danske og udenlandske softwarefirmaer har foretaget deres
  udvikling baseret på udvikling i lokale netværk.  Med den fortsatte
  ekspansion af udviklingen af internettet og med den fortsatte
  udvikling hvor begreber som "hjemmearbejdsplads" og
  "distancearbejde" dukker op oftere og oftere, må det forventes at
  softwareudviklingsfirmaer allerede er i gang med og i endnu højere
  grad vil foretage udviklingen af software baseret på utroligt mange
  computere bundet sammen af internettet.  Dette stiller store krav
  til de versionsstyringssystemer der benyttes.
 </para>

 <para>
  Styring af softwareprojekter er svært!  Specielt svært bliver det
  når mange arbejder på den samme kildetekst, og hvor samtidigt
  kommunikationen mellem projektdeltagerne er ringe eller besværlig.
  De krav der må stilles til versionsstyringssystemerne i sådanne
  projekter, er at alle ændringer let skal kunne tilgå andre på
  projektet, alle ændringer skal kunne hives ud af kildeteksten igen,
  og man skal kunne se hvem der har lavet hvad på hvilket tidspunkt.
 </para>

 <para>
  Når man en gang har prøvet at være to eller flere som fysisk retter
  i samme kildetekst uden at man bruger et versionsstyringssystem, er
  det indlysende at denne form for samarbejde er uproduktiv.  På
  sådanne præmisser er megen kommunikation og dermed megen uproduktiv
  tid nødvendig hvis det skal være muligt at opnå et
  tilfredsstillende resultat.  En mulighed for at øge produktiviteten
  er at gøre brug af et versionsstyringssystem.
 </para>

 <para>
  CVS er et multi-platform versionsstyringssystem som har alt det man
  kan ønske sig af et sådant system.  Det er frit tilgængeligt under
  GNU-licensen (GPL).  Det distribueres i køreklar form til de fleste
  unixsystemer (se <ulink
  url="http://prep.ai.mit.edu/pub/gnu">http://prep.ai.mit.edu/pub/gnu</ulink>
  og afspejlinger), såvel som til MS Windows (se <ulink
  url="http://www.cygnus.com/misc/gnu-win32">http://www.cygnus.com/misc/gnu-win32</ulink>).
  Du kan læse mere om CVS på <ulink url="http://www.cvshome.org/docs/blandy.html">http://www.cvshome.org/docs/blandy.html</ulink>,
  <ulink url="http://www.ibiblio.org/mdw/REF/CVS-BestPractices/html/index.html">http://www.ibiblio.org/mdw/REF/CVS-BestPractices/html/index.html</ulink> eller
<ulink url="http://cvsbook.red-bean.com/cvsbook.html">http://cvsbook.red-bean.com/cvsbook.html</ulink>.
 </para>

 <para>
  CVS er et forholdsvis nyt versionsstyringssystem, og dets håndtering
  af konflikter mellem forskellige udvikleres arbejde regnes for at
  være unik.
 </para>

 <sect2 id="cvs-funktionalitet">
  <title>CVS' funktionalitet</title>

  <para>
   CVS bruges til at gemme den historie som ens kildetekster (af den
   ene eller den anden slags) gennemløber.  Grundprincippet i CVS er
   at alle brugere har deres egen lokale kopi af kildeteksten som kan
   modificeres uafhængigt af andre brugere.  Dette kan ske med brugere
   på samme maskine eller på maskiner placeret vilkårligt langt fra
   hinanden.  Når ens personlige kopi af kildeteksten er stabil og
   fungerende, kan alle de opdaterede filer lægges ind i CVS-arkivet
   igen, eventuelt først efter at være blevet flettet sammen med andre
   udvikleres ændringer af de samme filer.  På denne måde kan man uden
   at begrænse andre i deres arbejde udføre meget arbejde (lang tids
   arbejde og/eller mange ændringer) på sin lokale kopi af
   kildeteksten, uden alvorlig risiko for at der opstår problemer når
   rettelserne lægges ind i det fælles arkiv.
  </para>

  <para>
   CVS understøtter at arkivet (samlingen med
   versionsstyringssystemets information, inklusive kildeteksterne)
   kan gøres tilgængelig på nettet uden at man behøver at montere
   diske fra andre maskiner.  Almindeligvis anvendes
   <command>ssh</command> til at håndtere sikker udveksling af data
   mellem programmørernes maskiner og det centrale arkiv.
  </para>

  <para>
   CVS udmærker sig ved at have et sæt af
   kommandoer til at pakke distributionen ud, at opdatere ens egen
   distribution med andres ændringer, at lægge ens egne ændringer i
   arkivet, at lave sideløbende grene af udviklingen af
   produktet, at samle sideløbende grene af udviklingen, at hente
   information om historien af ændringer osv.
  </para>

  <para>
   Det er værd at bemærke at
   tekstbehandlingsprogrammet Emacs automatisk vil bemærke det hvis
   du redigerer filer der ligger i et CVS-arkiv. Det vil så vise en
   ekstra menu der giver adgang langt de fleste af de daglige
   CVS-funktioner. Fra Emacs kan man bl.a. lægge filer ind i CVS,
   hente senere udgaver af de enkelte filer, og få sammenlignet
   forskellige udgaver af samme fil.
  </para>
 </sect2>

 <sect2 id="brug-af-cvs">
  <title>Daglig brug af CVS</title>

  <para>
   Hvis vi går ud fra at andre har taget sig af at lægge filerne fra
   et projekt du skal til at arbejde på i et CVS-arkiv (se <xref
   linkend="opsaet-cvs"/>, hvis du selv skal gøre det), er det
   forholdsvis enkelt at komme i gang.  Du skal blot kende CVS-arkivets
   adresse og projektets navn i arkivet.  De første tre af de følgende
   eksempler viser hvordan du går i gang med at arbejde med filer der
   ligger i et CVS-arkiv, afhængigt af hvilken form for adgang du har
   til det (<xref linkend="cvs-kom-i-gang-lokalt"/>, <xref
   linkend="cvs-kom-i-gang-anonym"/> og <xref
   linkend="cvs-kom-i-gang-ssh"/>).  Dernæst følger eksempler der
   viser hvordan du opdaterer din personlige kopi af arkivet (<xref
   linkend="cvs-kom-i-gang-update"/>), hvordan du lægger rettede filer
   tilbage i det fælles arkiv (<xref
   linkend="cvs-kom-i-gang-commit"/>), hvordan du tilføjer filer (<xref
   linkend="cvs-kom-i-gang-add"/>), hvordan du sletter filer (<xref
   linkend="cvs-kom-i-gang-rm"/>), og hvordan du lægger en rettet fil
   tilbage i det fælles arkiv direkte inde fra Emacs (<xref
   linkend="cvs-commit-emacs"/>).
  </para>

  <example id="cvs-kom-i-gang-lokalt">
   <title>
    Gå i gang med at <emphasis>bruge</emphasis> et lokalt CVS-arkiv
   </title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>kom i gang med at bruge et lokalt arkiv</secondary>
   </indexterm>

<screen>
<prompt>hven% </prompt><userinput>cvs \
-d /usr/local/CVSROOT checkout webspell</userinput>
</screen>

   <itemizedlist>
    <listitem>
     <para>
      "-d /usr/local/CVSROOT" betyder at det CVS-arkiv projektet skal
      hentes fra, ligger i kataloget
      <filename>/usr/local/CVSROOT</filename> på den maskine du
      arbejder på.
     </para>
    </listitem>

    <listitem>
     <para>
      "checkout" betyder at du vil have oprettet en kopi af et
      projekt der ligger i det førnævnte CVS-arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Og endelig er "webspell" navnet på det projekt vi vil have en
      kopi af.
     </para>
    </listitem>
   </itemizedlist>
  </example>

  <example id="cvs-kom-i-gang-anonym">
   <title>Anonym brug af et CVS-arkiv på nettet</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>kom i gang med at bruge et arkiv på nettet</secondary>
   </indexterm>

<screen>
<prompt>hven% </prompt><userinput>echo "update -dP" &gt;&gt; ~/.cvsrc</userinput>
<prompt>hven% </prompt><userinput>cvs \
-d :pserver:anonymous@anoncvs.kde.org:/home/kde checkout kde-i18n</userinput>
</screen>

   <para>
    Den første kommando sikrer blot at <command>cvs</command> kan
    forstå KDE-projektets CVS-tjener. Betragt det i denne sammenhæng
    blot som hvid magi.
   </para>

   <itemizedlist>
    <listitem>
     <para>
      "-d :pserver:anonymous@anoncvs.kde.org:/home/kde" betyder at
      det CVS-arkiv projektet skal hentes fra, ligger i
      kataloget <filename>/home/kde</filename> på maskinen
      "anoncvs.kde.org", og at du vil hente det som en anonym bruger.
     </para>
    </listitem>

    <listitem>
     <para>
      "checkout" betyder at du vil have oprettet en kopi af et
      projekt der ligger i det førnævnte CVS-arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Og endelig er "kde-i18n" navnet på det projekt vi vil have en
      kopi af.  I dette konkrete tilfælde er det oversættelser af KDE
      (menutekster og brugsanvisninger) til forskellige sprog.
     </para>
    </listitem>
   </itemizedlist>
  </example>

  <example id="cvs-kom-i-gang-ssh">
   <title>Brug af et CVS-arkiv på nettet over SSH</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>kom i gang med at bruge et arkiv på nettet over SSH</secondary>
   </indexterm>

<screen>
<prompt>hven% </prompt><userinput>export CVS_RSH=ssh</userinput>
</screen>

   <para>
    Denne kommando sætter en variabel der fortæller
    <command>cvs</command> at kommunikation over nettet skal kunne ske
    med SSH-protokollen (der er krypteret og dermed sikrer mod
    aflytning af adgangskoder og data).  Bemærk at variablen også skal
    være sat når du senere vil opdatere din kopi af projektet eller
    vil lægge en rettet fil ind i CVS-arkivet.  Det kan du hurtigt
    sikre med kommandoen <command>echo "export CVS_RSH=ssh" &gt;&gt;
    ~/.zshrc</command>.
   </para>

   <indexterm>
    <primary>CVS</primary>
    <secondary>checkout</secondary>
   </indexterm>

<screen>
<prompt>hven% </prompt><userinput>cvs \
-d tyge@cvs.sslug.dk:/usr/local/CVSROOT checkout linuxbog</userinput>
</screen>

   <itemizedlist>
    <listitem>
     <para>
      "-d tyge@cvs.sslug.dk:/usr/local/CVSROOT" betyder 
      at det CVS-arkiv projektet skal hentes fra, ligger i kataloget
      <filename>/usr/local/CVSROOT</filename> på maskinen
      "cvs.sslug.dk", og at du vil hente det som brugeren "tyge".
     </para>
    </listitem>

    <listitem>
     <para>
      "checkout" betyder at du vil have oprettet en kopi af et
      projekt der ligger i det førnævnte CVS-arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Og endelig er "linuxbog" navnet på det projekt vi vil have en
      kopi af.  I dette konkrete tilfælde er det hele bogserien "Linux
      - Friheden til at vælge".
     </para>
    </listitem>
   </itemizedlist>
  </example>

  <example id="cvs-kom-i-gang-update">
   <title>Opdatér din personlige kopi af et CVS-arkiv</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>opdatér personlig kopi</secondary>
   </indexterm>

   <indexterm>
    <primary>CVS</primary>
    <secondary>update</secondary>
   </indexterm>

<screen>
<prompt>hven% </prompt><userinput>cd webspell/</userinput>
<prompt>hven% </prompt><userinput>cvs update -d</userinput>
</screen>

   <itemizedlist>
    <listitem>
     <para>
      Du skal stå <emphasis>i</emphasis> kataloget med din lokale kopi
      af CVS-arkivet for at kunne opdatere filerne. Ovenfor bliver
      det gjort med kommandoen <command>cd webspell</command>.
     </para>
    </listitem>

    <listitem>
     <para>
      Argumentet "update" betyder at du vil have
      <emphasis>opdateret</emphasis> den personlige kopi af et
      CVS-arkiv der allerede ligger i det katalog du står i.
      Argumentet "-d" gør at også nye underkataloger bliver opdateret.
      Tilføj yderligere "-C" hvis eventuelle egne rettelser skal
      overskrives af CVS-arkivets version.
     </para>
    </listitem>
   </itemizedlist>
  </example>

  <example id="cvs-kom-i-gang-commit">
   <title>Læg en rettet fil tilbage i det fælles CVS-arkiv</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>læg en rettelse tilbage i det fælles arkiv</secondary>
   </indexterm>

   <para>
    Vi antager nu at vi som efter forrige eksempel står i kataloget
    med den personlige kopi af CVS-arkivet, og at vi har rettet en
    HTML-syntaksfejl i filen <filename>tjek.php</filename>.
   </para>

   <indexterm>
    <primary>CVS</primary>
    <secondary>commit</secondary>
   </indexterm>

<screen>
<prompt>hven% </prompt><userinput>cvs commit \
-m 'validator.w3.org brokkede sig' tjek.php</userinput>
</screen>

   <itemizedlist>
    <listitem>
     <para>
      "commit" betyder at du vil kopiere din rettede udgave af en fil
      ind i det fælles CVS-arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      "-m 'validator.w3.org brokkede sig'" betyder at rettelserne i
      CVS-arkivets logbog skal have kommentaren "validator.w3.org
      brokkede sig".
     </para>
    </listitem>

    <listitem>
     <para>
      Og endelig er "tjek.php" navnet på den fil du har rettet og vil
      kopiere ind i det fælles arkiv.
     </para>
    </listitem>
   </itemizedlist>
  </example>

  <example id="cvs-kom-i-gang-add">
   <title>Tilføj en ny fil til et CVS-arkiv</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>tilføj en ny fil</secondary>
   </indexterm>

   <indexterm>
    <primary>CVS</primary>
    <secondary>add</secondary>
   </indexterm>

   <para>
    Hvis vi nu har skrevet en ny fil ved navn "tak.html", og den ligger
    sammen med vores personlige kopi af projektet, kan vi tilføje den
    med kommandoerne:

<screen>
<prompt>hven% </prompt><userinput>cvs add tak.html</userinput>
<prompt>hven% </prompt><userinput>cvs commit -m 'lidt almindelig høflighed' tak.html</userinput>
</screen>
   </para>

   <itemizedlist>
    <listitem>
     <para>
      "add" betyder at du vil føje din rettede udgave af en fil til
      det fælles CVS-arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Og endelig er "tak.html" navnet på den fil du har skrevet og vil
      føje til det fælles arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Efter at "tak.html" er blevet føjet til arkivet, bruges "cvs
      commit" til at aktivere tilføjelsen.
     </para>
    </listitem>
   </itemizedlist>
  </example>

  <example id="cvs-kom-i-gang-rm-katalog">
   <title>Fjern et helt katalog i et CVS-arkiv</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>fjerne katalog</secondary>
   </indexterm>

   <para>
    CVS er ikke ret god til at slette kataloger. Måden at håndtere
    sletning af hele underkataloger er at slette alle filer i 
    kataloget og derefter køre <command>cvs update -d -P</command>.
    Her vil <literal>-d</literal> gøre at kataloger opdateres med, og 
    <literal>-P</literal> er at fjerne ("prune") tomme kataloger.
   </para>

   <para>
    I nedenstående eksempel fjerner vi <filename>mit_katalog</filename>
    som er et underkatalog af <filename>projekt</filename>.
   </para>

<screen>
<prompt>hven% </prompt><userinput>cd mit_katalog</userinput>
<prompt>hven% </prompt><userinput>ls</userinput>
CVS      Makefile    prg.c      prg.h
<prompt>hven% </prompt><userinput>rm prg.c prg.h Makefile</userinput>
<prompt>hven% </prompt><userinput>cvs remove prg.c prg.h Makefile</userinput>
<prompt>hven% </prompt><userinput>cvs commit -m "Farvel til gamle filer"</userinput>
<prompt>hven% </prompt><userinput>cd ..</userinput>
<prompt>hven% </prompt><userinput>cvs update -d -P</userinput>
</screen>
  </example>

  <example id="cvs-kom-i-gang-rm">
   <title>Fjern en fil fra et CVS-arkiv</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>fjern en fil</secondary>
   </indexterm>

   <indexterm>
    <primary>CVS</primary>
    <secondary>remove</secondary>
   </indexterm>

   <para>
    Vi har nu eksperimenteret lidt med en fil "<filename>tjek-eksp.php</filename>" og
    fundet ud af at der alligevel ikke er brug for den i projektet, så
    vi vil fjerne den fra den synlige del af CVS-arkivet (arkivet
    husker alle ændringer, så du vil stadig kunne gå tilbage til en
    udgave hvor filen fandtes).  Det klares med kommandoerne:
<screen>
<prompt>hven% </prompt><userinput>rm -f tjek-eksp.php</userinput>
<prompt>hven% </prompt><userinput>cvs remove tjek-eksp.php</userinput>
<prompt>hven% </prompt><userinput>cvs commit -m 'det gik ikke' tjek-eksp.php</userinput>
</screen>
   </para>

   <itemizedlist>
    <listitem>
     <para>
      CVS vil ikke fjerne en fil fra arkivet hvis du stadig har en
      kopi af den i din personlige kopi af CVS-arkivet, så vi starter
      med kommandoen <command>rm -f tjek-eksp.php</command> der
      fjerner filen fra kataloget.
     </para>
    </listitem>

    <listitem>
     <para>
      "remove" betyder at du vil fjerne filen fra det fælles CVS-arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Og endelig er "<filename>tjek-eksp.php</filename>" navnet på den fil der skal fjernes
      fra det fælles arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Efter at "<filename>tjek-eksp.php</filename>" er blevet slettet fra
      arkivet, bruges
      "cvs commit" til at aktivere sletningen.
     </para>
    </listitem>
   </itemizedlist>

  </example>


  <example id="cvs-commit-emacs">
   <title>
    Læg en rettet fil tilbage i det fælles arkiv direkte inde fra
    Emacs
   </title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>og Emacs</secondary>
   </indexterm>

   <indexterm>
    <primary>Emacs</primary>
    <secondary>og CVS</secondary>
   </indexterm>

   <para>
    Hvis du har rettet i en fil fra et CVS-arkiv i Emacs, kan du lægge
    den rettede fil tilbage i arkivet direkte inde fra Emacs.  Det kan
    for eksempel være praktisk hvis du løbende vil lave
    sikkerhedskopier af en rapport du er i gang med at skrive, så du
    uden problemer kan gå tilbage til tidligere udgaver af filen.  For
    at lægge filen tilbage i arkivet taster du først
    <keysym>Ctrl-X</keysym> <keysym>V</keysym> <keysym>V</keysym>.
    Hvis filen ikke allerede er gemt, får du nu mulighed for
    det. Dernæst kommer der et vindue i Emacs hvor du kan indtaste en
    bemærkning om de seneste ændringer. Når du har indtastet
    ændringerne, taster du <keysym>Ctrl-C</keysym>
    <keysym>Ctrl-C</keysym>, og så er filen lagt tilbage i CVS-arkivet.
   </para>

   <para>
    Hvis forbindelsen til CVS-arkivet går over en SSH-forbindelse, vil
    du blive bedt om løsen eller adgangskode både før og efter du
    indtaster bemærkningerne til ændringerne.
   </para>

   <para>
    Hvis det er en ny fil du vil oprette i CVS-arkivet, er det først
    anden gang du taster <keysym>Ctrl-X</keysym> <keysym>V</keysym>
    <keysym>V</keysym> at filen rent faktisk bliver lagt ind i arkivet.
    I første omgang bliver filen blot registreret (svarer til
    <command>cvs add</command>).
   </para>
  </example>

<!--

<para>
 Antag at man laver en ændring af kildeteksten som så skal kunne tilgå de
 andre på projektet. Dette gøres ved at skrive
</para>

<indexterm>
 <primary>CVS</primary>
 <secondary>commit</secondary></indexterm>

<screen>
<prompt>hven% </prompt><userinput>cvs commit FILNAVN</userinput>
</screen>

<para>
hvor "FILNAVN" er den fil man har rettet i. Dette starter automatisk
brugerens default teksteditor, hvor man kort skriver, hvad der er blevet
ændret, og denne log information gemmes med filen. Hvis filnavnet undlades
vil CVS lægge alle ændrede filer ind i CVS. Nu kan de andre på projektet få
den nye kildetekst ved at skrive
</para>

<indexterm><primary>cvs</primary><secondary>update</secondary></indexterm>

<screen>
<prompt>hven% </prompt><userinput>cvs update FILNAVN</userinput>
</screen>

<para>
Og igen kan FILNAVN udelades og de filer som ikke er ajour, vil blive
opdateret. Bemærk, at dette ikke sker automatisk, men først når man selv vil
det. På denne måde gøres det til en særskilt operation at få opgraderes
kildeteksten, hvor man må lægge mærke til hvilke ændringer som er foretaget.
CVS kan også automatisk sende et brev ud til projektgruppen når filer
bliver opdateret, så man ved hvornår dette sker (brug
<command>cvs watch</command>). Se også <xref linkend="logmails-cvs">.
</para>
-->

  <sect3 id="cvs-konfliktloesning">
   <title>Konfliktløsning ved "dobbelt-opdatering"</title>

   <para>
    Hvis der er konflikter mellem en fil i din personlige kopi af CVS-arkivet
    og den samme fil i det fælles CVS-arkiv fordi en anden bruger i
    mellemtiden også har opdateret filen, så vil du skulle flette de to
    opdateringer sammen før du kan lægge dine rettelser ind i det fælles
    arkiv. Det gøres ved at du først "opdaterer" din lokale kopi af filen
    (<command>cvs update <filename>&lt;filnavn&gt;</filename></command>).
    CVS vil så markere forskellene mellem de to udgaver, så du i dit
    tekstbehandlingsprogram kan vælge hvilke udgaver af rettelserne du
    foretrækker. Når du har valgt mellem rettelserne og i øvrigt tjekket
    at filen er i orden, kan du lægge den sammeflettede opdatering ind i
    det fælles CVS-arkiv på sædvanlig vis
    (<command>cvs commit <filename>&lt;filnavn&gt;</filename></command>).
   </para>
  </sect3>

  <sect3 id="cvs-gamle-udgaver">
   <title>Gamle udgaver af filer i CVS-arkivet</title>

   <para>
    Hvis en fil er blevet rettet i en helt forkert retning, er det muligt at
    hente en gammel udgave af filen ud af det fælles CVS-arkiv og arbejde
    videre ud fra den. Det gøres med kommandoen <command>cvs update -r
    &lt;udgavenummer&gt; <filename>&lt;filnavn&gt;</filename></command>.
   </para>
  </sect3>

  <sect3 id="cvs-tags">
   <title>Sætte huskemærker (tags) i CVS</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>tag</secondary>
   </indexterm>

   <indexterm>
    <primary>CVS</primary>
    <secondary>update -r</secondary>
   </indexterm>

   <para>
    Det kan være meget praktisk at kunne sætte et mærke på en fil for
    at man til hver en tid kan gå tilbage til netop den version af filen.
    For at sætte et mærke (engelsk "tag") kører man 
    <command>cvs tag MÆRKE fil_liste</command> hvor <literal>MÆRKE</literal>
    er et navn (desværre må man ikke anvende mellemrum) a la 
    <literal>efter_indfletning_af_SSLUG_kode</literal> eller 
    <literal>foer_Peters_sommerferie</literal>.
   </para>

   <para>
    Hvis man har brug for at gå tilbage til et givet mærke køres
    <command>cvs update -r MÆRKE</command>. Samme teknik anvendes også 
    til at håndtere forskellige grene af koden.
   </para>
  </sect3>

  <sect3 id="cvs-filstatus">
   <title>Filers status</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>status</secondary>
   </indexterm>

   <para>
    Enhver kan og bør principielt tjekke status for de enkelte filer før 
    opdateringer bliver lagt ind i det fælles arkiv. Det gøres med kommandoen
    <command>cvs status <filename>&lt;filnavn&gt;</filename></command>.
    CVS vil så vise udgavenummeret for den fil du har liggende, såvel som
    udgavenummeret for den fil der ligger i det fælles arkiv.
   </para>

   <para>
    Anvend tilsvarende <command>cvs status -v <filename>&lt;filnavn&gt;</filename></command>
    til at få endnu mere information om filen inklusive forgreninger.
   </para>

   <para>
    <emphasis>Tip:</emphasis>
    En meget effektiv måde at få styr på status for alle filer er at
    anvende <command>cvsstat</command> eller <command>cvschk</command>
    det kan findes på <ulink
    url="http://cvs.sslug.dk/cvs2html/">http://cvs.sslug.dk/cvs2html/</ulink>.
   </para>

  </sect3>

  <sect3 id="cvs-logbogen">
   <title>Logbogen</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>log</secondary>
   </indexterm>

   <para>
    Hver gang du lægger ændringer ind i det fælles CVS-arkiv, kan du skrive
    en besked i logbogen om <emphasis>hvorfor</emphasis> du har lavet de
    ændringer. I <xref linkend="cvs-kom-i-gang-commit"/> bruger vi
    kommandolinjeflaget "-m" til at angive teksten til logbogen. Hvis du ikke
    bruger "-m"-flaget, vil CVS i stedet starte det tekstbehandlingsprogram
    systemvariablen "<literal>EDITOR</literal>" peger på, så du kan skrive
    teksten der.
   </para>

<!--
<para>
Hver af disse "cvs commit" ordrer vil starte en editor op, hvor brugeren
skal skrive (kortfattet) hvilke ændringer der er lavet siden sidst. Dette
skaber en log historie for hver fil som er guld værd, hvis man er lidt væk
fra kildeteksten og skal arbejde videre senere. Du kan også angive disse
log-beskeder direkte
</para>
-->

   <para>
    Hvis du på et tidspunkt vil se hvad der for eksempel står i logbogen
    om filen <filename>tjek.php</filename>, bruger du kommandoen:
<screen>
<prompt>hven% </prompt><userinput>cvs log tjek.php</userinput>
</screen>
   </para>

   <para>
    Den vil give dig en liste med de forskellige udgaver af filen, hvem der
    har lavet ændringerne, og hvad der står om dem i logbogen. Selve
    ændringerne bliver dog ikke vist.
   </para>
  </sect3>

  <sect3 id="cvs-diff">
   <title>Forskelle mellem forskellige udgaver af en fil</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>diff</secondary>
   </indexterm>

   <indexterm>
    <primary>CVS</primary>
    <secondary>Forskelle mellem forskellige udgaver af en fil</secondary>
   </indexterm>

   <indexterm>
    <primary>Forskelle mellem forskellige udgaver af en fil i et CVS-arkiv</primary>
   </indexterm>

   <indexterm>
    <primary>diff</primary>
    <secondary>CVS</secondary>
   </indexterm>

   <para>
    Logbogen (<command>cvs log</command>) viser ikke selve ændringerne
    i en fil.  For at se dem skal man bruge tilvalget
    <option>diff</option>.  Den helt enkle brug af tilvalget
    <option>diff</option> er:

<screen>
<prompt>hven% </prompt><userinput>cvs diff tjek.php</userinput>
</screen>

    der viser forskellene mellem den udgave af
    <filename>tjek.php</filename> der ligger i CVS-arkivet og den der
    arbejdes med.
   </para>

   <para>
    Hvis man vil se forskellene mellem to udgaver af en fil i
    CVS-arkivet, bruger man tilvalget <option>-r</option> til at
    identificere de to udgaver:

<screen>
<prompt>hven% </prompt><userinput>cvs diff -r 1.21 -r 1.22 vaerktoej-cvs.sgml</userinput>
</screen>
   </para>
  </sect3>

  <sect3 id="cvs-doervogter">
   <title>CVS med SSH på en alternativ port</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>gennem en dørvogter</secondary>
   </indexterm>

   <indexterm>
    <primary>CVS</primary>
    <secondary>med SSH på en alternativ port</secondary>
   </indexterm>

   <indexterm>
    <primary>dørvogter</primary>
    <secondary>CVS gennem</secondary>
   </indexterm>

   <indexterm>
    <primary>SSH på en alternativ port</primary>
    <secondary>CVS gennem</secondary>
   </indexterm>

   <para>
    Hvis CVS-arkivet ligger på en maskine der står bag en dørvogter,
    eller hvis SSH af andre mystiske omstændigheder ikke kører på port
    22, er det lidt sværere at få <command>cvs</command> til at
    kontakte arkivet.  Problemet kan klares ved at man fortæller SSH
    hvilken port SSH kører på <emphasis>uden</emphasis> at fortælle
    CVS det. Det gør man i SSH's opsætningsfil
    <filename>$HOME/.ssh/config</filename> hvor man for eksempel kan
    tilføje:

<programlisting>
Host cvs.virksomhed.dk
   Hostname cvs-bag-doervogter.virksomhed.dk
   Port 4444
</programlisting>

    hvilket betyder at når CVS -- og dermed SSH -- bliver bedt om at kontakte
    "cvs.virksomhed.dk" (underforstået at det er på port 22), så vil SSH i
    virkeligheden kontakte "cvs-bag-doervogter.virksomhed.dk" på port 4444.
   </para>

   <para>
    Nu kan du altså kontakte CVS-arkivet bag dørvogteren ganske som i
    eksempel <xref linkend="cvs-kom-i-gang-ssh"/>:
   </para>

   <indexterm>
    <primary>CVS</primary>
    <secondary>checkout</secondary>
   </indexterm>

<screen>
<prompt>hven% </prompt><userinput>cvs \
-d tyge@cvs.virksomhed.dk:/usr/local/CVSROOT checkout hemmeligt_projekt</userinput>
</screen>
  </sect3>
 </sect2>

 <sect2 id="opsaet-cvs">
  <title>Opsætning af CVS</title>

  <indexterm>
   <primary>CVS</primary>
   <secondary>opsætning af</secondary>
  </indexterm>

  <indexterm>
   <primary>opsætning af</primary>
   <secondary>CVS</secondary>
  </indexterm>

  <para>
   Endelig skal nævnes hvordan man opretter et fælles CVS-arkiv, og hvordan
   man lægger en samling filer ind i det fælles arkiv.
  </para>

  <sect3 id="cvs-oprettelse">
   <title>Oprettelse af et CVS-arkiv</title>

   <indexterm>
    <primary>cvs</primary>
    <secondary>init</secondary>
   </indexterm>

   <indexterm>
    <primary>CVS</primary>
    <secondary>init</secondary>
   </indexterm>

   <para>
    Hvis du ikke allerede har adgang til et CVS-arkiv, du kan lægge dine
    filer ind i, må du oprette et. Hvis du har systemadministratorrettigheder
    bør du oprette et katalog med navnet
    <filename>/usr/share/CVSROOT</filename> og lægge det der. Alternativt
    kan du for eksempel lægge det i <filename>$HOME/.CVSROOT</filename>.
    Det er vigtigt at alle der skal kunne lægge filer ind i og rette
    filer i CVS-arkivet, har adgang til at skrive i kataloget. Vi går her
    ud fra at de alle er med i brugergruppen "cvsusers" (se
    systemadministratorbogen for information om brugergrupper). CVS-arkivet
    oprettes med kommandoen:

<screen>
<prompt>hven% </prompt><userinput>cvs -d $HOME/.CVSROOT init</userinput>
</screen>
   </para>

   <para>
    Når en bruger vil oprette sin egen arbejdskopi af CVS-arkivet, skal
    han/hun blot kende navnet på det katalog du valgte at lægge det fælles
    centrale CVS-arkiv i (husk at "$HOME" refererer til
    <emphasis>dit</emphasis> hjemmekatalog;
    <command>echo $HOME/.CVSROOT</command> vil give dig det fulde navn på
    det katalog der blev brugt i ovenstående eksempel). Se i øvrigt
    eksemplerne <xref linkend="cvs-kom-i-gang-lokalt"/>,
    <xref linkend="cvs-kom-i-gang-anonym"/> og
    <xref linkend="cvs-kom-i-gang-ssh"/> for flere detaljer. Vi kommer ikke
    ind på hvordan man giver anonym adgang til et CVS-arkiv her.
   </para>
  </sect3>

  <sect3 id="cvs-oprette-et-projekt">
   <title>Opret et projekt i CVS-arkivet</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>import</secondary>
   </indexterm>

   <para>
    Lad os komme videre. For at du kan lægge dine filer i CVS for første
    gang, skal du flytte dig til hovedbiblioteket for kildeteksten (vi antager
    at det - og projektet - hedder <filename>webspell</filename>, og at du
    oprettede CVS-arkivet som beskrevet i forrige afsnit) og importere
    filerne, fjerne filtræet og til sidst trække det ud af CVS-arkivet igen
    (denne gang <emphasis>med</emphasis> udgavehåndteringsinformation):

<screen>
<prompt>hven% </prompt><userinput>cd webspell</userinput>
<prompt>hven% </prompt><userinput>cvs -d $HOME/.CVSROOT import webspell Daisy foerste-udgave-i-cvs</userinput>
<prompt>hven% </prompt><userinput>cd ..</userinput>
<prompt>hven% </prompt><userinput>mv webspell webspell-før_cvs</userinput>
<prompt>hven% </prompt><userinput>cvs -d $HOME/.CVSROOT checkout webspell</userinput>
</screen>
   </para>

   <para>
    <command>Daisy</command> er et felt der af CVS kaldes "vendor tag"
    (leverandørmærke), og <command>foerste-udgave-i-cvs</command> er et
    felt der af CVS kaldes "release tag" (udgavemærke).
   </para>

   <para>
    Det kan også nævnes at en række ekstra værktøjer fås til CVS, se
    <ulink url="http://freshmeat.net/">http://freshmeat.net/</ulink> under
    CVS. Et af disse er cvs2html der findes fra <ulink
    url="http://cvs.sslug.dk/cvs2html/">http://cvs.sslug.dk/cvs2html/</ulink>.
    cvs2html anvendes til at reformattere den loginformation der er
    skrevet ind for hver fil ved "cvs commit", til HTML-filer. For
    internetbaserede samarbejdsprojekter er dette virkeligt smart.
   </para>

   <para>
    Det tager et par timer at komme ind i denne måde at arbejde på, men ved alle
    programmerings- eller skriveprojekter i øvrigt med mere end en person vil
    CVS tjene dette overhead ind i hundredefold.
   </para>
  </sect3>

  <sect3 id="logmails-cvs">
   <title>Få breve med log-meddelelser ved cvs commit</title>

   <para>
    Når flere folk arbejder sammen på et software-projekt, er det
    nødvendigt at man nemt kan se hvad andre personer har ændret i
    filerne. Med <command>cvs watch add FILNAVN</command> vil du
    modtage breve når andre kører <command>cvs commit
    FILNAVN</command>, men her vil du ikke se hvad de har ændret. Du
    kan få en bedre føling med ændringerne ved at bruge et lille
    program <filename>log</filename> der følger med cvs. Med det
    program kan du få et brev om hvilke filer som er ændret, og du får
    også den log-meddelelse brugeren skrev, med i brevet. Hvis man
    inden for projektet holder en god stil med at skrive ordentlige
    log-meddelelser, så er dette super.
   </para>

   <para>
    Lad os se på opsætningen af dette.  Først skal du lave en logfil i
    CVSROOT-kataloget som alle deltagere i dit projekt kan læse og
    skrive.  <emphasis>I det følgende skal du erstatte
    STI_TIL_CVS-RODEN med den fulde sti til dit
    CVSROOT-katalog.</emphasis>

<screen>
<prompt>hven% </prompt><userinput>touch STI_TIL_CVS-RODEN/CVSROOT/commitlog</userinput>
<prompt>hven% </prompt><userinput>chgrp PROJEKTGRUPPE STI_TIL_CVS-RODEN/CVSROOT/commitlog</userinput>
<prompt>hven% </prompt><userinput>chmod g+rw STI_TIL_CVS-RODEN/CVSROOT/commitlog</userinput>
</screen>
   </para>

   <para>
    Dernæst skal vi rode i noget af de "helligste" af cvs-opsætningen.

    <indexterm>
     <primary>CVS</primary>
     <secondary>CVSROOT</secondary>
    </indexterm>

<screen>
<prompt>hven% </prompt><userinput>cvs -d STI_TIL_CVS-RODEN checkout CVSROOT</userinput>
<prompt>hven% </prompt><userinput>vi CVSROOT/loginfo</userinput>
</screen>

    Indsæt følgende linje til sidst hvis
    <filename>tyge@hven.oresund.dk</filename> skal modtage breve. Er der flere
    som skal modtage breve, så tilføj gerne flere "-m modtager@maskine"
    efter hinanden:

<programlisting>
DEFAULT /usr/share/cvs/contrib/log -m tyge@hven.oresund.dk -f STI_TIL_CVS-RODEN/CVSROOT/commitlog
</programlisting>
   </para>

   <para>
<screen>
<prompt>hven% </prompt><userinput>cvs commit -m "Man kan modtage logbeskeder per post" CVSROOT/loginfo</userinput>
<prompt>hven% </prompt><userinput>cvs release -d CVSROOT</userinput>
</screen>

    De sidste linjer vil regenerere CVSROOT (sted hvor CVS-opsætningen
    er gemt), og derefter sletter man den CVSROOT-kopi man har checket
    ud.
   </para>
  </sect3>
 </sect2>

 <sect2 id="cvs-forgreninger">
  <title>Forgreninger i udviklingen</title>

  <para>
   Lad os se lidt mere på starten, da vi lavede projektet.

<screen>
<prompt>hven% </prompt><userinput>cd MODUL_DIR</userinput>
<prompt>hven% </prompt><userinput>cvs -d STI_TIL_CVS-RODEN import MODUL VENDOR_TAG RELEASE_TAG</userinput>
</screen>

   Dette genererer med det samme to grene (engelsk: "branches") som
   man altid kan komme tilbage til.
  </para>

  <para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
      1.1.1 - VENDOR_TAG
     </para>
    </listitem>
    <listitem>
     <para>
      1.1.1.1 - RELEASE_TAG
     </para>
    </listitem>
   </itemizedlist>

   Går man i gang med at checke filerne ud, rette og køre <command>cvs
   commit</command>, så kommer de enkelte versioner til at hedde
   version 1.1, 1.2, 1.3 osv.
  </para>

  <para>
   Ofte vil alle bruge samme gren af filerne, men hvad gør man hvis
   man nu har brug for at kode et stykke tid på noget som lammer
   resten af udviklerne på samme projekt. I dette tilfælde kan man
   oprette en gren til dette - de andre udviklere kommer ikke til at
   se noget anderledes, og to adskilte udviklingsgrene kan køre.
  </para>

  <para>
   Lad os antage at vi arbejder med et modul i CVS med navn
   "sslugkode" som er importeret i CVS ved at skrive <command>cvs
   import sslugkode start version0</command>. Da der ikke er nogen
   naturlig "vendor" sættes leverandør-tag blot til "start" og
   start-version til "version0".
  </para>

  <para>
   <indexterm>
    <primary>CVS</primary>
    <secondary>rtag</secondary>
   </indexterm>

   For at skabe "gren1" ud fra hovedgrenen "version0" skriver man
   (uden at man nødvendigvis har koden checket ud):

<screen>
<prompt>hven% </prompt><userinput>cvs rtag -b -r version0 gren1 sslugkode</userinput>
</screen>
  </para>

  <para>
   Tilsvarende kunne man måske have en anden udvikler som skal
   arbejde samtidig på en anden gren, "gren2":

<screen>
<prompt>hven% </prompt><userinput>cvs rtag -b -r version0 gren2 sslugkode</userinput>
</screen>
  </para>

  <para>
   For at isolere sig selv i grenen "gren1" skrives:

<screen>
<prompt>hven% </prompt><userinput>cvs -d STI_TIL_CVS-RODEN checkout sslugkode</userinput>
<prompt>hven% </prompt><userinput>cd sslugkode</userinput>
<prompt>hven% </prompt><userinput>cvs update -r gren1</userinput>
</screen>

   eller direkte

<screen>
<prompt>hven% </prompt><userinput>cvs -d STI_TIL_CVS-RODEN checkout -r gren1 sslugkode</userinput>
</screen>
  </para>

  <para>
   Det normale er derefter at udvikleren retter, laver <command>cvs
   commit</command> som vanligt. Fordelen er at de andre udviklere
   ikke ser dette. Grenene er totalt afkoblede indtil der laves en
   "merge"
  </para>

  <para>
   Hvis det skulle ske at vores udvikler fra "gren1" skal hjælpe ham
   som arbejder i "gren2"-grenen, så kan han lave <command>cvs
   commit</command> på egne filer og derfter skifte direkte over til
   "gren2":

<screen>
<prompt>hven% </prompt><userinput>cvs update -r gren2</userinput>
</screen>
  </para>

  <para>
   Endelig kan man skifte ud til hoved-sporet (komme ud af henholdsvis
   "gren1" og "gren2" ved at skrive:

<screen>
<prompt>hven% </prompt><userinput>cvs update -A</userinput>
</screen>
  </para>

  <sect3 id="cvs-join">
   <title>Flette grene sammen igen</title>

   <indexterm>
    <primary>CVS</primary>
    <secondary>flette grene sammen igen</secondary>
   </indexterm>

   <indexterm>
    <primary>CVS</primary>
    <secondary>update -j</secondary>
   </indexterm>

   <para>
    Antag at to udviklingsgrene som hver for sig har udviklet sig, på
    et tidspunkt skal flettes sammen. Du har været så smart at du
    kørte <command>cvs tag TAG1</command> da du startede med din
    "gren1", og du har også gemt et mærke TAG2 ved slutningen af
    "gren1" - dvs. du har har lige kørt <command>cvs tag
    TAG2</command> i "gren1".
   </para>

   <para>
    I "gren2"-grenen kan du opdatere samtlige ændringer fra "gren1"-grenen
    mellem TAG1 og TAG2 ved at skrive:

<screen>
<prompt>hven% </prompt><userinput>cvs update -j TAG1 -j TAG2</userinput>
</screen>
   </para>

   <para>
    Hvis man ikke var i "gren2", skal man først sikre at man er i
    "gren2"-grenen:

<screen>
<prompt>hven% </prompt><userinput>cvs update -r gren2</userinput>
<prompt>hven% </prompt><userinput>cvs update -j TAG1 -j TAG2</userinput>
</screen>
   </para>

   <para>
    Der er lidt mere information om emnet på <ulink
    url="http://groups.yahoo.com/group/info-cvs/message/12246">http://groups.yahoo.com/group/info-cvs/message/12246</ulink>.
   </para>
  </sect3>
 </sect2>

 <sect2 id="misc-med-cvs">
  <title>Diverse med CVS</title>

  <para>
   Det kan nævnes at hvis Emacs indlæser en fil der er koblet ind i
   CVS, vil Emacs automatisk genkende dette og indsætte en ekstra
   menu, hvorfra du på enkel vis kan sende tilføjelser til den fælles
   database (selve ændringerne skal du ikke selv styre - det klarer
   Emacs og CVS).
  </para>

  <para>
   Skal man anvende en "export" version til distribution, eller blot
   ikke ønsker at lave en "checkout", så er <command>cvs export
   PROJEKT</command> også en mulighed. Den henter kun filerne, men
   ikke CVS-informationsfilerne. Meget praktisk til at skelne mellem
   udgivelse af filer ("export") i forhold til udvikler-version med
   fuld CVS-information ("checkout").
  </para>

  <para>
   Vi har tidligere vist at projekt/kildetekst hentes med:

<screen>
<prompt>hven% </prompt><userinput>cvs STI_TIL_CVS-RODEN checkout projektnavn</userinput>
</screen>
  </para>

  <para>
<!--
   Men for folk, der deltager i mange projekter er det interessant at man
   faktisk også kan angive variablen <literal>CVSROOT</literal> som argument
   på kommandolinjen:

<screen>
<prompt>hven% </prompt><userinput>cvs -d USER@tux.hjemme:/usr/local/CVSROOT checkout projektnavn</userinput>
</screen>

   og det skal bemærkes at man faktisk ikke anvender
   <literal>CVSROOT</literal> efter at man har kørt <command>cvs
   checkout</command>.
-->

   Hvis man ser efter i <filename>projekt-katalog/CVS</filename>, så
   finder man der tre filer som tilhører CVS:

   <itemizedlist mark="bullet">
    <listitem>
     <para>
      <filename>Repository</filename> indeholder projekt-navn på CVS-serveren.
     </para>
    </listitem>
    <listitem>
     <para>
      <filename>Root</filename> indeholder <literal>CVSROOT</literal> for det
      pågældende projekt.
     </para>
    </listitem>
    <listitem>
     <para>
      <filename>Entries</filename> indeholder listen over de filer og
      kataloger som er registreret i CVS.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Næste trick er for dem som anvender SSH til at kommunikere med CVS.
   Man kan få ssh til at understøtte komprimering i
   <filename>~/.ssh/config</filename>:

<programlisting>
Compression      yes
CompressionLevel 6
</programlisting>

   Men vær opmærksom på at visse servere ikke kan finde ud af at
   anvende komprimering, så er der uforklarlige problemer med at få
   forbindelse, så slå det fra.
  </para>
 </sect2>
</sect1>
