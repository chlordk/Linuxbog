<sect1 id="vaerktoej-cvs">
 <title>Concurrent versioning system (CVS)</title>

 <indexterm>
  <primary>revisionskontrolsystemer</primary>
  <secondary>CVS</secondary>
 </indexterm>
 <indexterm>
  <primary>CVS</primary>
 </indexterm>
 <indexterm>
  <primary>Concurrent versioning system</primary>
 </indexterm>
 <indexterm>
  <primary>versionsstyring</primary>
  <secondary>med CVS</secondary>
 </indexterm>

 <para>
  <emphasis>Concurrent versioning system</emphasis> (CVS) er et
  versionsstyringssystem.  Dette er godt nok en programmeringsbog, men
  i virkeligheden bør man bruge et versionsstyringssystem til alle
  projekter, der varer længere end et par dage, eller har flere end en
  enkelt deltagende forfattere.  Versionsstyringssystemets opgave er
  at holde styr på de forskellige udgaver en fil har eksisteret i,
  hvilke ændringer der er foretaget, hvorfor, og af hvem.  Der holdes
  styr på dette i et centralt fælles <emphasis>CVS-arkiv</emphasis>,
  hvor alle ændringer registreres.  En af de ting, der gør CVS til
  noget særligt blandt versionsstyringssystemer er at det tillader at
  flere forfatter samtidig arbejder på de samme filer.  Så længe der
  ikke er flere, der retter i de samme linier, vil CVS flette de
  forskellige ændringer sammen, efterhånden som de bliver lagt ind i
  det fælles arkiv.
 </para>

 <para>
  Versionsstyringssystemer som CVS er en nødvendighed for
  udviklingsprojekter der - som for eksempel Linux - foregår spredt
  rundt omkring i verden.  Antag, at et firma eller universitet har
  behov for at kunne arbejde med udvikling af programmer på kryds og
  tværs af geografi, hvor al kommunikation skal ske via internettet.
  To spørgsmål melder sig hurtigt til systemadministratoren: Hvad med
  sikkerheden og hvordan kan man styre softwareudviklingsprocessen,
  når der er mange mennesker involveret, på en sådan måde at man kan
  lave udgivelser som altid kan genskabes (til serviceformål), mens
  man samtidigt videreudvikler, og dermed har behov for at kunne bakke
  tilbage gennem opdateringerne i tilfælde af fejl.
 </para>

 <para>
  De fleste danske og udenlandske softwarefirmaer har foretaget deres
  udvikling baseret på udvikling i lokale netværk.  Med den fortsatte
  ekspansion af udviklingen af internettet og med den fortsatte
  udvikling, hvor begreber som "hjemmearbejdsplads" og
  "distancearbejde" dukker op oftere og oftere, må det forventes at
  softwareudviklingsfirmaer allerede er igang med og i endnu højere
  grad vil foretage udviklingen af software baseret på utroligt mange
  computere bundet sammen af internettet.  Dette stiller store krav
  til de versionsstyringssystemer, der benyttes.
 </para>

 <para>
  Styring af softwareprojekter er svært!  Specielt svært bliver det
  når mange arbejder på den samme kildetekst, og hvor samtidigt
  kommunikationen mellem projektdeltagerne er ringe eller besværlig.
  De krav, der må stilles til versionsstyringssystemerne i sådanne
  projekter er, at alle ændringer let skal kunne tilgå andre på
  projektet, alle ændringer skal kunne hives ud af kildeteksten igen,
  og man skal kunne se hvem der har lavet hvad på hvilket tidspunkt.
 </para>

 <para>
  Når man en gang har prøvet at være to eller flere som fysisk retter
  i samme kildetekst, uden af man bruger et versionsstyringssystem, er
  det indlysende at denne form for samarbejde er uproduktiv.  På
  sådanne præmisser er megen kommunikation og dermed megen uproduktiv
  tid nødvendig, hvis det skal være muligt at opnå et
  tilfredsstillende resultat.  En mulighed for at øge produktiviteten
  er at gøre brug af et versionsstyringssystem.
 </para>

 <para>
  CVS er et multi-platform versionsstyringssystem som har alt det man
  kan ønske sig af et sådant system.  Det er frit tilgængeligt under
  GNU-licensen (GPL).  Det distribueres i køreklar form til de fleste
  unixsystemer (se <ulink
  url="http://prep.ai.mit.edu/pub/gnu">http://prep.ai.mit.edu/pub/gnu</ulink>
  og afspejlinger), såvel som til MS Windows (se <ulink
  url="http://www.cygnus.com/misc/gnu-win32">http://www.cygnus.com/misc/gnu-win32</ulink>).
  Du kan læse mere om CVS på <ulink
  url="http://www.sourcegear.com/CVS">http://www.sourcegear.com/CVS</ulink>.
 </para>

 <para>
  CVS er et forholdsvis nyt versionsstyringssystem og dets håndtering
  af konflikter mellem forskellige udvikleres arbejde regnes for at
  være unik.
 </para>

 <sect2 id="cvs-funktionalitet">
  <title>CVS' funktionalitet</title>

  <para>
   CVS bruges til at gemme den historie som ens kildetekster (af den
   ene eller den anden slags) gennemløber.  Grundprincippet i CVS er,
   at alle brugere har deres egen lokale kopi af kildeteksten, som kan
   modificeres uafhængigt af andre brugere.  Dette kan ske med brugere
   på samme maskine eller på maskiner placeret vilkårligt langt fra
   hinanden.  Når ens personlige kopi af kildeteksten er stabil og
   fungerende kan alle de opdaterede filer lægges ind i CVS-arkivet
   igen, eventuelt først efter at være blevet flettet sammen med andre
   udvikleres ændringer af de samme filer.  På denne måde kan man uden
   at begrænse andre i deres arbejde, udføre meget arbejde (lang tids
   arbejde og/eller mange ændringer) på sin lokale kopi af
   kildeteksten, uden alvorlig risiko for at der opstår problemer, når
   rettelserne lægges ind i det fælles arkiv.
  </para>

  <para>
   CVS understøtter at arkivet (samlingen med
   versionsstyringssystemets information, inklusive kildeteksterne)
   kan gøres tilgængelig på nettet uden at man behøver at montere
   diske fra andre maskiner.  Almindeligvis anvendes
   <command>ssh</command> til at håndtere sikker udveksling af data
   mellem programmørernes maskiner og der centrale arkiv.
  </para>

<!--
  <para>
   CVS udmærker sig ved at have et intuitivt let forståeligt sæt af
   kommandoer til at pakke distributionen ud, at opdatere ens egen
   distribution med andres ændringer, at lægge ens egne ændringer i
   repositoriet, at lave sideløbende grene af udviklingen af
   produktet, at samle sideløbende grene af udviklingen, at hente
   information om historien af ændringer osv.
  </para>
-->

  <para>
   <!-- Det CVS mangler i forhold til nogle af de kommercielle er en
   glat grafisk brugergrænseflade der fungerer på tværs af
   styresystemerne (tjek lige KDE-projektets forslag til
   CVS-værktøjer). --> Det er værd at bemærke at
   tekstbehandlingsprogrammet Emacs automatisk vil bemærke det, hvis
   du redigerer filer der ligger i et CVS-arkiv. Det vil så vise en
   ekstra menu, der giver adgang langt de fleste af de daglige
   CVS-funktioner. Fra Emacs kan man bl.a. lægge filer ind i CVS,
   hente senere udgaver af de enkelte filer, og få sammenligne
   forskellige udgaver af samme fil.
  </para>
 </sect2>

 <sect2 id="brug-af-cvs">
  <title>Daglig brug af CVS</title>

  <para>
   Hvis vi går ud fra at andre har taget sig af at lægge filerne fra
   et projekt du skal til at arbejde på i et CVS-arkiv (se <xref
   linkend="opsaet-cvs">, hvis du selv skal gøre det) er det
   forholdsvis enkelt at komme igang.  Du skal blot kende CVS-arkivets
   adresse og projektets navn i arkivet.  De første tre af de følgende
   eksempler viser hvordan du går i gang med at arbejde med filer, der
   ligger i et CVS-arkiv, afhængigt af hvilken form for adgang du har
   til det (<xref linkend="cvs-kom-i-gang-lokalt">, <xref
   linkend="cvs-kom-i-gang-anonym"> og <xref
   linkend="cvs-kom-i-gang-ssh">).  Dernæst følger eksempler, der
   viser hvordan du opdaterer din personlige kopi af arkivet (<xref
   linkend="cvs-kom-i-gang-update">), hvordan du lægger rettede filer
   tilbage i det fælles arkiv (<xref
   linkend="cvs-kom-i-gang-commit">), hvordan du tilføjer filer (<xref
   linkend="cvs-kom-i-gang-add">) og hvordan du sletter filer (<xref
   linkend="cvs-kom-i-gang-rm">).
  </para>

  <example id="cvs-kom-i-gang-lokalt">
   <title>
    Gå i gang med at <emphasis>bruge</emphasis> et lokalt CVS-arkiv
   </title>

   <indexterm>
    <primary>cvs</primary>
    <secondary>kom igang med at bruge et lokalt arkiv</secondary>
   </indexterm>

<screen>
<prompt>[daisy@linus daisy]$ </prompt><userinput>cvs -d /usr/local/CVSROOT checkout webspell</userinput>
</screen>

   <itemizedlist>
    <listitem>
     <para>
      "-d /usr/local/CVSROOT" betyder at det CVS-arkiv projektet skal
      hentes fra ligger i kataloget
      <filename>/usr/local/CVSROOT</filename> på den maskine du
      arbejder på.
     </para>
    </listitem>

    <listitem>
     <para>
      "checkout" betyder at du vil have oprettet en kopi af et
      projekt, der ligger i det førnævnte CVS-arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Og endelig er "webspell" navnet på det projekt vi vil have en
      kopi af.
     </para>
    </listitem>
   </itemizedlist>
  </example>

  <example id="cvs-kom-i-gang-anonym">
   <title>Anonym brug af et CVS-arkiv på nettet</title>

   <indexterm>
    <primary>cvs</primary>
    <secondary>kom igang med at bruge et arkiv på nettet</secondary>
   </indexterm>

<screen>
<prompt>[daisy@linus daisy]$ </prompt><userinput>echo "update -dP" &gt;&gt; ~/.cvsrc</userinput>
<prompt>[daisy@linus daisy]$ </prompt><userinput>cvs -d :pserver:anonymous@anoncvs.kde.org:/home/kde checkout kde-i18n</userinput>
</screen>

   <para>
    Den første kommando sikrer blot at <command>cvs</command> kan
    forstå KDE-projektets CVS-tjener. Betragt det i denne sammenhæng
    blot som hvid magi.
   </para>

   <itemizedlist>
    <listitem>
     <para>
      "-d :pserver:anonymous@anoncvs.kde.org:/home/kde" betyder at
      betyder at det CVS-arkiv projektet skal hentes fra ligger i
      kataloget <filename>/home/kde</filename> på maskinen
      "anoncvs.kde.org" og at du vil hente det som en anonym bruger.
     </para>
    </listitem>

    <listitem>
     <para>
      "checkout" betyder at du vil have oprettet en kopi af et
      projekt, der ligger i det førnævnte CVS-arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Og endelig er "kde-i18n" navnet på det projekt vi vil have en
      kopi af.  I dette konkrete tilfælde er det oversættelser af KDE
      (menutekster og brugsanvisninger) til forskellige sprog.
     </para>
    </listitem>
   </itemizedlist>
  </example>

  <example id="cvs-kom-i-gang-ssh">
   <title>Brug af et CVS-arkiv på nettet over SSH</title>

   <indexterm>
    <primary>cvs</primary>
    <secondary>kom igang med at bruge et lokalt på nettet over SSH</secondary>
   </indexterm>

<screen>
<prompt>[daisy@linus daisy]$ </prompt><userinput>export CVS_RSH=ssh</userinput>
</screen>

   <para>
    Denne kommando sætter en variabel, der fortæller
    <command>cvs</command> at kommunikation over nettet skal kunne ske
    med SSH-protokollen (der er krypteret og dermed sikrer mod
    aflytning af adgangskoder og data).  Bemærk at variablen også skal
    være sat, når du senere vil opdatere din kopi af projektet eller
    vil lægge en rettet fil ind i CVS-arkivet.  Det kan du hurtigt
    sikre med kommandoen <command>echo "export CVS_RSH=ssh" &gt;&gt;
    ~/.zshrc</command>.
   </para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt><userinput>cvs \
-d sparre@cvs.sslug.dk:/usr/local/CVSROOT checkout linuxbog</userinput>
</screen>

   <itemizedlist>
    <listitem>
     <para>
      "-d sparre@cvs.sslug.dk:/usr/local/CVSROOT" betyder at betyder
      at det CVS-arkiv projektet skal hentes fra ligger i kataloget
      <filename>/usr/local/CVSROOT</filename> på maskinen
      "cvs.sslug.dk" og at du vil hente det som brugeren "sparre".
     </para>
    </listitem>

    <listitem>
     <para>
      "checkout" betyder at du vil have oprettet en kopi af et
      projekt, der ligger i det førnævnte CVS-arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Og endelig er "linuxbog" navnet på det projekt vi vil have en
      kopi af.  I dette konkrete tilfælde er det hele bogserien "Linux
      - Friheden til ...".
     </para>
    </listitem>
   </itemizedlist>
  </example>

  <example id="cvs-kom-i-gang-update">
   <title>Opdatér din personlige kopi af et CVS-arkiv</title>

   <indexterm>
    <primary>cvs</primary>
    <secondary>opdatér personlig kopi</secondary>
   </indexterm>

<screen>
<prompt>[daisy@linus daisy]$ </prompt><userinput>cd webspell/</userinput>
<prompt>[daisy@linus daisy/webspell]$ </prompt><userinput>cvs update</userinput>
</screen>

   <itemizedlist>
    <listitem>
     <para>
      Du skal stå <emphasis>i</emphasis> kataloget med din lokale kopi
      af CVS-arkivet for at kunne opdatere filerne.  Herover bliver
      det gjort med kommandoen <command>cd webspell</command>.
     </para>
    </listitem>

    <listitem>
     <para>
      Argumentet "update" betyder at du vil have
      <emphasis>opdateret</emphasis> den personlige kopi af et
      CVS-arkiv, der allerede ligger i det katalog du står i.
     </para>
    </listitem>
   </itemizedlist>
  </example>

  <example id="cvs-kom-i-gang-commit">
   <title>Læg en rettet fil tilbage i det fælles CVS-arkiv</title>

   <indexterm>
    <primary>cvs</primary>
    <secondary>læg en rettelse tilbage i det fælles arkiv</secondary>
   </indexterm>

   <para>
    Vi antager nu at vi som efter forrige eksempel står i kataloget
    med den personlige kopi af CVS-arkivet og at vi har rettet en
    HTML-syntaksfejl i filen <filename>tjek.php</filename>.
   </para>

<screen>
<prompt>[daisy@linus daisy/webspell]$ </prompt><userinput>cvs commit \
-m 'validator.w3.org brokkede sig' tjek.php</userinput>
</screen>

   <itemizedlist>
    <listitem>
     <para>
      "commit" betyder at du vil kopiere din rettede udgave af en fil
      ind i det fælles CVS-arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      "-m 'validator.w3.org brokkede sig'" betyder at rettelserne i
      CVS-arkivets logbog skal have kommentaren "validator.w3.org
      brokkede sig".
     </para>
    </listitem>

    <listitem>
     <para>
      Og endelig er "tjek.php" navnet på den fil du har rettet og vil
      kopiere ind i det fælles arkiv.
     </para>
    </listitem>
   </itemizedlist>
  </example>

  <example id="cvs-kom-i-gang-add">
   <title>Tilføj en ny fil til et CVS-arkiv</title>

   <indexterm>
    <primary>cvs</primary>
    <secondary>tilføj en ny fil</secondary>
   </indexterm>

   <para>
    Hvis vi nu har skrevet en ny fil ved navn "tak.html" og den ligger
    sammen med vores personlige kopi af projektet kan vi tilføje den
    med kommandoerne:
<screen>
<prompt>[daisy@linus daisy/webspell]$ </prompt><userinput>cvs add tak.html</userinput>
<prompt>[daisy@linus daisy/webspell]$ </prompt><userinput>cvs commit -m 'lidt almindelig høflighed' tak.html</userinput>
</screen>
   </para>

   <itemizedlist>
    <listitem>
     <para>
      "add" betyder at du vil føje din rettede udgave af en fil til
      det fælles CVS-arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Og endelig er "tak.html" navnet på den fil du har skrevet og vil
      føje til det fælles arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Efter at "tak.html" er blevet føjet til arkivet bruges "cvs
      commit" til at aktivere tilføjelsen.
     </para>
    </listitem>
   </itemizedlist>
  </example>

  <example id="cvs-kom-i-gang-rm">
   <title>Fjern en fil fra et CVS-arkiv</title>

   <indexterm>
    <primary>cvs</primary>
    <secondary>fjern en fil</secondary>
   </indexterm>

   <para>
    Vi har nu eksperimenteret lidt med en fil "tjek-eksp.php" og
    fundet ud af at der alligevel ikke er brug for den i projektet, så
    vi vil fjerne den fra den synlige del af CVS-arkivet (arkivet
    husker alle ændringer, så du vil stadig kunne gå tilbage til en
    udgave hvor filen fandtes).  Det klares med kommandoerne:
<screen>
<prompt>[daisy@linus daisy/webspell]$ </prompt><userinput>rm -f tjek-eksp.php</userinput>
<prompt>[daisy@linus daisy/webspell]$ </prompt><userinput>cvs remove tjek-eksp.php</userinput>
<prompt>[daisy@linus daisy/webspell]$ </prompt><userinput>cvs commit -m 'det gik ikke' tjek-eksp.php</userinput>
</screen>
   </para>

   <itemizedlist>
    <listitem>
     <para>
      CVS vil ikke fjerne en fil fra arkivet, hvis du stadig har en
      kopi af den i din personlige kopi af CVS-arkivet, så vi starter
      med kommandoen <command>rm -f tjek-eksp.php</command>, der
      fjerner filen fra kataloget.
     </para>
    </listitem>

    <listitem>
     <para>
      "rm" betyder at du vil fjerne filen fra det fælles CVS-arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Og endelig er "tjek-eksp.php" navnet på den fil der skal fjernes
      fra det fælles arkiv.
     </para>
    </listitem>

    <listitem>
     <para>
      Efter at "tjek-eksp.php" er blevet slettet fra arkivet bruges
      "cvs commit" til at aktivere sletningen.
     </para>
    </listitem>
   </itemizedlist>
  </example>


<!--

<para>
 Antag at man laver en ændring af kildeteksten som så skal kunne tilgå de
 andre på projektet. Dette gøres ved at skrive
</para>

<indexterm><primary>cvs</primary><secondary>commit</secondary></indexterm>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs commit FILNAVN</userinput>
</screen>

<para>
hvor "FILNAVN" er den fil man har rettet i. Dette starter automatisk
brugerens default teksteditor, hvor man kort skriver, hvad der er blevet
ændret, og denne log information gemmes med filen. Hvis filnavnet undlades
vil CVS lægge alle ændrede filer ind i CVS. Nu kan de andre på projektet få
den nye kildetekst ved at skrive
</para>

<indexterm><primary>cvs</primary><secondary>update</secondary></indexterm>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs update FILNAVN</userinput>
</screen>

<para>
Og igen kan FILNAVN udelades og de filer som ikke er ajour, vil blive
opdateret. Bemærk, at dette ikke sker automatisk, men først når man selv vil
det. På denne måde gøres det til en særskilt operation at få opgraderes
kildeteksten, hvor man må lægge mærke til hvilke ændringer som er foretaget.
CVS kan også automatisk sende et brev ud til projektgruppen når filer
bliver opdateret, så man ved hvornår dette sker (brug
<command>cvs watch</command>). Se også <xref linkend="logmails-cvs">.
</para>
-->

  <sect3 id="cvs-konfliktloesning">
   <title>Konfliktløsning ved "dobbelt-opdatering"</title>

   <para>
    Hvis der er konflikter mellem en fil i din personlige kopi af CVS-arkivet
    og den samme fil i det fælles CVS-arkiv, fordi en anden bruger i
    mellemtiden også har opdateret filen, så vil du skulle flette de to
    opdateringer sammen, før du kan lægge dine rettelser ind i det fælles
    arkiv. Det gøres ved at du først "opdaterer" din lokale kopi af filen
    (<command>cvs update <filename>&lt;filnavn&gt;</filename></command>).
    CVS vil så markere forskellene mellem de to udgaver, så du i dit
    tekstbehandlingsprogram kan vælge hvilke udgaver af rettelserne du
    foretrækker. Når du har valgt mellem rettelserne og i øvrigt tjekket
    at filen er i orden kan du lægge den sammeflettede opdatering ind i
    det fælles CVS-arkiv på sædvanlig vis
    (<command>cvs commit <filename>&lt;filnavn&gt;</filename></command>).
   </para>
  </sect3>

  <sect3 id="cvs-gamle-udgaver">
   <title>Gamle udgaver af filer i CVS-arkivet</title>

   <para>
    Hvis en fil er blevet rettet i en helt forkert retning, er det muligt at
    hente en gammel udgave af filen ud af det fælles CVS-arkiv, og arbejde
    videre udfra den. Det gøres med kommandoen <command>cvs update -r
    &lt;udgavenummer&gt; <filename>&lt;filnavn&gt;</filename></command>.
   </para>
  </sect3>

  <sect3 id="cvs-filstatus">
   <title>Filers status</title>

   <para>
    Enhver kan og bør principielt tjekke status for de enkelte filer før 
    opdateringer bliver lagt ind i det fælles arkiv. Det gøres med kommandoen
    <command>cvs status <filename>&lt;filnavn&gt;</filename></command>.
    CVS vil så vise udgavenummeret for den fil du har liggende såvel som
    udgavenummeret for den fil der ligger i det fælles arkiv.
   </para>
  </sect3>

  <sect3 id="cvs-logbogen">
   <title>Logbogen</title>

   <para>
    Hver gang du lægger ændringer ind i det fælles CVS-arkiv, kan du skrive
    en besked i logbogen om <emphasis>hvorfor</emphasis> du har lavet de
    ændringer. I <xref linkend="cvs-kom-i-gang-commit"> bruger vi
    kommandolinieflaget "-m" til at angive teksten til logbogen. Hvis du ikke
    bruger "-m"-flaget, vil CVS i stedet starte det tekstbehandlingsprogram
    systemvariablen "EDITOR" peger på, så du kan skrive teksten der.
   </para>

<!--
<para>
Hver af disse "cvs commit" ordrer vil starte en editor op, hvor brugeren
skal skrive (kortfattet) hvilke ændringer der er lavet siden sidst. Dette
skaber en log historie for hver fil som er guld værd, hvis man er lidt væk
fra kildeteksten og skal arbejde videre senere. Du kan også angive disse
log-beskeder direkte
</para>
-->

   <para>
    Hvis du på et tidspunkt vil se, hvad der for eksempel står i logbogen
    om filen <filename>tjek.php</filename> bruger du kommandoen:

<screen>
<prompt>[daisy@linus daisy/webspell]$ </prompt><userinput>cvs log tjek.php</userinput>
</screen>

    Den vil give dig en liste med de forskellige udgaver af filen, hvem der
    har lavet ændringerne, og hvad der står om dem i logbogen. Selve
    ændringerne bliver dog ikke vist.
   </para>
  </sect3>

  <sect3 id="cvs-diff">
   <title><command>cvs diff</command></title>

   <indexterm><primary>cvs</primary><secondary>diff</secondary></indexterm>

   <para>
    Selve ændringerne i kildeteksten vises ikke her. Disse fås ved at skrive
<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs diff FILNAVN</userinput>
</screen>
    og her kan et udgavenummer tilføjes, så man kan se, hvordan den lokale
    kildetekst afviger fra kildeteksten med den valgte revision.
   </para>
  </sect3>
 </sect2>

<!--
 <sect2 id="cvs-forgreninger">
  <title>Forgreninger i udviklingen</title>

  <para>
   Det kan ske at man vil arbejde med parallel udvikling på to eller flere
   udgaver af samme projekt. Det kan for eksempel være i forbindelse med at
   man udgiver programmet (eller bogen) og dernæst både vil kunne håndtere
   fejlrettelser - men ikke tilføjelser - i den udgivne udgave og vil kunne
   videreudvikler programmet. Denne bog bliver rent faktisk til på den måde;
   mens den officielle udgave af bogen kun bliver rørt, hvis der bliver fundet
   deciderede fejl i den, bliver der parallelt foretaget store
   omstruktureringer og ændringer i bogen.
  </para>

  <example id="cvs-opret-gren">
   <title>Opret en ny gren på udviklingstræet</title>

   <para>
    Sådan opretter man en ny gren på sit udviklingstræ...
   </para>
  </example>
 </sect2>
-->

 <sect2 id="opsaet-cvs">
  <title>Opsætning af CVS</title>

  <indexterm>
   <primary>CVS</primary>
   <secondary>opsætning af</secondary>
  </indexterm>

  <indexterm>
   <primary>opsætning af</primary>
   <secondary>CVS</secondary>
  </indexterm>

  <para>
   Endelig skal nævnes hvordan man opretter et fælles CVS-arkiv og hvordan
   man lægger en samling filer ind i det fælles arkiv.
  </para>

  <sect3 id="cvs-oprettelse">
   <title>Oprettelse af et CVS-arkiv</title>

   <para>
    Hvis du ikke allerede har adgang til et CVS-arkiv, du kan lægge dine
    filer ind i, må du oprette et. Hvis du har systemadministratorrettigheder
    bør du oprette et katalog med navnet
    <filename>/usr/share/CVSROOT</filename> og lægge det der. Alternativt
    kan du for eksempel lægge det i <filename>$HOME/.CVSROOT</filename>.
    Det er vigtigt at alle, der skal kunne lægge filer ind i og rette
    filer i CVS-arkivet har adgang til at skrive i kataloget. Vi går her
    ud fra at de alle er med i brugergruppen "cvsusers" (se
    systemadministratorbogen for information om brugergrupper). CVS-arkivet
    oprettes med kommandoen

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>cvs -d $HOME/.CVSROOT init</userinput>
</screen>
   </para>

   <para>
    Når en bruger vil oprette sin egen arbejdskopi af CVS-arkivet, skal
    han/hun blot kende navnet på det katalog du valgte at lægge det fælles
    centrale CVS-arkiv i (husk at "$HOME" refererer til
    <emphasis>dit</emphasis> hjemmekatalog;
    <command>echo $HOME/.CVSROOT</command> vil give dig det fulde navn på
    det katalog der blev brugt i ovenstående eksempel). Se i øvrigt
    eksemplerne <xref linkend="cvs-kom-i-gang-lokalt">,
    <xref linkend="cvs-kom-i-gang-anonym"> og
    <xref linkend="cvs-kom-i-gang-ssh"> for flere detaljer. Vi kommer ikke
    ind på hvordan man giver anonym adgang til et CVS-arkiv her.
   </para>
  </sect3>

<!--
<para>
Da vi anvendte <command>grep</command> på alt der startede med "CVS",
fik vi også en anden variabel med <filename>CVS_RSH</filename>, som
angiver hvordan man kommunikerer med CVS-serveren. Er det en og samme
maskine udelades den variabel, og er det en anden maskine anvendes
enten secure shell (<command>ssh</command>) eller remote shell
(<command>rsh</command>). Se mere om <command>ssh</command> i bogen
"Linux - friheden til sikkerhed på internettet").
</para>
-->

  <sect3 id="cvs-oprette-et-projekt">
   <title>Opret et projekt i CVS-arkivet</title>

   <indexterm><primary>cvs</primary><secondary>import</secondary></indexterm>

   <para>
    Lad os komme videre. For at du kan lægge dine filer i CVS for første
    gang skal du flytte dig til hovedbiblioteket for kildeteksten (vi antager
    at det - og projektet - hedder <filename>webspell</filename> og at du
    oprettede CVS-arkivet som beskrevet i forrige afsnit) og importere
    filerne, fjerne filtræet og til sidst trække det ud af CVS-arkivet igen
    (denne gang <emphasis>med</emphasis> udgavehåndteringsinformation):

<screen>
<prompt>[daisy@linus daisy]$ </prompt><userinput>cd webspell</userinput>
<prompt>[daisy@linus daisy/webspell]$ </prompt><userinput>cvs -d $HOME/.CVSROOT import webspell Daisy 'Første udgave i CVS'</userinput>
<prompt>[daisy@linus daisy/webspell]$ </prompt><userinput>cd ..</userinput>
<prompt>[daisy@linus daisy]$ </prompt><userinput>mv webspell webspell-før_cvs</userinput>
<prompt>[daisy@linus daisy]$ </prompt><userinput>cvs -d $HOME/.CVSROOT checkout webspell</userinput>
</screen>

    <command>Daisy</command> er et felt, der af CVS kaldes "vendor tag"
    (leverandørmærke) og <command>'Første udgave i CVS'</command> er et
    felt, der af CVS kaldes "release tag" (udgavemærke).
   </para>

   <para>
    Det kan også nævnes at en række ekstra værktøjer fås til CVS, se
    <ulink url="http://freshmeat.net/">http://freshmeat.net/</ulink> under
    CVS. Et af disse er cvs2html, der findes fra <ulink
    url="http://cvs.sslug.dk/cvs2html/">http://cvs.sslug.dk/cvs2html/</ulink>.
    cvs2html anvendes til at reformattere den loginformation, der er
    skrevet ind for hver fil ved "cvs commit", til HTML-filer. For
    internetbaserede samarbejdsprojekter er dette virkeligt smart.
   </para>

   <para>
    Det tager et par timer at komme ind i denne måde at arbejde på, men alle
    programmerings- eller skriveprojekter i øvrigt med mere end en person vil
    CVS tjene dette overhead ind i hundredefold.
   </para>
  </sect3>

  <sect3 id="logmails-cvs">
   <title>Få breve med log-meddelelser ved cvs commit</title>

   <para>
    Når flere folk arbejder sammen på et software-projekt er det nødvendigt
    at man nemt kan se hvad andre personer har ændret i filerne. Med
    <command>cvs watch add FILNAVN</command> vil du modtage breve når andre
    kører <command>cvs commit FILNAVN</command>, men her vil du ikke se hvad
    de har ændret. Du kan få en bedre føling med ændringerne ved at bruge et
    lille program <filename>log</filename>, der følger med cvs. Med det
    program kan du få et brev om hvilke filer, som er ændret og du får også
    den log-meddelelse brugeren skrev med i brevet. Hvis man indenfor
    projektet holder en god stil med at skrive ordentlige log-meddelelser,
    så er dette super.
   </para>

   <para>
    Lad os se på opsætningen af dette. Først skal du lave en logfil i
    CVSROOT-kataloger, som alle deltagere i dit projekt kan læse og skrive.
   </para>

<para>
<emphasis>I det følgende skal du erstatte STI_TIL_CVS-RODEN med den fulde sti
til dit CVSROOT-katalog.</emphasis>.
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>touch STI_TIL_CVS-RODEN/CVSROOT/commitlog</userinput>
<prompt>[anne@linus ~]$ </prompt><userinput>chgrp PROJEKTGRUPPE STI_TIL_CVS-RODEN/CVSROOT/commitlog</userinput>
<prompt>[anne@linus ~]$ </prompt><userinput>chmod g+rw STI_TIL_CVS-RODEN/CVSROOT/commitlog</userinput>
</screen>

<para>
Dernæst skal vi rode i noget af de "helligste" af cvs-opsætningen.
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>cvs -d STI_TIL_CVS-RODEN checkout CVSROOT</userinput>
<prompt>[anne@linus ~]$ </prompt><userinput>vi CVSROOT/loginfo</userinput>
</screen>

<para>
Indsæt følgende linie til sidst hvis <filename>pto@sslug.dk</filename>
skal modtage breve. Er der flere som skal modtage breve så tilføj
gerne flere <filename>-m modtager@e-postadresse</filename> efter hinanden.
</para>

<screen>
DEFAULT /usr/lib/cvs/contrib/log -m pto@sslug.dk -f STI_TIL_CVS-RODEN/CVSROOT/commitlog
</screen>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs commit -m "Man kan modtage logbeskeder per post" CVSROOT/loginfo</userinput>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs release -d CVSROOT</userinput>
</screen>

<para>
De sidste linier vil regenerere CVSROOT (sted hvor CVS-opsætningen er
gemt), og derefter sletter man den CVSROOT-kopi man har checket ud.
</para>

  </sect3>
 </sect2>

 <sect2 id="cvs-forgreninger">
  <title>Forgreninger i udviklingen</title>

  <para>
   Lad os se lidt mere på starten, da vi lavede projektet

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cd MODUL_DIR</userinput>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs -d STI_TIL_CVS-RODEN import MODUL VENDOR_TAG RELEASE_TAG</userinput>
</screen>
  </para>

  <para>
   Dette genererer med det samme to grene (engelsk: "branches"), som man
   altid kan komme tilbage til.

   <itemizedlist mark="bullet">
    <listitem>
     <para>
      1.1.1 - VENDOR_TAG
     </para>
    </listitem>
    <listitem>
     <para>
      1.1.1.1 - RELEASE_TAG
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Går man igang med at checke filerne ud, rette og køre <command>cvs
   commit</command>, så kommer de enkelte versioner til at hedde version
   1.1, 1.2, 1.3 osv.
  </para>

  <para>
   Ofte vil alle bruge samme gren af filerne, men hvad gør man hvis man
   nu har brug for at kode et stykke tid på noget som lammer resten af
   udviklerne på samme projekt. I dette tilfælde kan man oprette en gren
   til dette - de andre udviklere kommer ikke til at se noget anderledes
   og to adskilte udviklingsgrene kan køre.
  </para>

  <para>
   Lad os antage at vi arbejder med et modul i CVS med navn "sslugkode"
   som er importeret i CVS ved at skrive <command>cvs import sslugkode
   start version0</command>. Da der ikke er nogen naturlig "vendor"
   sættes leverandør-tag blot til "start" og start-version til "version0".
  </para>

  <para>
   For at skabe "gren1" ud fra hovedgrenen "version0" skriver man (uden
   at man nødvendigvis har koden checket ud)

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs rtag -b -r version0 gren1 sslugkode</userinput>
</screen>
  </para>

  <para>
   Tilsvarende kunne man måske have en anden udvikler, som skal arbejde
   samtidig på en anden gren, "gren2"

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs rtag -b -r version0 gren2 sslugkode</userinput>
</screen>
  </para>

  <para>
   For at isolere sig selv i grenen "gren1" skrives
<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs -d STI_TIL_CVS-RODEN checkout sslugkode</userinput>
<prompt>[anne@linus ~]$</prompt> <userinput>cd sslugkode</userinput>
<prompt>[anne@linus sslugkode]$</prompt> <userinput>cvs update -r gren1</userinput>
</screen>
   eller direkte
<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs -d STI_TIL_CVS-RODEN checkout -r gren1 sslugkode</userinput>
</screen>
  </para>

  <para>
   Det normale er derefter at udvikleren retter, laver <command>cvs
   commit</command> som vanligt. Fordelen er at de andre udviklere ikke
   ser dette. Grenene er totalt afkoblede indtil der laves en "merge"
  </para>

  <para>
   Hvis det skulle ske at vores udvikler fra "gren1" skal hjælpe han
   som arbejder i "gren2"-grenen, så kan han lave <command>cvs
   commit</command> på egne filer og derfter skifte direkte over til "gren2"

<screen>
<prompt>[anne@linus sslugkode]$</prompt> <userinput>cvs update -r gren2</userinput>
</screen>
  </para>

  <para>
   Endelig kan man skifte ud til hoved-sporet (komme ud af henholdsvis
   "gren1" og "gren2" ved at skrive

<screen>
<prompt>[anne@linus sslugkode]$</prompt> <userinput>cvs update -A</userinput>
</screen>
  </para>

  <sect3 id="cvs-join">
   <title>Flette grene sammen igen</title>

   <para>
    Antag at to udviklingsgrene, som hver for sig har udviklet sig, på et
    tidspunkt skal flettes sammen.
   </para>

   <para>
    I "gren2"-grenen kan du opdatere med nyeste ting fra "gren1"-grenen
    ved at skrive

<screen>
<prompt>[anne@linus sslugkode]$</prompt> <userinput>cvs update -j gren1</userinput>
</screen>
   </para>

   <para>
    Hvis man ikke var i "gren2" skal man først sikre at du er i "gren1"-grenen.

<screen>
<prompt>[anne@linus sslugkode]$</prompt> <userinput>cvs update -r gren2</userinput>
<prompt>[anne@linus sslugkode]$</prompt> <userinput>cvs update -j gren1</userinput>
</screen>
   </para>
  </sect3>
 </sect2>

 <sect2 id="misc-med-cvs">
  <title>Diverse med CVS</title>

  <para>
   Det kan nævnes, at hvis Emacs indlæser en fil, der er koblet ind i CVS,
   vil Emacs automatisk genkende dette og indsætte en ekstra menu, hvorfra
   du på enkel vis kan sende tilføjelser til den fælles database (selve
   ændringerne skal du ikke selv styre - det klarer Emacs og CVS).
  </para>

  <para>
   Skal man anvende en "export" version til distribution, eller blot ikke
   ønsker at lave en "checkout", så er <command>cvs export PROJEKT</command>
   også en mulighed. Den henter kun filerne, men ikke
   CVS-informationsfilerne. Meget praktisk til at skelne mellem udgivelse
   af filer ("export") i forhold til udvikler-version med fuld
   CVS-information ("checkout").
  </para>

  <para>
   Vi har tidligere vist, at projekt/kildetekst hentes med:

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs STI_TIL_CVS-RODEN checkout projektnavn</userinput>
</screen>
  </para>

  <para>
<!--
   Men for folk, der deltager i mange projekter er det interessant at man
   faktisk også kan angive variablen <literal>CVSROOT</literal> som argument
   på kommandolinien:

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cvs -d USER@tux.hjemme:/usr/local/CVSROOT checkout projektnavn</userinput>
</screen>

   og det skal bemærkes at man faktisk ikke anvender
   <literal>CVSROOT</literal> efter at man har kørt <command>cvs
   checkout</command>.
-->

   Hvis man ser efter i
   <filename>projekt-katalog/CVS</filename>, så finder man der tre filer,
   som tilhører CVS:

   <itemizedlist mark="bullet">
    <listitem>
     <para>
      <filename>Repository</filename> indeholder projekt-navn på CVS-serveren.
     </para>
    </listitem>
    <listitem>
     <para>
      <filename>Root</filename> indeholder <literal>CVSROOT</literal> for det
      pågældende projekt.
     </para>
    </listitem>
    <listitem>
     <para>
      <filename>Entries</filename> indeholder listen over de filer og
      kataloger som er registreret i CVS.
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   Næste trick er for dem som anvender SSH til at kommunikere med CVS.
   Man kan få ssh til at understøtte komprimering i
   <filename>~/.ssh/config</filename>:

<screen>
Compression yes
CompressionLevel 6
</screen>
  </para>

  <para>
   Men vær opmærksom på at visse servere ikke kan finde ud af at anvende
   komprimering, så er der uforklarlige problemer med at få forbindelse, så
   slå det fra.
  </para>
 </sect2>
</sect1>
