<!-- $Id$ -->
<SECT1 id="program-shell">
<title>Shell-programmering</title>
<indexterm><primary>Shell programmering</primary></indexterm>
<indexterm><primary>/bin/sh</primary></indexterm>
<indexterm><primary>sh</primary></indexterm>
<indexterm><primary>bash</primary></indexterm>
<para>
Hvis du ofte har brug for at køre nogle bestemte programmer for at
håndtere en tilbagevendende opgave, bør du sætte dig ind i hvordan man
skrive et <emphasis>shell-skript</emphasis>. Kender du til
batch-filer under DOS, har du en ide om, hvad det går ud på. Et
shell-skript er i bund og grund blot en tekstfil, der indeholder en
række kommandoer og måske nogle ekstra linjer til at vælge hvilke dele
af scriptet, der skal udføres.
</para>
<para>
Til forskel fra DOS' batchfiler er shell-sproget dog langt mere fuldt
- det kan, sammen med alle standard-UNIX-kommandoerne, næsten det
samme som et 'rigtigt' programmeringssprog. Ligesom alle andre sprog
har det sine styrker og sine svagheder. Et shell-skript er generelt
bedst til de store linjer -  de er gode til at fortælle andre
programmer, hvad der skal gøres, men ikke så gode til at gøre det
detaljerede arbejde selv.
</para>

<para>
Det første eksempel på et shell-skript bør være "Hello World", som
skriver en tekst på skærmen.
</para>

<screen>
#!/bin/sh
echo "Hello World"
</screen>

<para>
Dette gemmes under navnet <filename>HelloWorld</filename> eller
lignende, og derefter gøres filen kørbar med <command>chmod +x
HelloWorld</command>. Du kan nu teste eksemplet ved at skrive
<command>./HelloWorld</command> på en kommando linje (f.eks. i en
xterm). Du skal skrive punktum og skråstreg foran programnavnet, hvis
du ikke har ændret din søgesti ($PATH) i
<filename>~/.profile</filename>.
</para>

<para>
Et eksempel kunne være, at du fandt ud af, at du ofte havde brug for en
nem metode til at tage en hurtig kopi af tekstfilerne i
arbejdskataloget.
</para>

<screen>
#!/bin/sh
echo "Starter sikkerhedskopiering..."
mkdir backup
cp *.txt backup
echo "Sikkerhedskopiering slut"
</screen>

<para>
Gem denne tekst i en fil med navnet <filename>bu</filename> (for "back
up"), og gør den kørbar med kommandoen <userinput>chmod +x
bu</userinput>. Nu kan du køre <filename>bu</filename> fra kommandolinjen:
</para>

<screen>
<prompt>$</prompt> <userinput>./bu</userinput>
Starter sikkerhedskopiering...
Sikkerhedskopiering slut
</screen>

<para>
Første linje i scriptet er egentlig en kommentar, men giver
samtidig systemet besked om, at dette er et shell-skript og ikke f.eks. et
perl-skript.
</para>

<para>
Hvis du er lidt forsigtig anlagt og gerne vil undgå at komme til at
overskrive en eksisterende backup, kan du udvide skriptet en smule:
</para>

<screen>
#!/bin/sh
echo "Starter sikkerhedskopiering..."
mkdir backup
if [ $? -eq 0 ]
then
    echo "kataloget ./backup oprettet..."
else
    echo "kataloget ./backup kunne IKKE oprettes"
    echo "bu afsluttes"
    exit 1
fi
cp -v *.txt backup
echo "bu slut"
</screen>

<indexterm><primary>Shell variable</primary></indexterm>
<para>
I linje 4 i skriptet støder vi på en såkaldt shell-variabel, nemlig
<filename>$?</filename>, der betyder "resultatet af sidst udførte
kommando". Her bruges den til at vise, om <filename>mkdir</filename>
lykkedes eller ej.
</para>

<para>
Hvis vi så finder ud af, at vi af og til har brug for at overskrive en
backup, kan vi ændre vores skript en smule, så vi ved at tilføje
<userinput>-O</userinput> på kommandolinjen kan få den til at være
ligeglad med, om kataloget findes i forvejen:
</para>

<screen>
#!/bin/sh
echo "Starter sikkerhedskopiering..."
mkdir backup
if [ $? -eq 0 ]
then
    echo "kataloget ./backup oprettet..."
else
    echo "kataloget ./backup kunne IKKE oprettes"
    OVERWRITE="-O"
    if [ $# -eq 1 ]	        # $# angiver antallet af kommandolinjeparametre
    then
        if [ $1 != $OVERWRITE ] # $1 er første kommandolinjeparameter
        then
            echo "bu afsluttes"
            exit 1
        else
            echo "der overskrives..."
        fi
    else
        echo "bu afsluttes"
        exit 1
    fi
fi
cp -v *.txt backup
echo "bu slut"
</screen>

<para>
Du kan faktisk nå temmelig langt ved hjælp af shell-skript, men det kan
hurtigt blive lidt kryptisk at læse. Kunsten er nok i virkeligheden at
stoppe, mens legen er god, og vælge et "rigtigt" programmeringssprog, når
opgaven kræver det. Alligevel bør du lære at skrive shell-programmer, dels
for at lave dine egne små praktiske løsninger på dagligdagens problemer,
dels for at kunne forstå andres shell-programmer.
</para>

<para>
Endelig kan det nævnes at der findes en del bøger om
shell-programmering, bl.a. fra <ulink
url="http://www.oreilly.com">O'Reilly</ulink>, bl.a. "Learning the
Bash Shell". Eksemplerne fra denne bog er interessante og de kan
hentes fra 
<ulink url="http://www.oreilly.com/catalog/bash/">http://www.oreilly.com/catalog/bash/</ulink>.
En anden god introduktion til Bash-Prog-Intro-HOWTO, som kan findes på 
<ulink url="http://sunsite.auc.dk/ldp">http://sunsite.auc.dk/ldp</ulink>.
</para>


<SECT2 ID="sed">
<title>sed</title>
<indexterm><primary>sed</primary></indexterm>
<para>
Programmet <command>sed</command> er ofte anvendt i UNIX til at
modificere tekst, såsom at uddrage eller ændre en mindre del af en
tekstlinie. Ofte læses teksten fra en pipe-konstruktion eller fra en fil og
tilsvarende afleveres resultatet i en fil eller til en pipe.
Fordelen med <command>sed</command> i forhold til Perl (som kan meget
mere) er at sed er et lille program, og derfor hurtigere at udføre.
</para>

<para>
Lad os tage et eksempel med anvendelse af sed.  I shell-skript kan man
ofte være interesseret i at finde stinavne (eng. pathname), basefilename 
og extension udfra den fulde sti i $0 for shell-skript.  Så for at manipulere med
fuld sti kan man gøre følgende:
</para>

<SCREEN>
  pathname=`echo $0 | sed 's#[^/]*$##'`
  progname=`echo $0 | sed 's#^.*/##'`
  noext=`echo $0 | sed 's/\.[^\.]\+$//'`

  ext =`echo $progname | sed 's/^.\+\.//'`
  ext2=`echo $progname | sed 's/^.\+\././'`
</screen>

<para>
Dog vil ovenstående eksempler måske fejle for visse typer stinavne,
men de plejer at virke for de fleste "normale" sti+filnavne man
anvender.
</para>

<para>
Alle 5 eksempler indeholder en enkelt sed-kommando, nemlig en
'substitute'-kommando (erstat en del af inputtet med noget andet) -
det er hvad s'et står for.
Substitute-kommandoen har normalt formatet s/gammelt/nyt/
(hvor <filename>gammelt</filename> er regulært udtryk, se <filename>man 7
regex</filename>, og <filename>nyt</filename> er det der skal
erstattes med), men som det er illustreret i de to første eksempler,
kan man også bruge et andet tegn end skråstreg til at afgrænse de to
felter med - her er brugt <filename>#</filename>.
</para>

<para>
Lad os som eksempel tage filnavnet
<filename>/home/peter/hello.c</filename> som eksempel.
I de fire første sed-programmer fjernes en del af teksten - der
erstattes med ingenting.
I <filename>pathname</filename>-eksemplet findes stinavnet ved at
fjerne den sidste del af filnavnet, til og uden den sidste
skråstreg. Resultatet er <filename>/home/peter/</filename>.
<filename>progname</filename>-eksemplet finder programfilens navn ved
at fjerne starten, til og med den første skråstreg - resultatet er
<filename>hello.c</filename>.
<filename>noext</filename>-eksemplet fjerner extensionen, altså fra
slutningen og tilbage til og med det sidste punktum - tilbage er
<filename>/home/peter/hello</filename>.
Endelig finder <filename>ext</filename>-eksemplet extensionen ved at
fjerne fra starten og til og med det sidste punktum i filnavnet.
</para>

<para>
Det sidste eksempel (<filename>ext2</filename>) virker som det næstsidste (<filename>ext</filename>) og finder
filnavnets extension, bortset fra at ext2 lader et punktum stå - der
erstattes med <filename>.</filename>.
</para>

<para>
Vil du vide mere om <command>sed</command>, så kan du læse 
mere på <ulink url="http://2dos.homepage.dk/batutil/help/SED.HTM">http://2dos.homepage.dk/batutil/help/SED.HTM</ulink>.
</para>

</SECT2><!-- sed -->

<SECT2 id="tcsh">
<title>tcsh</title>

<indexterm><primary>tcsh</primary></indexterm>

<para>
På de fleste UNIX-kompatible maskiner, såsom Linux, findes flere forskellige
kommando-shells (kommandofortolkere).
Nogle ad de mest kendte er <filename>ksh</filename> (Korn-shellen),
<filename>sh</filename> (Bourne-shellen) og
<filename>csh</filename>. De er meget udbredte, men til daglig anvendelse
mangler flere af dem visse nyttige funktioner, såsom vis forrige
kommando, kommando- og filnavn-udfyldning (tryk på tabulator). Derfor
er <filename>Bash</filename> (Bourne Again-shellen) og
<filename>tcsh</filename> bedre alternativer.
</para>
<para>
I Linux er sh blot et link til bash. Dette går godt, fordi bash er
bagud-kompatibel med sh (deraf navnet og ordspillet 'Bourne Again
shell'), og afsnittet om shellprogrammering tidligere i dette kapitel
gælder altså også for Bash.
Her skal vi nævne lidt om tcsh, som er en videreudvikling af csh.
</para>

<para>
<!-- dette kan med fordel flyttes et andet sted hen i kapitlet: -->
Når man logger ind via kommandolinje, havner man normalt i en
shell. For at finde ud  af, hvilken shell der skal startes, ser
login-programmet i filen <filename>/etc/passwd</filename>, som indeholder en
liste over alle brugernavne samt nogle oplysninger om hver, en linje
pr. bruger. Det sidste felt på hver linje angiver hvilket program, den
pågældende bruger har som standardshell
(dette kan være et hvilket som helst program - det behøver ikke at
være en shell, men kunne også være f.eks. 
<filename>vi</filename> eller <filename>emacs</filename>).
Hvis du har bestemt dig for at bruge tcsh som shell, skal dette felt
altså ændres
(typisk fra <filename>/bin/bash</filename>)
til <filename>/bin/tcsh</filename>,
afhængigt af hvor kommandofortolkeren ligger.
</para>

<para>
Når tcsh startes, udfører den først kommandoerne skrevet i filerne
<filename>/etc/csh.login</filename> (ved login) og
<filename>/etc/csh.cshrc</filename> (ved hver shell, der startes). De
bliver altså udført for alle brugere, der bruger tcsh.
Derefter udføres tilsvarende kommandoer, der er angiver i
<filename>~/.login</filename> og <filename>~/.tcshrc</filename> - disse
filer kan tilpasses af og til den enkelte bruger.
Når tcsh afsluttes, køres tilsvarende
<filename>/etc/csh.logout</filename> og <filename>~/.logout</filename>.
Et eksempel på <filename>.login</filename> er:
<indexterm><primary>.login</primary></indexterm>
</para>	

<indexterm>
 <primary>Dansk</primary>
 <secondary>Tastatur og sprog</secondary>
</indexterm>

<screen>
#!/bin/csh
# User .login file (/bin/csh initialization).

# Begræns forbrug for programmer
limit coredumpsize 0
limit stacksize 140000
limit datasize 140000
limit memoryuse 140000
limit filesize 20000

# Editor
setenv EDITOR emacs
# CVS skal bruge Secure Shell
setenv CVS_RSH ssh
setenv RSYNC_RSH ssh
# gzip skal komprimere maksimalt
setenv GZIP "-9 -v"
setenv HOSTNAME "cat /etc/HOSTNAME"
unsetenv LESS
# Brug latin1 tegnsæt med less kommandoen
setenv LESSCHARSET latin1
# Vælg printer til lp
setenv PRINTER lp

#Dansk tastaturopsætning
setenv LC_ALL da_DK
setenv LANG da

# Manual path
setenv MANPATH /usr/local/man:/usr/man/preformat:/usr/man:/usr/X11/man

if ( ! $?PAGER ) then
  setenv PAGER less
endif

#if ($TERM == linux) startx

# Hvis du er i tekst terminal 1, så start X op automatisk
if (`echo $tty` == tty1) startx
</screen>

<screen>
#!/bin/tcsh
# User .tcshrc file (/bin/tcsh initialization).

# Standard fil maske rw for mig - r for andre og gruppe
umask 022
# Path (søgesti)
set path = ( .  ~/bin /usr/local/bin /usr/X11R6/bin \
 /bin /usr/bin /usr/X11R6/bin /usr/lib/teTeX/bin \
 /usr/local/Office51/bin )

if ( ! $?prompt ) exit                      # Shell is interactive

set filec
set notify
set nobeep
set cdpath  = ( ~:/usr/spool )
#set watch = (1 any any)
set history = 500                           # Command prompt history
set savehist                                # Number to save across sessions
set autolist                                # List choices in name completion
set correct = cmd                           # Checks spelling of commands
set prompt  = "%{^[[1m%}${user}@`hostname`%/>%{^[[0m%} " # Command prompt

#Gør at ls får farver
alias ls 'ls --color=always'
                                                      # in boldface
set matchbeep=nomatch

# Er der er en .alias fil, så indlæs denne
if ( -e ~/.alias ) source ~/.alias
</screen>

<para>
Der er øvrigt en del eksempler og tips vedrørende opsætning af shells mv. på
<ulink url="http://www.sslug.dk/artikler/begyndertips">http://www.sslug.dk/artikler/begyndertips</ulink>
</para>

</SECT2><!-- tcsh -->
</SECT1><!-- shell -->
