<!-- $Id$ -->
<SECT1 id="program-shell">
 <title>Kommandofortolker-programmering</title>

 <indexterm><primary>kommandofortolker-programmering</primary></indexterm>
 <indexterm><primary>shell-programmering</primary></indexterm>
 <indexterm><primary>/bin/sh</primary></indexterm>
 <indexterm><primary>sh</primary></indexterm>
 <indexterm><primary>bash</primary></indexterm>

 <para>
  Hvis du ofte har brug for at køre nogle bestemte programmer for at håndtere
  en tilbagevendende opgave, bør du sætte dig ind i hvordan man skrive et
  program i en kommandofortolker. Kender du til "batch-filer" under DOS, har
  du en idé om, hvad det går ud på. Et kommandofortolkerprogram er i bund og
  grund blot en tekstfil, der indeholder en række kommandoer og måske nogle
  ekstra linjer til at vælge hvilke dele af programmet, der skal udføres.
 </para>

 <para>
  Til forskel fra DOS' "batch-filer" er kommandofortolkerne du finder på dit
  Linux-system noget mere fleksible. Du råder over et komplet og ganske
  anvendeligt programmeringssprog.
  <!-- Gør man ikke også det i DOS? -->
  Ligesom andre programmeringssprog har det sine styrker og sine svagheder.
  Kommandofortolkeren er generelt bedst til de store linjer - til at fortælle
  andre programmer hvad der skal gøres, men ikke så gode til at gøre det
  detaljerede arbejde.
 </para>

 <para>
  Det første eksempel på et kommandofortolkerprogram bør være "Hello World"
  der blot skriver en tekst på skærmen.
 </para>

<screen>
#!/bin/sh
echo "Hello World"
</screen>

 <para>
  Dette gemmes under navnet <filename>HelloWorld</filename> eller lignende, og
  derefter gøres filen kørbar med <command>chmod +x HelloWorld</command>. Du
  kan nu afprøve programmet ved at skrive <command>./HelloWorld</command> på
  en kommandolinje (for eksempel i en xterm). Du skal skrive punktum og
  skråstreg foran programnavnet for at fortælle kommandofortolkeren at
  programmet ligger i det katalog du står i.
 </para>

 <para>
  Et andet eksempel kunne være, at du fandt ud af, at du ofte havde brug for
  en nem metode til at tage en hurtig kopi af tekstfilerne i arbejdskataloget.
 </para>

<screen>
#!/bin/sh
echo "Starter sikkerhedskopiering..."
mkdir backup
cp *.txt backup
echo "Sikkerhedskopiering slut"
</screen>

 <para>
  Gem denne tekst i en fil med navnet <filename>sk</filename> (for
  "sikkerhedskopi"), og gør den kørbar med kommandoen
  <command>chmod +x sk</command>. Nu kan du køre <filename>sk</filename> fra
  kommandolinjen:

<screen>
<prompt>$ </prompt><userinput>./sk</userinput>
Starter sikkerhedskopiering...
Sikkerhedskopiering slut
</screen>
 </para>

 <para>
  Første linje i programmet er egentlig en kommentar, men giver samtidig
  systemet besked om, at dette er et fortolket program og at det skal
  fortolkes af <filename>/bin/sh</filename> og ikke af for eksempel Perl.
 </para>

<para>
Hvis du er lidt forsigtig anlagt og gerne vil undgå at komme til at
overskrive en eksisterende sikkerhedskopi, kan du udvide programmet en smule:
</para>

<screen>
#!/bin/sh
echo "Starter sikkerhedskopiering..."
mkdir backup
if [ $? -eq 0 ]
then
    echo "kataloget ./backup oprettet..."
else
    echo "kataloget ./backup kunne IKKE oprettes"
    echo "bu afsluttes"
    exit 1
fi
cp -v *.txt backup
echo "bu slut"
</screen>

<indexterm><primary>Kommandofortolkervariable</primary></indexterm>
<para>
På linje 4 i programmet støder vi på en lidt speciel variabel, nemlig
<literal>$?</literal>, der betyder "resultatet af sidst udførte
kommando". Her bruges den til at vise, om <filename>mkdir</filename>
lykkedes eller ej.
</para>

<para>
Hvis vi så finder ud af, at vi af og til har brug for at overskrive en
backup, kan vi ændre vores program en smule, så vi ved at tilføje
<userinput>-O</userinput> på kommandolinjen kan få den til at være
ligeglad med, om kataloget findes i forvejen:
</para>

<screen>
#!/bin/sh
echo "Starter sikkerhedskopiering..."
mkdir backup
if [ $? -eq 0 ]
then
    echo "kataloget ./backup oprettet..."
else
    echo "kataloget ./backup kunne IKKE oprettes"
    OVERWRITE="-O"
    if [ $# -eq 1 ]	        # $# angiver antallet af kommandolinjeparametre
    then
        if [ $1 != $OVERWRITE ] # $1 er første kommandolinjeparameter
        then
            echo "bu afsluttes"
            exit 1
        else
            echo "der overskrives..."
        fi
    else
        echo "bu afsluttes"
        exit 1
    fi
fi
cp -v *.txt backup
echo "bu slut"
</screen>

 <para>
  Du kan faktisk nå temmelig langt i kommandofortolkeren, men det kan hurtigt
  blive lidt kryptisk at læse. Kunsten er nok i virkeligheden at stoppe, mens
  legen er god, og vælge et "rigtigt" programmeringssprog, når opgaven kræver
  det. Alligevel bør du lære at skrive programmer i kommandofortolkeren, dels
  for at lave dine egne små praktiske løsninger på dagligdagens problemer,
  dels for at kunne forstå andres kommandofortolkerprogrammer.
 </para>

 <para>
  Endelig kan det nævnes at der findes en del bøger om programmering af
  kommandofortolkere, blandt andet "Learning the Bash Shell" fra <ulink url=
  "http://www.oreilly.com/">O'Reilly</ulink>. Eksemplerne i denne bog er
  interessante og de kan hentes fra <ulink url=
  "http://www.oreilly.com/catalog/bash/">http://www.oreilly.com/catalog/bash/</ulink>.
  En anden god introduktion er Bash-Prog-Intro-HOWTO der kan findes på <ulink
  url="http://sunsite.dk/ldp">http://sunsite.dk/ldp</ulink>.
 </para>

<SECT2 ID="sed">
<title>sed</title>
<indexterm><primary>sed</primary></indexterm>
<para>
Programmet <command>sed</command> er ofte anvendt i Unix til at
modificere tekst, såsom at uddrage eller ændre en mindre del af en
tekstlinie. Ofte læses teksten fra en pipe-konstruktion eller fra en fil og
tilsvarende afleveres resultatet i en fil eller til en pipe.
Fordelen med <command>sed</command> i forhold til Perl (som kan meget
mere) er at sed er et lille program, og derfor hurtigere at udføre.
</para>

 <para>
  Lad os tage et eksempel med anvendelse af <command>sed</command>. I
  kommandofortolkeren kan man ofte være interesseret i at dele et komplet
  filnavn op i katalogets navn og filens navn. Hvis vi ser på programmets
  eget navn, <literal>$0</literal>, kan vi lave disse manipulationer:
 </para>

<SCREEN>
  pathname=`echo $0 | sed 's#[^/]*$##'`
  progname=`echo $0 | sed 's#^.*/##'`
  noext=`echo $0 | sed 's/\.[^\.]\+$//'`

  ext =`echo $progname | sed 's/^.\+\.//'`
  ext2=`echo $progname | sed 's/^.\+\././'`
</screen>

<para>
Dog vil ovenstående eksempler måske fejle for visse typer stinavne,
men de plejer at virke for de fleste "normale" sti+filnavne man
anvender.
</para>

<para>
Alle 5 eksempler indeholder en enkelt sed-kommando, nemlig en
'substitute'-kommando (erstat en del af inputtet med noget andet) -
det er hvad s'et står for.
Substitute-kommandoen har normalt formatet s/gammelt/nyt/
(hvor <filename>gammelt</filename> er regulært udtryk, se <filename>man 7
regex</filename>, og <filename>nyt</filename> er det der skal
erstattes med), men som det er illustreret i de to første eksempler,
kan man også bruge et andet tegn end skråstreg til at afgrænse de to
felter med - her er brugt <filename>#</filename>.
</para>

<para>
Lad os som eksempel tage filnavnet
<filename>/home/peter/hello.c</filename> som eksempel.
I de fire første sed-programmer fjernes en del af teksten - der
erstattes med ingenting.
I <filename>pathname</filename>-eksemplet findes stinavnet ved at
fjerne den sidste del af filnavnet, til og uden den sidste
skråstreg. Resultatet er <filename>/home/peter/</filename>.
<filename>progname</filename>-eksemplet finder programfilens navn ved
at fjerne starten, til og med den første skråstreg - resultatet er
<filename>hello.c</filename>.
<filename>noext</filename>-eksemplet fjerner extensionen, altså fra
slutningen og tilbage til og med det sidste punktum - tilbage er
<filename>/home/peter/hello</filename>.
Endelig finder <filename>ext</filename>-eksemplet extensionen ved at
fjerne fra starten og til og med det sidste punktum i filnavnet.
</para>

<para>
Det sidste eksempel (<filename>ext2</filename>) virker som det næstsidste (<filename>ext</filename>) og finder
filnavnets extension, bortset fra at ext2 lader et punktum stå - der
erstattes med <filename>.</filename>.
</para>

<para>
Vil du vide mere om <command>sed</command>, så kan du læse 
mere på <ulink url="http://2dos.homepage.dk/batutil/help/SED.HTM">http://2dos.homepage.dk/batutil/help/SED.HTM</ulink>.
</para>

</SECT2><!-- sed -->

<SECT2 id="tcsh">
<title>tcsh</title>

<indexterm><primary>tcsh</primary></indexterm>

<para>
På de fleste Unix-kompatible maskiner, såsom Linux, findes flere forskellige
kommandofortolkere.
Nogle ad de mest kendte er <filename>ksh</filename> (Korn Shell),
<filename>sh</filename> (Bourne Shell) og
<filename>csh</filename> (C Shell). De er meget udbredte, men til daglig anvendelse
mangler flere af dem visse nyttige funktioner, såsom vis forrige
kommando, kommando- og filnavn-udfyldning (tryk på tabulator). Derfor
er <filename>Bash</filename> (Bourne Again Shell) og
<filename>tcsh</filename> bedre alternativer.
</para>
<para>
I Linux er sh blot et link til bash. Dette går godt, fordi bash er
bagud-kompatibel med sh (deraf navnet og ordspillet 'Bourne Again
Shell'), og afsnittet om kommandofortolkerprogrammering tidligere i dette kapitel
gælder altså også for Bash.
Her skal vi nævne lidt om tcsh, som er en videreudvikling af csh.
</para>

<para>
<!-- dette kan med fordel flyttes et andet sted hen i kapitlet: -->
Når man logger ind via kommandolinje, havner man normalt i en
kommandofortolker. For at finde ud  af, hvilken kommandofortolker der skal startes, ser
login-programmet i filen <filename>/etc/passwd</filename>, som indeholder en
liste over alle brugernavne samt nogle oplysninger om hver, en linje
pr. bruger. Det sidste felt på hver linje angiver hvilket program, den
pågældende bruger har som standardkommandofortolker
(dette kan være et hvilket som helst program - det behøver ikke at
være en kommandofortolker, men kunne også være f.eks. 
<filename>vi</filename> eller <filename>emacs</filename>).
Hvis du har bestemt dig for at bruge tcsh som kommandofortolker, skal dette felt
altså ændres
(typisk fra <filename>/bin/bash</filename>)
til <filename>/bin/tcsh</filename>,
afhængigt af hvor kommandofortolkeren ligger.
</para>

<para>
Når tcsh startes, udfører den først kommandoerne skrevet i filerne
<filename>/etc/csh.login</filename> (ved login) og
<filename>/etc/csh.cshrc</filename> (ved hver kommandofortolker, der startes). De
bliver altså udført for alle brugere, der bruger tcsh.
Derefter udføres tilsvarende kommandoer, der er angiver i
<filename>~/.login</filename> og <filename>~/.tcshrc</filename> - disse
filer kan tilpasses af og til den enkelte bruger.
Når tcsh afsluttes, køres tilsvarende
<filename>/etc/csh.logout</filename> og <filename>~/.logout</filename>.
Et eksempel på <filename>.login</filename> er:
<indexterm><primary>.login</primary></indexterm>
</para>	

 <indexterm><primary>tekster</primary><secondary>danske</secondary></indexterm>
 <indexterm><primary>danske tekster</primary></indexterm>
 <indexterm><primary>tastatur</primary><secondary>dansk</secondary></indexterm>
 <indexterm><primary>dansk tastatur</primary></indexterm>
 <indexterm><primary>sortering</primary><secondary>dansk</secondary></indexterm>
 <indexterm><primary>dansk sortering</primary></indexterm>

<screen>
#!/bin/csh
# User .login file (/bin/csh initialization).

# Begræns forbrug for programmer
limit coredumpsize 0
limit stacksize 140000
limit datasize 140000
limit memoryuse 140000
limit filesize 20000

# Editor
setenv EDITOR emacs
# CVS skal bruge Secure Shell
setenv CVS_RSH ssh
setenv RSYNC_RSH ssh
# gzip skal komprimere maksimalt
setenv GZIP "-9 -v"
setenv HOSTNAME "cat /etc/HOSTNAME"
unsetenv LESS
# Brug latin1 tegnsæt med less kommandoen
setenv LESSCHARSET latin1
# Vælg printer til lp
setenv PRINTER lp

# Dansk tastaturopsætning, danske tekster, dansk alfabetisk sortering, m.m.
setenv LC_ALL da_DK
setenv LANG da

# Manual path
setenv MANPATH /usr/local/man:/usr/man/preformat:/usr/man:/usr/X11/man

if ( ! $?PAGER ) then
  setenv PAGER less
endif

#if ($TERM == linux) startx

# Hvis du er i tekst terminal 1, så start X op automatisk
if (`echo $tty` == tty1) startx
</screen>

<screen>
#!/bin/tcsh
# User .tcshrc file (/bin/tcsh initialization).

# Standard fil maske rw for mig - r for andre og gruppe
umask 022
# Path (søgesti)
set path = ( .  ~/bin /usr/local/bin /usr/X11R6/bin \
 /bin /usr/bin /usr/X11R6/bin /usr/lib/teTeX/bin \
 /usr/local/Office51/bin )

if ( ! $?prompt ) exit                      # Shell is interactive

set filec
set notify
set nobeep
set cdpath  = ( ~:/usr/spool )
#set watch = (1 any any)
set history = 500                           # Command prompt history
set savehist                                # Number to save across sessions
set autolist                                # List choices in name completion
set correct = cmd                           # Checks spelling of commands
set prompt  = "%{^[[1m%}${user}@`hostname`%/>%{^[[0m%} " # Command prompt

#Gør at ls får farver
alias ls 'ls --color=always'
                                                      # in boldface
set matchbeep=nomatch

# Er der er en .alias fil, så indlæs denne
if ( -e ~/.alias ) source ~/.alias
</screen>

<para>
Der er øvrigt en del eksempler og tips vedrørende opsætning af kommandofortolkere med vider på
<ulink url="http://www.sslug.dk/artikler/begyndertips">http://www.sslug.dk/artikler/begyndertips</ulink>
</para>

</SECT2><!-- tcsh -->
</SECT1><!-- shell -->
