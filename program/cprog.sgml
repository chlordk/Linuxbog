<!-- $Id$ -->
<sect1 id="basalcprog">
 <title>C- og C++-programmering</title>

 <indexterm><primary>C</primary></indexterm>
 <indexterm><primary>C++</primary></indexterm>

 <para>
  Programmeringssproget C og Unix-familien af styresystemer har traditionelt
  været tæt knyttet til hinanden. Dette gælder i høj grad også for Linux.
  Kernen og langt de fleste programmer er skrevet i C. C++ er en udvidelse af
  C, der giver mulighed for objektorienteret programmering. 
 </para>

 <para>
  Skal et program køre hurtigt, så er C og C++ gode valg af
  programmeringssprog. Både C og C++ har dog en syntaks der dels er svær at
  forstå for begyndere og dels let leder til alvorlige fejl i programmerne.
  I både C og C++ er det op til brugeren at allokere hukommelse til
  datastrukturer, og sørge for at programmet kun skriver inden for den
  allokerede hukommelse. Dette er en egenskab ved C der historisk har ledt til
  mange problematiske programmeringsfejl, og en grund til at det kan tage lang
  tid at finde fejl i C- og C++-programmer. C har også en meget primitiv
  repræsentation af strenge. C++ er lidt bedre på dette punkt, men for
  eksempel Perl er et langt stærkere sprog til behandling af store mængder
  tekst. I det hele taget har C og C++ problemer med håndtering af forskellige
  datatyper og en alvorlig mangel på beskyttelse mod utilsigtede oversættelser
  mellem de forskellige datatyper.
 </para>

 <para>
  <indexterm><primary>GNU C/C++</primary></indexterm>

  GNU C/C++ er en af de allerbedste oversættere på markedet i dag. I
  modsætning til Windows-verdenen er oversætteren ikke låst inde i en
  grafisk brugergrænseflade. Det giver større frihed for den enkelte til at
  sammensætte et personligt udviklingsmiljø - enten grafisk eller
  tekstbaseret. Med lidt tilvænning er det også hurtigt at anvende, specielt
  hvis der skal oversættes meget kildetekst per gang. Der er også den store
  fordel,
  at det er meget udbredt inden for Unix-verdenen, hvorfor kildetekst og
  oversættelsesfiler (engelsk: makefiles) uden problemer kan flyttes,
  oversættes og køres på andre typer af Unix-systemer.
 </para>

 <sect2 id="hello-c">
  <title>Hello, world!</title>

  <indexterm>
   <primary>Hello, world!</primary>
   <secondary>C</secondary>
  </indexterm>

  <para>
   Per tradition er HelloWorld-programmet det første C-program, man skal få
   til at virke. Programmet skriver en kort tekst "Hello World" ud på skærmen
   og afslutter. Indtast følgende i en editor, og gem det som
   <filename>hello.c</filename>.
  </para>

<screen>
#include &lt;stdio.h&gt;

int main(void)
{
  printf("Hello, world!\n");
}
</screen>

  <para>
   I kataloget, hvor filen er gemt, kan programmet nu oversættes ved at skrive

   <screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>gcc -o hello hello.c</userinput>
   </screen>
  </para>

  <para>
   <indexterm><primary>gcc</primary></indexterm>

   C-oversætteren hedder <command>gcc</command>. Den skal her lave en kørbar
   fil med navnet <filename>hello</filename>, og den skal oversætte og samle
   programmet udfra kildeteksten i <filename>hello.c</filename>. Det oversatte
   program <filename>hello</filename> køres ved at skrive
   <command>./hello</command> i et terminalvindue.
</para>

</sect2><!-- foerstecprog -->

<sect2 id="biblioteker-c">
<title>Funktions biblioteker!</title>
<indexterm><primary>Funktions biblioteker</primary><secondary>dynamisk linking</secondary></indexterm>

<para>
Programmet <command>nm</command> kan bruges til at liste funktionerne
der defineres i et program. Prøv at køre følgende kommando

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>nm hello</userinput>
</screen>
</para>

<para>
Så kan du se, at programmet bl.a. kalder funktionen
<command>printf</command> og indeholder en funktion
<command>main</command>. Programmet er blevet linket dynamisk
til to eksterne biblioteker - dette kan ses ved at skrive <filename>ldd
hello</filename> <indexterm><primary>ldd</primary></indexterm>
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>ldd hello</userinput>
        libc.so.6 => /lib/libc.so.6 (0x40003000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x00000000)
</screen>

<para>
Ideen er, at alle de programmer bruger <command>printf</command>
funktionen, kan deles om en <command>printf</command> funktion.
Printf funktionen findes i et delt bibliotek af funktioner
(biblioteket af alle standard C funktioner kaldes libc). På den
måde bliver alle programmer mindre. Programmer, der gør brug af
delte biblioteker, kan dog ikke køre på en computer med mindre
alle delte biblioteker er tilstede.  
</para>


<para>
At den eksterne funktion <command>printf</command> rent faktisk kommer
fra <filename>libc</filename>, kan ses ved at skrive
<indexterm><primary>nm</primary></indexterm>
</para>


<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>nm /lib/libc.so.6 | grep "printf"</userinput>
</screen>

<para>
Det var lidt om dynamisk linking. Koden kan også oversættes så
funktioner fra delte biblioteker linkes statisk ind i den udføre
bare fil.
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>gcc -o hello hello.c -static
</userinput>
</screen>

<para>
Bemærk ændringen i filstørrelsen (fra ca. 4 kbytes til over 400 kbytes).
Nu vil <command>ldd hello</command> vise, at der ikke er eksterne
biblioteker nødvendige for at køre programmet.
</para>

<para>
Med Linux distributioner følger en lang række af funktions biblioteker
der indeholder funktioner til at læse og skrive mange forskellige
billedformater, læse XML filer, hente web sider, læse og skrive pakkede
filer, vekselvirke med X windows og meget mere. Funktions biblioteker
kommer næsten altid i to pakker: en der installere de filer, der
kræves for at køre programmer anvender biblioteket, og en anden pakke
(kaldet devel), der indeholder C headeres og dokumentation, der skal
til for selv at udvikle programmer, der gør brug af et funktions bibliotek.
</para>

<para>
Hvis programmer bruger funktionsbiblioteker, der ikke linkes ind som
standard, så skal disse biblioteker listes når programmet oversættes.
Foreksempel matematik biblioteket libm, linkes med når flaget -lm
skrives sidst i oversættelseskommandoen. Da alle biblioteker
starter med "lib" er der specificeres dette ikke på kommandolinien.
</para>

<para>
Hvis biblioteksfilen ikke ligger i de kataloger som oversætteren normalt
gennemsøger kan dette specificeres med flagene
-L/home/mig/minelibs -lmig. Dette fortæller oversætteren at biblioteket
<filename>libmig.a</filename> i <filename>/home/mig/minelibs</filename>
kataloget skal inkluderes. Glemmer du at linke de relevante biblioteker,
når kildeteksten oversættes, så vil oversættere generere en fejl om
manglende symboler.
</para>

<para>
Skal oversætteren inkludere header filer, der ikke ligger normale steder,
kan stien til disse inkluderes med flaget -I/home/mig/mineheadere.
Når <command>#include "minhead.h"</command> oversættes vil 
oversætteren finde <filename>minhead.h</filename> i
<filename>/home/mig/mineheadere</filename> kataloget.
Brug <command>man gcc</command> for at få hjælp til de mange
muligheder som gcc og g++ har.
</para>

</sect2><!-- biblioteker -->

<sect2 id="foerstecppprogram">
<title>Det første C++-program</title>

<para>
I følgende enkle eksempel ønskes et program, der indlæser to tal, finder
det største af de to og skriver dette ud. Omkring C- og C++-programmering kan
henvises til en af de mange standardbøger om C og C++. Koden er ikke det
primære, men kunne se således ud.
</para>

<screen>
#include &lt;iostream.h&gt;

void read2(int&,int&);
void writeMax(int);

int main()
{
  int val1,val2,maxVal;

  read2(val1,val2);

  if (val1>val2) maxVal=val1;
            else maxVal=val2;

  writeMax(maxVal);

  return 0;
}

void read2(int& v1,int& v2)
{
  cout &lt;&lt; "Indtast to heltal ";
  cin &gt;&gt; v1 &gt;&gt; v2;
}

void writeMax(int val)
{
  cout &lt;&lt; val
       &lt;&lt; " er det største tal\n";
}
</screen>

<para>
Eksemplet gemmes som <filename>eks1.cpp</filename>. Og kan
oversættes ved at udføre følgende
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>g++ -o eks1 eks1.cpp </userinput>
</screen>

<para>
 Du kan eventuelt lave en fil, hvor der står ordren til at oversætte en fil
 udfra en variabel. En hurtig måde er direkte at bruge <command>echo</command>
 funktionen.
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>echo 'g++ $1.cpp -ggdb -lm -o $1' > mycompile</userinput>
</screen>

<para>
 Koden <filename>$1</filename> betyder første argument, hvorfor filen
 kaldes med første argument lig med C-kildetekstens filnavn. I filen
 inkluderes fejlsøgningsinformation med flaget -ggdb. Filen er gemt under
 navnet <filename>mycompile</filename>. I eksemplet anvendes
 apostroffer ('), i det man med gåseøjne (dvs. "") får erstattet
 variable (med et dollar-tegn foran) <emphasis>før</emphasis>
 kommandoen udføres.
</para>

<para>
Nu skal vi sørge for at filen kan køres:
</para>

<screen><prompt>[daisy@linus daisy]$ </prompt> <userinput>chmod a+x mycompile</userinput></screen>

<para>Nu kan du skrive
</para> 

<screen><prompt>[daisy@linus daisy]$ </prompt> <userinput>./mycompile filnavn
</userinput></screen>

<para>
Det antages, at kildefilen hedder <filename>filnavn.cpp</filename>, og
den kørbare fil kommer til at hedde <filename>filnavn</filename>.
</para>

<para>
Det er vigtigt at være opmærksom på at det er ikke ligemeget hvad
filen med kildeteksten kaldes. C++-programmer hedder altid .C .C++ eller
.cpp. Hvis man forsøger at oversætte C-programmer med C++-oversætteren
(<command>g++ program.c -o program</command>), så kommer der fejl.
</para>


</sect2><!-- foerstecppprogram -->

<sect2 id="makefiles">
<title>Oversættelse af flere C-filer med makefiler</title>

<indexterm><primary>make</primary></indexterm>
<indexterm><primary>Makefile</primary></indexterm>
<para>
Næste eksempel er to filer, hvor den ene kalder funktioner i den anden. I
eksemplet, der er C-kildetekst, er det igen det største af to tal, der skal
findes og skrives ud.
</para>

<para>
Følgende fil kan gemmes som <filename>ceks2.c</filename>.
</para>

<screen>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

float v1,v2,retval;

float max(float,float);

int main(void)
{
  v1=sin(2.34);
  v2=tan(4.4);

  retval=max(v1,v2);

  printf("Af %f og %f er %f stoerst\n",v1,v2,retval);
  return 0;
}
</screen>

<para>
Følgende fil kan gemmes som <filename>cfkt.c</filename>.
</para>

<screen>
float max(float f1,float f2)
{
  float f3;

  if (f1>f2)
    f3=f1;
  else
    f3=f2;

  return f3;
}
</screen>


<screen><prompt>[daisy@linus daisy]$ </prompt> <userinput>gcc -o ceks2 ceks2.c cfkt.c -lm</userinput></screen>

<para>
En langt mere elegant metode er at lave en makefile. Herefter skrives blot
<command>make</command>, og C-oversætteren vil kun oversætte de filer, der
er nye i forhold til objektfilerne. Makefiles kan også anvendes til at
styre oversættelse generelt såsom af LaTeX-kode. En makefile (med navnet
<filename>Makefile</filename>) kunne være følgende.
</para>

<screen>
# Makefile til GNU C-oversætteren - dette er en kommentar
# I dette eksempel oversættes to filer.
# ceks2.c og cfkt.c oversættes til den kørbare fil ceks2

# Navn paa oversaetter = gcc
CC = gcc

# Navn paa koerbar fil
OUTPUT   = ceks2

# Kilde fil navne, bemærk der er ingen mellemrum efter \ tegnet.
sources  = ceks2.c \
           cfkt.c

# Automatisk navngivning af objektfiler, hvor .c laves om til .o
OBJS        = $(sources:.c=.o)

# Oversætterflag: Optimering niveau 2
CFLAGS      = -O2

#Linkerflag: Inkluderer matematik-bibliotek
LDFLAGS      = -lm

# Foelgende linje tjekker om en .o fil er nyere end den koerbare fil. Hvis
# dette er tilfaeldet, linkes disse. Dvs. kun nye elementer oversættes.
$(OUTPUT): $(OBJS)
        $(CC) $(CFLAGS) -o $(OUTPUT) $(OBJS) $(LDFLAGS)
</screen>

<para>
Makefilen består af en masse definitioner af variable og en 
eller flere opskrifter. Opskriften fortæller at $(OUTPUT)
(ceks2) afhænger af objekt kode filerne $(OBJS)
(ceks2.o og cfkt.o), og at at ceks2 programmet kan laves
med opskriften <command>cc -O2 -g -o ceks2 ceks2.o cfkt.o -lm</command>. 
Bemærk, at der skal stå en tabulator foran alle opskrifter.
Der må ikke anvendes mellemrum. Make programmet gætter selv hvordan
.c filer skal oversættes for at danne objekt filer .o.
</para>

<para>
Når makefilen er skrevet, kan programmet bare oversættes ved at skrive
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>make</userinput>
</screen>

<para>
i det katalog, hvor makefilen findes. En makefile kan være meget lang og
indeholde mange opskrifter, der indbyrdes kan afhænge af hinanden. Make
programmet undersøger datoen på alle filer, og hvis datoen på kildeteksten
er nyere end datoen på den tilsvarende objekt fil, så er objekt filen
forældet, og make oversætter automatisk kildeteksten igen og linker 
programmet med den nye objekt fil.
</para>
</sect2><!-- makefiles -->

<sect2 id="GDB">
<title>GNU debuggeren og DDD</title>
<indexterm><primary>GDB</primary></indexterm>
<indexterm><primary>DDD</primary></indexterm>
<indexterm><primary>Visuelt programmeringsmiljø</primary><secondary>debug</secondary></indexterm>
<para>
Til GNU C/C++ findes en tekst-baseret debugger (<filename>gdb</filename>), som virker fint sammen med
oversætteren. Hvis alle filer er oversat med flaget
<filename>-ggdb</filename>, kan man kalde debuggeren ved at skrive
<command>gdb filnavn</command>, hvor <filename>filnavn</filename> er
navnet på den kørbare fil.
</para>

<para>
Man kan vise (display) enkelte variabler eller strukturer. Du kan sætte
"breakpoints" og meget andet, men det hele er tekstbaseret. Programmet
<command>gdb</command> kan med fordel kaldes fra editoren Emacs ved at
skrive <filename>Meta-x gdb</filename> (Meta=Alt). Så fås en delt skærm
med debugger og kildetekst, der kører sammen. Du kan i et terminalvindue
skrive <command>man gdb</command> for at få muligheder for debuggeren.
Når et program skal debugges så er det en meget god ide at oversætte
det uden optimering, dvs. fjern <filename>-O2</filename> ved oversættelse.
</para>

<para>
Ønsker du at anvende en grafisk debugger, kan du med fordel
installere <command>ddd</command> (Data-Display-Debugger), som giver
en fuldt professionel grafisk brugerflade til fejlfinding i C-, C++-, Perl-, Python-,
Java- og Fortran-kildetekst.  Specielt lækkert er, at man nemt kan følge
indholdet af strukturer, tabeller og simple variabler. DDD kan hentes fra
<ulink url="http://www.cs.tu-bs.de/softech/ddd">http://www.cs.tu-bs.de/softech/ddd</ulink>.
</para>

<figure ID="DDD-fig" FLOAT="1">
<title>DDD
</title>
<graphic FILEREF="ddd22.&magic;"  SCALE="50"></graphic>
</figure>

</sect2><!-- GDB -->


<sect2 id="kdevelop">
<title>KDevelop</title>
<indexterm><primary>KDevelop</primary></indexterm>
<indexterm><primary>Visuelt programmeringsmiljø</primary><secondary>KDevelop</secondary></indexterm>
<para>
Der er ved at komme integrerede udviklingsmiljøer til Linux, som det
kendes fra f.eks. Visual C++ til Windows. Man kan købe Code Warrior
til Linux, Code Crusader og Delphi er også godt på vej 
(Code Crusader er ikke så godt designet).
</para>
<para>
Et spændende helt nyt program er KDevelop til KDE.
</para>

<figure ID="kdevelop1-fig" FLOAT="1">
<title>Opstartsbillede til KDevelop
</title>
<graphic FILEREF="kdevelop1.&magic;"  SCALE="50"></graphic>
</figure>

<para>
Ambitionsniveauet er meget højt, og til trods for at det er den første
beta-version, som er blevet testet her, så ser det positivt ud.
</para>

<para>
Som det ses på <xref linkend="kdevelop2-fig"/>, så er der der ligheder
med Visual C++ fra Microsoft. Man kan nemt overskue alle filer,
klasser, strukturer og variable i projektet. Der er god understøttelse for at
oversætte, debugge (ser det ud til), og revisionskontrol er direkte
integreret. Dette er baseret på CVS. Der er mulighed for integreret
dokumentation baseret på SGML. 
</para>

<figure ID="kdevelop2-fig" FLOAT="1">
<title>KDevelop
</title>
<graphic FILEREF="kdevelop2.&magic;"  SCALE="50"></graphic>
</figure>

<para>
En ting, som er et meget stort plus ved KDevelop i forhold til Visual
C++ er at alle projekt-filer er tekstbaserede, dvs. man kan se alt
med en almindelig teksteditor og rette hvis man har noget specielt,
der skal ind.  KDevelop laver i øvrigt selv standard-makefiler, så man
kan oversætte programmerne udenfor det grafiske miljø. Med andre ord, så er
KDevelop en naturlig overbygning på GNU-værktøjerne, uden at disse
erstattes.  KDevelop følger med f.eks. Red Hat 7.0 og kan
hentes fra projektets websted
<ulink url="http://www.kdevelop.org/">http://www.kdevelop.org/</ulink>.
</para>

<figure ID="kdevelop3-fig" FLOAT="1">
<title>KDevelop har naturligvis også indbygget dokumentation for at
lave grafiske programmer
</title>
<graphic FILEREF="kdevelop3.&magic;"  SCALE="50"></graphic>
</figure>

</sect2><!-- kdevelop -->

<sect2 id="Glade">
<title>Glade</title>
<indexterm><primary>Glade</primary></indexterm>

<para>
Glade er et program, der kan bruges til at designe grafiske
brugergrænseflader, der bruger GTK og Gnome biblioteketerne.
Glade kan generere grafiske brugergrænseflader og gemme dem
som C-, C++-, Perl-, Eiffel- og Ada-kildetekst. Glade genererer
automatisk makefiler til at oversætte programmet.
</para>

<para>
Glade er ikke et integreret udviklingsmiljø, men er kan kun
lave grafiske grænseflader. I glade kan man for eksempel definere at
der skal kaldes en bestemt funktion, når der, for eksempel,
trykkes på en knap. Glade gemmer så kildeteksten med en tom
funktionsdefinition. Det er op til programmøren at indsætte kode i
denne funktion, så programmet rent faktisk gør noget.
</para>

<figure ID="glade-fig" FLOAT="1">
<title>Design af grafisk brugergrænseflade i Glade (her vist med Aqua themaet).
</title>
<graphic FILEREF="glade1.&magic;" SCALE="50"></graphic>
</figure>

<para>
En specielt smart egenskab ved Glade er at den kan gemme hele
definition af et grafisk brugergrænseflade i en fil, vha. libglade
funktionsbiblioteket kan et C-program automatisk genskabe det
grafiske brugergrænseflade igen og på den måde lave et fungerende
grafisk brugergrænseflade. 
</para>

</sect2> <!-- Glade -->


<sect2 id="efence">
<title>Electic Fence</title>
<indexterm><primary>Electric Fence</primary></indexterm>

<para>
Electric Fence er et bibliotek, der er uvurderligt til hurtigt
finde buffer overløb eller underløb. Et typisk problem i C er
man allokere en tabel, men forsøger at skrive efter tabellens
slut eller før dens start. En anden typisk fejl er at allokere
en streng, der er for lille, som i det følgende eksempel
</para>

<screen>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
   char* p=(char*)malloc(16*sizeof(char)); 
   char* q=(char*)malloc(16*sizeof(char)); 

// test for NULL

   strcpy(q,"efence test");
   strcpy(p,"efence test buffer overflow");  // 27 tegn lang!!

   printf("q:%s\n",q);
   printf("p:%s\n",p);
}
</screen>

<para>
Oversættes dette program med <command>gcc -o test test.c</command>,
så kan der ske alt muligt, når det køres, men typisk vil det udskrive
</para>

<screen>
q:low
p:efence test buffer overflow
</screen>

<para>
En streng kopieres til streng pointeren p, men strengen er længrer end
den hukommelsesblok, der er allokeret. Strcpy overskriver derfor
delvist q strengen "efence test". Et program kan sagtens køre viderer
efter at et buffer overløb, men måske er dette buffer overløb årsagen
til at programmet fejler katastofalt en halv time senere. Det kan derfor
være uhyre svært at finde denne type fejl, da programmet bare fejler et
mystisk sted, mens årsagen til fejlen blev introduceret et helt andet
sted i kildeteksten.
</para>

<para>
Oversættes programmet istedet med <command>gcc -o test test.c -ggdb -lefence</command>
vil programmet fejle, og gemme en <filename>core</filename> fil, når 
det udfører den anden strcpy() linie.
Køres <command>ddd test core</command> så vil debuggeren fortælle i
hvilen linie buffer overløbet skete. <command>man efence</command>
giver en masse information om hvordan efence virker, og hvordan
det kan bruges til at teste for buffer underløb og meget andet.
</para>

</sect2>  <!-- efence -->


<sect2 id="C-books">
<title>Bøger om C-programmering under Linux</title>

<para>
Der findes mange bøger om C-programmering på Unix-systemer. Vi nøjes
her med at nævne et par stykker, som vi synes er gode:
</para>

<para>
<itemizedlist mark="bullet" spacing="compact">

<listitem>
<para>
Donald Axel <emphasis>Linux - Friheden til at programmere i
C</emphasis>,
<ulink url="http://www.sslug.dk/linuxbog">http://www.sslug.dk/linuxbog</ulink>
</para>
<para>
En bog om sproget C, som er under aktiv udvikling. 
</para>
</listitem>


<listitem>
<para>
Michael K. Johnson &amp; Erik W. Troan: <emphasis>Linux Application Development</emphasis>,
Addison Wesley, ISBN 0-201-30821-5, 538 sider.
</para>
<para>
En god og klar indføring i C-programmering under Linux. Lidt dyr, men
lækkert udført og med den fordel, at den er skrevet specifikt til
Linux.
</para>
</listitem>

<listitem>
<para>
David A. Curry: <emphasis>Unix Systems Programming</emphasis>,
O'Reilly &amp; Associates, Inc., ISBN 1-56592-163-1, 596 sider.
</para>
<para>
Denne glimrende bog handler i høj grad om de samme emner, som behandles
i den førnævnte Linux Application Development, men kommer lidt mere ud
i hjørnerne af stoffet og beskriver forskellene mellem forskellige
kommercielle Unix-varianter. Linux nævnes ikke, men så godt som alle
forklaringer og eksempler kan bruges uændret under Linux.
</para>
</listitem>

<listitem>
<para>
W. Richard Stevens: <emphasis>Advanced Programming in the Unix Environment</emphasis>,
Addison Wesley, ISBN 0-201-56317-7, 742 sider.
</para>
<para>
Dette er bestemt ikke en begynderbog (hvad titlen heller ikke på nogen
måde kan siges at antyde), men hvis du har lyst til at lære en masse
om, hvordan et Unix-system fungerer og programmeres, kan vi
kun anbefale denne bog på det varmeste. Den kommer gennem alle
relevante emner på en meget grundig måde og binder til sidst i bogen
det hele sammen i et par større eksempler, der gennemgås ganske
grundigt.
</para>
</listitem>

</itemizedlist>
</para>

<para>
Fælles for de tre nævnte bøger er, at de henvender sig til læsere, der
allerede er godt inde i C som programmeringssprog. Hvis du har brug
for at lære C fra grunden, findes der utroligt mange bøger at vælge
mellem. Prøv som udgangspunkt at tage et kig på disse to (den første
er en klassiker):
</para>

<para>
<itemizedlist mark="bullet" spacing="compact">

<listitem>
<para>
Brian W. Kernighan &amp; Dennis M. Ritchie: <emphasis>The C Programming Language (2nd Edition)</emphasis>,
Prentice Hall, ISBN 0-131-10362-8, 272 sider.
</para>
</listitem>

<listitem>
<para>
Steve Oualline: <emphasis>Practical C Programming</emphasis>,
O'Reilly &amp; Associates, Inc., ISBN 1-565-92306-5, 454 sider.
</para>
</listitem>

</itemizedlist>
</para>

<para>
Hvis du har brug for en referencemanual til C, skulle du kigge på denne bog:
</para>

<para>
<itemizedlist mark="bullet" spacing="compact">

<listitem>
<para>
Samuel P. Harbison &amp; Guy L. Steele Jr.: <emphasis>C: A Reference Manual
(Fourth Edition)</emphasis>,
Prentice Hall, ISBN 0-13-326224-3, 462 sider.
</para>
<para>
Det er ikke en lærebog i C-programmering, men derimod en god opslagsbog. Den
har alle detaljer med, også C's standardbibliotek. Bogen beskriver den
internationale ISO-standard (ISO/IEC 9899:1990). Den giver desuden tips til,
hvordan man skriver programmer, der kan oversættes uden fejl med enten en
C- eller en C++-oversætter.
</para>
</listitem>

</itemizedlist>
</para>

<para>
Der findes en del bøger om C++-programmering. Følgende er biblen.
</para>

<itemizedlist>
<listitem>
<para>
B. Stoustrup: <emphasis>The C++ Programming Language</emphasis>,
Addison Wesley, ISBN 0-201-70073-5, 1019 sider. (special edition)
</para>
<para>
Dette er ikke en begynderbog, men en god referense bog om alle
C++ sprogets muligheder. Bogen er skrevet af Bjarne Stoustrup,
der opfandt C++ sproget.
</para>
</listitem>
</itemizedlist>


</sect2><!-- C-books -->


</sect1><!-- basalcprog -->

