<!-- $Id$ -->
<SECT1 id="basalcprog">
<title>C og C++ programmering</title>

<indexterm><primary>C</primary></indexterm>
<indexterm><primary>C++</primary></indexterm>
<para>
Programmeringssproget C og UNIX har traditionelt været tæt knyttet til
hinanden, og dette gælder i høj grad også for Linux. Kernen og langt de
fleste applikationer er skrevet i C.
</para>

<indexterm><primary>GNU C/C++</primary></indexterm>
<para>
GNU C/C++ er en af de allerbedste oversættere på markedet i dag. I
modsætning til Windows-verdenen er oversætteren ikke indkapslet i en
grafisk brugergrænseflade. Det giver større frihed for den enkelte til at
sammensætte et personligt udviklingsmiljø - enten grafisk eller
tekstbaseret. Med lidt tilvænning er det også hurtigt at anvende, specielt
hvis der skal oversættes meget kode per gang. Der er også den store fordel,
at det er standard inden for UNIX-verdenen, hvorfor kode og
oversættelsesfiler (engelsk: makefiles) uden problemer kan flyttes, oversættes
og
køres på andre typer af UNIX-systemer.
</para>


<sect2 id="hello-c">
<title>Hello, world!</title>
<INDEXTERM><PRIMARY>Hello, world!</PRIMARY><SECONDARY>C</SECONDARY></INDEXTERM>

<para>
Per tradition er HelloWorld-programmet det første C-program, man skal få
til at virke. 
Programmet skriver en kort tekst "Hello World" ud på skærmen og afslutter.
Indtast følgende (brug <command>emacs</command>,
<command>pico</command> eller <command>vi</command>), og gem det som
<filename>hello.c</filename>.
</para>

<screen>
#include &lt;stdio.h&gt;

int main(void)
{
  printf("Hello, world!\n");
}
</screen>

<para>
I kataloget, hvor filen er gemt, kan programmet nu oversættes ved at
skrive
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>gcc -o hello hello.c</userinput></screen>

<indexterm><primary>gcc</primary></indexterm>
<para>
C-oversætteren hedder <command>gcc</command>. Den skal her lave en
kørbar fil med navnet <filename>hello</filename>, og den skal oversætte
og linke ud fra kildeteksten i <filename>hello.c</filename>.
</para>

<para>
Det oversatte C-program <filename>hello</filename> køres ved at skrive
navnet i en <command>xterm</command>. For dem, som har C-erfaring,
kommer der et par tips nu. En lille sjov ordre er at skrive

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>nm hello</userinput>
</screen>

Så kan du se, at programmet bl.a. kalder funktionen
<filename>printf</filename> og indeholder en funktion
<filename>main</filename>.  Programmet er blevet linket dynamisk
til to eksterne biblioteker - dette kan ses ved at skrive <filename>ldd
hello</filename>
<indexterm><primary>ldd</primary></indexterm>
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>ldd hello</userinput>
        libc.so.6 => /lib/libc.so.6 (0x40003000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x00000000)
</screen>

<para>
At den eksterne funktion <filename>printf</filename> rent faktisk kommer
fra <filename>libc</filename>, kan ses ved at skrive
<indexterm><primary>nm</primary></indexterm>
</para>


<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>nm /lib/libc.so.6 | grep "printf"</userinput>
</screen>

<para>
Det var lidt om dynamisk link. Ideen er, at programmet kun indeholder de
nødvendige dele. Under udførelsen af programmet bruges nogle af de nævnte
eksterne biblioteker. Koden kan også oversættes med alle eksterne
funktioner linket statisk ind.
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>gcc -o hello hello.c -static
</userinput>
</screen>

<para>
Bemærk ændringen i filstørrelsen (fra ca. 4 kbytes til over 400 kbytes).
Nu vil <filename>ldd hello</filename> vise, at der ikke er eksterne
biblioteker nødvendige for at køre programmet.  Nu tilbage til lidt mere
simple eksempler.
</para>
</sect2><!-- foerstecprog -->

<sect2 id="foerstecppprogram">
<title>Det første C++ program</title>

<para>
I følgende enkle eksempel ønskes et program, der indlæser to tal, finder
det største af de to og skriver dette ud. Omkring C/C++ programmering kan
henvises til en af de mange standardbøger om C og C++. Koden er ikke det
primære, men kunne se således ud.
</para>

<screen>
#include &lt;iostream.h&gt;

void read2(int&,int&);
void writeMax(int);

int main()
{
  int val1,val2,maxVal;

  read2(val1,val2);
  maxVal = (val1>val2)?val1:val2;
  writeMax(maxVal);

  return 0;
}

void read2(int& v1,int& v2)
{
  cout << "Indtast to heltal ";
  cin >> v1 >> v2;
}

void writeMax(int val)
{
  cout << val
       << " er det største tal\n";
}
</screen>

<para>
Eksemplet gemmes som <filename>eks1.c++</filename>.
</para>

<para>
Oversættelse kan ske med en såkaldt "makefile", men her sker det ved
direkte at kalde oversætteren.
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>g++ eks1.c++ -o eks1</userinput>
</screen>

<para>
Du kan eventuelt lave en fil, hvor der står ordren til at oversætte
en fil ud fra variabel. En hurtig måde er direkte at bruge
<command>echo</command> funktionen til dette.

<screen><prompt>[daisy@linus daisy]$ </prompt> <userinput>echo 'g++ $1.c++ -g -lm -o $1' > mycompile</userinput></screen>

Koden <filename>$1</filename> betyder første argument, hvorfor filen
kaldes med første argument lig med C-kodens filnavn. I filen inkluderes
debuginformation med flaget -g, og matematikbiblioteket linkes med -lm. I
dette tilfælde er dette ikke nødvendigt, men normalt vil det være det. Filen
er gemt under navnet <filename>mycompile</filename>. I eksemplet
anvendes enkelt ping-tegn (eng. quote), idet man med dobbelt-ping
(såsom "disse") får ekspanderet dollar-variable
<emphasis>før</emphasis> kommandoen udføres.
</para>

<para>
Nu skal vi sørge for at filen kan køres:
</para>

<screen><prompt>[daisy@linus daisy]$ </prompt> <userinput>chmod a+x mycompile</userinput></screen>

<para>Nu kan du skrive
</para> 

<screen><prompt>[daisy@linus daisy]$ </prompt> <userinput>./mycompile FILNAVN
</userinput></screen>

<para>
Det antages, at kildefilen hedder <filename>FILNAVN.c++</filename>, og
den kørbare fil kommer til at hedde <filename>FILNAVN</filename>.
</para>

<para>
Her skal det nævnes at .C .C++ og .cpp alle er C++-programmer. Hvis man
forsøger at oversætte C-programmer med C++-oversætteren (<command>g++
program.c -o program</command>), så kommer der problemer.
</para>


</sect2><!-- foerstecppprogram -->

<sect2 id="makefiles">
<title>Oversættelse af flere C-filer med makefiler</title>

<indexterm><primary>make</primary></indexterm>
<indexterm><primary>Makefile</primary></indexterm>
<para>
Næste eksempel er to filer, hvor den ene kalder funktioner i den anden. I
eksemplet, der er C-kode, er det igen det største af to tal, der skal
findes og skrives ud.
</para>

<para>
Følgende fil kan gemmes som <filename>ceks2.c</filename>.
</para>

<screen>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

float v1,v2,retval;

float max(float,float);

int main(void)
{
  v1=sin(2.34);
  v2=tan(4.4);

  retval=max(v1,v2);

  printf("Af %f og %f er %f stoerst\n",v1,v2,retval);
  return 0;
}
</screen>

<para>
Følgende fil kan gemmes som <filename>cfkt.c</filename>.
</para>

<screen>
float max(float f1,float f2)
{
  float f3;

  if (f1>f2)
    f3=f1;
  else
    f3=f2;

  return f3;
}
</screen>

<para>
Koden kan oversættes ved hjælp af GNU C-oversætteren
<command>gcc</command>. Brug <command>man gcc</command> for at få
hjælp til de mange muligheder.
</para>

<screen><prompt>[daisy@linus daisy]$ </prompt> <userinput>gcc -o ceks2 ceks2.c cfkt.c -lm</userinput></screen>

<para>
En langt mere elegant metode er at lave en makefile. Herefter skrives blot
<command>make</command>, og C-oversætteren vil kun oversætte de filer, der
er nye i forhold til objektfilerne. Makefiles kan også anvendes til at
styre oversættelse generelt såsom af LaTeX-kode. En makefile (med navnet
<filename>Makefile</filename>) kunne være følgende.
</para>

<screen>
# Makefile til GNU C-oversætteren - dette er en kommentar
# I dette eksempel oversættes to filer.
# ceks2.c og cfkt.c oversættes til exefilen ceks2

# Navn paa oversaetter = gcc
CC = gcc

# Navn paa koerbar fil
OUTPUT   = ceks2

# Kilde fil navne
sources  = ceks2.c \
           cfkt.c

# Automatisk navngivning af objektfiler, hvor  .c bliver til .o
OBJS        = $(sources:.c=.o)

# Oversætterflag: Maximal optimering -O2 og debug information -g
CFLAGS      = -O2 -g

#Linkerflag: Inkluderer matematik-bibliotek med -lm !!!!
LDFLAGS      = -lm

# Foelgende linje tjekker om en .o fil er nyere end den koerbare fil. Hvis
# dette er tilfaeldet, linkes disse. Dvs. kun nye elementer oversættes.
$(OUTPUT): $(OBJS)
	$(CC) $(CFLAGS) -o $(OUTPUT) $(OBJS) $(LDFLAGS)
</screen>

<para>
Bemærk, at der skal stå en tabulator foran de linjer, der skal køres,
såsom den sidste. Der må ikke anvendes mellemrum.
</para>

<para>
Når makefilen er skrevet, kan programmet oversættes ved at skrive
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>make</userinput>
</screen>

<para>
i det katalog, hvor makefilen findes. En makefile kan være meget lang og
indeholde mange regler.
</para>
</sect2><!-- makefiles -->

<sect2 id="GDB">
<title>GNU debuggeren og DDD</title>
<indexterm><primary>GDB</primary></indexterm>
<indexterm><primary>DDD</primary></indexterm>
<indexterm><primary>Visuelt programmeringsmiljø</primary><secondary>debug</secondary></indexterm>
<para>
Til GNU C/C++ findes en tekst-baseret debugger (<filename>gdb</filename>), som virker fint sammen med
oversætteren. Hvis alle filer er oversat med flaget
<filename>-g</filename>, kan man kalde debuggeren ved at skrive
<command>gdb FILNAVN</command>, hvor <filename>FILNAVN</filename> er
navnet på den kørbare fil.
</para>

<para>
Man kan vise (display) enkelte variabler eller strukturer. Du kan sætte
"breakpoints" og meget andet, men det hele er tekstbaseret. Programmet
<command>gdb</command> kan med fordel kaldes fra editoren Emacs ved at
skrive <filename>Meta-x gdb</filename> (Meta=Alt). Så fås en delt skærm
med debugger og kode, der kører sammen. Du kan i en
<command>xterm</command> skrive
<command>man gdb</command> for at få muligheder for debuggeren.
Ved fejl kan det
anbefales at oversætte kode uden optimering, dvs. fjern
<filename>-O2</filename> ved oversættelse, idet man således ikke får
fjernet overflødige variable og lignende, som så ikke kan vises med
debuggeren.
</para>

<para>
Ønsker du at anvende en grafisk debugger, kan du med fordel installere
<command>ddd</command>, som giver
en fuldt professionel grafisk brugerflade til debug af C, C++, Perl,
Java- og Fortran-kode.  Specielt lækkert er, at man nemt kan følge
indholdet af strukturer,
tabeller og simple variabler. DDD kan hentes fra
<ulink url="http://www.cs.tu-bs.de/softech/ddd">http://www.cs.tu-bs.de/softech/ddd</ulink>.
</para>

<FIGURE ID="DDD-fig" FLOAT="1">
<TITLE>DDD
</TITLE>
<GRAPHIC FILEREF="ddd22.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

</sect2><!-- GDB -->


<sect2 id="kdevelop">
<title>KDevelop</title>
<indexterm><primary>KDevelop</primary></indexterm>
<indexterm><primary>Visuelt programmeringsmiljø</primary><secondary>KDevelop</secondary></indexterm>
<para>
Der er ved at komme integrerede udviklingsmiljøer til Linux, som det
kendes fra f.eks. Visual C++ til Windows. Man kan købe Code Warrior
til Linux, Code Crusader og Delphi er også godt på vej 
(Code Crusader er ikke så godt designet).
</para>
<para>
Et spændende helt nyt program er KDevelop til KDE.
</para>

<FIGURE ID="kdevelop1-fig" FLOAT="1">
<TITLE>Opstartsbillede til KDevelop
</TITLE>
<GRAPHIC FILEREF="kdevelop1.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<para>
Ambitionsniveauet er meget højt, og til trods for at det er den første
beta-version, som er blevet testet her, så ser det positivt ud.
</para>

<para>
Som det ses på <xref linkend="kdevelop2-fig">, så er der der ligheder
med Visual C++ fra Microsoft. Man kan nemt overskue alle filer,
klasser, strukturer og variable i projektet. Der er god understøttelse for at
oversætte, debugge (ser det ud til), og revisionskontrol er direkte
integreret. Dette er baseret på CVS. Der er mulighed for integreret
dokumentationsmuligheder baseret på SGML. 
</para>

<FIGURE ID="kdevelop2-fig" FLOAT="1">
<TITLE>KDevelop
</TITLE>
<GRAPHIC FILEREF="kdevelop2.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<para>
En ting, som er et meget stort plus ved KDevelop i forhold til Visual
C++ er at alle projekt-filer er tekstbaserede, dvs. man kan se alt
med en almindelig teksteditor og rette hvis man har noget specielt,
der skal ind.  KDevelop laver i øvrigt selv standard makefiler, så man
kan oversætte programmerne udenfor det grafiske miljø. Med andre ord, så er
KDevelop en naturlig overbygning på GNU værktøjerne, uden at disse
erstattes.  KDevelop følger ikke med f.eks. Red Hat endnu, men kan
hentes fra projektets hjemmeside
<ulink url="http://www.kdevelop.org">http://www.kdevelop.org</ulink>.
</para>

<FIGURE ID="kdevelop3-fig" FLOAT="1">
<TITLE>KDevelop har naturligvis også indbygget dokumentation for at
lave grafiske programmer
</TITLE>
<GRAPHIC FILEREF="kdevelop3.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

</sect2><!-- kdevelop -->

<sect2 id="C-books">
<title>Bøger om C-programmering under Linux</title>

<para>
Der findes mange bøger om C-programmering på UNIX-systemer. Vi nøjes
her med at nævne et par stykker, som vi synes er gode:
</para>

<para>
<itemizedlist mark="bullet" spacing="compact">

<listitem>
<para>
Michael K. Johnson &amp; Erik W. Troan: <emphasis>Linux Application Development</emphasis>,
Addison Wesley, ISBN 0-201-30821-5, 538 sider.
</para>
<para>
En god og klar indføring i C-programmering under Linux. Lidt dyr, men
lækkert udført og med den fordel, at den er skrevet specifikt til
Linux.
</para>
</listitem>

<listitem>
<para>
David A. Curry: <emphasis>UNIX Systems Programming</emphasis>,
O'Reilly &amp; Associates, Inc., ISBN 1-56592-163-1, 596 sider.
</para>
<para>
Denne glimrende bog handler i høj grad om de samme emner, som behandles
i den førnævnte Linux Application Development, men kommer lidt mere ud
i hjørnerne af stoffet og beskriver forskellene mellem forskellige
kommercielle UNIX-varianter. Linux nævnes ikke, men så godt som alle
forklaringer og eksempler kan bruges uændret under Linux
</para>
</listitem>

<listitem>
<para>
W. Richard Stevens: <emphasis>Advanced Programming in the UNIX Environment</emphasis>,
Addison Wesley, ISBN 0-201-56317-7, 742 sider.
</para>
<para>
Dette er bestemt ikke en begynderbog (hvad titlen heller ikke på nogen
måde kan siges at antyde), men hvis du har lyst til at lære en masse
om, hvordan et UNIX-system fungerer og programmeres, kan vi
kun anbefale denne bog på det varmeste. Den kommer gennem alle
relevante emner på en meget grundig måde og binder til sidst i bogen
det hele sammen i et par større eksempler, der gennemgås ganske
grundigt.
</para>
</listitem>

</itemizedlist>
</para>

<para>
Fælles for de tre nævnte bøger er, at de henvender sig til læsere, der
allerede er godt inde i C som programmeringssprog. Hvis du har brug
for at lære C fra grunden, findes der utroligt mange bøger at vælge
mellem. Prøv som udgangspunkt at tage et kig på disse to (den første
er en klassiker):
</para>

<para>
<itemizedlist mark="bullet" spacing="compact">

<listitem>
<para>
Brian W. Kernighan &amp; Dennis M. Ritchie: <emphasis>The C Programming Language (2nd Edition)</emphasis>,
Prentice Hall, ISBN 0-131-10362-8, 272 sider.
</para>
</listitem>

<listitem>
<para>
Steve Oualline: <emphasis>Practical C Programming</emphasis>,
O'Reilly &amp; Associates, Inc., ISBN 1-565-92306-5, 454 sider.
</para>
</listitem>

</itemizedlist>
</para>

<para>
Hvis du har brug for en referencemanual til C, skulle du kigge på denne bog:
</para>

<para>
<itemizedlist mark="bullet" spacing="compact">

<listitem>
<para>
Samuel P. Harbison &amp; Guy L. Steele Jr.: <emphasis>C: A Reference Manual
(Fourth Edition)</emphasis>,
Prentice Hall, ISBN 0-13-326224-3, 462 sider.
</para>
<para>
Det er ikke en lærebog i C programmering, men derimod en god opslagsbog. Den
har alle detaljer med, også C's standardbibliotek. Bogen beskriver den
internationale ISO-standard (ISO/IEC 9899:1990). Den giver desuden tips til,
hvordan man skriver programmer, der kan oversættes uden fejl med enten en
C-oversætter eller en C++-oversætter.
</para>
</listitem>

</itemizedlist>
</para>


</sect2><!-- C-books -->


</SECT1><!-- basalcprog -->
