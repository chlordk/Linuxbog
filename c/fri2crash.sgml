<appendix id="A-crash">
<title>Crash course i C sproget</title>
<titleabbrev>C-sprogelementer</titleabbrev>
<para>
 C består som andre programmeringssprog af:
</para>

<itemizedlist>
 <listitem>
  <para>
   Datatyper. Vi vil gerne have forskellige slags variable
   til at opbevare tal, tekst og billeder.
  </para>
 </listitem>

 <listitem>
  <para>
   Operatorer. Vi vil gerne kunne foretage beregninger med vores data.
  </para>
 </listitem>

 <listitem>
  <para>
   Løkker og betingede sætninger (<emphasis>if</emphasis>,
   <emphasis>while</emphasis> m.fl.). Vi vil gerne kunne gøre
   noget specielt, hvis vores tal er blevet negativt.
  </para>
 </listitem>

 <listitem>
  <para>
   Modularitet. Vi vil gerne kunne genbruge kode, som for eksempel beregning af
   sinus eller udskrift til terminalvindue.
  </para>
 </listitem>
</itemizedlist>

<sect1 id="C-hvad-er">
<title>C i få ord</title>
<para>
 Programmeringssproget C blev oprindeligt lavet for at kunne skrive
 styresystemet Unix i et højniveausprog. C er derfor et effektivt sprog,
 det vil sige, at koden bliver oversat til så få maskininstruktioner
 som muligt, og derfor kører programmerne hurtigt.
</para>

<para>
 C er også et lille sprog, hvis man måler det i antallet af reserverede ord
 (kun 32). Det gør det nemt at lære.
</para>

<sidebar>
<programlisting id="tab-reserverede-ord">
Reserverede ord:

auto              double            int               struct
break             else              long              switch
case              enum              register          typedef
char              extern            return            union
const             float             short             unsigned
continue          for               signed            void
default           goto              sizeof            volatile
do                if                static            while
</programlisting>
</sidebar>

<indexterm><primary>C99 standard</primary></indexterm>
<indexterm><primary>keywords</primary></indexterm>
<indexterm><primary>nøgleord</primary></indexterm>

<para>
C99 standarden tilføjer flg. reserverede ord:
<literal>inline, restrict, _Bool, _Complex, _Imaginary.
</literal>
Desuden bør man have in mente, at C++ nøgleord også bør undgås,
d.v.s. class, private, public, virtual etc.
</para>

<para>
Anvendt på rette måde bliver koden meget læseligt, og derfor 
anvendes C sproget til mange forskellige slags opgaver, fra
hardware-niveau til højniveauopgaver.
</para>

<para>
 C++ er en udvidelse af C. C++ er tænkt som et bedre C. Det understøtter
 objektorienteret programmering, dataabstraktion og generiske algoritmer. Der
 er dog et par forskelle mellem ANSI-C og den grundlæggende C syntaks i
 C++. 
</para>

<para>
 Et minimalt C-program:
</para>

<example id="hello-world">
<title>Hello world! programmet.</title>

<programlisting>
/* Dette program skriver Hello, world! i et terminalvindue. */

main()
{
     printf("Hello, world!\n");
}
</programlisting>
</example>

<para>
Vores program definerer en funktion, d.v.s. et stykke kode, som
udfører en opgave. Navnet på vores funktion er main. main er det
sted, hvor et C program begynder at køre. Parenteserne efter
ordet main fortæller, at det er en funktion.
</para>

<para>
Koden, det, som bliver til maskininstruktioner, står mellem to
krøllede parenteser (eng. braces). Koden består af et
kald til en anden funktion, printf, som får til opgave at skrive vores
tekst på skærmen. Vores tekst står mellem dobbelt-quotes 
(gåseøjne, citationstegn). "\n" er måden at skrive et
linjeskift, som indgår i en tekst streng. '\' - tegnet, kaldet
backslash, signalerer, at nu kommer et bogstav, der skal opfattes
på en anden måde. '\n' kaldes derfor et meta-tegn, og backslash
anvendes som <emphasis>escape kode</emphasis>.
</para>

<para>
I kildeteksten kan man skifte linje stort set hvor man har lyst.
</para>

<para>
 Ovenstående kildetekst bør kunne oversættes (compileres) til et
 kørbart program. 
</para>

<screen>
<prompt>don@pluto $</prompt> <userinput>gcc hallo.c -o hallo </userinput>
<prompt>don@pluto $</prompt>
</screen>

<para>
<command> -o </command> optionen fortæller compileren, at det
færdige program skal skrives til en fil, der skal hedde hallo.
Ellers vil compileren lægge det oversatte program i en fil ved
navn a.out.  Nogle moderne oversættere vil klage over
udeladelser. GNU-C vil kun klage, hvis vi anvender kommandolinje
option -Wall, som betyder: "Giv mig alle advarsler mod uheldige
eller mangelfulde konstruktioner!" En helt korrekt version (også
C++) ser ud som følger:
</para>

<example id="ex-hello-types">
<title>Hello, World! med type-specifikationer.</title>
<programlisting>
/* Dette program skriver Hello, world! i et terminalvindue og er
 * meget omhyggeligt med anvendelse af typer. */

#include &lt;stdio.h&gt;

int main()
{
     (void) printf("Hello, world!\n");
     return 0;
}
</programlisting>
</example>

<indexterm><primary>return</primary></indexterm>

<para>
Eksemplet her erklærer, at main er en funktion, som returnerer en
int (integer, heltal). Med sætningen <literal>return 0;</literal>
returnerer den jo så altså netop også et heltal, nemlig 0.
<literal>return 0;</literal> betyder aflever et 0 til den, som
satte funktionen i gang. Man siger, at caller får returneret en
værdi.
</para>

<para>
printf er ligeledes en funktion, som returnerer en integer til
caller; det er antallet af bogstaver, den har skrevet ud. Da vi ikke har
brug for denne integer, fortæller vi oversætteren, at det er "med vilje",
at vi ignorer return value ved at skrive <emphasis> (void) </emphasis>.
Det kaldes et cast, støbeform: vi omstøber funktionens type!
</para>

<sect2 id="crash-datatyper">
<title>Data typer</title>
<para>
C sprogets indbyggede datatyper er:
</para>

<programlisting>
int h;        /* integer, heltal, maskinens hurtigste type, native type */

char b;       /* velegnet til bogstaver, men i virkeligheden bare en lille */
              /* integer, 8 bits (eller 9 ...) */

float f;      /* floating point med kun 32 bit, kun til grafikkort o.l. */

double df;    /* 8 eller 10 bytes floating point type */

int ia[10];   /* array med 10 elementer, mange af samme slags */

struct person_type {             /* gruppering af mange typer i en klump */
   int alder;
   char navn[10];
};

struct person_type mig;            /* udlaegning af lager, instantiering */
struct person_type medlem[10];     /* array af struct */

int *j;                            /* adressevariabel, pointer */
</programlisting>


<para>
En variabel, for eksempel <emphasis>int xyzzy</emphasis>, kan erklæres
udenfor en funktion, så er det et eksternt objekt, eller inde
mellem krøllede parenteser, braces, så er det en lokal variabel.
</para>

<sidebar>
<para>
Jeg har med vilje udeladt en del grumsede detaljer i ovenstående
type-oversigt. Hvis du, kære læser, er sur over det, så er her et resume
af det udeladte:
</para>

<para>
En long integer er lige så stor - måske større - end en int. I gcc i386
er de begge 32 bit. Nye standarder vil indeholde forskrift om at
oversættere skal understøtte _int8, _int16, _int32, _int64 etc. hvilket vil
være praktisk for mange opgaver. Man kan definere sådanne typer
selv ved hjælp af <literal>typedef</literal>.  For eksempel:

<programlisting>
typedef long long int _int64;
</programlisting>
</para>

<para>
Heltalstyperne (char, int, short int, long int, _int64 eller
long long) kan foranstilles <emphasis>signed</emphasis> (det er
default) eller <emphasis>unsigned</emphasis>. Erklærer man en
unsigned integer vil man i mange oversættere alligevel kunne
tilskrive den en negativ value. Unsigned vinder overfor signed i
type coercion i expression evaluering. (Coercion: tvang).
</para>
</sidebar>

<programlisting>
/* ramme for eksperimenter med variable af indbyggede typer */

int x;
char b;

main()
{
    double temp = -17.8;

    b = 67;
    printf("x er %d, b er %d, temperatur er %f\n",x,b,temp);
    {
        int *px; /* definition af variabel i top af blok. */
        px = &amp;x; /* tag adressen af x og læg over i p */

        printf("adressen på x er %p\n",px);
    }

    return 0;
}
</programlisting>

<para>
px er en adressevariabel, d.v.s en variabel, som kan indeholde en
adresse. Det kaldes også en pointer. Det ses af, at erklæringen
har en stjerne foran px. Man må gerne stille stjernen lige
bagefter int, men syntaktisk binder den til px. Derfor kan man
fx. erklære en integer pointer og en integer indenfor samme
semikolon, <literal> int* ptr2tal, tal;</literal> (kønt er
det ikke! Det bør virkelig undgås, dette her!)
</para>

<para>
"Og" tegnet, ampersand på engelsk, er adresse-operatoren
d.v.s. at den tager adressen på den variabel, den stilles foran.
<literal> px = &amp;x; </literal> betyder tag adressen på x og
læg den over i variablen px.
</para>

<para>
Adresser på en 32-bit CPU ligger mellem 1 og 4 milliarder eller 4
Giga. Altså 2<superscript>32 </superscript>.
</para>

<sect3 id="crash-struct">
<title>Struct - forskellige typer grupperet i en klump</title>

<para>
Med struct konstruktionen kan vi selv definere de datatyper, vi har brug
for, deraf betegnelse <emphasis> brugerdefinerede typer. </emphasis>
Notationen kræver lidt øvelse. Først bygger man en type op, det
kaldes, at man <emphasis> erklærer en type </emphasis>. Derefter
kan man definere objekter af denne type. Når man definerer et objekt,
reserveres der hukommelse i det færdige program til objektet.
</para>

<para>
Navnet efter ordet struct kaldes en tag (eller type tag; det
betyder et mærke eller en mærkat, udtales med g som i væg). Det
kan sammen med ordet struct bruges som type-specifikation. I
eksemplerne anvendes vinkler (større/mindre tegn, eller på
engelsk: angles) til meta ord - der skal indsættes et
unikt navn på de pågældende positioner.
</para>

<programlisting>
struct &lt;type_tag> {
   data-declarations ...
};

struct &lt;type_tag> new_var;
</programlisting>

<para>
Konkret eksempel:
</para>

<programlisting>
struct hus_t {
   int grundareal;
   int bebygget_areal;
   int pris;
};

struct hus_t madsensvej_20;
</programlisting>

<para>
Alternativt kan man opbygge en struct type ved hjælp af typedef. Denne
metode foretrækkes af mange, fordi man så ikke behøver at anvende ordet
struct når man definerer nye objekter.
</para>

<programlisting>
typedef struct &lt;type_tag> {
   &lt;data-definitions> ...
} &lt;type-specifier>;           /* &lt;--- her er den nye types navn */

&lt;type-specifier> min_variabel;
</programlisting>

<para>Et konkret eksempel på anvendelse af typedef-metoden: </para>

<programlisting>
typedef struct {
   int medlems_nr;
   char navn[800];
} medlems_type;                /* &lt;--- her er den nye types navn */

medlems_type medlem[200000];
</programlisting>

<para>
Somme tider gør ordet struct programmerne lettere at læse. Og
ordet struct, gør det lettere for oversætteren at give
forståelige fejlmeddelelser.
</para>

<programlisting>
struct hus_t {                 /* først erklæres ny type */
   char adr[280];
   int pris;
};

struct hus_t mithus;           /* typen anvendes, ram udlægning sker */

main() {
   mithus.pris = 780000;          /* nu kan vi bruge vores variabel */
   strcpy(mithus.adr,"Byvej 20";  /* initialisering af string kræver strcpy */
}
</programlisting>

<para>
Desuden findes der en nummereringstype, enumeration, som typisk
anvendes til en serie symbolske konstanter:
</para>
<example id="A-enum"><title>Enumeration</title>
<programlisting>
enum farve_t { red, green, blue };
</programlisting>
</example>
<para>
<emphasis> red </emphasis> vil her svare til værdien 0,
<emphasis> green </emphasis> til 1 etc. etc... red, green og blue
vil indgå som identifiers på linje med andre variable. Man kan nu
erklære en variabel af denne type, og en C++ compiler vil kunne
kontrollere, at vi ikke tildeler vores variabel ulovlige værdier.
En C-compiler overlader dette ansvar til programmøren.
</para>

<para>
En variant af struct er "union", som svarer til en slags
forudbestilt typecasting. Den er som skræddersyet til en
program-generator, der skal generere en oversætter - altså en
oversætter som oversætter en oversætter. Dette æske system har
fra tidligt i 70'erne i unix sammenhæng fået det sjove navn YACC,
Yet Another Compiler Compiler. I Gnu tool-settet er det blevet
til BISON - fordi bison er en fætter til Yak-oksen.  Ja-ja, læs
mellem linjerne, at denne her union <emphasis> er </emphasis> kun
til specielle lejligheder :-))
</para>
<indexterm><primary>union</primary></indexterm>
<example id="A-union"><title>Union</title>
<programlisting>
union yylval_type {
    long itype;
    tree ttype;
    enum tree_code code;
    const char *filename;
    int lineno;
};
union yylval_type yylval;
</programlisting>
</example>


</sect3>
</sect2>

<sect2 id="operatorer">
<title>Operatorer</title>

<para>
Aritmetiske operatorer.
</para>

<programlisting>
+ plus, addition
- minus, subtraktion
* asterisk, multiplikation
/ stroke ell. slash, division
% percent, modulus, rest af heltalsdivision.
</programlisting>


<para>
Assignment operatorer, tildeling.
</para>

<programlisting>
Op.   ex.          Beskrivelse
-------------------------------------------------------------------------------
=     a = b     :  læg værdien af b over i a.

++    ++c       :  læg en til c, increment operator.

                :  ++ operatoren kan stå efter identifieren:
  if (c++ &lt; 42) :  sammenlign med 42 og læg bagefter 1 til c.

--    --c       :  træk 1 fra c, decrement operator.
-------------------------------------------------------------------------------
</programlisting>

<para>
Desuden kan lighedstegnet kombineres med de 
forskellige aritmetiske operatorer:
</para>

<programlisting>
x += kaxi; /* tael x op med vaerdien af variablen kaxi */
</programlisting>


<para>
Relationelle operatorer, sammenligning.
</para>

<programlisting>
&lt; mindre end
> større end
&lt;= mindre end eller lig med
>= større end eller lig med

OBS!  ==    test for lighed
      !=    test for not lighed
            Husk det ved at tænke på at 
            den logiske operator NOT er et udråbstegn.
      !     not (tager kun én operand, hvis logiske værdi inverteres)

</programlisting>
<para>
Et expression er sandt, når det er forskelligt fra 0.
</para>
<para>
Et expression er falsk, når det er lig med 0.
</para>

<para>
Eksempler:
</para>

<programlisting>
  if (a > b) 
      printf("a er for stor\n");

  if (x > 1 || x != y)
      printf("x er større end 1 eller x er forskellig fra y!\n");
</programlisting>


<para>
Logiske operatorer.
</para>

<programlisting>
&& logisk AND
|| logisk OR

!  logisk NOT
</programlisting>

<para>
Bitwise operators, bitvise operatorer, manipulerer de enkelte bit eller
bitkolonner efter den almindelige logik.
</para>

<programlisting>
&    bitvis AND               1 & 1 == 1; 17 & 1 == 1;
|    bitvis OR                1 | 0 == 1; 17 | 1 == 17;
^    bitvis XOR               1 ^ 0 == 1; 17 ^ 1 == 16;
~    bitvis NOT               ~1    == 0xfffffffe;
>>   shift right              1 >>1 == 0; 17 >>1 == 8;
&lt;&lt;   shift left               1 &lt;&lt;1 == 2; 17 &lt;&lt;1 == 34;
</programlisting>

<para>
Pas på NOT operatoren, det er en tilde. I almindelig netscape opsætning
er den meget svær se.
</para>

<para>
Bitvis NOT er det samme som bitvis invertering. I ovenstående
eksempel er resultatet skrevet ud fra en antagelse af, at der er tale om
en 32-bit størrelse. Hvis der er tale om 64 bit, så vil der være 15 f'er
i stedet for "kun" 7. Hvis 32-bit størrelsen skulle skrives som
bit-mønster, så er der selvfølgelig 32 "cifre" der enten er 0 eller 1.
Det er en god ting at lave et mellemrum for hver fjerde. Så kan man
bedre jævnføre med hexadecimal notation.
</para>

<programlisting>
~1 == 1111 1111 1111 1111 1111 1111 1111 1110. 

      f    f    f    f    f    f    f    e

      15   15   15   15   15   15   15   14

Så altså, det er lidt nemmere at læse hexadecimal notation:

~1 == 0xffffffe
</programlisting>

<para>
Der er desværre ikke nogen standard funktion, som udskriver bit-mønster
for en integer. Hvis man vil skrive resultatet som BIT-mønster, så
må man programmere en funktion, der tester med bitvis and og derefter
foretager et shift, fx.
</para>

<programlisting>
    /* udskriv x's bitmønster: */
    { 
        int i = 0;
        char numstr[35];                    /* 2 + 32 + end of string */
        strcpy(numstr,"b:");                /* "b:" for binaert format */
        numstr[34] = 0;                     /* End of string mærke */
        while (i++ &lt; 32) {
            numstr[34-i] = (x & 1) + '0';
            x = x >> 1;
        }
        printf("%s\n",numstr);
    }
</programlisting>

<para>
Du kan afprøve de ovenstående ved at sætte den ind i en main() funktion,
hvor man allerøverst definerer en int x = 0xf0f0f0f0.
(File: bitmonst.c).
</para>

<para>
De andre bitmanipulationer kan også afprøves med små programmer som
nedenstående, god øvelse:
</para>

<programlisting>
main()
{
    printf("17 >> 1 == %d \n",17>>1);
    return 0;
}
</programlisting>

<!-- TODO: Pseudo overskrift, fremhævelse: -->
<para><command>Spørgsmålstegns-operatoren</command></para>

<para>
Specielt for C sproget er betingelses-operatoren (conditional
operator) spørgsmålstegnet:
</para>

<programlisting>
  yxi = (a>b)? a: b;
</programlisting>

<para>
Svarer til:
</para>

<programlisting>
  if (a > b)
     yxi = a;
  else
     yxi = b;
</programlisting>

<!-- TODO: Pseudo overskrift, fremhævelse: -->
<para> <command>Andre operatorer</command> </para>

<para>
Ud over ovenstående findes der adskillige specielle operatorer, der kun
må anvendes efter forudgående aftale med typetjekningssystemet. ;-)
</para>

<programlisting>
 &   adresse operator, tager adressen af et objekt.

 *   asterisk operator, tag indholdet på den adresse, som specificeres
     efter stjernen, <emphasis> dereferering af adresse. </emphasis>

 ->  kan bruges ved dereferering af en struct pointer.

 .   Bruges til adressering af et struct element.

 ()  Funktions operator.

 []  Array operator.


 sizeof  (en pseudo funktion, kan bruges som operator, giver os
          størrelsen af det objekt, som den står foran.)

 
 ,   Komma, listeoperator.
</programlisting>

<para>
Her er et simpelt eksempel - lav selv flere, bare for at afprøve
de enkelte operationer!
</para>

<programlisting>
int charcnt[256];

main()
{
    int yxi;
    double kaxi;
    long double kolme;

    printf("Size of charcnt: %d\n",sizeof charcnt);

    /* sizeof anvendes ofte som en pseudo funktion */
    printf("Size of yxi....: %d\n",sizeof(yxi));

    printf("Size of double.: %d\n",sizeof kaxi);
    printf("long double....: %d\n",sizeof kolme);

}
</programlisting>
<example id="ex-operator-precedence">
<title>Operator Præcedens</title>
<para>
<informaltable frame="all">
<tgroup cols="4">
<thead>
<row>
<entry>operatorer</entry>
<entry>niveau</entry>
<entry>associativitet</entry>
<entry>kommentarer</entry>
</row>
</thead>
<tbody>
<row>
<entry><literal>() [] ->  . </literal></entry>
<entry>1</entry>
<entry>v-h</entry>
<entry>Funktions-parenteser, array-index, struct-element. 
Dette niveau er det, der binder mest. Grupperings-parenteser er ikke en 
operator, men anvendes til at ændre rækkefølge af evaluering.</entry>
</row>
<row>
<entry><literal> ! ~ ++ --  -  (cast) * &amp; sizeof </literal></entry>
<entry>2</entry>
<entry>h-v</entry>
<entry>not, bit not, increment, fortegns-minus, cast, 
pointer afreferering, adressen på, objekt-størrelse</entry>
</row>
<row>
<entry><literal>*  /  %</literal></entry>
<entry>3</entry>
<entry>v-h</entry>
<entry>multiplikation, division, modulus</entry>
</row>
<row>
<entry><literal>+ -</literal></entry>
<entry>4</entry>
<entry>v-h</entry>
<entry>addition, subtraktion</entry>
</row>
<row>
<entry><literal>&lt;&lt; >></literal></entry>
<entry>5</entry>
<entry>v-h</entry>
<entry>shift</entry>
</row>
<row>
<entry><literal>&lt; &lt;= > >=</literal></entry>
<entry>6</entry>
<entry>v-h</entry>
<entry>sammenligning, relationsoperatorer </entry>
</row>
<row>
<entry><literal>== !=</literal></entry>
<entry>7</entry>
<entry>v-h</entry>
<entry>relationelle, test for lighed/forskel</entry>
</row>
<row>
<entry><literal>&amp;</literal></entry>
<entry>8</entry>
<entry>v-h</entry>
<entry>bitvis AND</entry>
</row>
<row>
<entry><literal>^</literal></entry>
<entry>9</entry>
<entry>v-h</entry>
<entry>bitvis XOR</entry>
</row>
<row>
<entry><literal>|</literal></entry>
<entry>10</entry>
<entry>v-h</entry>
<entry>bitvis OR</entry>
</row>
<row>
<entry><literal>&amp;&amp;</literal></entry>
<entry>11</entry>
<entry>v-h</entry>
<entry>logisk AND</entry>
</row>
<row>
<entry><literal>||</literal></entry>
<entry>12</entry>
<entry>v-h</entry>
<entry>logisk OR</entry>
</row>
<row>
<entry><literal>?:</literal></entry>
<entry>13</entry>
<entry>v-h</entry>
<entry>betingelses-operator</entry>
</row>
<row>
<entry><literal>= += -= *= /= %= &amp;= ^= |= &lt;&lt;= >>= </literal></entry>
<entry>14</entry>
<entry>h-v</entry>
<entry>tildeling (assignment)</entry>
</row>
<row>
<entry><literal>,</literal></entry>
<entry>15</entry>
<entry>v-h</entry>
<entry>komma, listeoperator; den mest adskillende operator; 
dette niveau skiller næsten lige så meget som semikolon</entry>
</row>
</tbody>

</tgroup>
</informaltable>
</para>
</example>

</sect2>

<sect2 id="flow-kontrol">
<title>Flow kontrol</title>
<para>
Flow kontrol er maskinens måde at reagere på data. Man kan klare
sig glimrende med færre, for eksempel med if, while og goto! Men C sproget
er kendt for sine gode flow-konstruktioner.
</para>

<programlisting>
    if (betingelse_opfyldt)
        do_dyt();
</programlisting>

<para>
Test inden udførelse:
</para>

<programlisting>
    while (betingelse_opfyldt)
        do_looping();
</programlisting>

<para>
Kør loop-body mindst en gang:
</para>

<programlisting>
    do {
        mindst_en_gang();
    } while (betingelse_opfyldt);
</programlisting>

<para>
Bemærk at man altid bør bruge braces her for at undgå forveksling
med en ordinær while-løkke.
</para>

<para>
Behagelig kontrol med tællevariable:

<programlisting>
    for (initialisering; betingelse; optælling) {
       loop_body ...
    }
</programlisting>

    for eksempel 

<programlisting>
    for (i = 0; i &lt; 10 ; ++i)
        printf("i er nu %d\n", i);
</programlisting>
</para>

<para>
Inde i loops kan man:
</para>

<programlisting>
    break:      Goto lige efter loop-end.

    continue:   Begynd forfra med test af betingelse.
</programlisting>

<para>
En switch realiseres om muligt som en jumptabel. En jumptabel er
en <emphasis>meget</emphasis> effektiv måde at teste på
størrelsen af en int:
</para>

<programlisting>
    switch (integer_variabel) {
    case 17:
             do_beep();
             break;
    case 42:
             do_hurra();
             break;
    default:
             do_whine();
    }
</programlisting>

<para>
For at komme ud af en masse loop-kontrol statements:
</para>

<programlisting>
   goto label;

   /* kode ... */
label:
</programlisting>

<para>
Bemærk, at case linjerne i switch statementet ligner og opfører sig
som labels, de er faktisk labels. Man fortsætter nedefter i næste case,
hvis der ikke er et break statement.
</para>


<para>
Et par eksempler, meget simple, først et eksempel, som smager på
værdien af en variabel:
</para>

<programlisting>
main()
{
    int i,j,k;

    i = 27;
    j = 2;

    if (i > j)
        k = i;
    else
        k = 2;

    return k;
}
</programlisting>

<para>
Et eksempel på en for-løkke:
</para>

<programlisting>
main()
    int fahr, celsius;

    for (fahr = 0; fahr &lt; 200; fahr = fahr + 20) {
        celsius = 5 * (fahr - 32) / 9;
        printf("Fahrenheit %3d svarer til celsius %3d\n", fahr, celsius);
    }
}
</programlisting>

</sect2>

<sect2 id="modularitet">
<title>Modularitet</title>
<para>
Funktionsbegrebet i C gør det muligt at genbruge kode; man kan bygge på
andres arbejde i stedet for at begynde på bar bund hver gang.
</para>

<para>
Et C program består typisk af mange forskellige filer, der kan
oversættes hver for sig. En fil - evt. med tilhørende header files - der
kan oversættes alene til et objekt modul, kaldes en oversættelses-unit
eller en translation-unit.
</para>

<para>
Allerede i vores første program benyttede vi os af, at der i et bibiotek
<emphasis> library </emphasis> lå en funktion (printf) som kunne skrive
tekst ud på terminalvinduet.
</para>

<para>
Det er muligt at have private variable i en translation unit.
</para>

<programlisting>
/* modular programmering - fil nr. 1, kryptio.c */
/* main læser fra tastatur (eller omdirigeret fil)
 * og skriver det krypterede bogstav ud på skærmen.
 */

#include &lt;stdio.h>

main()
{
    int c;
    while ( (c = getchar()) != EOF) {
        c = krypter(c);
        putchar(c);
    }
}
</programlisting>

<para>
Til ovenstående main vil vi nu skrive et simpelt modul, som foretager
kryptering:
</para>

<programlisting>
int krypter(int inputchar)
{
    return inputchar + 1;   /* 'cæsar' kryptering */
}
</programlisting>

<para>
Uha, det viser sig snart, at folk gennemskuer vores simple kryptering,
så nu laver vi en rigtig kryptering. Det smarte er, at vi kan erstatte
dette modul uden at lave om på det eller de programmer, som anvender
vores funktion "krypter()".
</para>

<para>
Bliv nu ikke forskrækket over, at der er en del ting i næste eksempel,
som ikke er fyldestgørende forklaret endnu. Prøv at læse det, evt.
indtaste og oversætte det. Prøv så at rette i det for at se, hvad der
sker undervejs. Når et problem er kompliceret, så skil det ad i mindre
dele og indsæt printf statements, så du kan se, hvad der sker undervejs.
</para>

<example id="ex-kryptering1">
<title>Simpel kryptering</title>
<programlisting>
/* file krypter1.c - en brugbar (men forsimplet)
 * krypteringsalgoritme. Kan ikke håndtere linjeskift m.v.
 */

int krypter(int inpchar)
{
    static char *keystring = "Under traeerne var der stille og roligt.";
    static int inuse;
    static char *mv;
    static int keylen;

    if (!inuse) {
        inuse = 1;
        mv = keystring;
        keylen = strlen(keystring);
    }
    if (mv - keystring > keylen)
        mv = keystring;
    if (inpchar &lt; ' ')
        inpchar = ' ';
    else if (inpchar > 126)
        inpchar = '~';
    return (inpchar + *mv++) % 93 + 33;
}
</programlisting>
</example>

<para>
Virker kun for ren ASCII tekst.
<footnote>
<para>
I parentes bemærket, hvis du vil gøre krypteringen ovenfor rigtig
ubrydelig skal du forbedre den lidt. Anvend længere keystring
(altid længere end meddelelsen), formatér output i linjer, som er
lige lange.  Bemærk, at hvis input består af lutter samme tegn,
så kan denne version ikke rigtigt skjule sin keystring. Ikke at
den kommer i klartekst, men det er muligt at regne baglæns og
finde keystringen.  Man skal behandle sekvenser af samme tegn på
en speciel måde, hvor man angiver antal og tegn.  Algoritmen er
en tilpasning af Kejser Augustus' og Livia's kode, som beskrevet
i Robert Graves' "I, Claudius".
</para>
<para>
Endelig er der ikke support for såkaldte offentlige keys, der kan
bruges til afkodning men ikke indkodning.
</para>
</footnote>
</para>

<para>
Ordet static, som står foran de 4 variable, som skal anvendes i
modulet her, betyder, at de ikke må kunne bruges fra andre
moduler eller funktioner i det færdige program. Det er såmænd
ikke fordi de skal være hemmelige, men blot for at sikre, at vi
har styr på, hvor der sker ændringer af variablen, som peger
fremad i krypteringsnøglen.
</para>

<para>
Hvis du blev bidt af ovenstående, så lav en dekryptering til den.
Eller læs eksempel-programmet afkrypt1.c. Desuden er der en
forbedret version, som håndterer linjeskift, krypter2.c og
afkrypt2.c
</para>

<para>
Det var små eksempler på anvendelse af datatyper, operatorer,
flowkontrol statements og modularisering. Det næste afsnit
af crash course i C programmering går lidt mere i dybden med
disse emner.
</para>

<para>
Først et spørgsmål: Lagde du mærke til, at variablen 'keylen'
havde fået ordet <emphasis>static</emphasis> stillet foran? Det
er en storage specifikation. Læs videre!
</para>

</sect2>
</sect1>

<sect1 id="sect-C-fundamentet">
<title>Lager klassifikation, storage classes</title>

<!--OBS! AL TEKST ER ÆNDRET RADIKALT:-->

<para>
Emner:
</para>

<itemizedlist mark="bullet">
<listitem>
<para>
externe variable, funktioner og konstanter
</para>
</listitem>
<listitem>
<para>
funktioner og lokale variable (auto)
</para>
</listitem>
<listitem>
<para>
programsektioner, stak, heap, bss, data, text
</para>
</listitem>
<listitem>
<para>
kontrolvariable for løkker eller loops
</para>
</listitem>
<listitem>
<para>
scope (synlighed) og varighed, lokale static variabel
</para>
</listitem>
<listitem>
<para>
rekursion og statics
</para>
</listitem>
<listitem>
<para>
funktioner som returnerer pointer til buffer
</para>
</listitem>
<listitem>
<para>
volatile,
</para>
</listitem>
<listitem>
<para>
register variable.
</para>
</listitem>
</itemizedlist>

<para>
Et C program består af definitioner af eksterne objekter, som
kan være funktioner eller variable. Eksterne objekter kan bruges
overalt i det program, hvori de forekommer, også fra separat
oversatte funktioner.
</para>
<para>
Modsætningen til eksterne variable er de variable, som defineres
inde i en funktion og de parametre, som funktionen modtager når
den bliver kaldt. De eksisterer, mens funktionen kører. De bliver
automatisk oprettet når programmet kører funktionen (eller
blokken) og nedlægges igen, når programmet forlader funktionen.
De kaldes derfor også automatiske variable. Det reserverede ord
<emphasis>auto</emphasis> kan anvendes om lokale variable, men er
overflødigt - det stammer fra de tidligste versioner af C
sproget.
</para>
<para>
Funktioner er altid eksterne objekter; man kan ikke definere en
funktion inden i en anden funktion, sådan som man for eksempel
kan i Pascal sproget.
</para>
<para>
Selv om eksterne objekter uden videre er "synlige" i hele
programmet, er der en metode til gøre dem private for et modul.
Det skal vi se på senere i dette afsnit.
</para>

<sect2 id="c-eksterne-variable">
<title>Externe variable, funktioner og konstanter</title>

<!--OBS! AL TEKST ER ÆNDRET RADIKALT:-->

<para>
For helt at være klar til diskussion af eksterne variable skal
det lige understreges, at et C program næsten altid opbygges af
separat oversatte moduler. De fleste af dem ligger måske i et
library - måske er det standard-library, libc.a - Andre ligger i
vores egne oversatte moduler, og vi kan give oversætteren besked om
det på kommandolinjen ved simpelthen at nævne alle de moduler,
som skal med. Oversætteren består af mange forskellige programmer,
og det sidste af dem, nemlig linkeren, foretager sammenkædningen
af modulerne (link = hægte eller led i en kæde).
</para>

<programlisting>
gcc -o mitprogram modul_1.c modul_2.c modul_3.o
</programlisting>

<para>
Oversætteren finder ud af, at modul_3.o er et oversat modul og
nøjes med at medtage det i link-kommandoen, som bygger den
kørbare fil, "program-image filen" eller bare "programmet".
</para>

<para>
En definition af en (ekstern) variabel består af en type
angivelse og et navn, kaldet en variabel-identifikation, på
engelsk: identifier.
</para>

<programlisting>
typespecifikator variabel-navn [, variabel-navn] ... ;
</programlisting>

<para>
Altså typisk for eksempel følgende:
</para>

<programlisting>
int en_taeller;
</programlisting>

<para>
En funktion defineres nogenlunde på samme måde, altså ved en type
og et navn (lige som en variabel) men derefter har vi brug for
nogle flere oplysninger, nemlig en parentes med argumentlisten,
og de program-sætninger (statements), som udgør funktionens
<emphasis>krop</emphasis>, omsluttet af braces. 
</para>

<programlisting>
typespecifikator funktion-navn(parameter-liste)
{
    funktion-sætning(er);
}
</programlisting>

<para>
En minimum funktion ses nedenfor:
</para>

<programlisting>
int placeholder() { }
</programlisting>

<para>
Selv om en tom funktion ikke laver noget, kan den dog være ganske
nyttig under udviklingen af et større program ved simpelthen at
være til stede, evt. returnere en brugbar (default) værdi.
</para>

<para>
Der skelnes i C sproget mellem en definition og en deklaration.
På dansk ser man ofte ordet erklæring i stedet for deklaration.
</para>

<indexterm><primary>extern (nøgleord)</primary></indexterm>
<indexterm><primary>deklaration</primary></indexterm>
<indexterm><primary>erklæring</primary></indexterm>

<para>
Hvis vi ønsker at anvende en variabel, som allerede er defineret
i et andet modul, så bruger vi en deklaration. Det er en
forklaring, så at sige, til oversætteren om, at der er en variabel
til rådighed i et andet modul i det færdige program, som hedder
sådan og sådan og er af den og den type, men som altså IKKE
findes i nærværende overstættelses-enhed (translation unit).
</para>

<programlisting>
extern int en_taeller;
</programlisting>

<para>
Nu ved oversætteren, at der i et andet modul findes en variabel,
som hedder en_taeller, og at det er ok, at vi bruger den.
</para>

<para>
Hvis vi derimod vil reservere lager til en variabel, så kaldes
det definition af en variabel. Når programmet kører og vi
opretter et objekt (enten ved hjælp af dynamisk lagerallokering
eller ved hjælp af lokale variable i en kodeblok) kaldes det
instantiering af et objekt.
</para>

<para>
I C foregår deklaration og definition ofte på samme tid.
Når jeg skriver <emphasis>int xyzzy</emphasis> foretager jeg både
deklaration og lagerudlægning.
</para>

<para>
Hvis jeg derimod skriver <emphasis>extern int xyzzy</emphasis> 
udlægges der ikke lager, men jeg indføjer et punkt i oversætterens
symboltabel. I denne entry ligger oplysning om navn og type.
</para>

<para>
I det andet modul skal der være defineret en variabel på 
<emphasis>det yderste niveau</emphasis> - så er det en ekstern
variabel, som kan eksistere uafhængigt af de funktioner, som det
andet modul måtte indeholde (måske indeholder det kun variable).
En variabel, som er erklæret i <emphasis>det yderste
niveau</emphasis> er altid en variabel, som kan ses af andre
moduler. Den er, pr default, eksporteret, ville man måske sige i
sprog som ADA og Oberon.
</para>

<para>
En ekstern variabel er - i C sproget - også altid en <emphasis>
statisk </emphasis> variabel.  Sådanne statiske variable har lige
så lang levetid som det program, der anvender dem. På den måde
ligner de programmets instruktioner.
</para>

<para>
Programkode og statiske data ligger da også anbragt på samme måde
i lageret, nemlig forneden, på de lave adresser, under det
område, som anvendes til hhv. bunke (heap) og stak. Både heap og
stak kan vokse, så det er meget passende, at de enes om at
udnytte det store mellemrum fra "bunden" med faste data og
programinstruktioner og "toppen" hvor operativsystemet forlanger
at få lov til at være i fred.
</para>

 <informaltable frame="all">
   <tgroup cols="1">
<thead>
  <row>
    <entry>toppen af lageret</entry>
  </row>
</thead>
<tbody>
  <row>
    <entry>Operativ system kode</entry>
  </row><row>
    <entry>Stak for bruger-applikationen</entry>
  </row><row>
    <entry>Mellemrum mellem stak og heap</entry>
  </row><row>
    <entry>Heap til dynamisk lageradministration</entry>
  </row><row>
    <entry>.bss, nulstillede externe variable</entry>
  </row><row>
    <entry>.data initialiserede, eksterne variable</entry>
  </row><row>
    <entry>.string konstanter mv.</entry>
  </row><row>
    <entry>.text, program instruktioner</entry></row>
</tbody>
   </tgroup>
</informaltable>


<para>
Der er dog lidt forskel på, hvor data anbringes, er de
initialiserede, således som for eksempel vores keystring i eksempel 
<xref linkend="ex-kryptering1"/>, anbringes de i en sektion, som
kaldes .data. Hvis vi ikke selv specificerer, at data skal
initialiseres, anbringes variablen i den sektion, som kaldes BSS
(eller .bss), og alle bit-terne vil blive nulstillet.
</para>

<para>
Navnet <emphasis>bss</emphasis> har rødder i IBM mainframe
assembler sproget, d.v.s. system 370, 390, 3900 og MVS.
Det står for <emphasis> Block Started by Symbol</emphasis>.
</para>

<para>
Lad os i stedet huske det som <emphasis> Base Static
Storage</emphasis>. Det er garanteret, at variable, som erklæres
uden for en funktionsblok men som ikke er explicit initialiserede
ved en "initializer", er nulstillede ved programmets start. Det
sørger opstartsmodulet af programkoden for, traditionelt kaldet
c0.c
</para>

<para>
Læg især mærke til, at lokale variable anbringes på "stak for
applikationen". Det er de højest tilgængelige adresser for vores
program. Herfra kan stakken vokse (hov - den vokser nedad!)
indtil den møder heap. På en linux-maskine kan den vokse mere end
to gigabyte, før der sker sammenstød. MS NT har "kun" afsat 2 Gb
til applikationer.
</para>

</sect2>

<sect2 id="sect-storage-spec">
<title>Storage specifications</title>
<indexterm><primary>Storage specifications</primary></indexterm>
<indexterm><primary>lagring, specifikation af</primary></indexterm>

<para>
Det reserverede ord <emphasis> static </emphasis> betyder
selvfølgelig statisk. Det kan, som vi har set i 
<xref linkend="ex-kryptering1"/>, bruges, hvis man <emphasis> inde
</emphasis> i en funktion ønsker at have en variabel, som
overlever funktionen, så at sige, husker fra gang til gang, hvad
værdi, den havde sidste gang. For eksempel en sidetæller i en
udskriftsfunktion.
</para>
<indexterm><primary>static</primary></indexterm>

<programlisting>
void topmargin_udskrift(char *section_navn)
{
     static int sidenummer;
     printf("%s %d\n", section_navn, sidenummer);
}

</programlisting>

<indexterm><primary>stak</primary></indexterm>
<indexterm><primary>heap</primary></indexterm>

<para>
Stakken gør det muligt at have lokale variable i funktioner, og
for at have et sæt variable HVER gang funktionen kaldes, det er
betingelsen for, at man kan benytte rekursion.  Tilsvarende er
heap'en det område, som benyttes til dynamiske lager-strukturer
som for eksempel en "liste" og et "træ". (se kap. 3,
<xref linkend="sect-abstract-datatypes"/>).
</para>

<para>
De steder, hvor der i nedenstående opstilling af lager-anvendelse
er anbragt nogle punktummer på sidelinjen er steder, hvortil der
ikke nødvendigvis er knyttet noget RAM, fysisk memory.
Programmets anbringelse i lageret ser normalt ud sådan her:
</para>

<indexterm><primary>memory</primary><secondary>layout</secondary></indexterm>
<programlisting>
              +----------------------------+
              | Den øverste gigabyte       |
              |   som operativsystemet     |
              |     benytter og beskytter  |
              |                            |
              .                            .
              .                            .
              .                            .
              |                            |
              |                            |
              +----------------------------+
              |                            |
              |  Stack område for          |
              |          brugerprogram     |
              |                            |
              |  Her laves en ramme med    |
              |  data for hver function    |
              |  som kaldes                |
              |                            |
              .                            .
              .                            .
              .                            .
              .                            .
              |                            |
              +----------------------------+
              |                            |
              |  Heap - der, hvor man kan  |
              |    allokere mere lager     |
              |                            |
              |  Benyttes af funktionerne  |
              |    malloc(3), calloc(3),   |
              |     free(3) og realloc(3). |
              |                            |
              |                            |
              +----------------------------+  -
              |                            |   \
              |  bss -                     |    \
              |    blok started by symbol  |     \
              |  ell. base static storage  |      NULSTILLES
              |                            |      ved load af program
              |  static variable som IKKE  |     /
              |  er initialiserede         |    /
              |                            |   /
              +----------------------------+  -
              |  .data                     |
              |  initialiserede strings mv.|
              +----------------------------+
              |  .text                     |
              |  Programmets instruktioner |
              |  d.v.s. kommandoer til CPU |
              +----------------------------+
              | Lille stykke i bunden til  |
              |   Operativsystemets        |
              |   Hardwarehaandtering      |
              +----------------------------+

</programlisting>

<indexterm><primary>bss</primary></indexterm>

<para>
Hvis vi ønsker at anbringe en variabel i .bss sektionen kan vi
enten erklære den uden for en funktion eller benytte
lagrings-specifikationen <emphasis>static</emphasis>. Sidstnævnte
metode muliggør statiske variable med lokal synlighed (altså
<emphasis> kun </emphasis> synlige inde i en funktion eller blok).
Hvis vi benytter "static" på eksternt niveau, d.v.s. uden for en
funktionsdefinition, har specifikationen den virkning, at
variabelen ikke får ekstern synlighed (external linkage).
</para>

<para>
Hvis en variabel erklæret inde i en funktion skal kunne huske sin
værdi fra gang til gang, når funktionen kaldes, skal den
defineres som static, hvilket vil bevirke, at den bliver anbragt
i .bss sektionen.
</para>

</sect2>

<sect2 id="c-konstanter">
<title>Konstanter og memory protection</title>
<indexterm><primary>konstanter</primary></indexterm>
<indexterm><primary>read-only memory</primary></indexterm>
<indexterm><primary>skrivebeskyttet lager</primary></indexterm>

<para>
Der er forskellige måder at organisere kørselen af et program,
men stort set alle benytter ovenstående opstilling som
udgangspunkt. Det egner sig til virtual memory management,
hvilket jo fra starten var udgangspunktet for Linux, og det giver
nogle fordele, som er ret store. Vi kan simpelt hen lade vores
program benytte 3 Gb memory - også selv om vi ikke har
installeret så meget. Afhængig af operativsystemets snedighed vil
der kun blive tildelt fysisk memory, når det er strengt
nødvendigt. Det vil sige, hvis vi vil skrive til memory. Når vi
har loadet vores program og vil starte det op igen fra en anden
brugers terminal, kan man stole på, at operativsystem kernen ikke
bruger mere RAM til at loade endnu en kopi af program
instruktionerne.
</para>

<para>
Så opdelingen af programmet i sektioner skyldes både vores egne
behov for at strukturere programmet og så et hensyn til
operativsystemet. Sektionerne skal gøre det lettere for
operativsystemet at optimere anvendelsen af memory.  Nogle
sektioner skal kun læses, for eksempel program-instruktionerne, andre
skal både læses og opdateres, og i hhv. heap og stack skal man
kunne udvide området under kørselen.
</para>

<para>
Hvis nu vores program alligevel forsøger at skrive på fx.
adressen for en funktion, så skal Linux kernens memory management
modul reagere ved at stoppe programmet.
</para>

<para>
På samme måde er der dele af initialiserede data, som ikke må
overskrives. Fx. streng-konstanten "Hello, world!\n" i eks.
<xref linkend="hello-world"/>. Man kan heller ikke så nemt komme
til at gøre det i netop det eksempel. Men se lige her:
</para>

<example id="ex-const-violation">
<title>Konstant streng</title>
<programlisting>
/* constviol.c, kørselsfejl når man ændrer en konstant. */
#include &lt;stdio.h>

char * ms1 = "Hello, ever changing world!\n";

int main()
{
     *ms1 = 'A'; /* segmentation violation, signal 11 */
     return 0;   /* abort forinden, exitkoden er 139 == 128+11 */
}

</programlisting>
</example>

</sect2>

<sect2 id="sect-scope">
<title>Storage specifikation og scope</title>

<indexterm><primary>scope</primary></indexterm>
<indexterm><primary>synsvidde, synlighed</primary></indexterm>

<para>
Scope betyder synlighed (within scope = "inden for synsvidde").
En af de rigtig gode ting ved C sproget er, at man kan skrive
programmerne således, at variable kun er tilgængelige i en
funktion eller et modul. Derved kan man uden stort besvær anvende
objektorienterede programmeringsprincipper.
</para>

<example id="ex-scope-rules">
<title>Scope eller synlighed</title>

<programlisting>
/* ... demonstration af scope regler, synligheds regler. */

char * ms1 = "Min nye Hello-world rapport";
char * ms2 = "(c) 2001 Donald Axel, 3210 Vejby";
static char *msp = "Denne char-ptr kan kun bruges i denne fil."

headerlinje(){
     static int sidenummer; /* kan kun bruges i denne funktion */
     printf("%s Side %d\n", ms1, ++sidenummer);
}
</programlisting>
</example>


<para>
Hvis vi definerer en variabel, for eksempel ms1, på samme niveau som
funktioner, så kaldes den et eksternt objekt. (Husk: Et C program
består af en række definitioner af eksterne objekter.)
</para>

<para>
Variablen ms1 vil - uden særlig angivelse af, at den er
"public", blive synlig i andre kildetekst filer. De skal blot
erklære en extern char * ms1;
</para>

<example id="ex-external-decl">
<title>Extern declaration</title>

<programlisting>
/* External declaration */

extern char * ms1;        /* synlig i hele denne source-fil.*/

bundlinje(){
     extern char * ms2;   /* kun synlig i denne funktion */
     printf("%s\n", ms1);
     printf("%s\n", ms2);
}
</programlisting>
</example>

<indexterm><primary>extern (nøgleord)</primary></indexterm>
<para>
Hov! Hvad er nu det - kan man deklarere en "extern" <emphasis>
inde </emphasis> i en funktion? Jada, og så er det meningen, at
oversætteren skal redde os, hvis vi kommer til at bruge den
<emphasis> uden </emphasis> for funktionen. Men deklarationen af
extern char *ms2; inde i funktionen forudsætter, at variablen er
defineret (og helst også initialiseret, i dette tilfælde!) et
andet sted, d.v.s. i en anden kildetekst-fil (source-file).
</para>

<para>
Bemærk dog, at det stadig accepteres af mange oversættere, at man
erklærer en ekstern variabel flere gange med samme navn. Det kan
man vist roligt sige er en praksis, som bør undgås. Specielt kan
det nævnes, at gcc accepterer at man definerer den samme variabel
to eller flere gange, hvis den defineres i ydre niveau og dermed
implicit er ekstern variabel!
</para>

<programlisting>
/* fil 1. Demonstration af uheldig praksis. */
/* programmet oversættes uden advarsler - ikke engang option
 * -Wall, som ellers betyder "giv mig alle advarsler" 
 * (warnings, derfor -W), får gcc til
 * at reagere på denne konstruktion! Men benyttes g++ får man
 * heldigvis en fejl på denne uheldige fremgangsmåde. */

int min_globale_variabel; /* ok, almindelig erklæring af en variabel. */

int min_globale_variabel; /* uha - burde udløse en warning! */
int min_globale_variabel; /* uha - burde udløse en warning! */

int main()
{
     printf("Værdien af min_globale_variabel er %d\n", min_globale_variabel);
     return 0;
}

</programlisting>

<indexterm><primary>static, anvendelse af</primary></indexterm>
<indexterm><primary>lint</primary></indexterm>
<indexterm><primary>lclint</primary></indexterm>

<para>
Det er jo godt nok kedeligt, hvis man tror, at man har to
forskellige variable, og oversætteren tror, at der kun er en.
Heldigvis findes der et værktøj (ud over c++) som kan afsløre
denne og andre sjuskefejl. Lint, en statisk syntakstjekker, har
været på banen siden Unix version 7, altså den første offentlige
udgave fra 1978. Der findes nu en fri lclint, som er
fantastisk god til at gennemgå programmer, og som vel at mærke
kan komme igennem include-filer uden brok. Lclint er så
pedantisk, at man somme tider ønsker at slå en masse warnings
fra, men det er der heldigvis også altid anvisninger på.
</para>

<para>
<screen>

<prompt>fri2c: </prompt><userinput>lclint globviol.c</userinput>
pluto:/qf3/attic/don/fri ::lclint globviol.c
LCLint 2.4b --- 18 Apr 98

globviol.c:14:5: Variable min_globale_variabel redefined
  A function or variable is redefined. One of the declarations should use
  extern. (-redef will suppress message)
   globviol.c:12:5: Previous definition of min_globale_variabel
globviol.c:15:5: Variable min_globale_variabel redefined
   globviol.c:12:5: Previous definition of min_globale_variabel
globviol.c:12:5: Variable exported but not used outside globviol:
                    min_globale_variabel
  A declaration is exported, but not used outside this module. Declaration can
  use static qualifier. (-exportlocal will suppress message)

Finished LCLint checking --- 4 code errors found

</screen>
</para>

<para>
lclint er endog så omhyggelig, at den advarer mig om, at
min_globale_variabel faktisk ikke bliver brugt i andre moduler
(der er jo heller ikke andre lige for tiden ...) og at jeg derfor
burde erklære denne variabel for static. Godt
gået.<footnote><para> lint og den systemuafhængige C-oversætter har som
oprindelig ophavsmand Stephen C. Johnson, som er en af de kendte
oversætter-teoretikere der arbejder på Bell Labs.</para></footnote>
</para>

<para>
Hvis man omvendt kun har erklæret alle sine eksterne variable med
keywordet extern, så vil gcc beklagende meddele "undefined
reference to min_extern". (Se øvelser i kap. 2 for at få mere
føling med håndtering af variable i C programmer).
</para>

<para>
<command>Tilbage til external variables!</command>
</para>

<para>
Lige som extern kan også <emphasis> static </emphasis> bruges
inde i og ude af funktioner.
</para>

<para>
Resumé: En variabel, som er erklæret i starten af en
funktion, er lokal - den er kun synlig i funktionen. Hvis man
angiver, at den skal være static, så anbringes den fysisk i en
datasektion, som eksisterer i hele programmets køretid. Men den
er stadig kun synlig i funktionen, hvori den er defineret.
</para>

<para>
Så hvad nu hvis man anvender det reserverede ord <literal>
static </literal> <emphasis>udenfor</emphasis> funktionerne,
altså lige som eksterne objekter? Jo, så bliver variablens
synlighed indskrænket - ikke til en funktion, vi er jo udenfor
funktionerne - men til den fil, hvori den er erklæret.
</para>

<para>
En af de lidt morsomme ting i C sprogets anvendelse af ordene er,
at ordet <emphasis>static</emphasis> derved kommer til at
betyde, at en variabel er "privat" for det modul, hvori den er
erklæret!
</para>

<indexterm><primary>static, betydning privat</primary></indexterm>
<indexterm><primary>privat</primary></indexterm>

<para>
Den oprindelige betydning af specifikationen "static" er
selvfølgelig, at variablen skal være statisk. Den skal anbringes
i sektionen for globale data, statiske data. De kalde statiske,
fordi de eksisterer hele tiden, så længe programmet kører. Men
for at give programmøren en hjælpende hånd med at kontrollere,
hvor den pågældende variabel kan være blevet ændret (hvis der af
en eller anden grund skulle opstå fejl i programmet?) så kan
synligheden af statiske variable på denne måde begrænses.
</para>

<para>
Static variabel erklæret inde i en funktion = scope i funktionen,
static inde i et modul = scope i modulet.
</para>

<para>
Et modul kaldes i syntaksbeskrivelser en oversættelsesenhed
(eng. translation unit) og består af en eller flere filer (include
filer) som oversættes til et objekt-modul.
</para>

<para>
Variablen i eksemplet ovenfor, sidenummer, kan kun bruges inde i
funktionen headerlinje(), men den husker alligevel nummeret fra
gang til gang, når funktionen bliver kaldt.
</para>

<para>
Hvis en funktion som for eksempel strftime(3) gerne vil aflevere en text
string med datoen formateret efter callers behov, så er det også
nødvendigt at returnere i en buffer, som ligger UDEN for
funktionen.
</para>

<para>
Man kunne somme tider ønske sig, at ordet static blev erstattet
af "modul-specifik" eller "privat". Det kan man jo bare gøre
selv ved hjælp af #define. I så fald skal man lige huske, at
private er et reserveret ord i C++. Man kunne måske i stedet
anvende "privat" (uden 'e' til sidst!) eller, bedre, et ord som
"hidden" eller ... "local"? SÅ ville der rigtig være rod i
semantikken! Problemet er nævnt i forbindelse med revision af C
som basis for C++, men som sagt finder private anvendelse i C++ ,
og det er på en lidt anden måde.
</para>

<para>
Husk at et C program består af eksterne objekter, som kan være
enten funktioner eller variable.
</para>

</sect2>

<sect2 id="c-kontrolvariable">
<title>Kontrolvariable for løkker eller loops</title>

<para>
Det fremhæves somme tider, at C++ er særlig smart fordi man kan
erklære variable der, hvor man har brug for dem. Det er sandelig
også en god ting. Man har dog for nylig indført nogle
forbedringer (læs rettelser) således at en kontrol-loop variabel,
som erklæres i for eksempel en for-løkke, går ud af scope ved afslutningen
af den blok, som styres af for løkken. Ellers kunne der nemt
opstå noget rod.
</para>

<para>
Denne fejlkilde er elimineret i C ved at man kan erklære variable
i enhver blok (hver gang man skriver en krøllet parentes start,
brace start), og denne variabels scope går så indtil blokkens
slutning. Nemt og logisk. Denne facilitet anvendes alt for lidt!
</para>

<example id="ex-local-control-var">
<title>En lokal kontrol variabel</title>

<programlisting>
/* loopcount.c, demonstration af ad-hoc variabel. */

#include &lt;stdio.h>

char *thisprog;

int main(int argc, char *argv[])
{
    thisprog = argv[0];
    printf("Program %s er startet ... \n", thisprog);
    {
        int jj = 0;              /* jj bliver oprettet */
        while(jj++ &lt; 10)
            printf("For %d. gang: Ih hvor vi kører\n", jj);
    }
                                 /* nu er jj nedlagt "automatisk" */
    printf("Program %s exiter graciøst!\n", thisprog);
    return 0;
}
</programlisting>
</example>

<para>
For at tillade oversætteren at optimere kan det forekomme, at
interne blokkes auto-variable faktisk oprettes samtidig med at
funktionens stack-frame sættes. Således gør gcc.
</para>
</sect2>

<sect2 id="c-ukontrollerede-variable">
<title>Flygtige ukontrollerede variable</title>

<para>
En speciel variabel klassifikation er nødvendig for programmer,
som deler memory med andre processer eller threads. Her anvendes
nøgleordet <emphasis>volatile</emphasis>. En variabel, som er
volatile, vil ikke blive optimeret væk, d.v.s. at når programmet
skal benytte variabelens værdi, vil der blive foretaget en
læsning, og en eventuel gammel værdi i et CPU register vil blive
kasseret.
</para>

<para>
Volatile specifikationen anvendes også på maskiner, som ikke har
et separat IO space men benytter en del af RAM som IO-porte.
</para>
</sect2>

<sect2 id="c-oversigt-variabel">
<title>Oversigt over variabel - anvendelse</title>

<para>
Oversigt over anvendelsen af static:
</para>

<itemizedlist mark="bullet">

<listitem>
<para>
En variabel erklæret uden for funktioner er en global variabel.
Det er egentlig det samme som at sige, at den er statisk, den
bliver stående som den er, gennem hele programmets levetid, 
på linje med funktionsobjekter.
</para>
</listitem>

<listitem>
<para>
En variabel erklæret udenfor funktioner får, hvis den er
initialiseret, plads i "data" sektionen, og i "bss" sektionen,
hvis den ikke er initialiseret. I så fald kan man regne med, at
den er nulstillet.
</para>
</listitem>

<listitem>
<para>
static for external object: specifikation af, at variablen
<emphasis> kun </emphasis> skal være synlig i det oversættelses
modul (translation unit) hvori den forekommer.
</para>
</listitem>
<listitem>
<para>
static for variabel i en funktion (kaldes lokal static) betyder,
at den kun er synlig i den funktion, hvori den er erklæret.
</para>
</listitem>

</itemizedlist>

<para>
Her er en præcisering af, hvordan man kan definere
forskellige slags lokale variable.
</para>

<itemizedlist mark="bullet">
<listitem>
<para>
Uden storage spec: En lokal variabel allokeres på
funktionsstakken. Skal initialiseres hver gang funktionen køres.
</para>
</listitem>
<listitem>
<para>
reserveret ord auto: overflødigt, samme som ovenfor.
</para>
</listitem>
<listitem>
<para>
reserveret ord register: Oversætteren vil, hvis det er muligt, anbringe
denne variabel i et af maskinens hurtige registre. Man kan ikke
tage adressen på en registervariabel.
</para>
</listitem>
<listitem>
<para>
reserveret ord extern: Variablen er defineret et andet sted,
normalt i en anden oversættelses enhed.
</para>
</listitem>
<listitem>
<para>
reserveret ord static: Variablen anbringes i regionen for
statiske variable. Den er kun synlig i den blok, gerne en
funktionsblok, hvori den er deklareret. (Den er selvfølgelig også
synlig i den oversættelses enhed, hvori den er defineret!)
</para>
</listitem>
<listitem>
<para>
En lokal variabel behøver ikke at blive defineret øverst i
funktionens yderste blok. Man kan definere nye lokale variable,
hver gang man skriver en start-brace (klamme).
</para>
</listitem>

</itemizedlist>


</sect2>
</sect1>



<sect1 id="sect-GNU-tools">
<title>GNU programmerings værktøjer</title>

<para>
GNU står for Gnu is Not Unix. Det skyldes, at man ikke må bruge
navnet Unix uden at betale for det, det var et registreret
varemærke i 80'erne, da <ulink url="http://www.gnu.org">
Richard M. Stallman </ulink> begyndte arbejdet med
open source tools.
</para>

<para>
Heldigvis er Unix i vore dage ikke mere et varemærke, men en
betegnelse for et operativ system, som overholder standarder. Se
<ulink url="http://www.opengroup.org">www.opengroup.org</ulink>
</para>

<para>
De vigtigste værktøjer er: Compileren, gcc, assembleren as eller
gas, linkeren ld, og object librarian ar. Med disse programmer
kan man bygge en programfil.
</para>

<para>
Til at inspicere indholdet af programfiler og objektfiler, også
kaldet dot-o filer, kan man benytte objdump.  Det kan også
disassemblere maskininstruktioner i objektmoduler.
</para>

<para>
Desuden er der den Gnu debuggeren, gdb. Der er adskillige
klikbare interfaces til gnu-værktøjerne. Begynd med xxgdb og
fortsæt med gide, Gnome Integrated Development Interface, og slut
med de store, forkromede værktøjer sourcenavigator og kdevelop,
alle sammen meget udmærkede, men tidrøvende. Skal jeg fremhæve
nogen på andres bekostning må jeg indrømme, at indpakning og
configure, make og make install af source navigator har imponeret
mig. Det fungerede for mig på 2 (forskellige) RedHat platforme
uden problemer.
</para>

<para>
Ud over klik-interfaces har man specielt meget glæde af
<command> indent, </command> et program, som kan foretage
formatering af en C kildetekst. Det er desværre ikke i stand
til at håndtere alle syntakskonstruktioner på lige god måde, men
har man en større mængde filer, som skal gennemarbejdes, er
indent meget nyttigt. Kan man ikke lide de tabulatortegn, der er
i en fil, kan man fjerne dem (anbefales!) med <command> expand
</command>.
</para>

<para>
Indent og expand og mange andre programmer kan med fordel køres
som filtre på den tekst - eller dele af den tekst - som man har i
editoren. Dette tillader vi og vist nok også Gnu Emacs. Se i
øvrigt <ulink url="http://&linuxbogurl;/"> Friheden til at
vælge applikationer. </ulink>
</para>

<para>
Nævnes skal også <command> gvim </command>, den forbedrede
editor, vi-improved, som med sit system-interface, hjælpesystem,
syntaksfremhævning, muse-interface og ortogonale
kommandostruktur ender med at være mange programmørers favoriteditor.
Der er dog flere, som benytter Gnu Emacs, Richard
Stallmans bud på, hvordan en editor skal konstrueres. Den har
features, som gvim ikke har, først og fremmest sammenligning og
opdatering af to næsten ens filer. Man kan nemt finde
kommandoerne til Emacs i menusystemet, og farver m.v. kan sættes
(ligesom for andre programmer) i $HOME/.Xdefaults. Jeg nævner det
her, fordi den RedHat valgte farve kombination ser frygtelig
dyster ud. Begge editorer har en tutorial, som guider begynderen
igennem de vigtigste operationer.
</para>

<para>
Dette afsnit er lige nu meget kort og ikke færdigt!
De vigtigste options til GNU-C compileren er:
</para>

<sect2 id="gnu-c-options">
<title>GNU C Compiler options</title>

<programlisting> <!--TODO: Formatering -->
-c              compile kun, skriver en &lt;navn>.o fil (dot-o fil, .o)
-d              output list af define, forudsætter -E
-g              inkluder debug information i resultat fil
-pedantic       check code after ANSI C code check spec-s.
-save-temps     save intermediate files, ufn.i ufn.s (hvorfor ikke ufn.o?)
-o xxx          send output til fil ved navn xxx. Hvis xxx ender
                   på .o, vil compileren *kun* gå til det step,
                   der generer .o filer.

-s              strip efter linkage 
-v              verbose, vis kommandoer fra gcc "administrator" program.

-I xxxx         path til ekstra include directory, vil blive søgt først.
-I-             Path(s) specificeret før denne option søges kun
                for "xxx" files i double quotes. Der er meget mere om
                -I option(s) in cpp.1 and cpp.doc

-E              send preproces output til ?
-MM             skriv MAKE regler for hvordan program er opbygget, bevirker,
                   at også -E switchen bliver sat.
-N? stack_check?

-O              Optimer. Skriver bedre kode, men pas på, kan ændre sekvens.
-P              Præproces uden linjer m/# info
-C              Lad kommentarer komme med
-trigraphs      Process ANSI standard trigraph sequences

-D"str"         Definér macro eller hvad du nu vil definere.
-u"str"         AF-definer en macro! (d.v.s. annuller virkningen
                   af en #define)



</programlisting>

</sect2>


<sect2 id="c-objdump-eksempler">
<title>objdump eksempler</title>
<para>
Her kommer eksempler på objdump anvendelse.
</para>
</sect2>

</sect1>

</appendix>


