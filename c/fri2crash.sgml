<appendix id="A-crash">
<title>Crash course i C sproget</title>
<titleabbrev>C-sprogelementer</titleabbrev>
<para>
 C består som andre programmeringssprog af:
</para>

<itemizedlist>
 <listitem>
  <para>
   Datatyper. Vi vil gerne have forskellige slags variable
   til at opbevare tal, tekst og billeder.
  </para>
 </listitem>

 <listitem>
  <para>
   Operatorer. Vi vil gerne kunne foretage beregninger med vores data.
  </para>
 </listitem>

 <listitem>
  <para>
   Løkker og betingede sætninger (<emphasis>if</emphasis>,
   <emphasis>while</emphasis> m.fl.). Vi vil gerne kunne gøre
   noget specielt, hvis vores tal er blevet negativt.
  </para>
 </listitem>

 <listitem>
  <para>
   Modularitet. Vi vil gerne kunne genbruge kode, som fx. beregning af
   sinus eller udskrift til terminalvindue.
  </para>
 </listitem>
</itemizedlist>

<sect1 id="C-hvad-er">
<title>C i få ord</title>
<para>
 Programmeringssproget C blev oprindeligt lavet for at kunne skrive
 styresystemet Unix i et højniveausprog. C er derfor et effektivt sprog, som
 har nemt ved at snakke med maskinkode (eng. assembly language).
</para>

<para>
 C er også et lille sprog, hvis man måler det i antallet af reserverede ord
 (kun 32). Det gør det nemt at lære syntaksen.
</para>

<sidebar>
<programlisting>
Reserverede ord:

auto              double            int               struct
break             else              long              switch
case              enum              register          typedef
char              extern            return            union
const             float             short             unsigned
continue          for               signed            void
default           goto              sizeof            volatile
do                if                static            while
</programlisting>
</sidebar>

<para>
C99 standarden tilføjer flg. reserverede ord:
<literal>inline, restrict, _Bool, _Complex, _Imaginary.
</literal>
</para>

<para>
Anvendt på rette måde bliver koden meget læseligt, og derfor 
anvendes C sproget til mange forskellige slags opgaver, fra
hardware-niveau til højniveauopgaver.
</para>

<para>
 C++ er en udvidelse af C. C++ er tænkt som et bedre C. Det understøtter
 objektorienteret programmering, dataabstraktion og generiske algoritmer. Der
 er dog et par forskelle mellem C og den grundlæggende C-lignende syntaks i
 C++. Det beror på det oprindelige C sprog's manglende typecheck
 af funktioners returværdier.
</para>

<para>
 Et minimalt C-program:
</para>

<example id="hello-world">
<title>Hello world! programmet.</title>

<programlisting>
/* Dette program skriver Hello, world! i et terminalvindue. */

main(){
     printf("Hello, world!\n");
}
</programlisting>
</example>

<para>
Vores program definerer en funktion, d.v.s. et stykke kode, som
udfører en opgave. Navnet på vores funktion er main. main er det
sted, hvor et C program begynder at køre. Parenteserne efter
ordet main fortæller, at det er en funktion.
</para>

<para>
Koden, det, som bliver til maskininstruktioner, står mellem to
krøllede parenteser (eng. braces). Koden består af et
kald til en anden funktion, printf, som får til opgave at skrive vores
tekst mellem double quotes på skærmen. "\n" er måden at skrive
linieskift mellem doublequotes.
</para>

<para>
 Ovenstående kildetekst bør kunne oversættes (eng. compile) til et
 kørbart program. De fleste moderne oversættere vil dog klage over
 udeladelser. En helt korrekt version (også C++) ser ud som følger:
</para>

<example id="ex-hello-types">
<title>Hello, World! med type-specifikationer.</title>
<programlisting>
/* Dette program skriver Hello, world! i et terminalvindue og er
 * meget omhyggeligt med consistent anvendelse af typer. */

#include &lt;stdio.h&gt;

int main(){
     (void) printf("Hello, world!\n");
     return 0;
}
</programlisting>
</example>

<para>
Ovenstående eksempel erklærer, at main er en funktion, som
returnerer en integer. Derfor returnerer den jo så altså netop
også et heltal, nemlig 0! <literal>return 0;</literal> betyder
aflever et 0 til den, som satte funktionen i gang. Man siger, at
caller får returneret en værdi.
</para>

<para>
printf er ligeledes en funktion, som returnerer en integer til
caller; det er antallet af bogstaver, den har skrevet ud. Da vi ikke har
brug for denne integer, fortæller vi oversætteren, at det er "med vilje",
at vi ignorer return value ved at skrive <emphasis> (void) </emphasis>.
Det kaldes et cast - støbeform, vi omstøber funktionens type!
</para>

<sect2 id="crash-datatyper">
<title>Data typer</title>
<para>
C sprogets indbyggede datatyper er:
</para>

<programlisting>
int x;        /* integer, heltal, maskinens hurtigste type, native type */

char b;       /* velegnet til bogstaver, men i virkeligheden bare en lille */
              /* integer, 8 bits (eller 9 ...) */

float f;      /* floating point med kun 32 bit, kun til grafikkort o.l. */

double df;    /* 8 eller 10 bytes floating point type */

int ia[10];   /* array med 10 elementer, mange af samme slags */

struct person_type {             /* gruppering af mange typer i en klump */
   int alder;
   char navn[10];
};

struct person_type mig;            /* udlaegning af lager, instantiering */
struct person_type medlem[10];     /* array af struct */

int *j;                            /* adressevariabel, pointer */
</programlisting>

<para>
Datatyperne kan erklæres udenfor en funktion, så er det globale objekter,
eller som lokale variable, indenfor funktionsbraces.
</para>

<sidebar>
<para>
Jeg har med vilje udeladt en del grumsede detaljer i ovenstående
type-oversigt. Hvis du, kære læser, er sur over det, så er her et resume
af det udeladte:
</para>

<para>
En long integer er lige så stor - måske større - end en int. I gcc i386
er de begge 32 bit. Nye standarder vil indeholde forskrift om at
oversættere skal understøtte _int8, _int16, _int32, _int64 etc. hvilket vil
være praktisk for mange opgaver. Man kan i dag definere sådanne typer
selv v.hj.a. typedef, fx. 
</para>

<programlisting>
typedef long long int _int64;
</programlisting>

<para>
Integer typerne (char, int, short int, long int, _int64 eller long long)
kan foranstilles signed (det er default) eller unsigned. Erklærer man en
unsigned integer vil man i mange oversættere alligevel kunne tilskrive den
en negativ value. Unsigned vinder overfor signed i type coercion i
expression evaluering.
</para>
</sidebar>

<programlisting>
/* ramme for eksperimenter med variable af indbyggede typer */

int x;
char b;

main()
{
    double temp = -17.8;

    b = 67;
    printf("x er %d, b er %d, temperatur er %f\n",x,b,temp);
    {
        int *px; /* definition af variabel i top af blok. */
        px = &amp;x; /* tag adressen af x og læg over i p */

        printf("adressen på x er %p\n",px);
    }

    return 0;
}
</programlisting>

<para>
px er en pointer. Det ses af, at erklæringen har en stjerne foran
px. Man må gerne stille stjernen lige bagefter int, men
syntaktisk binder den til px. Derfor kan man fx. erklære en
integer pointer og en integer indenfor samme semikolon, <literal>
int tal, *ptr2tal;</literal> (men kønt er det ikke!)
</para>

<para>
"Og" tegnet, ampersand på engelsk, er adresse-operatoren
d.v.s. at den tager adressen på den variabel, den stilles foran.
<literal> px = &amp;x; </literal> betyder tag adressen på x og
læg den over i variablen px.
</para>

<para>
Adresser på en 32-bit CPU ligger mellem 1 og 4 milliarder eller 4
Giga.
</para>

<sect3 id="crash-struct">
<title>Struct - forskellige typer grupperet i en klump</title>

<para>
Med struct konstruktionen kan vi selv definere de datatyper, vi har brug
for, deraf betegnelse <emphasis> brugerdefinerede typer. </emphasis>
Notationen kræver lidt øvelse. Først bygger man en type op, man
<emphasis> erklærer en type </emphasis>, derefter defineres objekter,
dvs. der reserveres hukommelse til objekter af den oprettede struct-type.
</para>

<para>
Navnet efter ordet struct kaldes en tag. Det kan sammen med ordet struct
bruges som type-specifikation. I eksemplerne anvendes angles til meta
ord - der skal indsættes et unikt navn på de pågældende positioner.
</para>

<programlisting>
struct &lt;type_tag> {
   data-declarations ...
};

struct &lt;type_tag> new_var;
</programlisting>

<para>
Alternativt kan man definere en struct type ved hjælp af typedef. Denne
metode foretrækkes af mange, fordi man så ikke behøver at anvende ordet
struct.
</para>

<programlisting>
typedef struct &lt;type_tag> {
   &lt;data-definitions> ...
} &lt;type-specifier>;           /* <--- her er den nye types navn */

&lt;type-specifier> min_variabel;
</programlisting>

<para>
Min opfattelse er den, at ordet struct gør programmerne lettere at læse.
Og oversætteren kan lettere finde fejl.
</para>

<programlisting>
struct hus_t {                 /* først erklæres ny type */
   char adr[280];
   int pris;
};

struct hus_t mithus;           /* typen anvendes, ram udlægning sker */

main() {
   mithus.pris = 780000;          /* nu kan vi bruge vores variabel */
   strcpy(mithus.adr,"Byvej 20";  /* initialisering af string kræver strcpy */
}
</programlisting>


</sect3>
</sect2>

<sect2 id="operatorer">
<title>Operatorer</title>

<para>
Aritmetiske operatorer.
</para>

<programlisting>
+ plus, addition
- minus, subtraktion
* asterisk, multiplikation
/ stroke ell. slash, division
% percent, modulus, rest af heltalsdivision.
</programlisting>


<para>
Assignment operatorer, tildeling.
</para>

<programlisting>
Op.   ex.          Beskrivelse
-------------------------------------------------------------------------------
=     a = b     :  læg værdien af b over i a.

++    ++c       :  læg en til c, increment operator.

                :  ++ operatoren kan stå efter identifieren:
  if (c++ &lt; 42) :  sammenlign med 42 og læg bagefter 1 til c.

--    --c       :  træk 1 fra c, decrement operator.
-------------------------------------------------------------------------------

Desuden kan lighedstegnet kombineres med de 
forskellige aritmetiske operatorer:

x += kaxi; /* tael x op med vaerdien af variablen kaxi */
</programlisting>


<para>
Relationelle operatorer, sammenligning.
</para>

<programlisting>
&lt; mindre end
> større end
&lt;= mindre end eller lig med
>= større end eller lig med

OBS!  ==    test for lighed
      !=    test for not lighed
            Husk det ved at tænke på at 
            den logiske operator NOT er et udråbstegn.
      !     not (tager kun én operand, hvis logiske værdi inverteres)

Et expression er sandt, når det er forskelligt fra 0.
Et expression er falsk, når det er lig med 0.

Eksempler:

  if (a > b) 
      printf("a er for stor\n");

  if (x > 1 || x != y)
      printf("x er større end 1 eller x er forskellig fra y!\n");
</programlisting>


<para>
Logiske operatorer.
</para>

<programlisting>
&& logisk AND
|| logisk OR

!  logisk NOT
</programlisting>

<para>
Bitwise operators, bitvise operatorer, manipulerer de enkelte bit eller
bitkolonner efter den almindelige logik.
</para>

<programlisting>
&    bitvis AND               1 & 1 == 1; 17 & 1 == 1;
|    bitvis OR                1 | 0 == 1; 17 | 1 == 17;
^    bitvis XOR               1 ^ 0 == 1; 17 ^ 1 == 16;
~    bitvis NOT               ~1    == 0xfffffffe;
>>   shift right              1 >>1 == 0; 17 >>1 == 8;
&lt;&lt;   shift left               1 &lt;&lt;1 == 2; 17 &lt;&lt;1 == 34;
</programlisting>

<para>
Pas på NOT operatoren, det er en tilde. I almindelig netscape opsætning
er den meget svær se.
</para>

<para>
Bitvis NOT er det samme som bitvis invertering. I ovenstående
eksempel er resultatet skrevet ud fra en antagelse af, at der er tale om
en 32-bit størrelse. Hvis der er tale om 64 bit, så vil der være 15 f'er
i stedet for "kun" 7. Hvis 32-bit størrelsen skulle skrives som
bit-mønster, så er der selvfølgelig 32 "cifre" der enten er 0 eller 1.
Det er en god ting at lave et mellemrum for hver fjerde. Så kan man
bedre jævnføre med hexadecimal notation.
</para>

<programlisting>
~1 == 1111 1111 1111 1111 1111 1111 1111 1110. 

      f    f    f    f    f    f    f    e

      15   15   15   15   15   15   15   14

Så altså, det er lidt nemmere at læse hexadecimal notation:

~1 == 0xffffffe
</programlisting>

<para>
Der er desværre ikke nogen standard funktion, som udskriver bit-mønster
for en integer. Hvis man vil skrive resultatet som BIT-mønster, så
må man programmere en funktion, der tester med bitvis and og derefter
foretager et shift, fx.
</para>

<programlisting>
    /* udskriv x's bitmønster: */
    { 
        int i = 0;
        char numstr[35];                    /* 2 + 32 + end of string */
        strcpy(numstr,"b: ");               /* "b:" for binaert format */
        numstr[34] = 0;                     /* End of string mærke */
        while (i++ < 32) {
            numstr[34-i] = (x & 1) + '0';
            x >> 1;
        }
        printf("%s\n",numstr);
    }
</programlisting>

<para>
Du kan afprøve de ovenstående ved at sætte den ind i en main() funktion,
hvor man allerøverst definerer en int x = 0xf0f0f0f0.
(File: bitmonst.c).
</para>

<para>
De andre bitmanipulationer kan også afprøves med små programmer som
nedenstående, god øvelse:
</para>

<programlisting>
main()
{
    printf("17 >> 1 == %d \n",17>>1);
    return 0;
}
</programlisting>

<para>
Conditional operator
</para>

<programlisting>
Specielt for C sproget er betingelses-operatoren:

  yxi = (a>b)? a: b;

Svarer til:

  if (a > b)
     yxi = a;
  else
     yxi = b;
</programlisting>

<para>
Andre operatorer
</para>

<programlisting>
Ud over ovenstående findes der adskillige specielle operatorer, der kun
må anvendes efter forudgående aftale med type checking systemet. ;-)

 &   adresse operator, tager adressen af et objekt.

 *   asterisk operator, tag indholdet på den adresse, som specificeres
     efter stjernen, <emphasis> dereferering af adresse. </emphasis>

 ->  kan bruges ved dereferering af en struct pointer.

 .   Bruges til adressering af et struct element.

 ()  Funktions operator.

 []  Array operator.


 sizeof  (en pseudo funktion, kan bruges som operator, giver os
          størrelsen af det objekt, som den står foran.)

 
 ,   Komma, listeoperator.
</programlisting>

<para>
Her er et enkelt eksempel - men lav selv flere!
</para>

<programlisting>
int charcnt[256];

main()
{
    int yxi;
    double kaxi;
    long double kolme;

    printf("Size of charcnt: %d\n",sizeof charcnt);

    /* sizeof anvendes ofte som en pseudo funktion */
    printf("Size of yxi....: %d\n",sizeof(yxi));

    printf("Size of double.: %d\n",sizeof kaxi);
    printf("long double....: %d\n",sizeof kolme);

}
</programlisting>

</sect2>

<sect2 id="flow-kontrol">
<title>Flow kontrol</title>
<para>
Flow kontrol er maskinens måde at reagere på data. Ikke alle er nødvendige.
</para>
<programlisting>
    if (betingelse_opfyldt)
        do_dyt();

Test inden udførelse:

    while (betingelse_opfyldt)
        do_looping();

Kør loop-body mindst en gang:

    do
        mindst_en_gang()
    while (betingelse_opfyldt);

Behagelig kontrol med tæller variable:

    for (initialisering; betingelse; optælling) {
       loop_body ...
    }

    fx. 
    for (i = 0; i &lt; 10 ; ++i)
        printf("i er nu %d\n", i);

Inde i loops kan man:

    break:      Goto lige efter loop-end.

    continue:   Begynd forfra med test af betingelse.

Jumptabel:

    switch (integer_variabel) {
    case 17:
             do_beep();
             break;
    case 42:
             do_hurra();
             break;
    default:
             do_whine();
    }

For at komme ud af en masse loop-kontrol statements:

   goto label;

   /* kode ... */
label:
</programlisting>

<para>
Bemærk, at case linierne i switch statementet ligner og opfører sig
som labels, de er faktisk labels. Man fortsætter nedefter i næste case,
hvis der ikke er et break statement.
</para>


<para>
Et par eksempler, meget simple, først et eksempel, som smager på
værdien af en variabel:
</para>

<programlisting>
main()
{
    int i,j,k;

    i = 27;
    j = 2;

    if (i > j)
        k = i;
    else
        k = 2;

    return k;
}
</programlisting>

<para>
Et eksempel på en for-løkke:
</para>

<programlisting>
main()
    int fahr, celsius;

    for (fahr = 0; fahr &lt; 200; fahr = fahr + 20) {
        celsius = 5 * (32 - fahr) / 9;
        printf("Fahrenheit %3d svarer til celsius %3d\n", fahr, celsius);
    }
}
</programlisting>

</sect2>

<sect2 id="modularitet">
<title>Modularitet</title>
<para>
Funktionsbegrebet i C gør det muligt at genbruge kode; man kan bygge på
andres arbejde i stedet for at begynde på bar bund hver gang.
</para>

<para>
Et C program består typisk af mange forskellige filer, der kan
oversættes hver for sig. En fil - evt. med tilhørende header files - der
kan oversættes alene til et objekt modul, kaldes en oversættelses-unit
eller en translation-unit.
</para>

<para>
Allerede i vores første program benyttede vi os af, at der i et bibiotek
<emphasis> library </emphasis> lå en funktion (printf) som kunne skrive
tekst ud på terminalvinduet.
</para>

<para>
Det er muligt at have private variable i en translation unit.
</para>

<programlisting>
/* modular programmering - fil nr. 1, kryptio.c */
/* main læser fra tastatur (eller omdirigeret fil)
 * og skriver det krypterede bogstav ud på skærmen.
 */

#include &lt;stdio.h>

main()
{
    int c;
    while ( (c = getchar()) != EOF) {
        c = krypter(c);
        putchar(c);
    }
}
</programlisting>

<para>
Til ovenstående main vil vi nu skrive et simpelt modul, som foretager
kryptering:
</para>

<programlisting>
int krypter(int inputchar)
{
    return inputchar + 1;   /* 'cæsar' kryptering */
}
</programlisting>

<para>
Uha, det viser sig snart, at folk gennemskuer vores simple kryptering,
så nu laver vi en rigtig kryptering. Det smarte er, at vi kan erstatte
dette modul uden at lave om på det eller de programmer, som anvender
vores funktion "krypter()".
</para>

<para>
Bliv nu ikke forskrækket over, at der er en del ting i næste eksempel,
som ikke er fyldestgørende forklaret endnu. Prøv at læse det, evt.
indtaste og oversætte det. Prøv så at rette i det for at se, hvad der
sker undervejs. Når et problem er kompliceret, så skil det ad i mindre
dele og indsæt printf statements, så du kan se, hvad der sker undervejs.
</para>

<example id="ex-kryptering1">
<title>Simpel kryptering</title>
<programlisting>
/* file krypter1.c - en brugbar (men forsimplet)
 * krypteringsalgoritme. Kan ikke håndtere linieskift m.v.
 */

int krypter(int inpchar)
{
    static char *keystring = "Under traeerne var der stille og roligt.";
    static int inuse;
    static char *mv;
    static int keylen;

    if (!inuse) {
        inuse = 1;
        mv = keystring;
        keylen = strlen(keystring);
    }
    if (mv - keystring > keylen)
        mv = keystring;
    if (inpchar &lt; ' ')
        inpchar = ' ';
    else if (inpchar > 126)
        inpchar = '~';
    return (inpchar + *mv++) % 93 + 33;
}
</programlisting>
</example>

<para>
Virker kun for ren ASCII tekst.
<footnote>
<para>
I parentes bemærket, hvis du vil gøre krypteringen ovenfor ubrydelig
skal du forbedre den lidt. Længere keystring (helst længere en
gennemsnitsmeddelelsen), formater output i linier, som er lige lange,
og bemærk, at hvis input består af lutter samme tegn, så kan denne
version ikke rigtigt skjule sin keystring. Ikke at den kommer i
klartekst, men det er muligt at regne baglæns og finde keystringen.
Man kan behandle sekvenser af samme char som et antal og en specielle
koder. Algoritmen er en tilpasning af Kejser Augustus' og Livia's
kode, som beskrevet i Robert Graves' "I, Claudius".
</para>
<para>
Endelig er der ikke support for såkaldte offentlige keys, der kan
bruges til afkodning men ikke indkodning.
</para>
</footnote>
</para>

<para>
Ordet static, som står foran de 4 variable, som skal anvendes i
modulet her, betyder, at de ikke må kunne bruges fra andre
moduler eller funktioner i det færdige program. Det er såmænd
ikke fordi de skal være hemmelige, men blot for at sikre, at vi
har styr på, hvor der sker ændringer af variablen, som peger
fremad i krypteringsnøglen.
</para>

<para>
Hvis du blev bidt af ovenstående, så lav en dekryptering til den.
Eller læs eksempel-programmet afkrypt1.c. Desuden er der en
forbedret version, som håndterer linieskift, krypter2.c og
afkrypt2.c
</para>

<para>
Det var små eksempler på anvendelse af datatyper, operatorer,
flowkontrol statements og modularisering. Det næste afsnit
af crash course i C programmering går lidt mere i dybden med
disse emner.
</para>

<para>
Først et spørgsmål: Lagde du mærke til, at variablen 'keylen'
havde fået ordet <emphasis>static</emphasis> stillet foran? Det
er en storage specifikation. Læs videre!
</para>

</sect2>
</sect1>

<sect1 id="sect-C-fundamentet">
<title>Lager klassifikation, storage classes</title>

<!--OBS! AL TEKST ER ÆNDRET RADIKALT:-->

<para>
Emner:
</para>

<itemizedlist mark="bullet">
<listitem>
<para>
externe variable, funktioner og konstanter
</para>
</listitem>
<listitem>
<para>
funktioner og lokale variable (auto)
</para>
</listitem>
<listitem>
<para>
programsektioner, stak, heap, bss, data, text
</para>
</listitem>
<listitem>
<para>
kontrolvariable for løkker eller loops
</para>
</listitem>
<listitem>
<para>
scope (synlighed) og varighed, lokale static variabel
</para>
</listitem>
<listitem>
<para>
rekursion og statics
</para>
</listitem>
<listitem>
<para>
funktioner som returnerer pointer til buffer
</para>
</listitem>
<listitem>
<para>
volatile,
</para>
</listitem>
<listitem>
<para>
register variable.
</para>
</listitem>
</itemizedlist>

<para>
Et C program består af definitioner af eksterne objekter, som
kan være funktioner eller variable. Eksterne objekter kan bruges
overalt i det program, hvori de forekommer, også fra separat
oversatte funktioner.
</para>
<para>
Modsætningen til eksterne variable er de variable, som defineres
inde i en funktion og de parametre, som funktionen modtager når
den bliver kaldt. De eksisterer, mens funktionen kører. De bliver
automatisk oprettet når programmet eksekverer funktionen (eller
blokken) og nedlægges igen, når programmet forlader funktionen.
De kaldes derfor også automatiske variable. Det reserverede ord
<emphasis>auto</emphasis> kan anvendes om lokale variable, men er
overflødigt - det stammer fra de tidligste versioner af C
sproget.
</para>
<para>
Funktioner er altid eksterne objekter; man kan ikke definere en
funktion inden i en anden funktion, sådan som man for eksempel
kan i Pascal sproget.
</para>
<para>
Selv om eksterne objekter uden videre er "synlige" i hele
programmet, er der en metode til gøre dem private for et modul.
Det skal vi se på senere i dette afsnit.
</para>

<sect2>
<title>Externe variable, funktioner og konstanter</title>

<!--OBS! AL TEKST ER ÆNDRET RADIKALT:-->

<para>
For helt at være klar til diskussion af eksterne variable skal
det lige understreges, at et C program næsten altid opbygges af
separat oversatte moduler. De fleste af dem ligger måske i et
library - måske er det standard-library, libc.a - Andre ligger i
vores egne oversatte moduler, og vi kan give oversætteren besked om
det på kommandolinien ved simpelthen at nævne alle de moduler,
som skal med. Oversætteren består af mange forskellige programmer,
og det sidste af dem, nemlig linkeren, foretager sammenkædningen
af modulerne (link = hægte eller led i en kæde).
</para>

<programlisting>
gcc -o mitprogram modul_1.c modul_2.c modul_3.o
</programlisting>

<para>
Oversætteren finder ud af, at modul_3.o er et oversat modul og
nøjes med at medtage det i link-kommandoen, som bygger den
eksekverbare fil, "program-image filen" eller bare "programmet".
</para>

<para>
En definition af en (ekstern) variabel består af en type
angivelse og et navn, kaldet en variabel-identifikation, på
engelsk: identifier.
</para>

<programlisting>
typespecifikator variabel-navn [, variabel-navn] ... ;
</programlisting>

<para>
Altså typisk fx. følgende:
</para>

<programlisting>
int en_taeller;
</programlisting>

<para>
En funktion defineres nogenlunde på samme måde, altså ved en type
og et navn (lige som en variabel) men derefter har vi brug for
nogle flere oplysninger, nemlig en parentes med argumentlisten,
og de program-sætninger (statements), som udgør funktionens
<emphasis>krop</emphasis>, omsluttet af braces. 
</para>

<programlisting>
typespecifikator funktion-navn(parameter-liste)
{
    funktion-sætning(er);
}
</programlisting>

<para>
En minimum funktion ses nedenfor:
</para>

<programlisting>
int placeholder() { }
</programlisting>

<para>
Selv om en tom funktion ikke laver noget, kan den dog være ganske
nyttig under udviklingen af et større program ved simpelthen at
være til stede, evt. returnere en brugbar (default) værdi.
</para>

<para>
Der skelnes i C sproget mellem en definition og en deklaration.
På dansk ser man ofte ordet erklæring i stedet for deklaration.
</para>

<indexterm><primary>extern (nøgleord)</primary></indexterm>

<para>
Hvis vi ønsker at anvende en variabel, som allerede er defineret
i et andet modul, så bruger vi en deklaration. Det er en
forklaring, så at sige, til oversætteren om, at der er en variabel
til rådighed i et andet modul i det færdige program, som hedder
sådan og sådan og er af den og den type, men som altså IKKE
findes i nærværende overstættelses-enhed (translation unit).
</para>

<programlisting>
extern int en_taeller;
</programlisting>

<para>
Nu ved oversætteren, at der i et andet modul findes en variabel,
som hedder en_taeller, og at det er ok, at vi bruger den.
</para>

<para>
Hvis vi derimod vil reservere lager til en variabel, så kaldes
det definition af en variabel. Når programmet kører og vi
opretter et objekt (enten ved hjælp af dynamisk lagerallokering
eller ved hjælp af lokale variable i en kodeblok) kaldes det
instantiering af et objekt.
</para>

<para>
I C foregår deklaration og definition ofte på samme tid.
Når jeg skriver <emphasis>int xyzzy</emphasis> foretager jeg både
deklaration og lagerudlægning.
</para>

<para>
Hvis jeg derimod skriver <emphasis>extern int xyzzy</emphasis> 
udlægges der ikke lager, men jeg indføjer et punkt i oversætterens
symboltabel. I denne entry ligger oplysning om navn og type.
</para>

<para>
I det andet modul skal der være defineret en variabel på 
<emphasis>det yderste niveau</emphasis> - så er det en ekstern
variabel, som kan eksistere uafhængigt af de funktioner, som det
andet modul måtte indeholde (måske indeholder det kun variable).
En variabel, som er erklæret i <emphasis>det yderste
niveau</emphasis> er altid en variabel, som kan ses af andre
moduler. Den er, pr default, eksporteret, ville man måske sige i
sprog som ADA og Oberon.
</para>

<para>
En ekstern variabel er - i C sproget - også altid en <emphasis>
statisk </emphasis> variabel.  Sådanne statiske variable har lige
så lang levetid som det program, der anvender dem. På den måde
ligner de programmets instruktioner.
</para>

<para>
Programkode og statiske data ligger da også anbragt på samme måde
i lageret, nemlig forneden, på de lave adresser, under det
område, som anvendes til hhv. bunke (heap) og stak. Både heap og
stak kan vokse, så det er meget passende, at de enes om at
udnytte det store mellemrum fra "bunden" med faste data og
programinstruktioner og "toppen" hvor operativsystemet forlanger
at få lov til at være i fred.
</para>

 <informaltable frame="all">
   <tgroup cols="1">
<thead>
  <row>
    <entry>toppen af lageret</entry>
  </row>
</thead>
<tbody>
  <row>
    <entry>Operativ system kode</entry>
  </row><row>
    <entry>Stak for bruger-applikationen</entry>
  </row><row>
    <entry>Mellemrum mellem stak og heap</entry>
  </row><row>
    <entry>Heap til dynamisk lageradministration</entry>
  </row><row>
    <entry>.bss, nulstillede externe variable</entry>
  </row><row>
    <entry>.data initialiserede, eksterne variable</entry>
  </row><row>
    <entry>.string konstanter mv.</entry>
  </row><row>
    <entry>.text, program instruktioner</entry></row>
</tbody>
   </tgroup>
</informaltable>


<para>
Der er dog lidt forskel på, hvor data anbringes, er de
initialiserede, således som fx. vores keystring i eksempel 
<xref LinkEnd="ex-kryptering1">, anbringes de i en sektion, som
kaldes .data. Hvis vi ikke selv specificerer, at data skal
initialiseres, anbringes variablen i den sektion, som kaldes BSS
(eller .bss), og alle bit-terne vil blive nulstillet.
</para>

<para>
Navnet <emphasis>bss</emphasis> har rødder i IBM mainframe
assembler sproget, d.v.s. system 370, 390, 3900 og MVS.
Det står for <emphasis> Block Started by Symbol</emphasis>.
</para>

<para>
Lad os i stedet huske det som <emphasis> base static
storage</emphasis>. Det er garanteret, at variable, som erklæres
uden for en funktionsblok men som ikke er explicit initialiserede
ved en "initializer", er nulstillede ved programmets start. Det
sørger opstartsmodulet af programkoden for, traditionelt kaldet
c0.c
</para>

<para>
Læg især mærke til, at lokale variable anbringes på "stak for
applikationen". Det er de højest tilgængelige adresser for vores
program. Herfra kan stakken vokse (hov - den vokser nedad!)
indtil den møder heap. På en Linux maskine kan den vokse mere end
to gigabyte, før der sker sammenstød. MS NT har "kun" afsat 2 GB
til applikationer.
</para>

</sect2>

<sect2 id="sect-storage-spec">
<title>Storage specifications</title>
<indexterm><primary>Storage specifications</primary></indexterm>
<indexterm><primary>lagring, specifikation af</primary></indexterm>

<para>
Det reserverede ord <emphasis> static </emphasis> betyder
selvfølgelig statisk. Det kan, som vi har set i 
<xref LinkEnd="ex-kryptering1">, bruges, hvis man <emphasis> inde
</emphasis> i en funktion ønsker at have en variabel, som
overlever funktionen, så at sige, husker fra gang til gang, hvad
værdi, den havde sidste gang. For eksempel en sidetæller i en
udskriftsfunktion.
</para>
<indexterm><primary>static</primary></indexterm>

<programlisting>
void topmargin_udskrift(char *section_navn)
{
     static int sidenummer;
     printf("%s %d\n", section_navn, sidenummer);
}

</programlisting>

<indexterm><primary>stak</primary></indexterm>
<indexterm><primary>heap</primary></indexterm>

<para>
Stakken gør det muligt at have lokale variable i funktioner, og
for at have et sæt variable HVER gang funktionen kaldes, det er
betingelsen for, at man kan benytte rekursion.  Tilsvarende er
heap'en det område, som benyttes til dynamiske lager-strukturer
som fx. en "liste" og et "træ". (se kap. 3,
<xref LinkEnd="sect-abstract-datatypes">).
</para>

<para>
De steder, hvor der i nedenstående opstilling af lager-anvendelse
er anbragt nogle punktummer på sidelinien er steder, hvortil der
ikke nødvendigvis er knyttet noget RAM, fysisk memory.
Programmets anbringelse i lageret ser normalt ud sådan her:
</para>

<indexterm><primary>memory</primary><secondary>layout</secondary></indexterm>
<programlisting>
              +----------------------------+
              | Den øverste gigabyte       |
              |   som operativsystemet     |
              |     benytter og beskytter  |
              |                            |
              .                            .
              .                            .
              .                            .
              |                            |
              |                            |
              +----------------------------+
              |                            |
              |  Stack område for          |
              |          brugerprogram     |
              |                            |
              |  Her laves en ramme med    |
              |  data for hver function    |
              |  som kaldes                |
              |                            |
              .                            .
              .                            .
              .                            .
              .                            .
              |                            |
              +----------------------------+
              |                            |
              |  Heap - der, hvor man kan  |
              |    allokere mere lager     |
              |                            |
              |  Benyttes af funktionerne  |
              |    malloc(3), calloc(3),   |
              |     free(3) og realloc(3). |
              |                            |
              |                            |
              +----------------------------+  -
              |                            |   \
              |  bss -                     |    \
              |    blok started by symbol  |     \
              |  ell. base static storage  |      NULSTILLES
              |                            |      ved load af program
              |  static variable som IKKE  |     /
              |  er initialiserede         |    /
              |                            |   /
              +----------------------------+  -
              |  .data                     |
              |  initialiserede strings mv.|
              +----------------------------+
              |  .text                     |
              |  Programmets instruktioner |
              |  d.v.s. kommandoer til CPU |
              +----------------------------+
              | Lille stykke i bunden til  |
              |   Operativsystemets        |
              |   Hardwarehaandtering      |
              +----------------------------+

</programlisting>

<indexterm><primary>bss</primary></indexterm>

<para>
Hvis vi ønsker at anbringe en variabel i .bss sektionen kan vi
enten erklære den uden for en funktion eller benytte
lagrings-specifikationen <emphasis>static</emphasis>. Sidstnævnte
metode vil være praktisk, hvis vi ønsker at erklære variabelen
inde i en funktion. Hvis vi benytter "static" på eksternt niveau,
d.v.s. uden for en funktionsdefinition, har specifikationen den
virkning, at variabelen ikke får ekstern synlighed (external
linkage).
</para>

<para>
Hvis en variabel erklæret inde i en funktion skal kunne huske sin
værdi fra gang til gang, når funktionen kaldes, skal den
defineres som static, hvilket vil bevirke, at den bliver anbragt
i .bss sektionen.
</para>

</sect2>

<sect2>
<title>Konstanter og memory protection</title>
<indexterm><primary>konstanter</primary></indexterm>
<indexterm><primary>read-only memory</primary></indexterm>
<indexterm><primary>skrivebeskyttet lager</primary></indexterm>

<para>
Der er forskellige måder at organisere kørselen af et program,
men stort set alle benytter ovenstående opstilling som
udgangspunkt. Det egner sig til virtual memory management,
hvilket jo fra starten var udgangspunktet for Linux, og det giver
nogle fordele, som er ret store. Vi kan simpelt hen lade vores
program benytte 3 GB memory - også selv om vi ikke har
installeret så meget. Afhængig af operativsystemets snedighed vil
der kun blive tildelt fysisk memory, når det er strengt
nødvendigt. Det vil sige, hvis vi vil skrive til memory. Når vi
har loadet vores program og vil starte det op igen fra en anden
brugers terminal, kan man stole på, at operativsystem kernen ikke
bruger mere RAM til at loade endnu en kopi af program
instruktionerne.
</para>

<para>
Så opdelingen af programmet i sektioner skyldes både vores egne
behov for at strukturere programmet og så et hensyn til
operativsystemet. Sektionerne skal gøre det lettere for
operativsystemet at optimere anvendelsen af memory.  Nogle
sektioner skal kun læses, fx. program-instruktionerne, andre
skal både læses og opdateres, og i hhv. heap og stack skal man
kunne udvide området under kørselen.
</para>

<para>
Hvis nu vores program alligevel forsøger at skrive på fx.
adressen for en funktion, så skal Linux kernens memory management
modul reagere ved at stoppe programmet.
</para>

<para>
På samme måde er der dele af initialiserede data, som ikke må
overskrives. Fx. streng-konstanten "Hello, world!\n" i eks.
<xref LinkEnd="hello-world">. Man kan heller ikke så nemt komme
til at gøre det i netop det eksempel. Men se lige her:
</para>

<example id="ex-konst">
<title>Konstant streng</title>
<programlisting>
/* constviol.c, at aendre en konstant ... */
#include &lt;stdio.h>

char * ms1 = "Hello, ever changing world!\n";

int main()
{
     *ms1 = 'A'; /* segmentation violation, signal 11 */
     return 0;   /* abort forinden, exitkoden er 139 == 128+11 */
}

</programlisting>
</example>

</sect2>

<sect2 id="sect-scope">
<title>Storage specifikation og scope</title>

<indexterm><primary>scope</primary></indexterm>
<indexterm><primary>synsvidde, synlighed</primary></indexterm>

<para>
Scope betyder synlighed (within scope = "inden for synsvidde").
En af de rigtig gode ting ved C sproget er, at man kan skrive
programmerne således, at variable kun er tilgængelige i en
funktion eller et modul. Derved kan man uden stort besvær anvende
objektorienterede programmeringsprincipper.
</para>

<example id="ex-scope-rules">
<title>Scope eller synlighed</title>

<programlisting>
/* ... demonstration af scope regler, synligheds regler. */

char * ms1 = "Min nye Hello-world rapport";
char * ms2 = "(c) 2001 Donald Axel, 3210 Vejby";
static char *msp = "Denne char-ptr kan kun bruges i denne fil."

headerlinie(){
     static int sidenummer; /* kan kun bruges i denne funktion */
     printf("%s Side %d\n", ms1, ++sidenummer);
}
</programlisting>
</example>


<para>
Hvis vi definerer en variabel, fx. ms1, på samme niveau som
funktioner, så kaldes den et eksternt objekt. (Husk: Et C program
består af en række definitioner af eksterne objekter.)
</para>

<para>
Variablen ms1 vil - uden særlig angivelse af, at den er
"public", blive synlig i andre kildetekst filer. De skal blot
erklære en extern char * ms1;
</para>

<example id="ex-external-decl">
<title>Extern declaration</title>

<programlisting>
/* External declaration */

extern char * ms1;        /* synlig i hele denne source-fil.*/

bundlinie(){
     extern char * ms2;   /* kun synlig i denne funktion */
     printf("%s\n", ms1);
     printf("%s\n", ms2);
}
</programlisting>
</example>

<indexterm><primary>extern (nøgleord)</primary></indexterm>
<para>
Hov! Hvad er nu det - kan man deklarere en "extern" <emphasis>
inde </emphasis> i en funktion? Jada, og så er det meningen, at
oversætteren skal redde os, hvis vi kommer til at bruge den
<emphasis> uden </emphasis> for funktionen. Men deklarationen af
extern char *ms2; inde i funktionen forudsætter, at variablen er
defineret (og helst også initialiseret, i dette tilfælde!) et
andet sted, d.v.s. i en anden kildetekst-fil (source-file).
</para>

<para>
Bemærk dog, at det stadig accepteres af mange oversættere, at man
erklærer en ekstern variabel flere gange med samme navn. Det kan
man vist roligt sige er en praksis, som bør undgås. Specielt kan
det nævnes, at gcc accepterer at man definerer den samme variabel
to eller flere gange, hvis den defineres i ydre niveau og dermed
implicit er ekstern variabel!
</para>

<programlisting>
/* fil 1. Demonstration af uheldig praksis. */
/* programmet oversættes uden advarsler - ikke engang option
 * -Wall, som ellers betyder "giv mig alle advarsler" 
 * (warnings, derfor -W), får gcc til
 * at reagere på denne konstruktion! Men benyttes g++ får man
 * heldigvis en fejl på denne uheldige fremgangsmåde. */

int min_globale_variabel; /* ok, det bør enhver oversætter acceptere. */

int min_globale_variabel; /* uha - burde udløse en warning! */
int min_globale_variabel; /* uha - burde udløse en warning! */

int main()
{
     printf("Værdien af min_globale_variabel er %d\n", min_globale_variabel);
     return 0;
}

</programlisting>

<indexterm><primary>static, anvendelse af</primary></indexterm>
<indexterm><primary>lint</primary></indexterm>
<indexterm><primary>lclint</primary></indexterm>

<para>
Det er jo godt nok kedeligt, hvis man tror, at man har to
forskellige variable, og oversætteren tror, at der kun er en.
Heldigvis findes der et værktøj (ud over c++) som kan afsløre
denne og andre sjuskefejl. Lint, en statisk syntax-checker, har
været på banen siden Unix version 7, altså den første offentlige
udgave fra 1978. Der findes nu en fri lclint, som er
fantastisk god til at gennemgå programmer, og som vel at mærke
kan komme igennem include-filer uden brok. Lclint er så
pedantisk, at man somme tider ønsker at slå en masse warnings
fra, men det er der heldigvis også altid anvisninger på.
</para>

<para>
<screen>

<prompt>fri2c: </prompt><userinput>lclint globviol.c</userinput>
pluto:/qf3/attic/don/fri ::lclint globviol.c
LCLint 2.4b --- 18 Apr 98

globviol.c:14:5: Variable min_globale_variabel redefined
  A function or variable is redefined. One of the declarations should use
  extern. (-redef will suppress message)
   globviol.c:12:5: Previous definition of min_globale_variabel
globviol.c:15:5: Variable min_globale_variabel redefined
   globviol.c:12:5: Previous definition of min_globale_variabel
globviol.c:12:5: Variable exported but not used outside globviol:
                    min_globale_variabel
  A declaration is exported, but not used outside this module. Declaration can
  use static qualifier. (-exportlocal will suppress message)

Finished LCLint checking --- 4 code errors found

</screen>
</para>

<para>
lclint er endog så omhyggelig, at den advarer mig om, at
min_globale_variabel faktisk ikke bliver brugt i andre moduler
(der er jo heller ikke andre lige for tiden ...) og at jeg derfor
burde erklære denne variabel for static. Godt
gået.<footnote><para> lint og den systemuafhængige C-oversætter har som
oprindelig ophavsmand Stephen C. Johnson, som er en af de kendte
oversætter-teoretikere der arbejder på Bell Labs.</para></footnote>
</para>

<para>
Hvis man omvendt kun har erklæret alle sine eksterne variable med
keywordet extern, så vil gcc beklagende meddele "undefined
reference to min_extern". (Se øvelser i kap. 2 for at få mere
føling med håndtering af variable i C programmer).
</para>

<para>
<command>Tilbage til external variables!</command>
</para>

<para>
Lige som extern kan også <emphasis> static </emphasis> bruges
inde i og ude af funktioner.
</para>

<para>
Resumé: En variabel, som er erklæret i starten af en
funktion, er lokal - den er kun synlig i funktionen. Hvis man
angiver, at den skal være static, så anbringes den fysisk i en
datasektion, som eksisterer i hele programmets køretid. Men den
er stadig kun synlig i funktionen, hvori den er defineret.
</para>

<para>
Så hvad nu hvis man anvender det reserverede ord <literal>
static </literal> <emphasis>udenfor</emphasis> funktionerne,
altså lige som eksterne objekter? Jo, så bliver variablens
synlighed indskrænket - ikke til en funktion, vi er jo udenfor
funktionerne - men til den fil, hvori den er erklæret.
</para>

<para>
En af de lidt morsomme ting i C sprogets anvendelse af ordene er,
at ordet <emphasis>static</emphasis> derved kommer til at
betyde, at en variabel er "privat" for det modul, hvori den er
erklæret!
</para>

<indexterm><primary>static, betydning privat</primary></indexterm>
<indexterm><primary>privat</primary></indexterm>

<para>
Den oprindelige betydning af specifikationen "static" er
selvfølgelig, at variablen skal være statisk. Den skal anbringes
i sektionen for globale data, statiske data. De kalde statiske,
fordi de eksisterer hele tiden, så længe programmet kører. Men
for at give programmøren en hjælpende hånd med at kontrollere,
hvor den pågældende variabel kan være blevet ændret (hvis der af
en eller anden grund skulle opstå fejl i programmet?) så kan
synligheden af statiske variable på denne måde begrænses.
</para>

<para>
Static variabel erklæres inde i en funktion - scope i funktionen,
static inde i et modul = scope i modulet.
</para>

<para>
Et modul kaldes i syntax beskrivelser en oversættelses-enhed
(translation unit) og består af en eller flere filer (include
filer) som oversættes til et objekt-modul.
</para>

<para>
Variablen i eksemplet ovenfor, sidenummer, kan kun bruges inde i
funktionen headerlinie(), men den husker alligevel nummeret fra
gang til gang, når funktionen bliver kaldt.
</para>

<para>
Hvis en funktion som fx. strftime(3) gerne vil aflevere en text
string med datoen formateret efter callers behov, så er det også
nødvendigt at returnere i en buffer, som ligger UDEN for
funktionen.
</para>

<para>
Man kunne somme tider ønske sig, at ordet static blev erstattet
af "modul-specifik" eller "privat". Det kan man jo bare gøre
selv ved hjælp af #define. I så fald skal man lige huske, at
private er et reserveret ord i C++. Man kunne måske i stedet
anvende "privat" (uden 'e' til sidst!) eller, bedre, et ord som
"hidden" eller ... "local"? SÅ ville der rigtig være rod i
semantikken! Problemet er nævnt i forbindelse med revision af C
som basis for C++, men som sagt finder private anvendelse i C++ ,
og det er på en lidt anden måde.
</para>

<para>
Husk at et C program består af eksterne objekter, som kan være
enten funktioner eller variable.
</para>

</sect2>

<sect2>
<title>Kontrolvariable for løkker eller loops</title>

<para>
Det fremhæves somme tider, at C++ er særlig smart fordi man kan
erklære variable der, hvor man har brug for dem. Det er sandelig
også en god ting. Man har dog for nylig indført nogle
forbedringer (læs rettelser) således at en kontrol-loop variabel,
som erklæres i fx. en for-løkke, går ud af scope ved afslutningen
af den blok, som styres af for løkken. Ellers kunne der nemt
opstå noget rod.
</para>

<para>
Denne fejlkilde er elimineret i C ved at man kan erklære variable
i enhver blok (hver gang man skriver en krøllet parentes start,
brace start), og denne variabels scope går så indtil blokkens
slutning. Nemt og logisk. Denne facilitet anvendes alt for lidt!
</para>

<example id="ex-local-control-var">
<title>En lokal kontrol variabel</title>

<programlisting>
/* loopcount.c, demonstration af ad-hoc variabel. */

#include &lt;stdio.h>

char *thisprog;

int main(int argc, char *argv[])
{
    thisprog = argv[0];
    printf("Program %s er startet ... \n", thisprog);
    {
        int jj = 0;              /* jj bliver oprettet */
        while(jj++ &lt; 10)
            printf("For %d. gang: Ih hvor vi kører\n", jj);
    }
                                 /* nu er jj nedlagt "automatisk" */
    printf("Program %s exiter graciøst!\n", thisprog);
    return 0;
}
</programlisting>
</example>

<para>
For at tillade oversætteren at optimere kan det forekomme, at
interne blokkes auto-variable faktisk oprettes samtidig med at
funktionens stack-frame sættes. Således gør gcc.
</para>

</sect2>

<sect2>
<title>Oversigt over variabel - anvendelse</title>

<para>
Oversigt over anvendelsen af static:
</para>

<itemizedlist mark="bullet">

<listitem>
<para>
En variabel erklæret uden for funktioner er en global variabel.
Det er egentlig det samme som at sige, at den er statisk, den
bliver stående som den er, gennem hele programmets levetid, 
på linie med funktionsobjekter.
</para>
</listitem>

<listitem>
<para>
En variabel erklæret udenfor funktioner får, hvis den er
initialiseret, plads i "data" sektionen, og i "bss" sektionen,
hvis den ikke er initialiseret. I så fald kan man regne med, at
den er nulstillet.
</para>
</listitem>

<listitem>
<para>
static for external object: specifikation af, at variablen
<emphasis> kun </emphasis> skal være synlig i det oversættelses
modul (translation unit) hvori den forekommer.
</para>
</listitem>
<listitem>
<para>
static for variabel i en funktion (kaldes lokal static) betyder,
at den kun er synlig i den funktion, hvori den er erklæret.
</para>
</listitem>

</itemizedlist>

<para>
Her er en præcisering af, hvordan man kan definere
forskellige slags lokale variable.
</para>

<itemizedlist mark="bullet">
<listitem>
<para>
Uden storage spec: En lokal variabel allokeres på
funktionsstakken. Skal initialiseres hver gang funktionen køres.
</para>
</listitem>
<listitem>
<para>
reserveret ord auto: overflødigt, samme som ovenfor.
</para>
</listitem>
<listitem>
<para>
reserveret ord register: Oversætteren vil, hvis det er muligt, anbringe
denne variabel i et af maskinens hurtige registre. Man kan ikke
tage adressen på en registervariabel.
</para>
</listitem>
<listitem>
<para>
reserveret ord extern: Variablen er defineret et andet sted,
normalt i en anden oversættelses enhed.
</para>
</listitem>
<listitem>
<para>
reserveret ord static: Variablen anbringes i regionen for
statiske variable. Den er kun synlig i den blok, gerne en
funktionsblok, hvori den er deklareret. (Den er selvfølgelig også
synlig i den oversættelses enhed, hvori den er defineret!)
</para>
</listitem>
<listitem>
<para>
En lokal variabel behøver ikke at blive defineret øverst i
funktionens yderste blok. Man kan definere nye lokale variable,
hver gang man skriver en start-brace (klamme).
</para>
</listitem>

</itemizedlist>


</sect2>
</sect1>

</appendix>


