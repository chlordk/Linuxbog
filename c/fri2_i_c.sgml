
<chapter id="c-programmering-start"><title>Funktioner,
modularitet og relevante teknikker</title>

<abstract><para>
Resume: Hello-world programmer isolerer og afprøver en speciel teknik.
For at konstruere og lære nye teknikker er det en god ting at
kunne isolere hver eneste lille funktionalitet i det nye program,
man ønsker at bygge. Denne teknik kan man kalde terrasse-teknik.
</para></abstract>

<para>
Et C-program består af en serie definitioner af eksterne
objekter. Et eksternt objekt kan være en funktion eller en
datadefinition, d.v.s. en variabel. For at få overblik over en
opgave fra begyndelsen af, er det godt at vide, hvordan man
opdeler en opgave i mindre dele. Ikke blot hvilke
funktionaliteter, som lader sig isolere, men også en idé om,
hvordan man bærer sig ad med at opdele et program i mindre
programdele. Det er hovedemnet for dette kapitel.
</para>

<indexterm><primary>objekt, eksternt</primary></indexterm>

<para>
En opdeling forudsætter, at der er mulighed for at koble
forskellige moduler sammen igen på et senere tidspunkt ved hjælp
af libraries, header filer og make filer. Det vil nærværende
kapitel give nogle eksempler på.
</para>

<para>
I C er funktioner grundlaget for opdelingen af programmer i
mindre dele. Som Kernighan siger: funktioner gør det muligt
at genbruge kode, gør det muligt, at en programmør bygger videre
på en anden programmørs arbejde.
</para>

<para>
Det er vel at mærke sådan at forstå, at jeg, i mit nye program,
kan includere al funktionalitet fra noget, som er skrevet i
forvejen <emphasis> uden at jeg skal ændre i eller kopiere fra den
oprindelige kode. </emphasis>
</para>

<para>
Grundlaget for genbrug er som sagt funktionen, men ved hjælp af
separat kompilering, statiske variable og evt. dynamisk
allokering af mere hukommelse kan denne teknik forfines, således
at man reelt set råder over objektorienterede metoder. Det bedst
kendte eksempel er ANSI C bibliotekets Input Output del, som
bygger på begrebet en FILE. Man kan erklære en variabel af typen
<literal> FILE* </literal> uden at ane, hvad den indeholder. Det
varierer også fra system til system. Men fælles for alle
<literal> FILE* </literal> er, at man kan åbne dem, <literal>
fopen() </literal>, læse fra dem <literal> fread() </literal> og
skrive til dem <literal> fwrite() </literal> finde en position,
lukke igen og meget andet.
</para>

<sect1 id="tour"><title>ANSI prototyper og modularitet</title>
<para>
I dette kapitel ser vi på hvordan man opdeler en lille opgave i
en beregningsdel og en hoveddel. Undervejs eksperimenteres
med funktioner og prototyper.
</para>

<para>
Derefter ses på filter programmer, som er programmer, der læser
noget input og transformerer dette til en bestemt slags output.
For et givet input vil output altid være det samme.
</para>

<para>
Dette princip udstrækkes til et forholdsvis kompliceret program,
som parser sgml tags og formaterer lidt på en sgml tekst. Endelig
er der forslag til mange øvelser undervejs, og den interesserede
læser vil sikkert ikke kunne lade være med at eksperimentere
yderligere. God fornøjelse!
</para>

<para>
Men allerførst skal vi lige se på, hvilken betydning returværdien
fra en funktion kan have på et helt andet program, nemlig en
shell eller kommandofortolkeren. Vi bruger et minimal program til
at isolere fænomenet.
</para>

<indexterm><primary>Kernighan, Brian</primary></indexterm>
<indexterm><primary>Ritchie, Dennis</primary></indexterm>

<sect2 id="brohoved">
<title>Et brohoved.</title>
<para>
Forhåbentlig kender du Kernighan &amp; Ritchies bog The
C Programming Language. Det første kapitel, den berømte "tour"
gennem C sproget, starter med et program, der skriver "Hello,
World!" på en uddataenhed (altså en skærm eller
lignende).<footnote><para>
Hvis du ikke kender bogen "The C Programming Language" af Kernighan &
Ritchie, og hvis du ikke er en øvet C programmør, så vil jeg anbefale,
at du køber eller låner den og bruger nogle uger til at arbejde
kapitel 1 igennem - lav så mange af de ekstra øvelser, som du kan
nå. Nærværende kapitel er en ikke en erstatning for den
oprindelige "tour", men et supplement. Man kalder det for
learning by doing eller deduktiv spiralpædagogik; vi udleder,
hvordan C sproget fungerer ved at prøve det mange gange og ved at
gøre øvelser lidt sværere hver gang.
</para>

<para>
Hvis Kernighan &amp; Ritchie bogen også forekommer for vanskelig
- den er nemlig heller ikke for helt grønne begyndere - så er der
nogle andre introduktionsbøger, som kan guide dig igennem
grundlæggende øvelser i programmering, f.eks. "Practical C" fra
O'Reilly.
</para>

<para>
Hvis du har lidt gåpå-mod, kan du måske alligevel klare dig ved
at bladre/klikke dig om til appendiks A i denne bog; dér gives en
oversigt over C sprogets fire forskellige bestanddele, datatyper,
operatorerne, flow-konstruktionerne - og om opdeling af
programmer i moduler.
</para>

<para>
K&amp;R bogen giver imidlertid flere eksempler end jeg har med
i Appendiks A, og forklarer variationer på programmerne,
variationer, som er rigtig gode til at få én igang med selv at
forsøge. Det kan du selvfølgelig også gøre med eksemplerne i
denne bog.
</para>

<para>
Det specielle ved Kernighan &amp; Ritchies programeksempler i
Kapitel 1 af den berømte bog er, at programmerne er nyttige. På
en kommandolinje kan de bruges med det samme til endda ret
fornuftige og realistiske ting.  Hvis du ikke er fortrolig med
kommandolinjesyntaks, så kan du finde eksempler i bogen »Linux &ndash;
Friheden til at lære Unix«.  Det er en god idé at
eksperimentere lidt med de simpleste Unix-programmer, inden du
går videre. Prøv f.eks. date, cal, uptime, id, who, finger, "echo
hej", strings /usr/bin/ls, file *, ls, pwd, cd, du, df, man gcc,
man ld, man ld.so, ldd /usr/bin/ls osv. (klassiske unix
kommandoer).
</para></footnote>
</para>

<para>
Det program kunne man jo så udnævne til stamfaderen for en
hel kategori. "Hello-world" programmer isolerer en feature og 
afprøver, hvordan den virker. Et "hello-program" skal helst kunne
køre, selv om vi nogen gange nøjes med at skrive en funktion for
at se, om oversætteren accepterer den syntaks, vi anvender.
</para>

<indexterm><primary>minimal-programmer</primary></indexterm>
<indexterm><primary>hello-programmer</primary></indexterm>

<para>
Et "hello-program" kan være et, som skriver noget på skærmen,
eller det kan hente dato-information, så kan vi få bekræftet, om
dato funktionerne opfører sig, som vi forventer, eller ej. Vi
kunne kalde det for et minimalprogram. Vi kunne også sige, at vi
isolerer de features i C sproget, som vi ønsker at
lære/undersøge/afprøve. Metoden er vigtig at lære. Det er
en ekstremt nyttig metode; med den kan man løse flere problemer,
end man kan med en debugger.
</para>
</sect2>


<sect2 id="sect-return-value">
<title>Returværdi fra en funktion</title>
<indexterm><primary>retur værdi</primary></indexterm>
<indexterm><primary>ANSI funktioner</primary></indexterm>

<para>
Det, vi skal i gang med nu, er at undersøge, hvordan funktioner
afleverer data til hinanden, og hvordan C sproget gør det lettere
at lave sådan nogle "kasser", ofte kaldet black box, om hvilken
man ved, at den kan dit og dat, og at den er helt uafhængig af
resten af vores program.  
</para>

<para>
Et helt grundlæggende "Hello-world" program er et, som
simpelt hen afslutter med det samme! Sådan et kommer her:
</para>

<example id="ex-hello"><title>HELLO - statuskode</title>
<programlisting role="C">
<literal>
/* frame.c Minimalt program til afproevning af statuskode. */

int main()
{
    return 0;
}

/* end of file frame.c */
</literal>
</programlisting>
</example>

<indexterm><primary>kommentarer</primary></indexterm>
<para>
Program-source, kildeteksten består af 8 linjer, hvis man
tæller kommentarer og tomme linjer med. Aller øverst er der en
kommentar, som fortæller kort hvad meningen med programmet er.
En kommentar startes med "/*" og slutter med "*/".
</para>

<para>
Programmet består af en definition af ét eksternt objekt,
nemlig en funktion, som har navnet "main". Parenteserne efter main
fortæller, at main er et objekt af typen funktion. Parenteserne
kaldes derfor "funktions-operator" <footnote> <para> Tabellen
<xref linkend="ex-operator-precedence"/>, viser parenteserne
<emphasis>"()"</emphasis> øverst, fordi bindingen mellem
identifier og () er stærkere end bindinger mellem andre
operatorer.  </para> </footnote> Selve koden i main er indrammet
i krøllede parenteser, braces. Koden består af kun én sætning,
eller <emphasis> statement </emphasis>, nemlig 
</para>

<programlisting>
return 0;
</programlisting>

<para>
<emphasis> return </emphasis> er en specifikation af, at
funktionen skal aflevere noget til den, som har bedt om at få
udført funktionen (har <emphasis>kaldt</emphasis> den.)
</para>

<indexterm><primary>reserverede ord</primary></indexterm>
<para>
return er et <emphasis> reserveret ord </emphasis>, d.v.s.
et ord, som oversætteren er født med at kende. C sproget har 32
reserverede ord. (se <xref linkend="C-hvad-er"/> .)
</para>


<para>
Nullet er et "udtryk", (aritmetisk udtryk) med en talværdi.
Vi kunne også have skrevet return 234 eller return 7000143. I
dette tilfælde vil det dog være klogt at holde talværdien 
under 256.
</para>

<indexterm><primary>udtryk, expressions</primary></indexterm>

<para>
Eksempler på andre expressions: kroner = timer * timeloen;
hvor det forudsættes at kroner, timer og timeloen er variable,
som indeholder fornuftige værdier. Et expression, som afsluttes
med semikolon, kaldes et statement.
</para>

<indexterm><primary>sætning, statement</primary></indexterm>

<para>
Hvis der er flere statements i en funktion, udføres de i
rækkefølge, oppefra nedefter.
</para>

<para>
Et kald til en funktion, som f.eks. flg.: <literal>
abs(-5); </literal> er også et expression, i dette tilfælde med
værdien 5.  Kald til en funktion vil ofte returnere en variabel
af typen heltal, <emphasis> integer </emphasis>, og en integer i
et expression kan erstattes af et kald til en funktion, som
returnerer en integer.
</para>

<para>
 Det er en konvention, at kørsel af et program, som benytter
 standardbiblioteket (med bl.a. læse- og skrivefunktioner) begynder med
 funktionen <emphasis>main</emphasis>.  Når man kommer til slutningen af denne
 funktion, slutter programmet her med at returnere en statuskode til
 styresystemet. Denne statuskode bruger man til at markere om programmet blev
 afbrudt af en fejl (og lignende). Hvis et program slutter uden et
 "return &lt;expression&gt;;" er det sjusk.
</para>

<para>
 Kernighan &amp; Ritchie dropper return-sætningen en del gange i
 <emphasis>bogen</emphasis>, men det er faktisk sjusk alligevel! De gør det
 selvfølgelig fordi det er lettere at forklare et program, hvori der kun er de
 nødvendigste linjer.
</para>

<para>
 Statuskoden bør fortælle, om programmet kunne køre uden fejl,
 (dvs. uden fejl, der er påført af ydre omstændigheder, som
 f.eks. at en datafil mangler).  Det er altså programmørens
 mulighed for at sende et signal om at "alt er vel" eller "her
 opstod en fatal fejl".
</para>

<para>
 Hvis programmøren vil fortælle systemet, at der var en fejl, skrives
 simpelthen:
</para>

<programlisting>
return 255;
</programlisting>

<para>
Tallet kan i Unix-kommandofortolker-sammenhæng læses i variabelen $?,
som kan styre processtrømmen i et Unix-skalprogram <emphasis> (en
shell) </emphasis>.<footnote><para> I Microsoft miljøer som
"errorlevel", der kan bruges af if-sætninger i batch-filer.
</para> </footnote> Øvelse: Ret, så programmet returnerer 117 og
se, om du kan udskrive systemvariablen $? med kommandoen 
</para>

<screen>
<prompt>dax@pluto$</prompt> echo $?
 0
<prompt>dax@pluto$</prompt>
</screen>

<para>
Det lille program ovenfor kunne oversættes/compileres <footnote>
<para> Generer det, hvis jeg staver engelske computer-udtryk på
engelsk? </para></footnote> med flg. kommando:
</para>

<screen>
<prompt>dax@pluto$</prompt><userinput> gcc frame.c -o frame </userinput>
<prompt>dax@pluto$</prompt>
</screen>

<para>
Derefter kan det køres fra current directory (i det aktuelle
katalog, eller sagt på en tredie måde, fra det bibliotek, som vi
står i <footnote> <para> Se "Friheden til at programmere"
afsnittet om C sproget, hvis du har brug for lidt mere indføring
i, hvordan man bruger kommandolinjen. </para> </footnote> ) med
en kommando som:
</para>

<screen>
<prompt>dax@pluto$</prompt><userinput> ./frame </userinput>
<prompt>dax@pluto$</prompt>
</screen>
<para>
   eller, hvis din PATH-systemvariabel ender på ':'
</para>
<screen>
<prompt>dax@pluto$</prompt><userinput> frame </userinput>
<prompt>dax@pluto$</prompt>
</screen>

<para>
Eksemplet lider imidlertid af en alvorlig skavank, vi kan
jo næsten ikke se, om programmet rent faktisk kører. Det laver jo
ikke noget! Derfor tilføjer vi en lille output kommando:
</para>

<example id="ex-stdout"><title>Skriv message på standard output.</title>
<programlisting role="C">
<literal>
/* frame2.c Skriv til stdout og afslut. */

#include &lt;stdio.h>

int main()
{
    puts("Hello! Programmet frame2 kører nu...");
    return 0;
}

/* end of file frame2.c */
</literal>
</programlisting></example>

<para>
Her er flere ting, som er værd at lægge mærke til. Dels et
include direktiv, d.v.s. en kommando, som fortæller oversætteren,
at den skal læse en fil, der hedder stdio.h. Når filnavnet står i
<emphasis> vinkler </emphasis>, så betyder det, at oversætteren
skal lede der, hvor systemet normalt har sine filer med
erklæringer, "include filerne". På Unix, Linux og andre systemer
er det <filename>/usr/include</filename>, der gennemsøges først.
</para>

<para>
Oversætteren finder den pågældende file og læser den. Den
indeholder <emphasis>kun type erklæringer</emphasis>.
</para>

<para>
Den erklæring, som vi skal bruge, ser ud som følger:
</para>

<programlisting>
extern int puts (const char *__str);
</programlisting>

<para>
Den kunne dog også have set enklere ud:
</para>

<programlisting>
int puts (char *message);
</programlisting>

<indexterm><primary>prototype</primary>
           <secondary>funktion</secondary>
</indexterm>

<para>
Det kaldes en prototype. Denne gør det muligt for oversætteren
at tjekke, at funktionskald vil fungere efter hensigten.
</para>

<para>
Prototypen "int puts(char*)" fortæller, at puts er en
funktion, som returnerer en integer og forventer at få en
character pointer som argument.
</para>

<para>
En prototype for vores main (som burde findes i en af glibc
- systemets header filer) ville hjælpe oversætteren med at 
kontrollere, om vi overholdt interface mellem vores main og
bibliotekets startup procedure.
<footnote>
<para> I glibc2x: se efter
filerne <filename>./sysdeps/elf/start.S</filename> og 
<filename>./sysdeps/generic/libc-start.c</filename>
</para>
</footnote> 
Denne prototype ville se sådan ud:
</para>

<programlisting>
int main(int argc, char *argv[], char *env[]);
</programlisting>

<para>
Det er ikke nødvendigt at angive et navn, en identifier, på 
argumenterne, kun typen skal angives når vi skriver en prototype.
</para>

<programlisting>
int main(int, char *[], char *[]);
</programlisting>

<para>
Men det er oplagt at finde navne, som giver læseren en hjælp
til at forstå meningen med funktionen. Argc står for argument
count, argv for argument vector, en liste med alle parametre fra
det program, som har startet vores program op; env står for
systemvariable (eng. environment variables), her kan vi aflæse brugerpreferencer og
ligenende. Når vi ikke bruger parametrene til main, kan vi nøjes
med at skrive main(), altså en tom funktions-parentes.
</para>

<example id="ex-char-ptr"><title>En character pointer</title>
<programlisting role="C">
<literal>
/* frame3.c Demonstration af character pointer. */

#include &lt;stdio.h>

int main()
{
    char *charpointer = "Hallo! Programmet frame3 kører nu...";
    puts(charpointer);
    return 0;
}

/* end of file frame3.c */
</literal>
</programlisting></example>

<para>
char *message er erklæring af en variabel. Variabelen er en
character pointer, det vil sige en adresse variabel. Den
initialiseres på samme source linje, som den erklæres. 
Det er simpelthen en praktisk skrivemåde. Det svarer til:
</para>

<programlisting role="C">
main()
{
    char * charptr;              /* charptr er en variabel */
    charptr = "Hallo etc... ";
</programlisting>

<para>
En literal string, "Hallo etc... "; er ikke en variabel, men er
en besked til oversætteren om at initialisere et dataområde med den
tekst, som vi nu ønsker os. For at kunne bruge teksten skal vi
enten gemme adressen på den (altså cptr = "Hallo etc...") eller
også give adressen på denne string til den funktion, som skal
bruge den: <literal> puts("Hallo etc.."); </literal>
</para>

<para>
En gengivelse af dette system af RAM-adresser og indhold
kunne tegnes som en reol. Her er det en reol, hvor hver hylde har
et indhold, der enten kan være 4 bytes eller 4 bogstaver, eller
én adresse (32 bits).
</para>

<programlisting role="C">
        Adresse               
        eller
        hylde-nr.      Indhold

                    ~             ~
                    :             :
                    +-------------+
                    |             |
                    |  o !   P    |
           800440   +-------------+
                    |             |
                    |  H a l l    |
           800436   +-------------+
                    |             |
                    |             |
                    +-------------+
                    |             |
                    :             :
                    :             :
                    :             :
                    |             |
           120808   +-------------+  charptr er en adressevariabel,
                    |             |  som indeholder adressen
                    |  &lt;800436>   |  på en string, "Hallo! Prog...etc."
 charptr:  120804   +-------------+
                    |             |
                    |             |
           120800   +-------------+
                    |             |
                    |             |
           120796   +-------------+
                    :             :
                    :             :
                    |             |
                    :             :
                    :             :
                    |             |
</programlisting>


<para>
Det, der skrives på skærmen, er tekst, som bogstav
for bogstav ligger i programmets data-del. 
</para>

<para>
Lad os nu gå over til beregningsprogrammer. Hvis de ikke har
noget input, er de en slags "hello" programmer, fordi de isolerer
de aritmetiske operationer. Selv om vi begynder med simple
eksempler, kan det sandelig godt være nyttige programmer. Den
oprindelige idé om computere var jo blot at de skulle beregne
ting, som var trælse at beregne i hånden, planetbaner,
skatteopgørelser og lignende ;-)
</para>
</sect2>
</sect1>

<sect1 id="s1-datatyper">
<title>Parameterlister og datatyper</title>

<para>
I foregående afsnit afleverede vi én oplysning til en funktion. I
dette afsnit skal vi aflevere flere oplysninger og desuden se,
hvordan en funktion kan udføre sit arbejde på en så robust og
fornuftig måde, at vi ikke behøver at spekulere på, om programmet
bliver ustabilt, hvis brugeren foretager sig noget tåbeligt.
</para>

<para>
Vi vil foreløbig nøjes med at bruge de indbyggede datatyper, men
det er på ingen måde en begrænsning for C programmøren, at
sproget "kun har" int, double, char etc, for vi kan jo opbygge
andre datatyper ved hjælp af brugerdefinerede datatyper,
struct, og vi kan manipulere de enkelte bits ved hjælp af bitvise
operatorer.
</para>

<para>
På den måde kan man bygge udmærkede repræsentationer af de
datatyper, som findes i andre sprog, men som savnes i C.  For
eksempel kan man opbygge en tegnbaseret repræsentation af tal,
ligesom det findes i Lisp. Ved hjælp af denne repræsentation
kan man opnå mange hundrede (tusinder) decimalers præcision i
beregninger.
</para>

<sect2 id="sect-beregning">
<title>Datatyper og beregninger</title>

<para>
Den grundlæggende datatype i C sproget er int, en forkortelse for
integer, heltal. Størrelsen af denne datatype er ikke altid den
samme, på en 8 bit computer er det 16 bit (hmm, fik du den?) og på
en 64 bit computer er det 64 bit. Hvis man vil foretage
64-bit beregninger på en 8-bit computer, så kan det godt lade sig
gøre, det vil blot være væsentligt langsommere end hvis man
nøjes med at benytte maskinens "medfødte" datatype. Det kan
implementeres som en oversætterfunktionalitet, eller det kan være, at
det er implementeret som maskin-instruktioner, der benytter flere
registre. Intel 386-arkitekturen benytter to registre til 64-bit
aritmetik, men har dog ikke ægte 64-bit division. Det må man så
lave på en anden måde.
</para>

<para>
Lad os prøve at foretage nogle beregninger med heltal. Det må
gerne være nogle simple beregninger, sådan at vi nemt kan
kontrollere, om programmet regner rigtigt. Sidenhen kan vi ændre
det til noget mere imponerende.
</para>

<sect3 id="sect-procent1">
<title>En procentberegning</title>

<example id="ex-hello-beregning"><title>HELLO - beregning.</title>
<programlisting role="C">
<literal>
/* procent.c beregner en procentdel af et givet tal. */

#include &lt;stdio.h>

int main()
{
    int procent = 17;
    int kroner = 100;
    int resultat;

    resultat = kroner * procent / 100;

    printf("resultat er: %d\n", resultat);

    return 0;
}

/* end of file procent.c */
</literal>
</programlisting></example>

<para>
Det er en stor fordel, at resultatet er nemt at kontrollere,
brug simple tal indtil programmet er stabilt.
</para>

<para>
Vi har indført nogle variable - kroner, procent, resultat.
Det er simpelt hen kasser med tal i. Der er straks fyldt værdier
i kasserne.
</para>

<para>
Navnene er valgt sådan, at man kan regne ud, hvad meningen er med
variabelen.
</para>

<programlisting> 
int kroner = 100;
</programlisting>

<para>
betyder, at vi reserverer en plads til en heltalsvariabel og
straks fylder tallet 100 i.
</para>

<para>
Selve beregningen kan skrives i programmet næsten på samme måde,
som man ville skrive formelen på et stykke papir. Hvis man er
vant til, at (x y) betyder x gange y, så skal man selvfølgelig
passe på at man ikke glemmer multiplikations operatoren '*'.
</para>

<programlisting>
resultat = kroner * procent / 100;
</programlisting>

<para>
<literal> resultat </literal> er navnet på den "kasse", hvor
resultatet skal gemmes, og den kaldes en "left value",
venstre-værdi, fordi den kan stå på venstre side af et
lighedstegn eller assignment (tildelings) operator. Venstre side
af assignment operatoren skal være et udtryk, der kan evalueres
som en adresse, ellers kan man jo ikke komme til at gemme
resultatet af vejen.  Hvad der måtte ligge af interessante
værdier i sådan en "kasse", forsvinder efter et assignment.
</para>

<para>
<literal>printf()</literal> får at vide, at den skal skrive
variablen "resultat" ud ved hjælp af procent-tegnet efterfulgt af
'd'. Nu får <literal>printf()</literal> ikke én, men
<emphasis>to</emphasis> oplysninger, nemlig format string'en
mellem double quotes, (gåseøjne) og talvariabelen
<emphasis>resultat</emphasis>.
</para>

<programlisting>
"resultat er: %d\n"   &lt;== string-var
"resultat er: %d\n", resultat &lt;== string-var, tal-var
</programlisting>

<para>
Den anden linje kaldes en liste eller en <emphasis>
parameter liste </emphasis>; de to medlemmer er adskilt af et
komma, komma er liste-operator.<footnote><para> Parametre er
oplysninger til en funktion. </para></footnote> 
</para>

<para>
Det er nok lidt for besværligt at rette i programmet her,
hver gang jeg vil udføre en procent beregning! Så i stedet laver
vi i næste afsnit et program, som prompter for (beder om input
af) det tal, der skal beregnes procent af.  Dermed forlader vi
"Hello-world" sfæren og bevæger os ind i fejlmulighedernes
paradis, interaktive programmer.
</para>
</sect3>
</sect2>

<sect2 id="prompt-og-input">
<title>Prompt og input</title>
<para>
Input fortjener et kapitel for sig. Men lad os alligevel her
skrive et program, som læser inddata fra tastaturet, og som godt
nok forventer, at der bliver tastet tal (cifre) ind, men på den
anden side ikke tager skade af, at brugeren indtaster noget helt
andet - eventuelt skubber en bog henover tastaturet, så der kommer
input i store mængder.
</para>

<sect3 id="input-og-beregning">
<title>Input af tal og beregning</title>

<example id="ex-io-ber"><title>Input og beregning.</title>
<programlisting role="C">
<literal>
/* procent2.c prompt for tal og beregn procentdel. */

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
    int procent = 17;
    int kroner;
    int resultat;
    char inputlinje[800];

    printf("BEREGNING AF %d %%\n",procent);
    while (printf("Input tal:"), fgets(inputlinje,800,stdin)!=NULL) {
      kroner = atoi(inputlinje);
      resultat = kroner * procent / 100;
      printf("resultat er: %d\n", resultat);
    }
    return 0;
}

/* end of file procent2.c */
</literal>
</programlisting></example>

<para>
I nogle C-bibliotek implementationer skal man flushe
printf-output hvis der ikke er en "newline" til sidst:
</para>

<programlisting role="C">
... printf("Input tal:"), fflush(stdout),
</programlisting>

<para>
Denne måde at kæde expressions sammen med
et komma er bestemt ikke den mest pædagogiske. Det er faktisk
grimt! Men når jeg nu har gjort det alligevel, så er det for at
understrege, at C sprogets liste-operator (komma'et) er
anvendelig i mange sammenhæng. Men lad nu være med at skrive for
meget komatøs kode!  
</para>

<para>
Det er værdien af det sidste expression, som er afgørende
for, om expression-listen evaluerer til sand eller falsk.  
</para>

<para>
Input læses af fgets(3). Den skal have 3 oplysninger,
adressen på den buffer, som den må lægge characters i, længden på
bufferen (den læser maximalt længde - 1 og afslutter string med
en null-byte) og den fil, som den skal læse input fra. Her
anvendes "kodeordet" stdin, som er defineret i &lt;stdio.h>.
</para>

<para>
fgets(3) returnerer NULL hvis der ikke er mere input. Dette
kan ske hvis brugeren taster "symbolsk end-of-file", der som
regel sættes til ^D med stty kommandoen. Men hvis input er
omdirigeret, så sker det jo som forventet, når man rammer
slutningen på filen.
</para>

<para>
Der er includeret en fil mere, stdlib.h, som indeholder
prototype til atoi - Ascii TO Integer conversion.<footnote>
<para> Sørg for, at du virkelig ved, hvad ascii er for noget!
</para> </footnote>
</para>

<programlisting>
#define __P(args)  args

extern int atoi __P ((__const char *__nptr));
/* __P(args) er en kommando til præprocessoren, det kaldes
 * en macro, og den har til formål at gøre
 * bibliotek funktionerne brugbare sammen med mange
 * forskellige C-oversættere. Nogle varianter af C-oversættere kan
 * ikke forstå komplicerede prototypeerklæringer.
 */
/* derfor svarer denne prototype til:
extern int atoi(const char* string_som_skal_converteres);
 */
</programlisting>

<para>
Det smukke i procent2.c er, at man ikke kan få programmet
til at gå ned ved ondskabsful indtastning, når der promptes for
et tal. Man kan godt få det til at regne forkert, hvis man
indtaster et tal, som er større end 126 mio.  Men dels er fgets()
en robust funktion, som ikke laver buffer overflow, selv om
brugeren indtaster 2 Gb data, og <literal> atoi(char*) </literal>
er en robust konverteringsrutine, som ikke brokker sig, hvis
input ikke er cifre.  Hvis man indtaster bogstaver, ignoreres de,
og der returneres 0.
</para>

<para>
88kr. vil blive konverteret til heltallet 88, hvilket svarer
til, hvad man forventer. Senere vil vi lave en
indtastningsrutine, som giver brugeren en warning, hvis han ikke
indtaster tal. <!-- TODO -->
</para>

<para>
Det er programmørens ansvar at sørge for den rigtige
længdeangivelse til fgets' anden parameter. Det er lettere at
holde styr på den slags, hvis man benytter preprocessor macro'er
til at definere symboler for konstant-talværdier.
</para>

<programlisting role="C">
#define MAXLINJE 800
char inputlinje[MAXLINJE];

main()
{
    fgets(inputlinje, MAXLINJE, stdin);
    return 0;
}
</programlisting>

<para>
Ikke semikolon i #define linjen, det er <emphasis> ikke
</emphasis> et statement.
</para>

<para>
Øvelser for de lidt mere erfarne: Prøv at ændre programmet,
så der anvendes double precision floating point variable. Prøv
også at tilføje en kontrolberegning, som finder ud af, om der har
været overflow. Hvis der er overflow, så skriv en fejlmeddelelse
til brugeren i stedet for at skrive resultatet, men stop ikke
programmet.
</para>

<para>
Prøv også at skriv en version, hvor man kan indtaste
procentsatsen først, eller et, som udskriver værdien af kroner i
både australske, canadiske og US dollar.
</para>

<para>
Lav et program, som udskriver flere valutaer pr. linje i en
tabel, f.eks.  svarende til kr. 100, 200, 300, 400, 500 ... ) 
</para>
</sect3>
</sect2>
</sect1>

<sect1 id="s1-modular-beregning">
<title>ANSI prototyper og modularisering</title>

<para>
Opdelingen i funktioner er grundlaget for strukturering af
opgaverne, som man måtte være ved at løse. 
</para>
<para>
Funktioner er den teknik, som gør det muligt at genbruge kode,
sådan at man ikke behøver at begynde fra bunden hver gang, men
kan bygge videre på andres arbejde.
</para>
<para>
Der er ikke noget problem, der er så stort, at det ikke kan deles
op i mindre :-)
</para>

<sect2 id="s2-modularisering">
<title>Kursomregning</title>
<para>
For at illustrere, hvordan man trækker en beregning ud af et
program, kunne vi bruge en beregning så simpel som x = a + b.
</para>

<para>
Skal eksemplet være en lille smule realistisk foreslår jeg
imidlertid, at vi i stedet laver en kursomregningsfunktion. Man
kan forestille sig, at der er skal så mange beregninger til (f.eks.
en tabel i en udskrift eller priser på en faktura) at det er en
stor lettelse at få udført beregningen i en funktion.
</para>

<para>
Det er forhåbentlig indlysende, at en "euro-funktion" 
ville kunne indgå i bankers udbetalingsautomater, i
faktureringsprogrammer etc.etc.
</para>

<para>
Lad os derfor benytte kursomregning til at forske i den
teknik, som kaldes modularisering. Det endelige mål er en
omregningsfunktion i et bibliotek af forskellige financielle
funktioner. Man må forestille sig valutaveksling med og
uden gebyr og afrunding etc. Dette er så den rå omregning
til brug for rapporter eller lignende. Det er simpelt hen en
funktion, som får vores kroner og "afleverer" dollar (eller
Euro<!--&eur;-->).  Udgangspunktet er en tilretning af <xref
linkend="ex-io-ber"/>, så vi kan afprøve funktionen mens vi
skriver på den. For at gøre det mere overskueligt, har jeg
imidlertid valgt at sløjfe prompt-input delen; den kan man
evt. selv tilføje efter mønsteret i <xref linkend="ex-io-ber"/>.
</para>

<para>
Jeg må indrømme, at jeg efter at have skrevet dette her afsnit syntes,
at det var lidt rigeligt langt! Grunden til, at jeg lader det stå
er, at jeg har set så mange programmører, der havde svært ved at forstå
mekanikken i funktionskald. Først når man forstår hvad der sker i
computeren under et funktionskald kan man udnytte C sprogets
fulde styrke. 
</para>

<sect3 id="spaghetti">
<title>Beregning som del af main-koden</title>

<example id="ex-dollar-omregning">
<title>Dollar omregning, spaghetti 
<footnote><para>
Spaghetti er en derogativ betegnelse for en lang, uoverskuelig
liste med programmeringsinstruktioner. 
(Eller er det noget andet?  ;-)
</para>
</footnote> version.
</title>

<programlisting role="C">
/* dollar0.c Input Kroner, beregn Dollar. UDGANGSPUNKT. */

#include &lt;stdio.h>

int main()
{
    int kurs = 865;
    int kroner = 100;
    int resultat;

    resultat = kroner * 100 / kurs;
    printf("Kroner %d giver Dollar %d\n", kroner, resultat);
    return 0;
}
/* end of file dollar0.c */
</programlisting>
</example>

<para>
Først trækker vi beregningen ud af programmet og lægger den
i en funktion, som vi kalder kr2dollar.
</para>

</sect3>
<sect3 id="ANSI-prototyper">
<title>En ANSI prototype</title>

<example id="ex-dollar-funktion">
<title>Dollar omregning med beregning i funktion.</title>
<programlisting role="C">
/* dollar1.c Input kroner, kald int kr2dollar(int) */

#include &lt;stdio.h>

/* vi erklærer nu en prototype for vores funktion. En prototype kan
 * kendes på, at der efter funktionsparentesen er et semikolon - ikke
 * nogen braces, som ville signalere starten af en kodeblok.
 */

int kr2dollar(int);
int kurs = 865;

int main()
{
    int kroner = 100;
    int resultat;

    resultat = kr2dollar(kroner);
    printf("Kroner %d giver Dollar %d\n", kroner, resultat);
    return 0;
}

int kr2dollar(int kr)
{
    return kr * 100 / kurs;
}

/* end of file dollar1.c */
</programlisting>
</example>

<para>
Bemærk, at main står øverst i programmet. C inviterer til top -
down programmering. Vi kan kalde kr2dollar uden at have nogen
som helst idé om, hvordan vi vil implementere den. Selvfølgelig
er programmet ikke færdigt, før end vi har skrevet den sidste
kode, men i nødsfald kan man somme tider klare sig med en
forsimplet udgave - eller en stub, en tom funktion - der, hvor
man ikke har skrevet al koden.
</para>

<para>
Men funktionen kr2dollar er <emphasis> erklæret </emphasis>
inden den anvendes, det er linjen lige neden under #include
direktivet.  Erklæringen er en slags forklaring til oversætteren
af, hvad det er for en funktion. Den bevirker, at
oversætteren opretter en entry i en symboltabel, så den kan slå
op, hvad "kr2dollar" er for noget, næste gang den forekommer i
kildeteksten. 
</para>

<para>
Derfor ved oversætteren, hvad type der kommer ud af
funktionen. Det kunne være, at det var en flydendetals dims i
stedet for et heltal. (Ja forresten, det synes du nok, at det
burde være!  Det ville være rart med flydende tal for at få
decimaler på, se <xref linkend="ex-dollar-double"/>. Men strengt
taget kunne vi få en mere præcis beregning ved at anvende
64-bits integers til at repræsentere 100-dele øre. For den
avancerede: Prøv det! Og husk at indsætte et komma på det
rigtige sted, når du skriver det ud.)
</para>

<para>
<literal> kr2dollar() </literal> består af KUN et return
statement. Godt nok skal der regnes lidt, før end return værdien
er klar, det er jo selve ideen i funktionen.
</para>

<para>
I almindelig stenalder C kunne man nøjes med at kalde
funktionen uden at forklare oversætteren, at det var en funktion,
der returnerede en integer. Det kaldes "implicit integer"
regelen. <footnote><para>Det hænger sammen med, at der 
alle funktioner i de aller første C-oversættere returnerede
en integer. Funktioner, som returnerer doubles er stadig i
mindretal.</para></footnote>
</para>
</sect3>

<sect3 id="c-modulaer-beregning">
<title>Modulariseret udgave af beregningen</title>

<para>
Nu skiller vi beregnings funktionen ud, så den ligger i en
fil for sig selv - den er på vej til at blive en del af vores
"financial library" (;-).
</para>

<para>
Desuden lader vi variabelen "resultat" udgå, for vi kan jo
bare anbringe funktionskaldet der, hvor resultatet skal skrives.
</para>

<example id="ex-dollar-int-main">
<title>Dollar omregning, modul version.</title>
<programlisting role="C">
/* dollar2.c ask for Kroner and call int kr2dollar(int) */

#include &lt;stdio.h>
#include &lt;stdlib.h>

int kr2dollar(int);

int main()
{
    int kroner = 100;

    printf("Kroner %d giver Dollar %d\n", kroner, kr2dollar(kroner));
    return 0;
}
/* end of file dollar2.c */
</programlisting></example>

<para>
Som det kan ses, har vi klippet de nederste 4 linjer ud,
hvor funktionen kr2dollar var defineret. Den står nu i en fil,
som vi kalder kr2dollar.c:
</para>

<example id="ex-dollar-funktion-int">
<title>kr2dollar modul.</title>
<programlisting role="C">
/* kr2dollar.c - beregn dollar ud fra kroner */

int kr2dollar(int kr)
{
    int kurs = 865;
    return kr * 100 / kurs;
}
/* end of file kr2dollar.c */
</programlisting></example>

<para>
Kursen er ikke mere tilgængelig i main, vi har
isoleret den, så den kun kan ses i funktionen, som omregner. Det
er en primitiv udgave af et udmærket princip. 
</para>

<para>
Det ville være fint, hvis vi skrev en funktion, som hentede
kursen fra en pålidelig kilde, f.eks. en eller anden nationalbank
på internettet.  Når vi så skulle bruge kursen, kunne vi kalde
denne funktion. 
</para>

<para>
De to filer kan oversættes på flere forskellige måder:
</para>

<para>
Enten:
</para>

<programlisting>
gcc -Wall dollar2.c kr2dollar.c -o omregning
</programlisting>

<para>
Eller:
</para>

<programlisting>
gcc -Wall -c dollar2.c
gcc -Wall -c kr2dollar.c
gcc dollar1.o kr2dollar.o -o omregning
</programlisting>

<para>
Eller:
</para>

<programlisting>
gcc -Wall -c kr2dollar.c
ar -rv libfinans.a kr2dollar.o
gcc -Wall -c dollar2.c
gcc -Wall dollar1.o -L./ -lfinans
</programlisting>

<para>
Læg lige mærke til, at vi har genereret en bibliotek file med
en meget simpel kommando, ar -rv libfinans.a &lt;objectfile> ...
</para>

<para>
Hvis vi skulle glemme prototypen for denne simple beregning,
så vil der ikke opstå fejl i dette eksempel. Det skyldes, 
at vi stadig har regelen
om implicit integer, når vi skriver standard C programmer.
<footnote><para> Reglen kan være meget praktisk for den erfarne
programmør, som i visse situationer kan gøre et program lidt mere
læseligt, fordi der er mindre "støj". <!-- COMMENT: Men der er en
sjov historie om dette religiøse spørgsmål! Bjarne Stroustrup
overvejede, hvordan man dog skulle kunne klare problemerne med
implicit integers og ingen parametre, som før var det samme som,
at alt var tilladt! En dag siger Ritchie til ham, at det skal han
da ikke spekulere på, man kan da godt indføre et krav om, at
parametre skal specificeres. - eller lignende emne, hvor Ritchie
gav ham støtte til at gå videre med sagen. --> </para>
</footnote>
</para>

<para>
Med GNU C-oversætteren vil man dog få en advarsel: "implicit declaration
of function `kr2dollar'". Det betyder simpelthen, at oversætteren har
opdaget, at vi kalder kr2dollar, men ikke kan finde den i typetabellen.
Oversætteren antager at funktionen returnerer en integer. Man får kun
denne warning, hvis man anvender -Wall (Warning level, give us ALL
warnings).
</para>
</sect3>


<sect3 id="modul-return-double">
<title>Modul med return type double</title>

<para>
Lad os nu prøve at definere kr2dollar() som en funktion, der
returnerer en double. Prøv nogle eksperimenter med programmet.
Der er vist nogle forslag.
</para>

<example id="ex-dollar-double"><title>Dollar omregning, double version.</title>
<programlisting role="C">
/* dollar3.c bed om Kroner og call double kr2dollar(double) */

#include &lt;stdio.h>
#include &lt;stdlib.h>

double kr2dollar(double);  /* prøv at udelade denne her! */


int main()
{
    double kroner = 100;

    printf("Kroner %10.2f giver Dollar %10.2f\n", kroner, kr2dollar(kroner));
    return 0;
}
/* end of file dollar3.c */
</programlisting></example>

<para>
I ovenstående eksempel er det nødvendigt, at der erklæres en
prototype for kr2dollar. Hvis prototypen udelades, vil gcc, ligesom i
forrige eksempel, stadig <emphasis>kun</emphasis> give en warning,
og endda kun under forudsætning af, at -Wall anvendes! 
</para>

<screen id="wrong-type-coersion">
<prompt>$$</prompt>\
<userinput>gcc -Wall -c dollar3x.c # version uden prototype for kr2dollar():
</userinput>
dollar3x.c: In function `main':
dollar3x.c:16: warning: implicit declaration of function `kr2dollar'
dollar3x.c:16: warning: double format, different type arg (arg 3)
</screen>

<para>
Og her kommer så den anden fil med funktionen, som foretager
omregning med double precision floating point parameteren kr.
</para>

<example id="ex-dollar-modul-double">
<title>kr2dollar, return type double, module.</title>
<programlisting role="C">
/* kr2dollar.c - beregn dollar ud fra kroner, double */


double kr2dollar(double kr)
{
    return kr / 8.65; 
}
/* end of file kr2dollar.c */
</programlisting></example>


<para>
Oversættelse uden prototype vil som sagt alligevel resultere i en
objektfil, som kan linkes med vores nye finans-bibliotek uden at
man får en fejlmeddelelse. Men når man kører programmet, kan man
se, at det ikke regner rigtigt, uha uha.
</para>

<para>
Når man oversætter et sådant program, vil oversætteren opfatte
retur værdien fra en ikke erklæret funktion som en integer. Denne
vil typisk være placeret i det primære register. På Intel x86
register EAX eller EBX. Oversætteren kan ikke kontrollere, om den
kaldte funktion placerer sin retur værdi dér. Det er jo et helt
andet modul, og måske endda et modul, som ikke er skrevet endnu.
</para>

<para>
Oversætteren "ser", at den retur værdien fra den funktion, som
antages at være en integer, skal afleveres (her som argument til
printf). Hvis returværdien er en integer, ligger den i EAX
registeret. Derfor skriver compileren en instruktion, som skubber
værdien af EAX op på applikations-stakken.  Printf er, også i
denne sammenhæng, lidt speciel, fordi den ikke aner, hvilke
argumenter den får, før end den har læst format-specifikationen.
Hvis vi skulle personificere printf, så ville den sige: "Jeg skal
skrive et double precision floating point tal ud, ergo må der
ligge sådan et på stakken. Det tager jeg!" Og det gør den så, den
tager 8 bytes fra stakken uden at <emphasis> kunne </emphasis>
kontrollere, om de rent faktisk repræsenterer en double eller en
integer.
</para>

<para>
Det, som jeg prøver på at demonstrere, er konsekvensen af, at 
ANSI-C specifikationen ikke omfatter et krav om typekontrol under
link-processen.  Derfor er det nyttigt at tage notits af alle
warnings.
</para>

<para>
Det er specielt vanskeligt med <literal> printf(3) </literal>,
fordi det er tilladt at aflevere så mange parametre efter
format-specifikationen, som man har lyst til, af de typer,
som man har brug for. Det er vildt anarki, siger nogen,
men det er uhyre praktisk. Med printf kan man formatere
komplicerede rapporter med ét printf-statement, hvor det i
C++ kan ende med mange linjers kompliceret kode, som skal styre
forskellige skjulte interne variable i <literal> cout </literal>
funktionens talkonvertering.
</para>
</sect3>

<sect3 id="c-header-filer">
<title>Header filer</title>
<para>
For at automatisere processen med prototyper er det skik og brug at man
laver en header fil til hvert projekt, som man har i gang. I vores
minimal eksempel her:
</para>
<example><title>Header fil for kr2dollar</title>

<programlisting>
/* File: dollar3.h, prototypes for finans-program ... */

double kr2dollar(double kroner);
</programlisting>
</example>

<para>
Denne fil kan includeres i både der, hvor funktionen skal
anvendes, og der, hvor den defineres (programmeres). Det giver
jo kontrol med tingene.
</para>

<para>
Man får filen med ved at skrive: <literal> 
#include "dollar3.h"
</literal>
Bemærk, at der er anvendt double quotes om filnavnet fordi denne fil
ligger i current directory.
</para>

<para>
NB! Der er en lignende regel, som tillader, at en (global)
integer kan
defineres 2 gange. Det er straks mere farligt - for tænk nu hvis
det ikke var meningen  -  og det kan ikke tillades i C++.
</para>

</sect3>
</sect2>
</sect1>



<sect1 id="filter-programmer">
<title>Filter programmer</title>
<para>
Filter programmer er nogen, som læser input og producerer noget
output, som for samme input altid vil være det samme.
Filter programmer er som skabt til batchkørsel, d.v.s. som jobs,
der er automatiserede.
</para>

<para>
Her kommer det grundlæggende program:
</para>

<example id="simpelt-filter">
<title>Simpelt filter, input til output.</title>
<programlisting role="C">
/* filter0.c */

#include &lt;stdio.h>

int main()
{
    int c;
    while ( (c=getchar()) != EOF)
      putchar(c);
    return 0;
}
</programlisting>
</example>

<para>
Dette program er så dejligt at eksperimentere med. Når vi har
læst vores char med getchar, så kan vi gøre med den hvad vi vil,
f.eks. konvertere den fra DOS-tegnsæt til ISO-8859-1 tegnsæt. (Se
nedenfor.) Men i første omgang, som her, skriver vi blot vores
char ud nøjagtig som vi fik den ind. Hvis nu vi bruger en
kommandolinje som nedenfor, kan vi kontrollere, at programmet
faktisk kopierer nøjagtigt, d.v.s. at library funktionerne bag
vores getchar() og putchar() er ok.
</para>

<programlisting>
MITPROMPT$ filter0 < /usr/dict/words > words.cpy
MITPROMPT$ cmp /usr/dict/words words.cpy
MITPROMPT$ echo $?
           0
MITPROMPT$ 
# $? er statuskode eller exitcode, som indikerer om
# der er fejl eller ej. 0 betyder ingen fejl, ingen forskelle.
</programlisting>

<para>
Man kunne tro, at det er uhyre ineffektivt at læse en stor fil
et bogstav af gangen, men det er det ikke, hvis vores run-time
library ellers er blot nogenlunde godt skrevet. For det første
skal det nævnes at getchar og putchar er <emphasis> macroer </emphasis>,
derved spares et funktionskald.
</para>

<para>
For det andet kan man med omdirigering på kommandolinjen bruge
sådanne simple programmer til at behandle filer. Det er altså
ikke nødvendigt at sidde og taste data ind til sine eksempler.
</para>

<para>
For at forstå den klassiske konstruktion ((c=getchar()) != EOF)
er det en god idé at erstatte (c=getchar()) med c, variabelen,
som indeholder det læste bogstav. Så står der:
</para>

<programlisting>
    while (c != EOF) {
       ...
</programlisting>

<para>
Et assignment (en tilskrivning, på lokalsproget) har en værdi,
nemlig værdien af den sidst foretagne tildeling. Her er der kun
en tildeling i udtrykket, så det er meget nemt. Værdien af
(c=getchar()) er c.
</para>

<para>
Læg også mærke til, at det er en int vi bruger til at gemme
vores indlæste bogstav. Integer er en datatype, som er
større end char. Derfor kan den rumme en værdi, som garanteret
ikke er et lovligt bogstav, og det er den, som systembiblioteket
indsætter, når der ikke er mere input. Det er som regel -1, og
EOF skal være defineret i stdin.
</para>

<sect2 id="tegn-og-tal">
<title>Tegn og talværdier</title>
<indexterm><primary>filter</primary></indexterm>
<para>
Lad os først bruge programmet til at skrive bogstavernes talværdi
ud i både almindelige titals - notation, i hexadecimal notation,
og, hvis bogstavet er udskrivbart, som glyf, eller
tegn-repræsentation.
</para>

<example id="hex-filter">
<title>Filter, som skriver ascii ordinal value.</title>
<programlisting role="C">
/* char2tal.c */

#include &lt;stdio.h>

int main()
{
    int c;
    while ( (c=getchar()) != EOF) {
      printf("Decimal-værdi %3d, hexadecimal værdi 0x%2x ", c, c);
      if (c > 31 && c &lt; 127)
          printf("%c\n", c);
      else
          printf(".\n");
    }
    return 0;
}
</programlisting>
</example>

<para>
Dette program producerer noget output, som indeholde alle de
samme informationer som den oprindelige fil. Den indeholder endda
flere informationer, skønt ikke så mange som den kunne.
</para>

<para>
Vi har med dette program <emphasis> mappet </emphasis> input til
output på en måde, så vi ikke har tabt data. Vi kan skrive et
program, som ud fra outputfilen rekonstruerer den oprindelige
fil.
</para>

<para>
Der er også en anden sjov ting ved programmet: Hvis vi skulle
sende data over et ustabilt transmissionsmedium, så ville det
være nemt at finde de linjer, hvor data var gået tabt. I mange
tilfælde ville man ved mindre fejl endda kunne regne det rigtige
input ud. Denne form for overskud af bits til at repræsentere
data kalde redundans. "Redundancy" oversættes i ordbogen til
overflødighed, men vi kunne også oversætte det til "rigelighed",
"med ekstrareservebits som forsikring ..." (Bedre forslag
modtages med glæde!)
</para>

<para>
Som en biting til C++ interesserede kan det tilføjes, at man i
C++ nok også ville slippe nemmere afsted i dette tilfælde ved at
bruge printf. C++ cout() er ikke så nem at bruge til formatering
af kolonner og lignende.
</para>

<para>
Lad os dernæst bruge programmet til at tælle characters.
</para>

<example id="ex-char-count">
<title>Simpelt filter som character counter.</title>
<programlisting role="C">
/* filter1.c simpelt filter tæller chars istf at ouputte. */

#include &lt;stdio.h>

int nc;

int main()
{
    int c;
    while ( (c=getchar()) != EOF)
      ++nc;
    }
    printf("%d\n", nc);
    return 0;
}
</programlisting>
</example>


<para>
Hvorfor initialiseres nc ikke? Jo, for det er en global variabel,
og den er garanteret zeroed out. Al global hukommelse, som ikke er
explicit initialiseret, er garanteret en nulstilling. Man kan
selv gøre det, i øvrigt, hvis man har en snavset buffer:
memset(buf,0,lengde);
</para>

<para>
Et eksempel på en kørsel af programmet:
</para>

<programlisting>
MITPROMPT $ time charcount &lt; /usr/dict/words
409048
    0.32s real     0.27s user     0.04s system
</programlisting>

<para>
På min gamle maskine, 3/10 sekunder til at læse 400KB! Det er
pænt (i forhold til maskinens formåen). Den "officielle"
wordcount, wc &lt; /usr/dict/words er dog 10 gange hurtigere!
</para>

<para>
Husk at denne charcount ikke tæller bytes, men bogstaver. På en
linux maskine er dette normalt det samme. På et MicroSoft system
vil længden af filen ikke svare til antal characters talt på
<emphasis> denne </emphasis> metode, fordi MicroSoft
operativsystemer (og andre) benytter carriage-return line-feed
sekvenser til linjeskift.  Når man kører "normal C" - eller
simpel, POSIX-C - på en platform som MS-OS'erne, så filtreres
alle cr - tegn fra.
</para>

<para>
For at se alle ascii koder kan du benytte man kommandoen:
</para>
<programlisting>
PROMPT $ man ascii
[...]
PROMPT $ man groff-char
</programlisting>

</sect2>

<sect2 id="c-typisk-filter">
<title>Et typisk filter</title>

<para>
Et filterprogram, som svarer til den normale anvendelse af ordet
filter, er et program som kan konverterer CodePage 865
til ISO-8859-1. Det kan gøres på forskellige måder, men eksemplet
egner sig godt til at demonstrere, hvordan man "mapper" en
datamængde over i en anden.
</para>

<para>
Lad os for simplicitetens skyld gå ud fra, at hvert bogstav er en
byte. (Desværre er jeg ikke klar over, om iso8859-1 altid er en
byte, men det går vi altså ud fra, at de er.) Vi skal med andre
ord kunne konvertere en byte til en anden byte. Antallet af
mulige værdier i begge lejre er kun 256.
</para>

<para>
Den hurtigste teknik til en sådan opgave er derfor tabelopslag,
som kan svare på, hvilken ny værdi vores byte skal have ved at
bruge vores input som index i et array med 256 værdier.
</para>

<para>
For at prøve teknikken lader vi først en loop initialisere
arrayet først, således at der ingen konvertering ville finde
sted. Derefter prøver vi, om vores program kopierer input til
output <emphasis>uden</emphasis> ændringer.
</para>

<example id="ex-msdos2iso8859-1-forstadium">
<title>Codepage 865 til iso8859-1, forstadium.</title>
<programlisting>
/* ibm2iso0v1.c, forstadium til konverteringsprogram 
 * Codepage 865 -> iso8859.1
 */

#include &lt;stdio.h>

static char conv[256];

int main(int argc, char *argv[])
{
    int c;
    int jj;

    for (jj = 0; jj &lt; 256 ; ++jj)
        conv[jj] = jj;

    while ( (c=getchar()) != EOF) 
        putchar(conv[c]);

    return 0;
}

</programlisting>
</example>

<para>
Somme tider klager folk over, at C programmet ikke har boundary
tjek for arrays. Det er der selvfølgelig den gode grund til, at
det ville være spild af tid i et godt program. Hvorfor vil
ovenstående program ALDRIG gå ud over grænserne fra 0 til 256?
</para>

<para>
Hvordan tester man nu sådan et program? Her er Unix suverænt, man
omdirigerer input fra en fil og samler test output op i en anden
fil. På den måde opnår man, at selve test-proceduren kan
automatiseres (evt. sættes ind som et target i en makefile.)
</para>

<para>
<programlisting>
<prompt>fri2c: </prompt> gcc -Wall ibm2iso0v1.c -o ibm2iso0v1
<prompt>fri2c: </prompt> ibm2iso0v1 &lt textfile > textfile.kpi
<prompt>fri2c: </prompt> cmp textfile textfile.kpi
</programlisting>
</para>

<para>
Den næste terrasse, som vi vil nå op på, skal konvertere et
enkelt tegn og lade resten være. Vi benytter derfor stadig
loopen, men tilføjer nu en linje, som ændrer en enkelt af
tabelværdierne, og ser, om vi får det ønskede resultat, hvis vi
sender input af den pågældende værdi. (Det gør vi selvfølgelig).
</para>

<example id="ex-msdos2iso8859-1-Terrasse2">
<title>Terrasse 2</title>
<programlisting>

/* ibm2iso0v2 - forstadium 2, konvertering af en enkelt værdi. */

#include &lt;stdio.h>

static char conv[256];

int main(int argc, char *argv[])
{
    int c;
    int jj;

    for (jj = 0; jj &lt; 256 ; ++jj)
        conv[jj] = jj;

    conv['A'] = 'a';                  /* Ja, man må gerne! */

    while ( (c=getchar()) != EOF) 
        putchar(conv[c]);

    return 0;
}

</programlisting>
</example>

<para>
Når man kører ovenstående program (fra kommandolinje, med inddata
fra tastaturet) skal man få lille a hvis man taster store a.
Ellers skal alt output være det samme som input.
</para>

<para>
Den version af programmet, som vi slutter med her, behøver ikke
at være den endelige version. De mange sjove grafiske tegn, som
findes i codepage850 og 865 kan man jo forestille sig efterlignet
på mange måder, afhængig af, om man skal ud på en printer eller
en ascii skærm eller en grafisk tegneflade (stort arbejde!). Vi
nøjes med en version, som konverterer de danske tegn i
IBM-tegnsættet codepage 850 til ækvivalenterne i iso8859-1.
</para>

<example id="ex-msdos2iso8859-1-Terrasse3">
<title>Terrasse 3</title>
<programlisting>

/* ibm2iso.c - terrase 3, konvertering af danske tegn. */

#include &lt;stdio.h>

static char conv[256];

int main(int argc, char *argv[])
{
    int c;
    int jj;

    for (jj = 0; jj &lt; 256 ; ++jj)
        conv[jj] = jj;

    conv[134] = 'å';              /* 134 er codepage850 for å */
    conv[143] = 'Å';              /* 143 er codepage850 for Å */
    conv[145] = 'æ';
    conv[146] = 'Æ';
    conv[155] = 'ø';
    conv[157] = 'Ø';
    conv[130] = 'é';
    conv[144] = 'É';
                                  /* fortsæt listen efter behov */

    while ( (c=getchar()) != EOF)
        putchar(conv[c]);

    return 0;
}

</programlisting>
</example>
<para>
Den teknik, som er vist her ovenfor, er selvfølgelig lidt for
nem. Hvis man vil have en lynhurtig service ved hjælp af en
opslagstabel, skal tabellen selvfølgelig være initialiseret i
forvejen. Det må man med andre ord skrive i hånden:
</para>
<programlisting>
char ctab[256] = 0,1,2,3, /* nej ikke stop her! */
</programlisting>

<para>
Det er den teknik, som anvendes i library funktionerne
isprint(3), isdigit(3), toupper(3) osv. fordi det simpelthen er
den hurtigste måde. Hver konvertering koster kun en enkelt
indexerings-operation - især hvis funktionerne er erklæret som
inline funktioner (findes i gcc og er med i den nye standard
C99).
</para>

</sect2>

<sect2 id="sect-oversaetter-forstadium">
<title>Oversætter - teknik, forstadium</title>

<para>
Ud over de grundlæggende typer tekstfiltre, som vi har
set på her, ville det være nyttigt at se et par eksempler på
programmer, som kan filtrere mime-kodede postfiler.
</para>

<para>
Denne gang nytter det ikke at lave byte til byte mapning. Vi har
som input sekvenser, der begynder med et lighedstegn og
fortsætter med en hexadecimal talværdi for det ønskede output
tegn. Fx. vil i "blåbærgrød" i Mime-kodning blive skrevet således:
bl=e5b=e6rgr=F8d. Det er klart en forbedring at få det oversat
til noget, som ligner de danske tegn noget mere. Desuden kan man
bruge Mime-kodning til at angive et linjeskift, der ikke skal med
i den færdige tekst. Meget rart, hvis man har problemer med lange
linjer i for eksempel en mail transport agent. Det gøres ved at afslutte
linjen med et lighedstegn. <!-- TODO: Henvisning til mime-std.-->
</para>

<para>
Her kommer først en simpel version, som kun kan operere i en
kanal (på engelsk en pipe), d.v.s. den læser fra stdin og skriver 
til stdout. (Med programmer til kommando fortolkeren bash eller ksh,
kaldet shell scripts, kan man klare fil-opsætning for alle andre
situationer, så det er såmænd ikke så ringe endda!)
</para>

<example id="ex-mime2asc">
<title>mime afkodning, std.input</title>
<programlisting>

/* mime2asc.c - konvertering af mime - koder til ascii. */

#include &lt;stdio.h>

static char str[3];

int main(int argc, char *argv[])
{
    int c, c2;
    char *ptr;

    while ( (c=getchar()) != EOF) {
        if (c != '=')
            putchar(c);
        else {
            if ( (c2 = getchar()) == '\n')  /* aha! linjen ønskes ikke brudt */
                continue;                   /* print ikke ny-linje-tegn */
            else {
                if (feof(stdin)) exit(1);
                str[1] = getchar();
                if (feof(stdin)) exit(1);
                str[0] = c2;
                c = strtol(str, &amp;ptr, 16);
                putchar(c);
            }
        }
    }

    return 0;
}

</programlisting>
</example>

<para>
Programmet er uhyre simpelt i forhold til en produktionsversion,
men indeholder det nødvendige for at fremhæve pointen.
Håndteringen af End-Of-File er klodset, og fejl ved konvertering
af de to tegn efter lighedstegn håndteres slet ikke. EOF
håndteringen kunne håndteres ved at benytte en linjebuffer og
fgets(), og strtol(3) giver os et errno, som vi kunne tjekke på.
</para>

<para>
Vi benytter os af det faktum, at ethvert '=' skal forstås på en
speciel måde, det indleder en mime sekvens. Det kan man kalde for
et meta tegn, et tegn, som ikke blot er et tegn. Det er en
kommando, på samme måde som '\' er en speciel kommando i en C
string, '\n' betyder newline og ikke bogstavet n.
</para>

<para>
Hver gang vi støder ind i et tegn, undersøges, om det er et
lighedstegn, og hvis ikke går det ufiltreret til output.
</para>

<para>
Lighedstegnet smides væk og de to næste characters puttes i en
streng, der bliver opfattet som en hexadecimal værdi. Denne
konverteres ved kald til strtol(3) string to long. Denne fornemme
konverteringsrutine får en pointer til stringen med hexadecimal
tallet, adressen på en character pointer, som den så kan bruge
til at rapportere, hvor meget den kunne konvertere, og endelig et
tal, som er radix for konverteringen, d.v.s. at hvis vi vil
konvertere et almindeligt tal, skal vi aflevere et 10-tal her.
</para>

<para>
strtol(3) kunne godt undvære parameter 2, eller rettere, vi kunne
fortælle den, at der ikke er nogen pointer ved at aflevere en NULL
pointer. <literal>strtol(str,NULL,16);</literal>
</para>

<para>
strtol ville returnere et 0, hvis de efterfølgende bogstaver ikke
kan konverteres, og det ville selvfølgelig være en situation, vi
burde undersøge nøjere, ligesom errno, en static variabel i
library modulet, burde tjekkes. Prøv at gøre det, og giv
programmet input med fejl i og kontroller, at programmet
håndterer det på en fornuftig måde!
</para>

<para>
Lad os til sidst forbede programmet, så det selv kan finde ud af
at åbne filer, konvertere indholdet og skrive resultatet ud i en
fil med et andet navn.
</para>

<example id="ex-mime2ascii">
<title>Mime afkodning, fil input</title>
<programlisting role="C">
/* mime2ascii.c - fil konvertering af mime - koder til ascii. */

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;strings.h>

void konverter(FILE *infil, FILE *outfil);

int verbose;            // global flag

void error(char *message, int exitcode)
{
    fprintf(stderr,"%s\n",message);
    exit(exitcode);
}

#define MAXNAME 512

int main(int argc, char *argv[])
{
    FILE *fp, *nyfilp;
    char nyfilnavn[MAXNAME];
    char errormsg[MAXNAME+80];
    int j=0;

    while (++j &lt; argc) {
        if (argv[j][0] == '-')
            switch(argv[j][1]) {
                case 'v': verbose=1;
                          break;
                default: error("Option ikke forstået", 40);
            }
    }
    j=0;
    while (++j &lt; argc) {
        if (argv[j][0] == '-')
            continue;
        if (strlen(argv[j]) > MAXNAME - 2)
            error("Filnavn er for langt", 100);
        fp = fopen(argv[j],"r");
        if (!fp) {
            sprintf(errormsg, "Kan ikke åbne fil ved navn %s",argv[j]);
            error(errormsg,2);
        }
        strcpy(nyfilnavn,argv[j]);
        strcat(nyfilnavn,".X");
        nyfilp = fopen(nyfilnavn,"w");
        if (!nyfilp)
            error("Kan ikke åbne fil for skrivning",103);
        if (verbose)
            fprintf(stderr,"Har åbnet %s, starter konvertering\n", argv[j]);
        konverter(fp,nyfilp);
    }
    return 0;
}

void konverter(FILE *fil, FILE *outfil)
{
    int c, c2;
    char *ptr;
    static char str[3];

    while ( (c=getc(fil)) != EOF) {
        if (c != '=')
            putc(c,outfil);
        else {
            if ( (c2 = getc(fil)) == '\n')  /* aha! linjen ønskes ikke brudt */
                continue;                   /* print ikke ny-linje-tegn */
            else {
                if (feof(stdin)) exit(1);
                str[1] = getc(fil);
                if (feof(stdin)) exit(1);
                str[0] = c2;
                c = strtol(str, &amp;ptr, 16);
                putc(c,outfil);
            }
        }
    }
}

</programlisting>
</example>

<para>
En kommandolinje, som består af 3 ord, for eksempel mime2ascii fil1 fil2
vil blive opdelt i de tre ord, altså "mime2ascii" er det første,
"fil1" er det andet, "fil2" er det tredie ord.
</para>

<para>
argc er sat til 3 af den startup kode, som sætter vores program i
gang. argv[0] er derfor ordet "mime2ascii", det vil sige vores
eget programs navn. Da vores program <emphasis> altid
</emphasis> har et navn, er argc altid mindst 1. Man gemmer
sommetider programnavnet i en global character-pointer, fx.
således: 
</para>
<programlisting> 
char *thisprog; 
main(int argc, char *argv[])
{
    thisprog = argv[0];
    /* mere program ... */
</programlisting>

<para>
Hvis man skal have fat i sidste ord på kommandolinjen er det
altså <literal> argv[argc-1] </literal> - <emphasis> Husk,
</emphasis> at array elementer starter med 0, d.v.s. første
element er argv[0].
</para>

<para>
For at vise, hvordan main får argumenterne fra kommandolinjen,
kan man lave en "terrasse1" af dette program, hvor man nøjes med
at løbe argumenterne igennem og skrive dem ud på skærmen.
</para>

<para>
Læg mærke til, at programmet gennemløber kommandolinjen 2 gange.
Første gang er det blot for at få de eventuelle options. Vi har
lavet en enkelt optionmulighed, nemlig -v for verbose. Det
fungerer - men det er en meget rå form for kommandolinje analyse.
Vi vil i andre eksempler vise flere måder at gøre dette.
</para>

<para>
Alt i alt er mime2ascii dog betydeligt mere praktisk end
forgængeren. Det læser de filer, som man angiver på
kommandolinjen, og skriver det konverterede indhold ud i en fil
med samme navn med en tilføjelse af ".X". 
</para>

<para>
Det kunne lige så godt være en anden endelse, og det står dig
selvfølgelig frit for at ændre programmet til at lave filer, som
ender på <command>.txt</command>. Nogle gange vil man måske
ønske, at man sletter den oprindelige fil (eller gemmer den under
et andet navn) og omdøber (renamer) den konverterede fil til det
oprindelige filnavn. Dette er en god ide, hvis mime2ascii aldrig
laver fejl!  Det vil være en god opgave til programmeringsarbejde
at polere dette filter, således at det fungerer perfekt og selv
genererer fornuftige filnavne.
</para>

<para>
I afsnit <xref linkend="sect-parser-programmer"/> udvidedes denne
programtype, så den kan håndtere lidt længere sekvenser af tegn,
således at man kan analysere input på et lidt højere
abstraktionsniveau.
</para>

</sect2>

<sect2 id="sect-file-adder">
<title>Summering af tal i en fil.</title>

<para>
Et program, som ønsker at behandle linjer i st.f. characters, kan
optimere IO ved at benytte fgets(2). Vi kan benytte denne
funktion til at skrive et program, som læser en fil med tal og
lægger dem sammen og skriver resultatet. Det er fascinerende at
se et program, der kan behandle en megabyte datafil på brøkdele
af et sekund.
</para>

<para>
Allerede nu kan det forudses, at hvis den kan "forstå"
negative tal også vil kunne trække fra.
</para>

<para>
Der findes situationer fra det virkelige liv, hvor sådan et
program kunne være nyttigt. Hvis vi f.eks. har foretaget et udtræk
fra en stor database med alle telefon taksttelegrammer fra lørdag
24.00 til søndag 06.00, så kan vi beregne den samlede tid og hvor
meget det ville koste at give natterabat. Men også datafiler fra
alle mulige andre situationer ville kunne være input. Normalt vil
man på Unix klare den slags med awk, men hvis man skulle
optimere (f.eks. p.g.a. store datamængder fra en telefoni-data), så
kunne det blive aktuelt at skrive det rå C program.
</para>

<para>
Pseudokode er måden at programmere på, hvis man ikke er
interesseret i sprogets finurligheder, men blot ønsker at
forklare mekanikken i et program. Vores fil-additionsmaskine vil
i pseudokode se ud nogenlunde sådan her:
</para>

<programlisting>
Så længe der er linjer,
  læse næste linje,
  konverter linjen til et tal, hvis muligt
     er det ikke et tal, så vis linjenr, linje og gå ud;
  læg tallet til totalen.
Print totalen.
</programlisting>

<para>
Programmet er så simpelt, at vi skriver det i et hug.
</para>

<example id="beregnings-filter">
<title>Filter som konverterer linjer med tal til summen af tallene.</title>
<programlisting role="C">
/* summer.c */

#include &lt;stdio.h>
#include &lt;stdlib.h>   /* for string to double, strtod() */
#define MAXL 80000
int main()
{
    char line[MAXL];   /* for input */
    char *ptr;         /* for strtod konverteringspointer */
    double tal;        /* for det laeste tal */
    double sum = 0;    /* for totalen */

    while ( (fgets(line,MAXL,stdin)) != NULL) {
        tal = strtod(line,&amp;ptr);
        sum += tal;
    }
    printf("%18.2f\n",sum);
    return 0;
}
/* end of file summer.c */
</programlisting>
</example>

<para>
<literal>strtod(3)</literal> (STRing-TO-Double) er en funktion,
som konverterer en string til double. Denne funktion er mere
avanceret end atoi, i det den kan sætte en fejl-variabel, hvis
konverteringen ikke lykkes, og den kan flytte en pointer hen ad
tekst strengen til det første bogstav, der ikke kunne
konverteres. Man kan også bruge den på en mere simpel måde;
man giver den blot NULL som anden parameter, og krydser fingre og
siger: det skal nok gå alt sammen ...
</para>

</sect2>
</sect1>


<sect1 id="sect-parser-programmer">
<title>Analyse af input</title>

<para>
Er et oversætterprogram et filter? På en måde ja. En bestemt
slags input giver altid et bestemt output. Output er afhængigt af
(ét) input. 
</para>

<para>
Tag nu som eksempel følgende to små programmer. De vil, hvis vi
oversætter dem til statisk linkede, strippede filer, være helt
ens. I de færdige programmer vil der ikke være noget ord "alfa"
eller "beta" - det er blot et midlertidigt navn for nummeret på
den memory - celle, hvor oversætteren anbringer vores tal. Prøv
selv med kommandoen <command> strings prog1 </command>.
</para>

<programlisting role="C">
/* prog1.c - lav om på variabelnavne og oversæt: gcc prog1.c -s -o prog1 */
int alfa 112233;
main(){ printf("min globale variabel har værdien %d\n", alfa); }
</programlisting>

<programlisting role="C">
/* prog2.c ligner prog1 */
int beta 112233;
main()
{
    printf("min globale variabel har værdien %d\n", beta);
}
</programlisting>

<para>
Selv om vi ændrer variables navne og laver om på linjedeling,
kommentarer mv.  får vi nøjagtigt samme maskininstruktioner ud af
det, med andre ord, der er en entydig bestemmelse af ouput ud fra
input. Men for samme output kan vi altså have flere forskellige
input.
</para>

<para>
Kan et program analysere input? Det kommer an på, hvad man
mener med analyse. Hvis man forventer en forståelse, så nej, men
hvis analysen giver sig udslag i, at en struktur i input
oversættes til en anden struktur, så jo, så kan et program
analysere input.
</para>

<para>
Der sker en transformering af input, og den er bestemt af regler.
I en parser er det reglerne, som er de mest interessante. Når vi
ønsker at bygge en oversætter, så skifter vores fokus fra de
laveste, små input enheder, d.v.s. bogstaver og tal, til større
enheder, sætninger, blokke og funktioner.
</para>

<para>
Der er mange teknikker til at skifte fokus fra de laveste
inputenheder, characters og words, til højere niveauer, blokke
mv. En af mere taknemmelige metoder er den rekusivt nedstigende
parser, som opbygges af et hierarki af funktioner, hvor de
øverste tager sig af de store linjer, og de nederste i
call-hierarkiet tager sig af de mindste, syntaktiske enheder.
</para>

<para>
Den rekursivt nedstigende parser (recursive descent parser)
er en attraktiv metode for både begynderen og den viderekomne
programmør. Bjarne Stroustrup fortæller i sin bog "The Design and
Evolution af C++" at han oprindeligt ville bruge en recursive
descent parser til Cfront, den første C++ compiler. " [...] it
<emphasis>is</emphasis> possible to write an efficient and
reasonably nice recursive descent parser for C++. Several modern
C++ compilers use recursive descent." Stroustrup[1], p. 69.
</para>

<para>
For begynderen er det imidlertid en stor mundfuld at forstå en
fuld-skala rekursiv nedstignings parser, men det klares, som
bekendt, ved at dele opgaven op i små bidder. Intet problem er så
stort, at det ikke kan deles i flere mindre. Hvem har sagt det?
</para>

<para>
I de næste eksempler vil vi derfor opbygge en tag-parser efter
terrasse-princippet, d.v.s. at vi lægger ud med at løse en
beskeden del af opgaven.  Først når den virker, kommer vi
yderligere features på. Man er nødt til at skrive nogle simple
inputfiler for at teste programmet, men det kan nu være ganske
fornøjeligt at se, hvad der sker, når man "leger" med input.
</para>

<sect2 id="sect-tag-parser">
<title>En tag - parser</title>
<para>
Når man skriver tekst i sgml format, så vil det være rart, at man
kan få hjælp til at kontrollere sine tags. Det program, jade
<footnote> <para> Jade - James' DSSSL Engine, James Clark har
også skrevet groff programmet. </para> </footnote>, som
fremstiller html, postscript, pdf-filer etc.etc. ud fra vores
kildetekst, skal selvfølgelig også kunne tjekke for, at man har
anvendt tags på den rigtige måde. Men inden man kommer dertil,
kan det somme tider være rart med et mindre program, som
tjekker, at man har husket alle end-tags, og endnu bedre, et
program, som kan formatere lidt på afsnit og indrykning, så
kildeteksten er lettere at læse. Man kunne så fortsætte med at
lave et program, som ville udskrive en formateret ascii udgave.
</para>

<para>
Et sådant program kunne for eksempel få flg. input:
</para>

<programlisting>
&lt;chapter>&lt;title>Dette er kapitel 1.&lt;/title> &lt;para> Dette kapitel
handler om de teknikker, som en programmør kan bruge til at
analysere input.  &lt;/para> &lt;/chapter>
</programlisting>

<para>
Når vi har kørt input gennem vores tag-kontrolprogram, forventer
vi, at output skal se ud nogenlunde som flg.:
</para>

<programlisting>
&lt;chapter>
  &lt;title> Dette er kapitel 1.
  &lt;/title>
  &lt;para> Dette kapitel handler om de teknikker, som en programmør
         kan bruge til at analysere input.
  &lt;/para>
&lt;/chapter>

</programlisting>

<para>
Hvis der mangler en end-tag, skal programmet komme med en
fejlmeddelelse. Programmet kommer (forhåbentlig) til at ligne
indent programmet, som forskønner C - kildetekst ved at sørge for
systematisk indrykning og placering af kommentarer m.v. (se <xref
linkend="sect-GNU-tools"/>.)
</para>

<para>
Man kan diskutere detailler omkring formatering, men i første
omgang vil vi blot have den simplest mulige løsning. Og ikke nok
med det, den første version af programmet skal blot afprøve IO
mekanismerne.
</para>

<para>
Hvis vi skal analysere tags, skal vi kunne se mindst et ord af
gangen. Det er heldigvis meget nemt, idet vi kan nøjes med en
linjebuffer. Et ord vil aldrig være delt hen over en linje.
Orddelinger på grund af linjelængde forekommer <emphasis> ikke
</emphasis>.
</para>

<para>
Vores linjebuffer skal være stor nok, selvfølgelig, og vores
program skal reagere fornuftigt på buffer overflow, derfor bruger
vi fgets(), som stopper, når bufferen er fuld.
</para>

<para>
For at se på det næste bogstav skriver vi en lille funktion,
ch(), som blot returnerer det næste tegn i vores linjebuffer. Men
når vi læser og fremrykker pointeren, så skal der selvfølgelig
tjekkes på, om der er et gyldigt tegn forude, hvis der ikke er,
kaldes fillbuf.
</para>

<para>
I stil med <xref linkend="ex-mime2asc"/> kan vi dog lige tilføje
en lille feature til dette program, nemlig, at hver gang, der ses
en kile, d.v.s. &lt; ofte kaldet mindre-end tegnet, konverteres
til en sgml-kode, "&amp;lt;". Det har vist sig at være et nyttigt
program, når man vil inkludere for eksempel en stump af et C-program i en
sgml kildetekst.
</para>

<example id="ex-sgmlpre">
<title>En tag - parser, forstadium</title>
<programlisting role="C">
/* sgmlfmt_pre1.c Forstadium til mini program, som tjekker balancen i
 * sgml tags. I den nuværende skikkelse kan programmet erstatte
 * alle "mindre-end" tegn med sgml-koden for dette, altså &amp;lt; -
 * så det kan såmænd bruges til at filtrere C-programmer, der
 * skal includeres i en sgml-tekst. */

#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;strings.h>
#include &lt;errno.h>
#include &lt;error.h>

int status;
int eofile;                        /* global end of file */

#define MAXB 8000

char buf[MAXB];
int endbuf;
int bufindex;

int init();
int fillbuf();
int ch();
int gch();
int parse();

int main()
{
    if (init() == 0)
        return 1;
    while (!eofile) {
        if (ch() != '&lt;')
            putchar(gch());
        else {
	    printf("&amp;lt;");
	    gch(); /* discard character '&lt;' */
        }
    }
    return 0;
}


int init()
{
    /* insert initialization of global vars here */
    return fillbuf();
}

int fillbuf()
{
    char *rv;

    if (!(rv = fgets(buf, MAXB, stdin)))
	strcpy(buf, "");
    endbuf = strlen(buf);
    bufindex = 0;
    return (int) rv;
}

/* ch() returnerer den næste character i input stream *men* læser
 * ikke, og ændrer ikke noget i den eksisterende buffer. Det
 * svarer til at spørge "Hvad er det næste input tegn, hvis vi nu
 * gad gå videre?!"
 */

int ch()
{
    return buf[bufindex];
}

int nch()
{
    return buf[bufindex + 1];
}



/* Hvis vi altid vil kunne se mere end én character fremefter, må
 * vi udskifte gch() og fillbuf() funktionerne, således at de
 * tjekker, hvor meget er der i bufferen, og hvis der er for få
 * (mindre end ønsket) skal de efterfylde bufferen og justere
 * pointere.
 * Det søde ved denne implementering er imidlertid, at vi altid
 * har én character lookahead (garanteret), men hvis vi ser på et
 * ord, kan vi se hele resten af ordet, fordi et ord ikke kan
 * krydse en linjedeling.
 */

/* gch() returnerer samme som ch() men flytter pointeren en plads
 * frem. Hvis vi ved fremadrykning rammer end of line (en
 * nul-byte) må vi fylde bufferen, så ch() næste gang har et tegn
 * at kigge på.
 */

int gch()
{
    int c;
    if (nch() == 0) {
	c = ch();
        if (!fillbuf()) {
            eofile = 1;		/* will take effect for the next char */
        }
	return c;
    }
    return buf[bufindex++];
}

</programlisting>
</example>


<para>
Programmets main kunne såmænd udmærket nøjes med at benytte
getchar og putchar. Der er ikke noget vundet i <emphasis> dette
</emphasis> program ved at benytte en særlig input mekanisme. Men
det, som er det egentlige formål med programmet, er jo også at
bygge grundbestanddelen til et andet. Det er "terrasse 1", og
hvis det virker og kopierer input til output (med undtagelse af
&lt; tegn), så er grunden lagt til næste udgave af programmet,
som blot skal tjekke, om en tekst har balancerede tags.
</para>

<para>
Funktionerne ch() og gch() <emphasis> administrerer </emphasis>
bufferen. Andre funktioner i programmet kigger ikke direkte i
den globale variabel "buf[MAXB]". Det kunne være en privat
variabel, som lå i et IO-modul. (Prøv at ændre programmet på den
måde.)
</para>

<para>
En af de ting, der drillede ved konstruktionen af programmet,
var, at gch() skal fylde bufferen - den er jo ansvarlig, klart
nok, for at der er en næste byte at læse. gch() er den eneste,
som kalder filbuf. Men hvornår skal den fylde bufferen? Hvis 
buffer indexet peger på newline eller en streng-slutning
(null-byte), så kunne det være signal til at fylde bufferen op.
Da det alligevel blot er en newline, så kunne man smide den væk.
</para>

<para>
Men det er ikke en god idé (her) - for at det skal kunne lade sig
gøre at gengive linjeskift i for eksempel litteral tekst er det nødvendigt
at lade gch() kigge en byte fremad.
</para>

<para>
Så man skal altså huske at "gemme" den sidste byte i bufferen i
en variabel, og derefter fyldes bufferen igen.
</para>

<para>
Derved opstår der et andet problem. Hvornår rammer man end of
file. Hvis caller af gch() tester på end of file INDEN han bruger
den character, han har fået med gch(), så vil der - i denne
version - gå kage i systemet.
</para>

<para>
I dette lille program er det imidlertid overskueligt at huske, at
man skal anvende returværdien fra gch() inden man tester for end
of file (eller teste for end of file inden man kalder gch()).
</para>

<para>
Input mekanismen, som den er præsenteret her, er en forsimplet
udgave af input mekanismen i small-C compileren, se <xref
linkend="sect-uCc"/>.
</para>

<para>
Programmet anvender IKKE pointere. I stedet indexeres array'et
med variabelen bufindex.
</para>
</sect2>

<sect2 id="sect-recursion">
<title>Tjek balancering af tags</title>

<para>
I den næste version af tag-parseren, tagbal01.c, kan
man se, hvordan input mekanismen er bevaret. Programmet er ikke
gengivet her i sin fulde udstrækning, men ligger som en fil i
kataloget med eksempler. 
</para>

<para>
Opgaven består denne gang i at skrive et program, som kan læse
en tag og "huske den", indtil vi kommer frem til næste tag. Hvis
den næste tag er en end-tag (med skråstreg, for eksempel &lt;/chapter>) så
skal teksten <emphasis> efter </emphasis> skråstregen være samme
ord, som vores start tag. Hvis det er en ny start tag, fx.
&lt;section1>, så skal den accepteres, og programmet leder nu
efter en end-tag for section1.
</para>

<para>
Vi kan beskrive flow'et på flg. måde:
</para>
<programlisting>
<emphasis>
    så længe der er en tag &lt;navn>
       hvis den næste tag er en start tag
           kald rekursivt
       ellers
           hvis det ikke er en end-tag, som matcher &lt;navn>
               meld fejl
           ellers returnér ok

</emphasis>
</programlisting>
<para>
Når vi har fundet en end-tag, som matcher start-taggen, skal
vores funktion  altså returnere true (eller ok). Denne simple
version skriver m.a.o. ikke noget output.
</para>


<graphic fileref="recurs1.&magic;"  scale="100"></graphic>

<para>
Den funktion, som skal klare chapter-/chapter, kan selvfølgelig
være lavet sådan, at den <emphasis> kun </emphasis> leder efter
chapter. Men da mekanismen er den samme, når vi leder efter
section eller para, så er det nok bedre at lade vores funktion
acceptere et hvilket som helst tag navn, og så gemme det i en
character buffer. Derved kan vi bruge den samme mekanisme for
både chapter, section1 og alle mulige andre.
</para>

<para>
Programmet kunne i simplest mulige form simpelt hen se sådan
ud:
</para>

<programlisting>
scan_for_tags()
{
    char newbuffer[MAXT];
    int j = 0;

    if (ch() != '&lt;')
        parse_error("Need tag here\n");
    // ok, der er en tag
    gch();
    if (ch == '/')
        parse_error("Cannot have end tag here\n");
    while ( ch() != '>' )
        newbuffer[j++] = gch();
    // Nu skipper vi al almindelig tekst indtil næste tag.
    while (ch() != '&lt;')
        gch();
    // Nu stoler vi på, at vi kan se 2 characters frem
    if (!match("&lt;/")) {
        // ikke en endtag
        scan_for_tags();   // tag lige alle indskudte tags her!
    }
    // Ok, denne gang er det en end-tag:
    gch();gch(); // nu er vi fremme ved tag-navnet
    if (match(newbuffer)) {
       if (gch() != '>')
          parse_error("Need end-angle here\n");
       else
          return 1; // ok.
    }
    parse_error("tag-name non-match\n");
    // parse_error returnerer ikke, så vi kommer aldrig her, men
    // vil gerne gøre compileren glad...
    return 0;
}
</programlisting>

<para>
Ovenstående funktion kalder sig selv, hvis den ser en ny
start-tag efter at den er gået i gang med at lede efter en
end-tag.
</para>

<para>
Det er en simpel version af rekursiv nedstigning. Der er flere
forskellige ting, denne her parser ikke kan klare. Hvis man
skriver sin tag hen over en newline (hvilket er lovligt) så vil
parseren includere newline i tag-navnet. I det hele taget tager
den alt, bogstavelig taget alt, inden slut vinkelen, og gemmer
det som et tag-navn. Endvidere tjekker den ikke for buffer
overflow, men det kunne man nemt indføje. Den er ikke desto
mindre en god demonstration af, hvordan rekursionen kan gøre det
muligt for os at håndtere mange forskellige slags input. Hvis der
er 17 tags inden i hinanden, fint. Hvis vi først lægger 5 inden
i hinanden og bagefter får 2 endtags og så igen en start-tag,
fint, så klarer funktionen også at validere den slags input.
</para>

<para>
Det vil være en god øvelse at afprøve ovenstående. Det findes
ikke som en fil i eksemplerne. Man kan klippe funktionen her og
indsætte den i en kopi af sgmlfmt_pre1.c -- eller man kunne
skrive hele programmet for at få lidt øvelse.
</para>

</sect2>


<sect2 id="sect-tagbal01.c">
<title>Any-tag</title>

<para>
Lad os forfine ideen fra foregående eksempel. I stedet for at
lede efter start-tag tegnet, så overlader vi alt det beskidte
arbejde (inclusive håndtering af linjeskift og spaces) til en
funktion, som vi vil kalde anytag(). Derved bliver programmet
meget lettere at læse.
</para>

<para>
Hvis funktionen anytag() ser en tag, fint, så gemmer den navnet i
den buffer, den har fået og returnerer true. Hvis den ikke finder
en tag, så returnerer den blot false. Det må vores parser så
benytte sig af. Her kommer pseudo-koden:
</para>

<programlisting>
<emphasis>
   hvis der er en ny starttag &lt;navn>
       så længe der er mere input
           lad tekst data passere
           hvis der er en end-tag
               begynd forfra (d.v.s. se efter en ny starttag)
           ellers skift niveau (d.v.s. rekursivt kald)
   ellers
       returner false

</emphasis>
</programlisting>

<para>
Opmærksomheden kan nu koncentrere sig om, hvordan man scanner for
en tag med tilhørende slut-tag. Ovenstående pseudo-kode svarer
til funktionen parse_level1. Navnet giver en forudanelse om, at
man senere kunne have forskellige levels i parseren, som hver
især er udtryk for, at der gælder forskellige regler for
forskellige tags. Men her bliver de alle behandlet ens. Der er
ikke nogen regler for, hvilke tags der må være inde mellem andre
tags. Programmet skal blot kunne tjekke, at der efter en
&lt;tag>, kommer en &lt;/tag> (altså en slut-tag af samme type)
senere, evt, efter nogle andre, indskudte (nestede) tags og med
"tekst data" både før og efter.
</para>

<para>
For at få tag'en analyseret kalder parse_level1 den dertil
indrettede funktion anytag(), som afleverer navnet eller
keywordet på taggen i den buffer, som den får adressen på.
Parse_level1 gemmer navnet på taggen for senere at kontrollere,
at den tilsvarende end-tag har samme navn.
</para>

<para>
parse_level1 accepterer nu ord ved at kalde getword. Typisk ville
det være efter en para-tag. Når getword støder ind i et '&lt;'-tegn
stopper den. Når den returnerer 0 er det fordi den er stødt ind i
en ny tag (eller end-tag) -- eller fordi der ikke er mere input.
</para>

<para>
Nu kommer det spændende! Hvad må der komme efter? På dette sted i
input kan der komme en end-tag eller en ny tag. Hvis det er en
end tag, har vi sluttet ringen og bør gå et niveau ned og se, om
der er mere tekst efter end-taggen. Det gøres ved at breake og
hvis der ikke kommer en ny tag returneres fra parse_level1.
</para>

<para>
Hvis den nu har kaldt sig selv, så er vi ikke på det yderste
niveau. Der returneres til stedet lige efter det rekursive
call, og programmet begynder forfra på while-loop(2). Herved
vil det igen ser efter med getword, om der er "tekst-data". Men
altså på et niveau lavere. (Det kan ses på indrykningerne i
output).
</para>

<para>
Her kommer det centrale sted i programmet tagbal01.c:
</para>


<example id="ex-tag-balance1">
<title>Tjek om sgml-tags balancerer</title>
<programlisting>
#define MAXT 80

int parse_level1()
{
        char tagname[MAXT];
        while (!eofile) {                          /*(1)*/
                if (!anytag(tagname)) {
                        return 0;
                }
                while (!eofile) {                  /*(2)*/
                        while (getword())          /*(3)*/
                                putword();
                        if (have_endtag(tagname))
                                break;
                        (void) parse_level1();  /* nested tags */
                }
                blanks();
        }
        return 1;
}

</programlisting>
<blockquote>
<sidebar>
<para>
Efter en nested tag kan der komme mere tekst (som efter emphasis
tag fx.) Man skal derfor spørge efter flere words når man kommer
tilbage fra rekursivt kald til parse_level1(). Det er derfor, at
der forrest i while-løkke (2) er et tjek for tekst-data, nemlig
getword() (3).
</para>
<para>
Endvidere kan der jo komme en ny tag-konstruktion lige efter en
komplet cyklus <emphasis>på samme niveau</emphasis>.  Derfor må
man <emphasis> ikke </emphasis> returnere, hvis have_endtag()
returnerer true; altså hvis vi finder en end-tag, så skal vi se
efter, om der er en start-tag mere på samme niveau. Hvis der
<emphasis> ikke </emphasis> er det, <emphasis> så skal der
returneres </emphasis>.
</para>
</sidebar>
</blockquote>
</example>

<para>
Nøglen til forståelse er at følge flowet og forestille sig input
i stil med flg.: &lt;sect1> &lt;para> text-text &lt;emphasis>
_text_ &lt;/emphasis> text2 &lt;emphasis> !text3! &lt;/emphasis>
text4 &lt/para>&lt;/sect1>
</para>

<graphic fileref="recurs2.&magic;"  scale="100"></graphic>

<para>
Indsæt printf() statements forskellige steder i programmet og
afprøv med små input filer. Sæt ord mellem para-tags. Prøv at
undersøge, hvad der sker, hvis man ikke ignorerer return value i
det rekursive kald til parse_level1().
</para>

<para>
Det vil være en god øvelse at tjekke, om der i programmet er
mulighed for buffer overflow nogen steder.
</para>

</sect2>




<sect2 id="sect-tagtyper">
<title>Skelnen mellem tagtyper</title>

<para>
tagbal02.c er bygget op nøjagtigt som tagbal01.c, men kan skelne
mellem et par grundlæggende typer sgml-tags, nemlig comment,
programlisting og literal. Den kan også anvende en speciel
regel for programlisting og literal, tekst data imellem dem
bliver leveret videre som den er, uden formatering eller
ombrydning af linjer.
</para>

<example id="ex-tagbal-sammenligning">
<title>Udvidelse af parse-level1 med kendte tag-typer</title>
<programlisting role="C">
int parse_level1()
{
    char tagname[MAXT];
    while (!eofile) {
        blanks();
        if (comment()) {
            continue;
        }
        if (programlisting(tagname) || litt(tagname))
            (void) do_litteral(tagname);
        else if (!anytag(tagname))
            return 0;
        while (!eofile) {
            while (getword())
                putword();
            if (have_endtag(tagname))
                break;
            (void) parse_level1();      /* nested tags */
        }
        blanks();
    }
    return 1;
}

</programlisting>
</example>

<para>
Find funktionen parse_level1() og sammenlign med tagbal01.c. Nu
er det ikke kun anytag, den kalder. Der er kommet
special-funktioner til, som håndterer henholdsvis kommentarer,
programlisting og litteral-tags. De er bygget op som anytag(), de
returnerer false, hvis de ikke ser den tag type, som de er "sendt
ud for at lede efter".
</para>

<para>
Klart nok må man så vente med at kalde anytag() til efter at de
andre har fået chancen. Anytag() accepterer jo hvad som helst,
der er en tag, så andre funktioner ville overhovedet ikke blive
kaldt.
</para>

<para> 
I en sgml parser kunne anytag() benytte en liste over tilladte
tag navne; hvis en tag ikke stod i denne tabel, så var den
ulovlig og programmet skulle stoppe med en fejlmeddelelse.
</para>

<para>
Et eksempel på kørsel af programmet, med en lidt forsimplet form
for sgml-tags, kommer her.
</para>

<screen>
<prompt>dax@pluto: </prompt><userinput>cat lidt.sgml </userinput>

&lt;chapter>
&lt;sect1 id="tag_balance_tjekk">
&lt;para>
Dette       er
en prøvetekst.
&lt;/para>
&lt;para>
mere tekst i ny paragraf
&lt;footnote>&lt;para>
fodnote text kommer her.
&lt;/para> &lt;/footnote> 
&lt;/para>
&lt;programlisting>
		while (++x &lt; 10)
			printf("Hello!\n");
&lt;/programlisting>
&lt;/sect1>
&lt;/chapter>
&lt;!-- her kommer en kommentar -->
&lt;azerty> Programmet klager ikke over en ulovlig tag.
&lt;/azerty>

<prompt>dax@pluto: </prompt><userinput>tagbal02 &lt; lidt.sgml </userinput>
&lt;chapter>
  &lt;sect1 id="tag_balance_tjekk">
    &lt;para> Dette er en prøvetekst.
    &lt;/para>
    &lt;para> mere tekst i ny paragraf
      &lt;footnote>
        &lt;para> fodnote text kommer her.
        &lt;/para>
      &lt;/footnote>
    &lt;/para>
    &lt;programlisting>
                while (++x &lt; 10)
                        printf("Hello!\n");
    &lt;/programlisting>
  &lt;/sect1>
&lt;/chapter>
&lt;!-- her kommer en kommentar -->
&lt;azerty> Programmet klager ikke over en ulovlig tag.
&lt;/azerty>

<prompt>dax@pluto: </prompt>
</screen>

<para>
Som det kan ses, beklager programmet sig ikke over, at der
forekommer en ulovlig tag sidst i input. Programmet formaterer
teksten, ikke så avanceret, men nyttigt nok, og foretager
indrykning, hver gang der forekommer en tag er inde i en anden
tag.
</para>

<para>
Hele programmet ligger som en fil i eksempelsamlingen,
tagbal02.c.  
</para>

<para>
<command>Forslag til øvelse:</command> Dette program kan med få
modifikationer benyttes til at trække teksten ud af en sgml fil,
og endda i en læselig formatering. Overvej, hvilke forbedringer,
som kunne gøre denne tekstudtrækning - ascii formatering -
endnu mere nyttig. (Jeg har ikke nogen løsning på denne øvelse -
endnu!)
</para>

</sect2>


<sect2 id="sect-intelligent-wordcount">
<title>Tilstandsvariabel</title>

<para>
Det er lidt af en provokation at kalde det næste program for
et filter. Man kunne lige så godt kalde det en parser eller en
tilstandsmaskine. Det er også en lexical analyzer. Men strengt
taget er det også et filter. Der kommer noget input ind fra (kun)
én kilde, og afhængigt af dette spytter programmet noget andet
ud.  Der er en årsagssammenhæng fra input til output.  Det samme
input vil altid give det samme output.  Men det går kun den ene
vej. Et bestemt output kan produceres af mange forskellige slags
input.
</para>

<para>
I modsætning til de tidligere eksempler er der i dette eksempel
en variabel, som husker den tilstand, vi er i.
</para>

<para>
Og hvad er det så for et program? Et WORD count filter! Input er
tekst, og output er blot antallet af ord. Provokation! Er det
virkelig et filter? Ja, for det opfylder jo alle de ovenstående
krav. Det sluger input fra en kilde og omformer det til output,
som, ok, kan være det samme for flere forskellige slags input,
men samme input -- altid samme output. Vi baserer vores program
på en lille bemærkning i Kernighan &amp; Ritchies 
version af word count<xref linkend="ex-hello-wordcount"/>: Nemlig 
at begrebet "et ord" kan forfines, så man kan skelne mellem
rigtige ord og tal, tegnsætning og lignende.
</para>

<para>
Hvis du ikke kender det grundlæggende wordcount program, så er if
sætningerne i dette program næsten uforståelige. Se derfor
<xref linkend="ex-hello-wordcount"/> hvis du ikke kender det.
</para>

<para>
Programmet her starter med at være i en tilstand, som vi kalder
HVID.  Når vi ikke har læst noget, så må vi være på HVIDt papir.
</para>

<para>
Vi skal benytte en variabel til at huske denne tilstand, og vi
kalder den status.
</para>

<para>
For at gøre det lettere at læse programmet, lader vi denne
variabel være af enum - typen. Så kan en god oversætter holde styr
på, om vi tilskriver den andet end symbolske navne som tilhører
typen. Dog kun med warnings.
</para>

<example id="ex-word-and-digit-count">
<title>Ord - tælling</title>
<programlisting>
/*file ordtael.c */

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;ctype.h>

typedef long long _int64;

/* taellere: char, words, num, andet, lines */
_int64 nc, nw, nn, na, nl; 

enum status_t { HVID, ALFA, TAL, PUNC };

enum status_t status;

int main()
{
    int c;
    while ( (c=getchar()) != EOF) {
        ++nc;
        if (c == '\n')
            +nl;
        if (ispunct(c))
            ++na;
        if (isspace(c)) {
            status = HVID;
        } else {                                      /*(1)*/
            if (status == HVID || status == PUNC) {
                if (isalpha(c)) {                     /*(2)*/
                    status = ALFA;
                    ++nw;
                } else if (isdigit(c)) {              /*(3)*/
                    status = TAL;
                    ++nn;
                }
            } else if (ispunct(c)) {                  /*(4)*/
                    status = PUNC;
            }
        }
    }
    printf("Antal: chr %Ld, ord: %Ld, tal %Ld, andet %Ld, lin. %Ld\n",
            nc, nw, nn, na, nl);
    return 0;
}

/* OBS: Der er lidt flere braces i ovenstående eksempel end 
 * nødvendigt, det er i håb om bedre læselighed.
 */

/* end of file ordtael.c */
</programlisting>
</example>

<para>
Det er statusvariabelen, som "husker", om vi er inde i et ord
eller ej. Og det er statusvariablen, som gør det muligt at skrive
programmet på en <emphasis> forholdsvis </emphasis> læselig måde
Hvis opgaven imidlertid blev forsøgt løst <emphasis> uden
</emphasis> statusvariabel, så ville der komme endnu flere
if-sætninger. Inde i dem måtte man så lave nogle loops med
læsning af input, så længe vi er i et ord. Og så bliver programmet
fuldstændigt barokt kompliceret, prøv selv!. 
</para>

<para>
(1) Hvis vi lige er har fat i noget, der er "ikke-space" og
tilstanden stadig siger HVID, så betyder det jo, at vores
tilstand lige netop nu ændrer sig.  Derfor bør vi tælle antal af
ord (eller tal, tegnsætning, etc.) op.
</para>

<para>
(2) Som ord tæller vi alt, hvad der begynder med bogstaver.
</para>

<para>
(3) Som tal tæller vi alt, hvad der begynder med cifre.
</para>

<para>
(4) Læg mærke til, at ETHVERT skilletegn udløser en
tilstandsændring til PUNC, fordi denne sætning er sideordnet med
den if, der står lige efter den (1) mærkede else.
</para>

<para>
Hvis indrykningen i dette program bliver smadret, så er det
komplet umuligt at forstå meningen med det.
</para>

<para>
Programmet er udmærket til at danne sig et skøn over forholdet
mellem tal og ord i en artikel.
</para>

<para>
Ordtael.c er i stand til at taelle et funktionskald
som f.eks. qwerty(6000) som et ord, et tal og 2 andre tegn. Til
gengæld tæller det 123Mb som et tal (uden ord).
</para>

<programlisting role="C">
MITPROMPT$ ordtael &lt;&lt;STOP
hej(42);
STOP

Antal: chr 9, ord: 1, tal 1, andet 3, lin. 1
</programlisting>

<para>
Hvis vi skal forfine programmet, så er det klogt at skifte taktik.
Løsningen ovenfor skalerer ikke godt, når antallet af tilstande
vokser, og input indeholder mange flere kategorier. En
tilstandstabel kan bedre håndtere opgaven.
Se <xref linkend="c-parser-tilstandsmaskine"/>.
</para>

</sect2>
</sect1>

<sect1 id="fejl-og-haandtering">
<title>Fejl og håndteringen af dem.</title>

<sect2 id="fejl-kategorier">
<title>Hvilke slags fejl er interessante</title>
<para>
Det er egentlig ikke så interessant, set fra en programmørs
synspunkt, om en disk bryder sammen. Det kan man nemlig ikke
rigtig gøre noget ved, når det er sket. Den, der skriver drivere
til styresystemet, ville måske nok kunne lave noget programmel,
som forudsagde, at hardwaren trængte til service eller
udskiftning. Det er indenfor mulighedernes grænser.
</para>

<para>
Hvis vi skriver et almindeligt filteringsprogram, f.eks. et,
som konverterer fra MIME/html characters til extended ascii eller
rettere ISO-8859-1, så bør vi altså ikke begynde at lave tjek af
CPU-temperatur, disktilstand etc. Det hører hjemme et andet sted
og er ikke interessant for vores filterprogram.
</para>
<figure id="fig-fejl-fil-mangler" float="1">
<title>Eksempel på fejlhåndtering, informativ besked</title>
<graphic fileref="err2.&magic;"  scale="60"></graphic>
</figure>

</sect2>
</sect1>


<sect1 id="outformat1">
<title>Flere små programmer og øvelsesforslag.</title>
<para>
For at demonstrere styrken af små 10-24 linjers programmer
("Hallo-programmer") kommer her en serie sådanne små særlinge.
</para>

<sect2 id="hello-tal-format">
<title>Tal formatering ved udskrift med printf.</title>
<para>
Her kommer kildeteksten til et program, som kan skrive en
listing af tallene fra 0 til 7, inverteret og som 2's complement.
(Som lovet i <xref linkend="ex-numrep1"/>).
</para>

<example id="ex-tal-hex">
<title>Tallene fra 0 til 7 i hexadecimal notation.</title>
<programlisting role="C">
/* bitinvert.c viser hexadeximalt tallene fra 0 - 8  */
/* og desuden invertering, og såkaldt 2-s complement */

#include &lt;stdio.h>


char	*thisprg;

int main(int argc, char *argv[])
{
   int jj;

   thisprg = argv[0];

   for (jj=0;jj&lt;8;++jj) {
     printf("Word: %08x, Inverted: %08x, Complement: %08x\n",jj,~jj,~jj+1);
   }
   return 0;
}

/* end bitinvert.c */
</programlisting>
</example>
</sect2>

<sect2 id="cprog-hello-wordcount">
<title>Word count - med tak til Kernighan &amp; Ritchie</title>
<para>
Her er en simpel variant af Kernighan &amp; Ritchie's word count
program. Det er en ultra simpel tilstandsmaskine. Den har kun to
tilstande, enten er den i HVID tilstand, eller i SORT.
</para>

<para>
Hvis den er i HVID tilstand, har den læst et bogstav, som var
whitespace, d.v.s. typisk space eller newline eller tab. Hvis den
er i SORT tilstand, har den læst et tegn, som kræver tryksværte -
eller rettere, et, som ikke er et whitespace tegn.
</para>
<para>
Programmet skelner altså ikke mellem ord og tal eller
tegnsætning. Det anser bogstaver mellem to spaces for at være et
ord! Så simpel en ord-tællingsmekanisme kan såmænd da være meget
anvendelig i mange sammenhæng, 
f.eks. <literal>echo * | ordtael</literal> vil vise, hvor mange filer, 
der er i det
aktuelle katalog.  Det er grundlaget for det lidt mere avancerede
program <xref linkend="ex-word-and-digit-count"/> som kan 
skelne mellem ord og tal og skilletegn.
</para>

<example id="ex-hello-wordcount">
<title>Simpel ordtælling</title>
<programlisting>
/*file wc.c */

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;ctype.h>

int nc, nw, nl;  /* static vars garanteret 0 */

enum status_t { HVID, SORT };

enum status_t status;

int main()
{
    int c;
    while ( (c=getchar()) != EOF) {
        ++nc;
        if (c == '\n')
            ++nl;
        if (isspace(c))
            status = HVID;
        else                           /* &lt;--- SE kommentar!!!*/
            if (status == HVID) {
                status = SORT;
                ++nw;
            }
    }
    printf("%d %d %d\n", nc, nw, nl);
    /* lav en version, der KUN taeller ord! */
    return 0;
}

/* end of file wc.c */
</programlisting>
</example>

<para>
Læg mærke til, at programmet altid tæller characters, når der er
læst en. Hvis det er en newline, så tæller vi linjer. Klart nok.
Hvis det nu er en slags space (eller newline, tab, backspace,
vertical tab, formfeed ...) så lader vi den gå i HVID-tilstand.
</para>

<para>
Den efterfølgende ELSE er kernepunktet for forståelse. Hvad ved
vi, hvis vi havner i ELSE-sætningen? Jo, vi ved, at vores nys
indlæste character IKKE var hvid.
</para>

<para>
Hvad ved vi så, hvis STATUS er lig med HVID, og vores nys
indlæste bogstav var sort?
</para>

<para>
Joda, ... giv dig tid!
</para>

<para>
Så ved vi, at det foregående bogstav var hvidt (altså space) og
at det nuværende er sort, altså, det første bogstav i et ord. Så
derfor skifter vi tilstand til sort og tæller det nye ord med.
</para>

<para>
Så vores tilstandsvariabel <literal>status</literal> er meget
praktisk, fordi den kan huske for os, hvad det foregående bogstav
var, eller i bredere forstand, hvilken slags bogstav det var, og
dermed hvilken tilstand vores tællemaskine var i.
</para>

<para>
Det er et program, som er sindssygt svært at forstå for en
begynder, som heller ikke har erfaring med andre sprog. Sådan er
det forresten altid når if-sætninger gror oven i hinanden. Hvis
du har arbejdet dig igennem læsning af programmet og - bedre -
har fået det til at køre, evt. med dine egne tilføjelser, så du
kan se, hvad der sker undervejs, så har du taget et stort skridt
fremad indenfor programmering (og logisk tænkning).
</para>
</sect2>
</sect1>



<sect1 id="cprog-oevelser">
<title id="OV1">Øvelser</title>


<para>
Skriv frame2 om til frame2a, hvor du selv angiver prototypen
for puts, og se, om det oversætter og kører lige så godt som
frame2.c, der jo bruger headerfilen &lt;stdio.h>
</para>

<sect2 id="cprog-hello-beregninger">
<title>Forslag til beregningsøvelser</title>
<para>
Skriv procent.c om, så du også udskriver indholdet af
variablene kroner og procent.
</para>

<para>
Skriv procent.c om, sådan at den beregner 99% af 100
millioner (jo jo, det kan man gøre i hovedet, men det er for at
gøre det nemt at kontrollere resultatet!) Dette er ikke
en helt triviel opgave.
</para>

<para>
Lav en version af programmet, som selv kan finde ud af, om
der er overflow på beregningen. Hint: resultat / procent *
kroner. For den viderekomne kan opgaven løses ved, at man
benytter en assemblerinstruction, som tjekker for overflow
flaget.
</para>
</sect2>

</sect1>
</chapter>



