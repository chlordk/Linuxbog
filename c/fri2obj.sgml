<chapter id="object-orienteret-tankegang">
<title>Tankegang bag objektorienteret programmering</title>
<sect1 id="datatyper"><title>Konkrete og abstrakte datatyper</title>

<indexterm><primary>abstrakte datatyper</primary></indexterm>
<indexterm><primary>brugerdefinerede datatyper</primary></indexterm>

<para>
Er C et objektorienteret sprog? Hvorfor er det ikke
objektorienteret, når et C program er en række definitioner af
eksterne objekter? (external objects?)
</para>

<para>
Det korte svar er, at almindelig C ikke har virtuelle
funktioner. Desuden er der ikke support for generisk algoritme
programmering. Det er imidlertid interessant at vide, at C
sproget som sådan ikke forhindrer programmøren i at tænke
objektorienteret. I dette afsnit vil vi sammenligne to udgaver af
en linked liste, den ene skrevet i C og den anden i C++.
</para>

<para>
I øvrigt har de fleste sprog nogle mekanismer, som er
rigtigt objektorienterede, nemlig håndteringen af forskellige
numeriske typer.
</para>

<para>
Vi kan have en integer i en variabel og gange den med en
float og lægge resultatet i en double uden at compileren gider
fortælle, at der skal konverteres. Taber vi præcision ved at
konvertere fra double til integer, vil de fleste compilere give
en warning, men de konverterer dog.
</para>

<para>
Det er egentlig objektorientering i en nøddeskal. Definer
din algoritme (fx. addition) og sørg for, at den kan håndtere
forskellige data, d.v.s. objekter, på en passende måde.  Det
vanskelige ved objektorientering kommer, når man definerer nye
klasser eller objekttyper og så skal til at skrive regler for,
hvordan operatorer skal fungere etc. Som en øvelse i
objekt-orienteret tankegang kan man prøve at definere en struct,
som skal repræsentere brøker, som fx. 2/3, der jo ikke er det
samme som 0.6667.
</para>

<para>
Det er standard C sprogets struct, som er grundlaget for C++
klasse kontruktionen. C++ tillader, at der knyttes operationer
til en struct, og disse "medlemsfunktioner" kan erklæres inde i
klassen (på samme måde som data-medlemmer). I standard C kan man
benytte funktionspointere til at opnå samme funktionalitet, men
man skal jo selv udføre alt det grundlæggende arbejde (og huske
at gøre det!)
</para>

<para>
I C++ er det muligt at erklære en variabel af typen broek
som fx. nedenstående eksempel, og derefter benytte de tilhørende
operationer udtrykt ved de i forvejen kendte operatorer:
</para>

<programlisting role="C">
broek andel(1,3);
int bogpris = 360;
afgift = bogpris * andel;
</programlisting>

<para>
Det forudsætter selvfølgelig, at man har defineret typen broek og
tilhørende funktioner for operatorerne på en passende måde! 
</para>

<indexterm><primary>konkrete datatyper</primary></indexterm>

<para>
En sådan brugerdefineret datatype kaldes somme tider en konkret
datatype, i modsætning til en abstrakt datatype. Den konkrete
datatype har ingen "virtuelle funktioner" sådan som den abstrakte
har det. Læs videre:
</para>

<para>
Betegnelsen abstrakt datatype (ADT) bruges somme tider om alt,
hvad der kan indkapsles, men den mest rimelige anvendelse er nu
den, som Stroustrup angiver i sine forskellige bøger om C++. Hvis
vi skal skrive en hardware driver til en grafisk device (en som
er i stand til at tegne prikker på en angivet position) så kan vi
definere en klasse "shape" - men funktionen for, hvordan den skal
tegnes varierer for cirkel og rektangel. C++ supporterer den
slags konstruktioner: En generel klasse, "shape" og aktuelle
subklasser (eller arvende klasser, specialiserede) som så skal
definere en brugbar funktion til at udføre handlingen
"tegn_shape".
</para>

<para>
En funktion i klassen "shape", som erklæres for at være virtuel,
kan ikke kaldes (den eksisterer jo i virkeligheden kun, mens
programmet kompileres!) og det vil give compiler fejl, hvis de 
nedarvende klasser ikke definerer en (rigtig) funktion.
</para>

<para>
I de efterfølgende afsnit vil vi bruge betegnelsen "abstrakte
datatyper" mere løseligt om alt, hvad der kan indkapsles. Vi
stiller os tilfreds med, at implementering af funktionaliteten
kan udskiftes uden at brugere af datatypen skal ændre deres
kode.
</para>

</sect1>

<sect1 id="sect-abstract-datatypes">
<title>Abstrakte datatyper</title>

<indexterm><primary>abstrakte datatyper</primary></indexterm>

<para>
For at programmere på højt niveau i C sproget skabes
abstraktioner, som er funktionelle og nyttige. Fx. er en fil
en abstraktion, som operativsystemet leverer. Grundlaget for
abstraktionerne er som regel structures, de sammensatte
datatyper, som deklareres med nøgleordet <emphasis> struct
</emphasis>. For at bevare overblikket, for ikke at blande
detaillerne ind i den abstraktion, som vi ønsker at skabe, 
indkapsles sådanne data ofte, således at al tilgang sker gennem
funktionskald. Derved bliver det lettere at anvende den
pågældende abstraktion, man skal blot udstede en "kommando": Læs,
skriv, luk, gem o.s.v.
</para>

<para>
Et kendt eksempel er fil tilgang, funktionerne
fopen(), fread(), fprintf() etc., som klares ved hjælp af
datatypen FILE. Den skal man ikke "dissekere", den benyttes blot
som et håndtag til den datastrøm, hvorpå man ønsker at udføre
IO-operationer.
</para>

<indexterm><primary>FILE typen</primary></indexterm>
<example id="ex-fopen">
<title>FILE typen</title>
<programlisting role="C">
/* fileopen.c - demonstrerer fopen(). */
#include &lt;stdio.h>

main()
{
	FILE *fp;
	fp = fopen("fileopen.c","r");
	if (!fp) {
		perror("Kan ikke aabne filen \"fileopen.c\"");
		exit(2);
	}
	printf("Har aabnet filen \"fileopen.c\" \n");
	return 0;
}

</programlisting>
</example>

<para>
FILE er en abstrakt datatype. Hvis vi yderligere forestiller os,
at vi benytter vores program til at læse en "special-fil", fx. en
driver-entry via /dev/ kataloget eller en fil i /proc/ kataloget,
så har vi samme funktionalitet, som en C++ abstrakt datatype kan
give os.
</para>

<para>
FILE "håndtaget" benyttes til at tilgå filer, og de indre dele af
FILE (pointere, interface til kernen etc.) er ukendt for os, vi
behøver ikke at vide noget om buffere og pointere, men må
selvfølgelig gerne vide det<footnote><para>Hvis vi ved noget om
IO-buffere etc. ville vi ikke drømme om at bruge det i en
end-user applikation!</para></footnote>.
</para>

<para>
Det kan ikke understreges nok, at nøglen til succes er kendskab
til funktions interfacet og de andre teknikker til at indkapsle
de data, der naturligt hører sammen. 
</para>

<sect2 id="sect-sammensatte-datatyper">
<title>Sammensatte datatyper</title>

<para>
Sammensatte datatyper er nyttige, når vi i et program har brug
for at samle informationer om et "objekt i den virkelige verden".
Den engelske betegnelse er <emphasis>aggregate data
types</emphasis>, men det giver også mening at kalde dem for
brugerdefinerede datatyper.
</para>

<para>
Sammensatte datatyper er, som ordet siger, en sammensætning af
forskellige typer data. I C sproget erklæres en sådan datatype
ved hjælp af nøgleordet <emphasis> struct </emphasis>. Det er
selvfølgelig en forkortelse for structure. I andre sprog hedder
det en "record".
</para>

<example id="ex-aggregate">
<title>En struct</title>
<programlisting role="C">
struct tomat_t {
   int typenummer;
   char artsnavn[80];
   int goedningsforbrug;
   int pladskrav;
   int temperaturkrav;
   int saesonpris[24];
};

</programlisting>
</example>

<para>
Når man erklærer en struct efter ovenstående mønster, indsættes
en oplysning i compilerens symboltabel om typens navn, størrelse
samt offset og type på de enkelte elementer.
</para>

<para>
"tomat_t" kaldes en type tag, og den tjener to formål - dels
kan vi senere erklære flere variable af denne type, dels kan vi
erklære en pointer til samme type inden i vores struct. Derved
kan vi opbygge en kæde af elementer. En sådan kæde kaldes en
linked liste på engelsk (se <xref LinkEnd="sect-linked-list">)
</para>

<para>
Derefter kan man definere variable af den pågældende type med
syntaksen:
</para>

<example id="ex-definition">
<title>Definition af en variabel</title>
<programlisting role="C">
struct tomat_t sunglow;
</programlisting>
</example>

<para>
Det er ikke alle programmører, som kan lide denne notation.
Derfor er der mange, som benytter sig af <emphasis> typedef
</emphasis> til at danne nye typebetegnelser.
</para>

<example id="ex-typedef">
<title>Struct type ved hjælp af typedef</title>
<programlisting role="C">
typedef struct tomat_tag {
    int ident;
    char name[80];
    int spacing;
    /* etc - etc. */
} tomat_type, *tomat_ptr;

tomat_type softball;
tomat_ptr current_tomat;

</programlisting>
</example>

<para>
Det er meget rart, at man kan se på ordet tomat_type, at det ikke
er en variabel, men er en type. Ellers må man huske, at et ord
foran et andet <emphasis> skal </emphasis> være en
typebetegnelse. Til gengæld kan det være sværere for compileren
at finde ud af at diagnosticere fejl. I C++ er det altid tilladt
at udelade nøgleordene struct og class, undtagen i erklæringen af
typen.
</para>

<programlisting id="proglist-cplusplus-struct">
tomat_type red_sun;
</programlisting>

<para>
I parentes bemærket er der danske virksomheder, som har haft
enorme ekstraudgifter på at bruge danske betegnelser i
programmer, som skulle eksporteres, så det er nok klogt ved alle
større projekter at erkende babelstårn problematikken og benytte
engelsk, latin eller esperanto.
</para>

<example id="ex-declaration-and-definition">
<title>Erklæring og definition</title>
<programlisting role="C">
struct tomat_ty {
   int identifikation;
   char art[80];
   int goedningsforbrug;
   int pladskrav;
   int temperaturkrav;
   int saesonpris[24];
} sungold;

</programlisting>
</example>

<para>
I eksempel <xref LinkEnd="ex-declaration-and-definition"> er der
både erklæret en type, nemlig <emphasis>tomat_ty</emphasis>, og
en variabel, <emphasis>sungold</emphasis>. Bør kun anvendes i
ultrakorte programmer (stenografi-orienterede;-).
</para>
</sect2>

<sect2 id="sect-linked-list">
<title>Den linkede liste</title>
<para>
En af de mere almindelige abstrakte datatyper er den linkede
liste, på dansk en sammenkædet liste. Elementer kædes sammen ved
hjælp af en pointer, således at hvert element peger på det næste.
</para>

<para>
Et liste-element kan indeholde den eller de datatyper, man har
behov for. Hvis listen skal indeholde elementer af forskellig
størrelse, kan man enten udnytte, at det sidste element i en
struct kan strække sig ud over stuct'ens normale størrelse, eller
man kan benytte sig af en pointer til de data, som har variabel
størrelse. Det sidste er den "pæneste" løsning.
</para>

<para>
Hvis vi fx. skal liste et directory, kan vi samle de oplysninger,
som vi ønsker at gemme, op i en struct. I nedenstående eksempel
ønsker vi at sortere filerne på i-node nummer. Det kan gøres med
<literal> ls -i | sort </literal>, men for at få nogle ægte
eksempler på anvendelse af struct og pointere er det meget godt
at gå om bag kulisserne og se, hvordan ls programmet egentlig
bærer sig ad.
</para>

<para>
Når man skal finde en funktion i manual - pages, så kan man
benytte man -k (keyword). prøv fx. man -k printf. Der kommer
mange svar-linier. En af dem siger printf(1) - det er
kommando-linie versionen af printf. Men den vi bruger til C
programmer hedder printf(3). Tallene i parenteserne henviser til
manual-sektioner. Disse sektioner kan man læse mere om med
kommandoen <command> man 7 man </command>.
</para>

<para>
Når der nu nedenfor står readdir(3) er det altså den readdir
funktion, som beskrives i manual - sektion nummer 3, som det
handler om. Pas på readdir(2), som kommer på skærmen hvis man
blot skriver kommandoen <literal> man readdir </literal>.
</para>

<para>
readdir(3) er en POSIX funktion, som læser en entry fra et
directory og returnerer en pointer til en struct, der indeholder
navn og det tilhørende i-node nummer. Hvis man benytter
i-node-nummeret, er programmet ikke posix-compliant, men det er
der jo ikke noget at gøre ved (og det er ikke så vigtigt her).
</para>

<para>
Før man kan bruge readdir(3) skal man åbne directory-filen (et
directory er en fil på linie med alle andre filer, bestående af
filnavne og tilhørende i-node nummer. En fil kan have mange
navne, men i-node nummeret er en entydig definition af de
datablokke, som tilsammen udgør abstraktionen en fil. En fil er
en ordnet sekvens af bytes.)
</para>

<para>
opendir(3) får blot et navn (default ".", current dir, ligesom
programmet <emphasis>ls</emphasis>.) Når den returner, giver den
enten et "håndtag" til dir-filen, i stil med fopen(3). Hvis den
ikke kan finde et directory med det navn, som vi giver den,
returnerer den NULL. Det er en indikation af en fejlsituation, og
vi lader simpelthen programmet dø med en exitkode, som fortæller,
at det ikke gik godt.
</para>

<para>
Retur typen for opendir(3) er et interessant eksempel på en
struct, som vi får navn på - men som vi rent faktisk ikke ved
noget om. Vi har ikke størrelsen på denne struct, og en erklæring
af et objekt af denne type vil give en oversætter-fejl. 
Stik mod god skik er her et eksempel, som ikke kan oversættes:
</para>

<example id="ex-ukendt-objekt">
<title>Ukendt objekt.</title>
<programlisting role="C">
/* notgood.c, program som ikke kan oversaettes. */
#include &lt;stdio.h>
#include &lt;dirent.h>

main()
{
	DIR dirobjekt;
	printf("Programmet kører ... \n");
	return 0;
}

</programlisting>
</example>

<para>
Vi har (forsøgt) at erklære et objekt af typen DIR - men det kan
man ikke, for selv om typen DIR er defineret i &lt;dirent.h>, er
det <emphasis> kun sket som en typedef erklæring af en pointer
til et ukendt objekt.</emphasis>
</para>

<para>
Nedenfor følger så et eksempel på, at man GERNE må erklære et
objekt, som er en pointer til en ukendt genstand (jævnfør en void
pointer).
</para>


<example id="ex-typeloes-pointer">
<title>Pointer til ukendt objekt.</title>
<programlisting role="C">
/* memhog.c, program som allokerer 20MB RAM og venter */
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef struct dummy OBJEKT;
main()
{
	OBJEKT *p2objekt;
	p2objekt = malloc(20 * 1024 * 1024);
	if (p2objekt == NULL)
		printf("Ikke nok memory\n");
	else
		printf("Har allokeret 20MB memory\n");
	getchar();
	return 0;
}

</programlisting>
</example>

<para>
Ovenstående program oversættes uden warning/error. Det kan også
køre. I oversættelses-forløbet registreres blot, at OBJEKT er en
ukendt struct, og så er det tilladt at lave en pointer til den.
Alle forsøg på at erklære et "rigtigt" objekt af denne type og
alle forsøg på pointer-aritmetik (dvs. at skubbe pointeren hen på
næste objekt) vil udløse en fatal oversættelsesfejl, fordi
størrelsen er ukendt.
</para>

<para>
Forresten, nu vi er ved det, programmet bruger faktisk ikke ret
meget ram, fordi det ikke forsøger at skrive til den allokerede
blok. ps -u -C kan vise, hvordan det forholder sig:
</para>

<screen>
<PROMPT>ax@pluto:/udvikl$ </PROMPT> <USERINPUT>ps -u -C</USERINPUT>
USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
root     25170  0.1  0.9 21208  292 ttyp1    S    00:59   0:00 memhog
</screen>

<para>
Kolonnen VSZ viser forbruget af virtuel memory. Virtuel i denne
sammenhæng betyder, at der er reserveret adresser, men ikke
fysisk ram til disse 20 millioner bytes. RSS kolonnen viser
Resident Set Size, d.v.s. hvor meget fysisk RAM der faktisk anvendes.
</para>

<para>
Tilbage til dirlist1.c. Kommer opendir(3) tilbage med en gyldig
pointer (d.v.s. en som ikke er NULL), så kan vi fortsætte med at
kalde readdir(3), indtil <emphasis>den</emphasis> kommer tilbage 
med en NULL pointer.
</para>

<para>
Readdir(3) har sin egen private (static) buffer, og det er derfor
nødvendigt at gemme de oplysninger, som vi ønsker at gemme, i en
buffer. I første version undlader vi at gemme, fordi vi blot
ønsker at kontrollere, at opendir, readdir og closedir fungerer,
sådan som vi forventer.
</para>

<example id="ex-dirlist1">
<title>Listning af filnavne i et directory</title>
<programlisting role="C">
/* dirlist1.c læser alle navne i et directory */
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;dirent.h>

int showdir(char *dirname);

main(int argc, char *argv[])
{
	char *dirname;
	if (argc &lt; 2)
		dirname = ".";
	else
		dirname = argv[1];

	return showdir(dirname);
}

int showdir(char *name)
{
	DIR *d;
	struct dirent *dent;

	if ((d=opendir(name)) == NULL)
		return 1;
	while (dent = readdir(d))
		printf("Return from readdir: %s\n",dent->d_name);
	closedir(d);
	return 0;

}

</programlisting>
</example>

<para>
Hvordan kan programmøren nu vide, at navnefeltet i directory -
entry'en har betegnelsen d_name? Det kan man finde ud af på to
eller tre måder. Først benyttes man (manual) systemet. Hvis dette
ikke indeholder oplysning om readdir(3) funktionen, må man finde
headerfilen i /usr/include. Info systemet (evt. via emacs) kan
altid fortælle om glibc og GNU-C relaterede emner. Hvis dette
ikke er så rart at bladre i (der står for meget), er der ikke
andet at gøre end at finde source-filerne frem til glibc, pakke
ud og se, hvad man kan finde ud af om library funktionerne. Det
er ikke let at læse glibc - kildeteksterne. Det kræver bl.a.
beherskelse af emacs, som kan bruges til at fjerne alle de
#ifdef - styrede multiplatform blokke.
</para>

<para>
struct dirent findes i /usr/include/dirent.h. Det er den
ultimative sandhed her. <command> man readdir(3) </command> kunne
være forældet eller fejlagtig, men header-filen må være korrekt
for at glibc kan kompileres. Men selvfølgelig kan der også være
opstået fejl her, en anden header fil kan have sneget sig ind
(somme tider er det godt at være paranoid!)
</para>

<para>
Struct dirent kan se forskellig ud på forskellige systemer, 
derfor er det, at Posix standarden advarer mod at bruge andet end
navnet. Med navnet kan man såmænd også hive alle andre
oplysninger om filen frem, (se stat(3)).
</para>

<para>
Næste version, dirlist2.c, skal gemme alle navne med tilhørende
i-node nummer (og eventuelt flere andre oplysninger).
</para>

<example id="ex-linked-liste">
<title>Linked liste, oprettelse og gennemløb</title>
<programlisting role="C">
/* dirlist2.c læser og gemmer alle filnavne i et directory */

#include  ... /* main er den samme som dirlist1.c */


/* et liste element indeholder en pointer til næste element samt data eller
 * som her en pointer til allokeret blok der kan variere i størrelse.
 * Som navnet antyder, kunne man save flere oplysninger om hver directory
 * entry, men her er det kun navnet, som saves. For et mere fuldkomment
 * eksempel på, hvordan man gemmer alle oplysninger om en fil, se fileutils
 * source - eller nogle af de talrige andre eksempler, som kan findes på
 * nettet (fx. metalab.unc.edu - søg efter ydir).
 */

struct dirsav_t {
	char * name;
	struct dirsav_t * next;
};

static struct dirsav_t *createnew();
void insert_list(struct dirsav_t *head, char *data, int len);
void show_list(struct dirsav_t *head);

int showdir(char *name)
{
	DIR *d;
	struct dirent *dent;
	struct dirsav_t *head;

	if ((d=opendir(name)) == NULL)
		return 1;
	head = createnew();
	head->next = NULL;
	while (dent = readdir(d))
		insert_list(head, dent->d_name, strlen(dent->d_name));
	closedir(d);
	show_list(head);
	return 0;

}

</programlisting>
</example>

<para>
Som de ses er showdir funktionen ombygget, så den benytter sig af
et interface til nogle funktioner, som ikke er skrevet endnu. Der
oprettes en liste ved at det første element initialiseres, og
derefter indsættes det læste filnavn, hver gang readdir kaldes.
</para>

<para>
Hvis det kun var filnavnet, vi var interesserede i, ville det
være nemmere at lave et array af character pointere, men her er
det meningen på lidt længere sigt, at vi skal kunne indsætte et
ikke forud kendt antal elementer.
</para>

<example id="ex-liste-funktioner">
<title>Enkel implementering af linked liste</title>
<programlisting role="C">
/* Del 2 af programmet dirlist2.c - her er de tre funktioner, som
 * henholdsvis allokerer et nyt liste-element, indsætter et
 * element og show_list, som gennemløber listen. */

/* createnew() stopper programmet, hvis der ikke er mere ram. Det er den
 * enkleste og mest relevante fejl håndtering (her): Succes eller dø.
 * Et mere sigende navn kunne være mustCreatenew(); */

static struct dirsav_t * createnew()
{
	void *p2l;
	p2l = malloc(sizeof(struct dirsav_t));
	if (!p2l) {
		perror("Could not get memory for listmember");
		exit(254);
	}
	return p2l;
}

/* denne insert funktion er så simpel som mulig. Se evt. dirlist3.c (kommer
 * snart ... */

void insert_list(struct dirsav_t *ptr, char *obj, int len)
{
	struct dirsav_t *e;
				/* der reserveres hukommelse til det
				 * listeelement, som skal indsættes. */
	e = createnew();
	e->next = NULL;
				/* listen gennemløbes for at finde sidste
				 * element. Alternativt kunne man stoppe,
				 * når man nåede det sted, hvor det nye
				 * element passede ind, alfabetisk sorteret. */
	while (ptr->next)
		ptr = ptr->next;
				/* nu indsættes det nye element i den next
				 * pointer, som før var NULL. */
	ptr->next = e;
				/* så allokeres mere memory til den string
				 * eller andre data, som skal gemmes. */
	e->name = malloc(len+1);
				/* til sidst flyttes data over. Det er
				 * callers ansvar, at len er korrekt. */
	memcpy(e->name,obj,len);
}

/* løb gennem listen, spring første element over (for nemheds skyld bliver
 * det første element aldrig brugt til andet end til at pege på det næste)
 * Denne funktion VED at der er tale om en zero delimited character string
 * i namefeltet.
 * */

void show_list(struct dirsav_t *ptr)
{
	while(ptr = ptr->next)
		printf("Filename: %s\n",ptr->name);

}

</programlisting>
</example>

<para>
Eksemplet her egner sig godt til at arbejde videre med.
</para>


</sect2>
</sect1>
</chapter>

<chapter id="parser-tilstandsmaskine">
<title>Parsere og tilstandsmaskiner</title>

<sect1 id="declaration-parser">
<title>En declaration parser</title>

<para>
Erklæringer kan være vanskelige at læse, især når der indgår
pointere til funktioner. Installation af en signal handler med
funktionen signal(2) er kendt for sin vanskelige prototype.
</para>

<para>
Det ville være en god øvelse at skrive en komplet declaration
parser (og en sådan er på ønskesedlen til en udvidet version af
denne bog). Imidlertid findes der allerede en meget instruktiv
parser til interaktiv / didaktiv anvendelse, cdecl.
</para>

<para>
Cdecl manual-page går ud fra, at man er bekendt med de
væsentligste problemstillinger, men den forklarer ikke, hvordan
man løser læselighedsproblemet, hvis man ikke lige har cdecl ved
hånden!
</para>

<para>
For at gøre tingene vanskeligere, er Linux/Gnu signal.h fuld af
defines og særlige syntaktiske konstruktioner, som skal lette
læsningen for den erfarne multiplatform programmør - men som gør
det fuldstændigt umuligt for den almindelige begynder at finde
hoved og hale. I dette tilfælde er manual page for signal(2) en
lettelse. Der er oven i købet en forklaring på, hvordan man kan
opbygge deklarationen ved hjælp af "typedef"ning. Manual siderne
for glibc er med i RedHat og andre distributioner, men er ikke
en del af glibc systemet, der kun anvender info-pages.
</para>

<para>
Men i header filerne - kast et blik på /usr/include/signal.h - er
der så mange hensyn til diverse platforme at det bliver næsten
ulæseligt. Leder vi på "signal(" finder vi:
</para>

<para>
<literal>
#define signal(sig, handler) __sysv_signal ((sig), (handler))
</literal>
</para>

<para>
Ovenstående define kan man ikke fodre cdecl med. Heldigvis er
den ikke så svær at forstå. Signal er en funktion som skal
erstattes af __sysv_signal. De to parametre skal gives videre som
de er. Det ene skal være et signal, (fx. INTR, svarende
til control-C) og det andet skal være den funktion, som vi vil
have kørt, når vores program modtager signalet. Men så må vi jo
kigge efter, hvordan headerfilen definerer __sysv_signal().
</para>

<para>
<literal>
extern __sighandler_t __sysv_signal __P ((int __sig, __sighandler_t __handler));
</literal>
</para>

<para>
Heri indgår der - desværre - også en #define macro, nemlig
__sighandler_t. Så det er en større sag at finde rundt i.
</para>

<para>
Det, som cdecl er glimrende til, er at fodre den med en vanskelig
prototype og så se, hvordan den vil forklare det.
</para>

<para>
Vi finder med <command> man signal </command> følgende prototype:
</para>

<para>
<literal>
void (*signal(int signum, void (*handler)(int)))(int);
</literal>
</para>

<para>
Er det en void funktion? Jeg spørger bare ... Nej, det er ikke en
void funktion, det er en funktion, som returnerer en pointer til
en anden funktion, som er void. Nemlig den tidligere signal
handler. Så kan man jo geninstallere den, hvis man på et
tidspunkt skal tilbage til forrige niveau af signal handling.
</para>

<indexterm><primary>cdecl, eksempel på anvendelse</primary></indexterm>
<screen id="cdecl">
<PROMPT>ax@pluto:/udvik/$</PROMPT><USERINPUT>cdecl</USERINPUT>
<prompt>cdecl></prompt><userinput>void (*signal(int signum, void (*handler)(int)))(int)</userinput>
syntax error
</screen>

<para>
Ja, desværre kan denne udmærkede lille applikation heller ikke
klare denne iøvrigt korrekte prototype, så der er virkelig et
problem her.
</para>

<para>
Løsningen er, uden de store anstrengelser, at lære sig
"højre-venstre" teknikken. Vi kan også implementere en lille kopi
af cdecl programmet, som om ikke andet så kan håndtere de
simpleste deklarationer med funktions-pointere.
</para>

<para>
Højre venstre - teknikken består i at læse indefra den
identifier, som man ønsker at forstå. I ovenstående erklæring
"signal".
</para>

<para>
Til HØJRE for signal er der en parentes start. Det betyder:
"Signal er en funktion ..."
</para>

<para>
Efter parameter parentesen er der "lukket" ved hjælp af en
slut-parentes ekstra. Derfor må vi gå til VENSTRE. Vi er nu nået
til, at vi forventer angivelse af retur-type.
</para>

<para>
Til venstre står der '*' hvilket vi læser som "returnerer en
pointer til ..." - til hvad?
</para>

<para>
Parentes start spærrer for yderligere adgang til venstre, så vi
går mod højre, udenfor den matchende parentes og ser efter denne
endnu en parentes, aha, en pointer TIL EN FUNKTION, der står jo
igen parenteser, og i øvrigt med en int som parameter. Det mest
vanskelige er, at den VOID, som står forrest på linien, er retur
type angivelse til denne funktionspointer.
</para>

<para>
Det er ikke nemt. Læs man - siden for signal, den forklarer (som
nævnt ovenfor), at meningen med signal er, at den returnerer den
tidligere handler, så man kan reinstallere den senere.
</para>


</sect1>

<sect1 id="expression-parser">
<title>En expression parser</title>
<para>
Et program, som kan fodres med beregningsudtryk og levere
resultatet. Eksempel på input:
</para>
<programlisting>
calcu '200 * sin(0.444)'
85.911

calcu &lt;&lt;SLUT
2 + 3
5 * X
SLUT

Calc:      5.0000
Calc:     25.0000
Calc:

calcu
Calc: 32/square(2)
         ^Error
</programlisting>

<para>
Programmet benytter en særlig slem variant af printf format
specification, som skriver et antal spaces ud styret af en
variabel:
<literal>
printf("En padded string: %*s\n",lengde,string);
</literal>
Meget smart - men første gang lidt vanskeligt at læse og forstå.
Det styrer angivelsen af error positionen.
</para>

<para>
Programmet er i sin nuværende form ganske anvendeligt, fordi det
kan fungere som erstatning for expr programmet, der stiller alt
for mange krav til spaces og anden formatering til de
expressions, som skal evalueres. Men programmet kan simpelt hen
også anvendes til beregning af prislister (det har det faktisk
været!)
</para>

<example id="calculator">
<title>Calculator, recursive descent expression parsing </title>
<programlisting>
/* file calcu.c */
/* (c) Donald Axel GPL - license */
/* ANSI - C program demonstration, command line calculator */
/* Recursive descent parser */
/* Improve: Make a HELP command. Add more variables.       */

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;math.h>



#define MAXL 8196
char gs[MAXL];
char *cp;
char *errorp;
double oldval;

/* local prototypes: */
int calcu();
int evaluate(char *line, double *prev_result);
int stricmp(const char *s1, const char *s2);
int strnicmp(const char *s1, const char *s2, int len);


int main(int argc, char *argv[])
{
    int rv, jj;

    jj = 0;
    while (++jj &lt; argc) {
        strcat(gs, argv[jj]);
    }
    if (argc == 1)
        return calcu();
    strcat(gs, "\n");
    rv = evaluate(gs, &amp;oldval);
    if (!rv)
        printf("%g\n", oldval);
    else
        printf("Calcu:%s\n%*s\n", gs, rv, "^Error");
    return rv;
}


/* Description: */
/* calcu() sets up a string which is then evaluated as an expression  */
/* If (argc>1) main sets up string for evaluate() and prints result.  */
/* stricmp does not stop at '\n' - so we have to compare with "xx\n"  */
/* gettok() could solve that problem. TRY to use gettok().            */



int nextchar()
{
    ++cp;
    while (*cp == ' ')
        ++cp;
    return *cp;
}


int eatspace()
{
    while (*cp == ' ')
        ++cp;
    return *cp;
}


int calcu()
{
    FILE *ifil;
    char line[MAXL];
    int rpos;
    double r;

    ifil = stdin;
    while (1) {
        errorp = NULL;
        printf("Calc:");
        if (!fgets(line, MAXL, ifil))
            break;
        if (strlen(line) &amp;&amp; strnicmp(line,"QUIT",4)
&amp;&amp; stricmp(line,"Q\n"))
            rpos = evaluate(line, &amp;r);
        else
            break;
        if (!rpos) {
            printf("%-18g\n", r);
            oldval = r;
        } else {                /* prints Error in field min. 12 wide */
            printf("%*s\n", rpos, "^Error");
        }
    }
    return rpos;                /* if interactive rpos should always be 0 */
}


/* More local prototypes. This could, of course, be a separate file. */
double expression();
double product();
double potens();
double signedfactor();
double factor();
double stdfunc();


int evaluate(char *s, double *r)
{
    cp = s;
    eatspace();
    *r = expression();
    eatspace();
    if (*cp == '\n' &amp;&amp; !errorp)
        return (0);
    else
        return (cp - s) + 11;
}


double expression()
{
    double e;
    int opera2;

    /* printf("test arg:%s\n",cp); */

    e = product();
    while ((opera2 = *cp) == '+' || opera2 == '-') {
        nextchar();
        if (opera2 == '+')
            e += product();
        else
            e -= product();
    }
    eatspace();
    return e;
}


double product()
{
    double dp;
    int ope;

    dp = potens();
    while ((ope = *cp) == '*' || ope == '/') {
        nextchar();
        if (ope == '*')
            dp *= potens();
        else
            dp /= potens();
    }
    eatspace();
    return dp;
}


double potens()
{
    double dpo;

    dpo = signedfactor();
    while (*cp == '^') {
        nextchar();
        dpo = exp(log(dpo) * signedfactor());
    }
    eatspace();
    return dpo;
}


double signedfactor()
{
    double ds;
    if (*cp == '-') {
        nextchar();
        ds = -factor();
    } else
        ds = factor();
    eatspace();
    return ds;
}


double factor()
{
    double df;

    /* while (*cp!='\n') {
       putchar(*cp++);
       } 
     */

    switch (*cp) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        df = strtod(cp, &amp;cp);
        break;
    case '(':
        nextchar();
        df = expression();
        if (*cp == ')')
            nextchar();
        else
            errorp = cp;
        break;
    case 'X':
        nextchar();
        df = oldval;
        break;

    default:
        df = stdfunc();
    }
    /* printf("ddt: df = %lf, *cp = %c\n",df,*cp); */

    eatspace();
    return df;
}


char *functionname[] =
{
    "abs", "sqrt", "sin", "cos", "atan", "log", "exp", "\0"
};

double stdfunc()
{
    double dsf;
    char **fnptr;
    int jj;

    eatspace();
    jj = 0;
    fnptr = functionname;
    while (**fnptr) {
        /* printf("%s\n",*fnptr); */
        if (strncmp(*fnptr, cp, strlen(*fnptr)) == 0)
            break;

        ++fnptr;
        ++jj;
    }
    if (!**fnptr) {
        errorp = cp;
        return 1;
    }
    cp += (strlen(*fnptr) - 1);
    nextchar();
    dsf = factor();
    switch (jj) {
    case 0: dsf = abs(dsf);  break;
    case 1: dsf = sqrt(dsf); break;
    case 2: dsf = sin(dsf);  break;
    case 3: dsf = cos(dsf);  break;
    case 4: dsf = atan(dsf); break;
    case 5: dsf = log(dsf);  break;
    case 6: dsf = exp(dsf);  break;
    default:{
            errorp = cp;
            return 4;
        }
    }
    eatspace();
    return dsf;
}


/* end calcu.c */


</programlisting>
</example>
</sect1>


<sect1 id="Tilstandsmaskiner">
<title>Tilstandsmaskiner</title>
<para>
Tilstandsmaskiner er betegnelse for 2 ting. Alle programmer
er tilstands-maskiner. En speciel teknik, som anvendes i parsere,
indeholder en tilstandstabel.
</para>

<para>
Hvis man vil se en "rigtig" tilstandsmaskine, så kan man studere
output fra yacc eller bison parser-generatorer.
</para>

<para>
Næste udgave af denne bog vil bringe nogle overskuelige eksempler
på tilstandstabeller, genererede med bison og "håndlavede". Følg
med på www.sslug.dk i de nye udgaver af "Friheden" bøgerne!
</para>

</sect1>
</chapter>

