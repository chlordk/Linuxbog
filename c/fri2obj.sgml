<chapter id="object-orienteret-tankegang">
<title>Tankegang bag objektorienteret programmering</title>
<sect1 id="datatyper"><title>Konkrete og abstrakte datatyper</title>
<para>
Er C et objektorienteret sprog? Hvorfor er det ikke
objektorienteret, når et C program er en række definitioner af
eksterne objekter? (external objects?)
</para>

<para>
Det korte svar er, at almindelig C ikke har virtuelle
funktioner. Desuden er der ikke support for generisk algoritme
programmering. Det er imidlertid interessant at vide, at C
sproget som sådan ikke forhindrer programmøren i at tænke
objektorienteret. I dette afsnit vil vi sammenligne to udgaver af
en linked liste, den ene skrevet i C og den anden i C++.
</para>

<para>
I øvrigt har de fleste sprog nogle mekanismer, som er
rigtigt objektorienterede, nemlig håndteringen af forskellige
numeriske typer.
</para>

<para>
Vi kan have en integer i en variabel og gange den med en
float og lægge resultatet i en double uden at compileren gider
fortælle, at der skal konverteres. Taber vi præcision ved at
konvertere fra double til integer, vil de fleste compilere give
en warning, men de konverterer dog.
</para>

<para>
Det er egentlig objektorientering i en nøddeskal. Definer
din algoritme (fx. addition) og sørg for, at den kan håndtere
forskellige data, d.v.s. objekter, på en passende måde.  Det
vanskelige ved objektorientering kommer, når man definerer nye
klasser eller objekttyper og så skal til at skrive regler for,
hvordan operatorer skal fungere etc. Som en øvelse i
objekt-orienteret tankegang kan man prøve at definere en struct,
som skal repræsentere brøker, som fx. 2/3, der jo ikke er det
samme som 0.6667.
</para>

<para>
I C++ bliver det muligt at erklære en variabel af typen
broek (eller reference til broek) som fx. nedenstående eksempel
</para>

<programlisting role="C">
broek andel(2,3);
int bogpris = 350;
afgift = bogpris * andel;
</programlisting>

<para>
Forudsat, selvfølgelig, at man har defineret typen broek og
tilhørende operationer på en passende måde!
</para>

</sect1>

<sect1 id="sect-abstract-datatypes">
<title>Abstrakte data typer</title>
<para>
For at programmere på højt niveau i C sproget benyttes
sammensatte datatyper. For at bevare overblikket indkapsles
operationerne på data som regel ved hjælp af modularisering,
således at al tilgang til data sker gennem funktionskald. Et
kendt eksempel er fil tilgang, som klares ved hjælp af datatypen
FILE, som man ikke skal "dissekere", men blot benytter som et
håndtag til den datastrøm, hvorpå man ønsker at udføre
IO-operationer.
</para>

<para>
Det kan ikke understreges nok, at nøglen til succes er kendskab
til funktions interfacet og de andre teknikker til at indkapsle
de data, der naturligt hører sammen.
</para>

<sect2 id="sect-sammensatte-datatyper">
<title>Sammensatte datatyper</title>
<para>
Sammensatte datatyper er nyttige, når vi i et program har brug
for at samle informationer om et "objekt i den virkelige verden".
Den engelske betegnelse er <emphasis>aggregate data
types</emphasis>, men det giver også mening at kalde dem for
brugerdefinerede datatyper.
</para>

<para>
Sammensatte datatyper er, som ordet siger, en sammensætning af
forskellige typer data. I C sproget erklæres en sådan datatype
ved hjælp af nøgleordet <emphasis> struct </emphasis>. Det er
selvfølgelig en forkortelse for structure. I andre sprog hedder
det en "record".
</para>

<example id="ex-aggregate">
<title>En struct</title>
<programlisting role="C">
struct tomat_t {
   int typenummer;
   char artsnavn[80];
   int goedningsforbrug;
   int pladskrav;
   int temperaturkrav;
   int saesonpris[24];
};

</programlisting>
</example>

<para>
Når man erklærer en struct efter ovenstående mønster, indsættes
en oplysning i compilerens symboltabel om typens navn, størrelse
samt offset og type på de enkelte elementer.
</para>

<para>
"tomat_t" kaldes en type tag, og den tjener to formål - dels
kan vi senere erklære flere variable af denne type, dels kan vi
erklære en pointer til samme type inden i vores struct. Derved
kan vi opbygge en kæde af elementer. En sådan kæde kaldes en
linked liste på engelsk (se <xref LinkEnd="sect-linked-list">)
</para>

<para>
Derefter kan man definere variable af den pågældende type med
syntaksen:
</para>

<example id="ex-definition">
<title>Definition af en variabel</title>
<programlisting role="C">
struct tomat_t sunglow;
</programlisting>
</example>

<para>
Det er ikke alle programmører, som kan lide denne notation.
Derfor er der mange, som benytter sig af <emphasis> typedef
</emphasis> til at danne nye typebetegnelser.
</para>

<example id="ex-typedef">
<title>Struct type ved hjælp af typedef</title>
<programlisting role="C">
typedef struct tomat_tag {
    int ident;
    char name[80];
    int spacing;
    /* etc - etc. */
} tomat_type, *tomat_ptr;

tomat_type softball;
tomat_ptr current_tomat;

</programlisting>
</example>

<para>
Det er meget rart, at man kan se på ordet tomat_type, at det ikke
er en variabel, men er en type. Ellers må man huske, at et ord
foran et andet <emphasis> skal </emphasis> være en
typebetegnelse. Til gengæld kan det være sværere for compileren
at finde ud af at diagnosticere fejl. I C++ er det altid tilladt
at udelade nøgleordene struct og class, undtagen i erklæringen af
typen.
</para>

<programlisting id="proglist-cplusplus-struct">
tomat_type red_sun;
</programlisting>

<para>
I parentes bemærket er der danske virksomheder, som har haft
enorme ekstraudgifter på at bruge danske betegnelser i
programmer, som skulle eksporteres, så det er nok klogt ved alle
større projekter at erkende babelstårn problematikken og benytte
engelsk, latin eller esperanto.
</para>

<example id="ex-declaration-and-definition">
<title>Erklæring og definition</title>
<programlisting role="C">
struct tomat_ty {
   int identifikation;
   char art[80];
   int goedningsforbrug;
   int pladskrav;
   int temperaturkrav;
   int saesonpris[24];
} sungold;

</programlisting>
</example>

<para>
I eksempel <xref LinkEnd="ex-declaration-and-definition"> er der
både erklæret en type, nemlig <emphasis>tomat_type</emphasis>, og
en variabel, <emphasis>sungold</emphasis>. 
</para>
</sect2>

<sect2 id="sect-linked-list">
<title>Den linkede liste</title>
<para>
En af de mere almindelige abstrakte datatyper er den linkede
liste, på dansk en sammenkædet liste. Elementer kædes sammen ved
hjælp af en pointer, således at hvert element peger på det næste.
</para>

<para>
Et liste-element kan indeholde den eller de datatyper, man har
behov for. Hvis listen skal indeholde elementer af forskellig
størrelse, kan man enten udnytte, at det sidste element i en
struct kan strække sig ud over stuct'ens normale størrelse, eller
man kan benytte sig af en pointer til de data, som har variabel
størrelse. Det sidste er den "pæneste" løsning.
</para>

<para>
Hvis vi fx. skal liste et directory, kan vi samle de oplysninger,
som vi ønsker at gemme, op i en struct. I nedenstående eksempel
ønsker vi at sortere filerne på i-node nummer. Det kan gøres med
<literal> ls -i | sort </literal>, men for at få nogle ægte
eksempler på anvendelse af struct og pointere er det meget godt
at gå om bag kulisserne og se, hvordan ls programmet egentlig
bærer sig ad.
</para>

<para>
Når man skal finde en funktion i manual - pages, så kan man
benytte man -k (keyword). prøv fx. man -k printf. Der kommer
mange svar-linier. En af dem siger printf(1) - det er
kommando-linie versionen af printf. Men den vi bruger til C
programmer hedder printf(3). Tallene i parenteserne henviser til
manual-sektioner. Disse sektioner kan man læse mere om med
kommandoen <command> man 7 man </command>.
</para>

<para>
Når der nu nedenfor står readdir(3) er det altså den readdir
funktion, som beskrives i manual - sektion nummer 3, som det
handler om. Pas på readdir(2), som kommer på skærmen hvis man
blot skriver kommandoen <literal> man readdir </literal>.
</para>

<para>
readdir(3) er en POSIX funktion, som læser en entry fra et
directory og returnerer en pointer til en struct, der indeholder
navn og det tilhørende i-node nummer. Hvis man benytter
i-node-nummeret, er programmet ikke posix-compliant, men det er
der jo ikke noget at gøre ved (og det er ikke så vigtigt her).
</para>

<para>
Før man kan bruge readdir(3) skal man åbne directory-filen (et
directory er en fil på linie med alle andre filer, bestående af
filnavne og tilhørende i-node nummer. En fil kan have mange
navne, men i-node nummeret er en entydig definition af de
datablokke, som tilsammen udgør abstraktionen en fil. En fil er
en ordnet sekvens af bytes.)
</para>

<para>
opendir(3) får blot et navn (default ".", current dir, ligesom
programmet <emphasis>ls</emphasis>.) Når den returner, giver den
enten et "håndtag" til dir-filen, i stil med fopen(3). Hvis den
ikke kan finde et directory med det navn, som vi giver den,
returnerer den NULL. Det er en indikation af en fejlsituation, og
vi lader simpelthen programmet dø med en exitkode, som fortæller,
at det ikke gik godt.
</para>

<para>
Retur typen for opendir(3) er et interessant eksempel på en
struct, som vi får navn på - men som vi rent faktisk ikke ved
noget om. Vi har ikke størrelsen på denne struct, og en erklæring
af et objekt af denne type vil give en oversætter-fejl. 
Stik mod god skik er her et eksempel, som ikke kan oversættes:
</para>


<example id="ex-ukendt-objekt">
<title>Pointer til ukendt objekt.</title>
<programlisting role="C">
/* memhog.c, program som allokerer 20MB RAM og venter */
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef struct dummy OBJEKT;
main()
{
	OBJEKT *p2objekt;
	p2objekt = malloc(20 * 1024 * 1024);
	if (p2objekt == NULL)
		printf("Ikke nok memory\n");
	else
		printf("Har allokeret 20MB memory\n");
	getchar();
	return 0;
}

</programlisting>
</example>

<para>
Ovenstående program oversættes uden warning/error. Det kan også
køre. I oversættelses-forløbet registreres blot, at OBJEKT er en
ukendt struct, og så er det tilladt at lave en pointer til den.
Alle forsøg på at erklære et "rigtigt" objekt af denne type og
alle forsøg på pointer-aritmetik (dvs. at skubbe pointeren hen på
næste objekt) vil udløse en fatal oversættelsesfejl, fordi
størrelsen er ukendt.
</para>

<para>
Forresten, nu vi er ved det, programmet bruger faktisk ikke ret
meget ram, fordi det ikke forsøger at skrive til den allokerede
blok. ps -u -C kan vise, hvordan det forholder sig:
</para>

<screen>
<PROMPT>ax@pluto:/udvikl$ </PROMPT> <USERINPUT>ps -u -C</USERINPUT>
USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
root     25170  0.1  0.9 21208  292 ttyp1    S    00:59   0:00 memhog
</screen>

<para>
Kolonnen VSZ viser forbruget af virtuel memory. Virtuel i denne
sammenhæng betyder, at der er reserveret adresser, men ikke
fysisk ram til disse 20 millioner bytes. RSS kolonnen viser
Resident Set Size, d.v.s. hvor meget fysisk RAM der faktisk anvendes.
</para>

<para>
Tilbage til dirlist1.c. Kommer opendir(3) tilbage med en gyldig
pointer (d.v.s. en som ikke er NULL), så kan vi fortsætte med at
kalde readdir(3), indtil <emphasis>den</emphasis> kommer tilbage 
med en NULL pointer.
</para>

<para>
Readdir(3) har sin egen private buffer, og det er derfor
nødvendigt at gemme de oplysninger, som vi ønsker at gemme, i en
buffer. I første version undlader vi at gemme, fordi vi blot
ønsker at kontrollere, at opendir, readdir og closedir fungerer,
sådan som vi forventer.
</para>

<example id="ex-dirlist1">
<title>Listning af filnavne i et directory</title>
<programlisting role="C">
/* dirlist1.c læser alle navne i et directory */
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;dirent.h>

int showdir(char *dirname);

main(int argc, char *argv[])
{
	char *dirname;
	if (argc &lt; 2)
		dirname = ".";
	else
		dirname = argv[1];

	return showdir(dirname);
}

int showdir(char *name)
{
	DIR *d;
	struct dirent *dent;

	if ((d=opendir(name)) == NULL)
		return 1;
	while (dent = readdir(d))
		printf("Return from readdir: %s\n",dent->d_name);
	closedir(d);
	return 0;

}

</programlisting>
</example>

<para>
Hvordan kan programmøren nu vide, at navnefeltet i directory -
entry'en har betegnelsen d_name? Det kan man finde ud af på to
eller tre måder. Først benyttes man (manual) systemet. Hvis dette
ikke indeholder oplysning om readdir(3) funktionen, må man finde
headerfilen i /usr/include. Info systemet (evt. via emacs) kan
altid fortælle om glibc og GNU-C relaterede emner. Hvis dette
ikke er så rart at bladre i (der står for meget), er der ikke
andet at gøre end at finde source-filerne frem til glibc, pakke
ud og se, hvad man kan finde ud af om library funktionerne. Det
er ikke let at læse glibc - kildeteksterne. Det kræver bl.a.
beherskelse af emacs, som kan bruges til at fjerne alle de
#ifdef - styrede multiplatform blokke.
</para>

<para>
struct dirent findes i /usr/include/dirent.h. Det er den
ultimative sandhed her. man readdir(3) kunne være forældet eller
fejlagtig, men header-filen må være korrekt for at glibc kan
kompileres. Men selvfølgelig kan der også være opstået fejl her,
en anden header fil kan have sneget sig ind (somme tider er det
godt at være paranoid!)
</para>

<para>
Struct dirent kan se forskellig ud på forskellige systemer, 
derfor er det, at Posix standarden advarer mod at bruge andet end
navnet. Med navnet kan man såmænd også hive alle andre
oplysninger om filen frem, (se stat(3)).
</para>

<para>
Næste version, dirlist2.c, skal gemme alle navne med tilhørende
i-node nummer (og eventuelt flere andre oplysninger).
</para>

<example id="ex-linked-liste">
<title>Linked liste, oprettelse og gennemløb</title>
<programlisting role="C">
/* dirlist2.c læser og gemmer alle filnavne i et directory */

#include  ... /* main er den samme som dirlist1.c */


/* et liste element indeholder en pointer til næste element samt data eller
 * som her en pointer til allokeret blok der kan variere i størrelse.
 * Som navnet antyder, kunne man save flere oplysninger om hver directory
 * entry, men her er det kun navnet, som saves. For et mere fuldkomment
 * eksempel på, hvordan man gemmer alle oplysninger om en fil, se fileutils
 * source - eller nogle af de talrige andre eksempler, som kan findes på
 * nettet (fx. metalab.unc.edu - søg efter ydir).
 */

struct dirsav_t {
	char * name;
	struct dirsav_t * next;
};

static struct dirsav_t *createnew();
void insert_list(struct dirsav_t *head, char *data, int len);
void show_list(struct dirsav_t *head);

int showdir(char *name)
{
	DIR *d;
	struct dirent *dent;
	struct dirsav_t *head;

	if ((d=opendir(name)) == NULL)
		return 1;
	head = createnew();
	head->next = NULL;
	while (dent = readdir(d))
		insert_list(head, dent->d_name, strlen(dent->d_name));
	closedir(d);
	show_list(head);
	return 0;

}

</programlisting>
</example>

<para>
Som de ses er showdir funktionen ombygget, så den benytter sig af
et interface til nogle funktioner, som ikke er skrevet endnu. Der
oprettes en liste ved at det første element initialiseres, og
derefter indsættes det læste filnavn, hver gang readdir kaldes.
</para>

<para>
Hvis det kun var filnavnet, vi var interesserede i, ville det
være nemmere at lave et array af character pointere, men her er
det meningen på lidt længere sigt, at vi skal kunne indsætte et
ikke forud kendt antal elementer.
</para>

<example id="ex-liste-funktioner">
<title>Enkel implementering af linked liste</title>
<programlisting role="C">
/* Del 2 af programmet dirlist2.c - her er de tre funktioner, som
 * henholdsvis allokerer et nyt liste-element, indsætter et
 * element og show_list, som gennemløber listen. */

/* createnew() stopper programmet, hvis der ikke er mere ram. Det er den
 * enkleste og mest relevante fejl håndtering (her): Succes eller dø.
 * Et mere sigende navn kunne være mustCreatenew(); */

static struct dirsav_t * createnew()
{
	void *p2l;
	p2l = malloc(sizeof(struct dirsav_t));
	if (!p2l) {
		perror("Could not get memory for listmember");
		exit(254);
	}
	return p2l;
}

/* denne insert funktion er så simpel som mulig. Se evt. dirlist3.c (kommer
 * snart ... */

void insert_list(struct dirsav_t *ptr, char *obj, int len)
{
	struct dirsav_t *e;
				/* der reserveres hukommelse til det
				 * listeelement, som skal indsættes. */
	e = createnew();
	e->next = NULL;
				/* listen gennemløbes for at finde sidste
				 * element. Alternativt kunne man stoppe,
				 * når man nåede det sted, hvor det nye
				 * element passede ind, alfabetisk sorteret. */
	while (ptr->next)
		ptr = ptr->next;
				/* nu indsættes det nye element i den next
				 * pointer, som før var NULL. */
	ptr->next = e;
				/* så allokeres mere memory til den string
				 * eller andre data, som skal gemmes. */
	e->name = malloc(len+1);
				/* til sidst flyttes data over. Det er
				 * callers ansvar, at len er korrekt. */
	memcpy(e->name,obj,len);
}

/* løb gennem listen, spring første element over (for nemheds skyld bliver
 * det første element aldrig brugt til andet end til at pege på det næste)
 * Denne funktion VED at der er tale om en zero delimited character string
 * i namefeltet.
 * */

void show_list(struct dirsav_t *ptr)
{
	while(ptr = ptr->next)
		printf("Filename: %s\n",ptr->name);

}

</programlisting>
</example>

<para>
Eksemplet her egner sig godt til at arbejde videre med.
</para>


</sect2>
</sect1>
</chapter>

<chapter id="parser-filter-tilstandsmaskine">
<title>Filter-programmer, parsere, tilstandsmaskiner</title>

<sect1 id="declaration-parser">
<title>En declaration parser</title>
<para>
Erklæringer, declarations.
</para>
</sect1>

<sect1 id="expression-parser">
<title>En expression parser</title>
<para>
Et program, som kan fodres med beregningsudtryk og levere
resultatet. Eksempel på input:
</para>
<programlisting>
calcu '200 * sin(0.444)'
85.911

calcu &lt;&lt;SLUT
2 + 3
5 * X
SLUT

Calc:      5.0000
Calc:     25.0000
Calc:

calcu
Calc: 32/square(2)
         ^Error
</programlisting>

<para>
Programmet benytter en særlig slem variant af printf format
specification, som skriver et antal spaces ud styret af en
variabel:
<literal>
printf("En padded string: %*s\n",lengde,string);
</literal>
Meget smart - men første gang lidt vanskeligt at læse og forstå.
Det styrer angivelsen af error positionen.
</para>

<para>
Programmet er i sin nuværende form ganske anvendeligt, fordi det
kan fungere som erstatning for expr programmet, der stiller alt
for mange krav til spaces og anden formatering til de
expressions, som skal evalueres. Men programmet kan simpelt hen
også anvendes til beregning af prislister (det har det faktisk
været!)
</para>

<example id="calculator">
<title>Calculator, recursive descent expression parsing </title>
<programlisting>
/* file calcu.c */
/* (c) Donald Axel GPL - license */
/* ANSI - C program demonstration, command line calculator */
/* Recursive descent parser */
/* Improve: Make a HELP command. Add more variables.       */

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;math.h>



#define MAXL 8196
char gs[MAXL];
char *cp;
char *errorp;
double oldval;

/* local prototypes: */
int calcu();
int evaluate(char *line, double *prev_result);
int stricmp(const char *s1, const char *s2);
int strnicmp(const char *s1, const char *s2, int len);


int main(int argc, char *argv[])
{
    int rv, jj;

    jj = 0;
    while (++jj &lt; argc) {
        strcat(gs, argv[jj]);
    }
    if (argc == 1)
        return calcu();
    strcat(gs, "\n");
    rv = evaluate(gs, &amp;oldval);
    if (!rv)
        printf("%g\n", oldval);
    else
        printf("Calcu:%s\n%*s\n", gs, rv, "^Error");
    return rv;
}


/* Description: */
/* calcu() sets up a string which is then evaluated as an expression  */
/* If (argc>1) main sets up string for evaluate() and prints result.  */
/* stricmp does not stop at '\n' - so we have to compare with "xx\n"  */
/* gettok() could solve that problem. TRY to use gettok().            */



int nextchar()
{
    ++cp;
    while (*cp == ' ')
        ++cp;
    return *cp;
}


int eatspace()
{
    while (*cp == ' ')
        ++cp;
    return *cp;
}


int calcu()
{
    FILE *ifil;
    char line[MAXL];
    int rpos;
    double r;

    ifil = stdin;
    while (1) {
        errorp = NULL;
        printf("Calc:");
        if (!fgets(line, MAXL, ifil))
            break;
        if (strlen(line) &amp;&amp; strnicmp(line,"QUIT",4)
&amp;&amp; stricmp(line,"Q\n"))
            rpos = evaluate(line, &amp;r);
        else
            break;
        if (!rpos) {
            printf("%-18g\n", r);
            oldval = r;
        } else {                /* prints Error in field min. 12 wide */
            printf("%*s\n", rpos, "^Error");
        }
    }
    return rpos;                /* if interactive rpos should always be 0 */
}


/* More local prototypes. This could, of course, be a separate file. */
double expression();
double product();
double potens();
double signedfactor();
double factor();
double stdfunc();


int evaluate(char *s, double *r)
{
    cp = s;
    eatspace();
    *r = expression();
    eatspace();
    if (*cp == '\n' &amp;&amp; !errorp)
        return (0);
    else
        return (cp - s) + 11;
}


double expression()
{
    double e;
    int opera2;

    /* printf("test arg:%s\n",cp); */

    e = product();
    while ((opera2 = *cp) == '+' || opera2 == '-') {
        nextchar();
        if (opera2 == '+')
            e += product();
        else
            e -= product();
    }
    eatspace();
    return e;
}


double product()
{
    double dp;
    int ope;

    dp = potens();
    while ((ope = *cp) == '*' || ope == '/') {
        nextchar();
        if (ope == '*')
            dp *= potens();
        else
            dp /= potens();
    }
    eatspace();
    return dp;
}


double potens()
{
    double dpo;

    dpo = signedfactor();
    while (*cp == '^') {
        nextchar();
        dpo = exp(log(dpo) * signedfactor());
    }
    eatspace();
    return dpo;
}


double signedfactor()
{
    double ds;
    if (*cp == '-') {
        nextchar();
        ds = -factor();
    } else
        ds = factor();
    eatspace();
    return ds;
}


double factor()
{
    double df;

    /* while (*cp!='\n') {
       putchar(*cp++);
       } 
     */

    switch (*cp) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        df = strtod(cp, &amp;cp);
        break;
    case '(':
        nextchar();
        df = expression();
        if (*cp == ')')
            nextchar();
        else
            errorp = cp;
        break;
    case 'X':
        nextchar();
        df = oldval;
        break;

    default:
        df = stdfunc();
    }
    /* printf("ddt: df = %lf, *cp = %c\n",df,*cp); */

    eatspace();
    return df;
}


char *functionname[] =
{
    "abs", "sqrt", "sin", "cos", "atan", "log", "exp", "\0"
};

double stdfunc()
{
    double dsf;
    char **fnptr;
    int jj;

    eatspace();
    jj = 0;
    fnptr = functionname;
    while (**fnptr) {
        /* printf("%s\n",*fnptr); */
        if (strncmp(*fnptr, cp, strlen(*fnptr)) == 0)
            break;

        ++fnptr;
        ++jj;
    }
    if (!**fnptr) {
        errorp = cp;
        return 1;
    }
    cp += (strlen(*fnptr) - 1);
    nextchar();
    dsf = factor();
    switch (jj) {
    case 0: dsf = abs(dsf);  break;
    case 1: dsf = sqrt(dsf); break;
    case 2: dsf = sin(dsf);  break;
    case 3: dsf = cos(dsf);  break;
    case 4: dsf = atan(dsf); break;
    case 5: dsf = log(dsf);  break;
    case 6: dsf = exp(dsf);  break;
    default:{
            errorp = cp;
            return 4;
        }
    }
    eatspace();
    return dsf;
}


/* end calcu.c */


</programlisting>
</example>
</sect1>


<sect1 id="Tilstandsmaskiner">
<title>Tilstandsmaskiner</title>
<para>
Tilstandsmaskiner er betegnelse for 2 ting. Alle programmer
er tilstands-maskiner. En speciel teknik, som anvendes i parsere,
indeholder en tilstandstabel.
</para>

</sect1>
</chapter>

