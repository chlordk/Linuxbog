<chapter id="c-objekt-orienteret-tankegang">
<title>Brugerdefinerede datatyper og objekter</title>

<indexterm><primary>brugerdefinerede datatyper</primary></indexterm>
<indexterm><primary>konkrete datatyper</primary></indexterm>

<para>
Vis mig dine data, og jeg skal sige dig, hvad dit program vil
kunne gøre. Repræsentation af det problem, som man ønsker at
arbejde med, er altid et valg; der vil være flere oplysninger om
de enkelte ting, som vi repræsenterer i programmerne, end vi
bryder os om at have med i vores datastrukturer.
</para>

<para>
Når man sammensætter forskellige oplysninger i en klump, kalder
man resultatet en struct (en.: structure, struktur) - men gennem
tiderne har denne gruppering af oplysninger fået mange
betegnelser: node, record, entitet, genstand (en.: item),
element.
</para>

<para>
Da sådan en struct som regel forekommer som et element i en
tabel, er der ifølge Knuth også forfattere, som har brugt
betegnelsen "perler" om structs. De kan jo så trækkes på en snor
eller anbringes i en liste.
</para>

<sect1>
<title>Sammensætning af flere data</title>

<para>
Med et eksempel fra Donald Knuth kunne vi se på, hvordan man kan
programmere et kortspil.
</para>

<para>
En struct, som illustrerer et enkelt kort, kunne fx. se således
ud:
</para>

<programlisting>
/* der benyttes <EMPHASIS>bitfields</EMPHASIS> for at vise denne
 * feature. I stærkt memory kritiske applikationer kan dette
 * nogen gange betale sig. Kode til manipulation af bitfelterne
 * vil imidlertid gøre koden langsommere og større.
 */

struct kort_t {
    int tag:1;             /* bagsiden op = 1 */
    int farve:2;           /* 0 klør, 1 ruder, 2 hjerter, 3 spar */
    int rang:4;            /* 1 = es, 2 = toer, 13 = konge */
    struct kort_t *next;   /* kort nedenunder */
    char titel[5];         /* forkortet navnebetegnelse */
};

</programlisting>

<para>
Indholdet af et felt i en struct kan være hvad som helst - der
dog den lille begrænsning, at compileren skal kende alle typerne,
med mindre der er tale om en pointer til et eller andet ukendt
objekt.
</para>

<para>
Vi kan have tal eller tekst i et felt - eller en anden struct,
hvis det passer ind i vores planer.
</para>

<para>
Tag (engelsk: mærke) sat lig med 1 betyder, at kortet vender
bagsiden opad, tag == 0 betyder, at det vender forsiden op.
Feltet farve er selvfølgelig <emphasis> kortspilsfarve
</emphasis> d.v.s. klør, ruder, hjerter eller spar. Ved at
benytte 2 bits får vi værdierne 0, 1, 2 og 3 til rådighed.
Rang henviser til kortets værdi med es som ener, konge som
tretten'er.
</para>

<para>
Adressen på et objekt kaldes også et link eller en pointer
(vejviser, pegepind) eller reference til dette objekt.
</para>

<para>
Feltet <literal> struct kort_t *next; </literal> er et
felt, som kan indeholde adressen på et andet kort, i dette
tilfælde kunne det være kortet, som ligger nedenunder i en
kabale. I mange tilfælde kunne man nøjes med en adresse, som var
relativ i forhold til en base adresse.  Hvis der ikke er noget
kort nedenunder, kan vi give feltet værdien 0 som i denne
sammenhæng kaldes NULL.
</para>
<GRAPHIC FILEREF="kort1.&magic;"  SCALE="70"></GRAPHIC>

<para>
Dette afsnit er - sammen med de næste afsnit om konkrete og
abstrakte datatyper - under omarbejdelse. Hvis du har nogen
spørgsmål eller ønsker at bidrage skal du være velkommen. Jeg
regner med at få skrevet en hel del i løbet af dagene 16 - 24
juni 2001.
</para>

</sect1>

<sect1 id="datatyper">
<title>C og objekt-orienterede metoder</title>
<para>
Er C et objektorienteret sprog? Hvorfor er det ikke
objektorienteret, når et C program er en række definitioner af
eksterne objekter?
</para>

<para>
Det korte svar er, at almindelig C ikke har virtuelle
funktioner. Desuden er der ikke support for generisk algoritme
programmering. Det er imidlertid interessant at vide, at C
sproget som sådan ikke forhindrer programmøren i at tænke
objektorienteret. 
</para>

<para>
Hvorfor så ikke bruge C++ og glemme alt om C? Der er flere 
svar på dette spørgsmål. C oversætteren er stadig mere effektiv
end C++, selv om C++ teoretisk set burde generere kode af samme
størrelse og effektivitet. Et andet svar er, at C er sjovere og
mere læseligt end C++, men det er måske ikke alle, der er enige
i den betragtning. Hvis man vil forstå, hvad der sker i C++, er
det en fordel at forstå C sproget fuldt ud.
<footnote> 
<para> 
Anvendelse af objektorienterede fremgangsmåder er somme tider
ikke sagligt begrundet (ifølge Stroustrup; jeg kommer til at
skylde et sidetal i "The C++ Programming Language". Det er fx.
ikke hensigtsmæssigt at opbygge et grafisk library som ét stort
klassehierarki; det indskrænker mulighederne.
</para>
</footnote>
</para>

<example id="ex-kompilering-med-C-og-CXX">
<title>Kompilering af samme program med C og C++ oversættere</title>

<para>
Læg mærke til, at der benyttes flag -O for optimering, -s for at
fjerne symboltabellerne, således at programmet kun kommer til at
bestå af maskininstruktioner og dynamisk link - information.
Programfilen bliver lidt mindre for C oversætteren, men ikke
meget. Programmet er så lille, at resultatet kun må opfattes som
en strømpil. Prøv med nogle af de større programmer - og se, om
det er muligt at rette lidt i kildekoden, så C++ oversætteren
accepterer program kildeteksten!
</para>

<para>
Endelig bemærkes, at man får versionen af oversætter-systemet
frem ved kommandoen gcc -v eller g++ -v . Man må ikke sammenligne
programfiler genereret med fx. gcc 2.8.1 med programfiler, som er
genereret med gcc 2.95.2 eftersom der kan være meget stor forskel
på oversætterens håndtering af alignment, optimering m.v.
</para>

<screen>
<PROMPT>/fri $</PROMPT><USERINPUT>ls -lo cirkle1.c</USERINPUT>
-rw-r--r--   1 root          361 Apr 30 00:11 cirkle1.c
<PROMPT>/fri $</PROMPT><USERINPUT>gcc -Wall cirkle1.c -O -s -o cgg1</USERINPUT>
<PROMPT>/fri $</PROMPT><USERINPUT>ls -lo cgg1</USERINPUT>
-rwxr-xr-x   1 root         3028 Apr 30 00:11 cgg1
<PROMPT>/fri $</PROMPT><USERINPUT>gcc -v</USERINPUT>
Reading specs from /sources/gcc/bin-2.95.2/lib/gcc-lib/i586-pc-linux-gnu/2.95.2/specs
gcc version 2.95.2 19991024 (release)
<PROMPT>/fri $</PROMPT><USERINPUT>g++ -Wall cirkle1.c -O -s -o cxx1</USERINPUT>
<PROMPT>/fri $</PROMPT><USERINPUT>ls -lo cxx1</USERINPUT>
-rwxr-xr-x   1 root         3176 Apr 30 00:12 cxx1
<PROMPT>/fri $</PROMPT><USERINPUT>g++ -v</USERINPUT>
Reading specs from /sources/gcc/bin-2.95.2/lib/gcc-lib/i586-pc-linux-gnu/2.95.2/specs
gcc version 2.95.2 19991024 (release)
<PROMPT>/fri $</PROMPT>
</screen>
</example>

<para>
Hvis man skriver store programmer som fx. et operativsystem eller
et GUI library, så er det en fordel at kunne tænke og arbejde på
højt niveau. Derfor er det nyttigt at skrive "objektorienteret"
også når man arbejder med "almindelig-C" programmering.
Senere i dette kapitel vil vi sammenligne to udgaver af en linked
liste, den ene skrevet i C og den anden i C++. Så kan du selv
dømme.  Men aller først lidt introduktion om objekter, konkrete
og abstrakte datatyper.
</para>

<para>
De fleste sprog har nogle mekanismer, som er rigtigt
objektorienterede, nemlig håndteringen af forskellige numeriske
typer.
</para>

<para>
Vi kan have en integer i en variabel og gange den med en
float og lægge resultatet i en double uden at compileren gider
fortælle, at der skal konverteres. Taber vi præcision ved at
konvertere fra double til integer, vil de fleste compilere give
en warning, men de konverterer dog.
</para>

<para>
Det er egentlig objektorientering i en nøddeskal. Definer
din algoritme (fx. addition) og sørg for, at den kan håndtere
forskellige data, d.v.s. objekter, på en passende måde. Det
er lidt vanskeligt at skrive operatorfunktionerne på en sådan
måde, at de kan klare alle situationer, fx. både fortegns-minus
og subtraktions-minus, ofte kaldet unært og binært minus.
Som en øvelse i objekt-orienteret tankegang kan man prøve at
definere en struct, som skal repræsentere brøker, som fx. 2/3,
der jo ikke er det samme som 0.6667. I "almindeligt" C vil
man bruge funktionskald til at udføre aritmetiske konverteringer
og operationer, og det kunne nemt komme til at se lidt klodset
ud, som for eksempel her:
</para>

<programlisting role="C">
f()
{
    struct broek andel;
    struct broek afgift;
    struct broek *b_bogpris;

    andel.t = 1;
    andel.d = 3;
    b_bogpris = new_broek(360,1);
    broek_multiply(&amp;afgift,b_bogpris,&amp;andel); /* ikke kønt */
    free(b_bogpris);

    /* se filerne bogpris1.c bogpris2.cxx for hele source.  */
}
</programlisting>

<para>
I C++ er det muligt at erklære en variabel af typen broek
som fx. nedenstående eksempel, og derefter benytte de tilhørende
operationer udtrykt ved de i forvejen kendte operatorer:
</para>

<programlisting role="C">
broek andel(1,3);
int bogpris = 360;
broek afgift = bogpris * andel;  /* ret nemt at læse */
</programlisting>

<para>
Det forudsætter selvfølgelig, at man har defineret typen broek og
tilhørende funktioner for operatorerne på en passende måde! 
</para>

<indexterm><primary>konkrete datatyper</primary></indexterm>

<para>
En sådan brugerdefineret datatype kaldes somme tider en konkret
datatype, i modsætning til en abstrakt datatype. Den konkrete
datatype har ingen "virtuelle funktioner" sådan som den abstrakte
har det. Læs videre:
</para>

<para>
Betegnelsen abstrakt datatype (ADT) bruges somme tider om alt,
hvad der kan indkapsles, men den mest rimelige anvendelse er nu
den, som Stroustrup angiver i sine forskellige bøger om C++. Hvis
vi skal skrive en hardware driver til en grafisk device (en som
er i stand til at tegne prikker på en angivet position) så kan vi
definere en klasse "figur" - men for at opnå bedste hastighed
ønsker vi, at måden, den tegnes på, er optimeret for henholdsvis
cirkel og rektangel. C++ supporterer den slags konstruktioner: 
</para>

<para>
Vi kan i C++ definere en generel klasse, "figur", som omfatter de
grundlæggende egenskaber ved figur og tillige de operationer, som
hører sammen med den. Nogle af disse operationer kan vi endnu
ikke sige nøjagtigt hvordan vi ønsker implementeret. Hvis vi
gjorde, ville det ikke være optimalt.
</para>

<programlisting role="C">
struct figur {  // man kan skrive class i.st.f. struct 
    public:
        figur(){;}
        virtual void tegn_figur() =0; // =0 er nødvendigt
};
</programlisting>

<para>
Derefter definerer vi subklasser, det vil sige klasser, som
overtager (arver) egenskaberne fra den generelle klasse. Sådan en
klasse kaldes også specialiseret. Det kunne være cirkel, som jo
er mere specialiseret end "figur". Denne subklasse <emphasis>
skal </emphasis> definere en brugbar funktion til at udføre
handlingen "tegn_figur".
</para>

<programlisting role="C">
struct cirkel : figur {
    public:
	void tegn_figur(){
		printf("Tegner figur/cirkel...\n");
	}
};
</programlisting>

<para>
En funktion i klassen "figur", som erklæres at være virtuel,
kan ikke kaldes, den eksisterer jo i virkeligheden kun, mens
programmet kompileres. Det vil give oversættelses-fejl, hvis de 
nedarvende klasser ikke definerer en (rigtig) funktion. 
<footnote>
<para>
Det giver ikke en oversætter fejl, men en link fejl i c++ 2.95.2
hvis man glemmer =0; efter en virtuel funktion i baseklassen. 
</para>
</footnote>
</para>

<para>
I C kan man ikke få compileren til at hjælpe sig med at "huske",
at man skal skrive en optimeret, håndgribelig funktion som tegner
cirkel-figuren.
</para>

<para>
For at fortsætte parallellen med de numeriske typer, int, double,
long double etc., kan man sige, at de alle nedstammer fra en
abstrakt datatype "tal". I "tal-klassen" er der virtuelle
funktioner for addition, subtraktion etc. De er virtuelle, fordi
de ikke eksisterer for klassen "tal", men kun for de
specialiserede klasser, heltal, decimalbrøk og så videre.
</para>

<!-- tegning -->
<example id="ex-tal-abstraktion">
<title>Talklasse - en abstraktion</title>
<programlisting>
                 +-------------+
                 |             |
                 |    tal-     |
                 |   klasse    |
                 |             |
                 +------+------+
                        |
                        |
                        |
                        |
                        |
       +----------------+---------------+--------------+---------+
       |                |               |              |         |
       |                |               |              |         |
       |                |               |              |         |
       |                |               |              |         |
       |                |               |              |         |
   +---+--+        +----+----+    +------------+   +-------+  +------+
   | hel  |        | decimal |    | dobbelt    |   | posi- |  | char |
   | tal  |        | brøk    |    | precision  |   | tive  |  +------+
   +------+        +---------+    | decimalbrøk|   | heltal|
                                  +------------+   +-------+
</programlisting>
</example>

<para>
For heltals-objekter skal oversætteren realisere
operationen med heltal maskin-instruktioner, men hvis der derimod
er tale om decimalbrøker skal oversætteren realisere operationen
ved hjælp af flydende-komma maskin-instruktioner.
</para>

<para>
C sproget er ikke kun en "fattig" udgave af C++. C sproget bliver
til stadighed påvirket af udviklingen indenfor bl.a. C++ og tager
de bedste ting, som er fremkommet, med i standarden, se evt.
appendix C, C99. C og C++ moduler kan sættes sammen. C sproget
vil stadig blive valgt, hvor størrelse og hastighed er vigtigst,
for eksempel i kerne-moduler og drivere. Derfor er det vigtigt at
kunne håndtere højniveau programmering i C, og det er det, som
det efterfølgende afsnit handler om.
</para>

<para>
I de efterfølgende afsnit vil vi bruge betegnelsen "abstrakte
datatyper" mere løseligt om alt, hvad der kan indkapsles. Vi
stiller os tilfreds med, at implementering af funktionaliteten
kan udskiftes uden at brugere af datatypen skal ændre deres
kode.
</para>

</sect1>

<sect1 id="sect-abstract-datatypes">
<title>Abstrakte datatyper</title>

<indexterm><primary>abstrakte datatyper</primary></indexterm>

<para>
For at programmere på højt niveau i C sproget skabes
abstraktioner, som kan bruges til noget nyttigt. Fx. er en fil
en abstraktion, som operativsystemet leverer. <footnote> <para>
En fil er en ordnet sekvens af bytes. </para>
</footnote> Ved hjælp af fil abstraktionen kan vi hente data fra
eksterne kilder, så som diske, netforbindelser eller tastaturet.
</para>

<para>
Grundlaget for en sådan abstraktion er som regel structures, de
sammensatte datatyper, som deklareres med nøgleordet <emphasis>
struct </emphasis>. For at bevare overblikket, for ikke at blande
detaillerne ind i den abstraktion, som vi ønsker at skabe,
indkapsles sådanne data ofte, således at al tilgang sker gennem
funktionskald. Derved bliver det lettere at anvende den
pågældende abstraktion, man skal blot udstede en "kommando": Læs,
skriv, luk, flyt o.s.v.
</para>

<para>
Fil tilgang klares med funktionerne fopen(), fread(), fprintf()
etc., som benytter datatypen FILE som parameter, for fopen() er
det returværdien.  FILE typen skal man ikke "dissekere", det er
tilladt, men ikke fornuftigt at benytte de variable, som typen
består af. FILE benyttes blot som et håndtag til den datastrøm,
hvorpå man ønsker at udføre IO-operationer.
</para>

<indexterm><primary>FILE typen</primary></indexterm>
<example id="ex-fopen">
<title>FILE typen</title>
<programlisting role="C">
/* fileopen.c - demonstrerer fopen(). */
#include &lt;stdio.h>

main()
{
	FILE *fp;
	fp = fopen("fileopen.c","r");
	if (!fp) {
		perror("Kan ikke aabne filen \"fileopen.c\"");
		exit(2);
	}
	printf("Har aabnet filen \"fileopen.c\" \n");
	return 0;
}
/* se <xref LinkEnd="ex-mime2ascii"> for læsning fra en fil */
</programlisting>
</example>

<para>
FILE er en abstrakt datatype. Hvis vi benytter vores program til
at læse en "special-fil", fx. en driver-entry via /dev/ kataloget
eller en fil i /proc/ kataloget, så har vi samme funktionalitet,
som en C++ abstrakt datatype kan give os. For FILE typens
vedkommende leveres funktionaliteten ikke af vores programkode,
men af filsystemet i linux-kernen.
</para>

<para>
FILE "håndtaget" benyttes til at tilgå filer, og de indre dele af
FILE (pointere, interface til kernen etc.) er ukendt for os, vi
behøver ikke at vide noget om buffere og pointere, 

<footnote><para>
Vi må selvfølgelig gerne vide, hvad der gemmer sig i en FILE,
prøv selv at se efter i /usr/include/stdio.h og ikke mindst i
/usr/include/libio.h som rummer selve struct-definitionen, bl.a.
<programlisting>
  char* _IO_read_ptr;   /* Current read pointer */
  char* _IO_read_end;   /* End of get area. */
  char* _IO_read_base;  /* Start of putback+get area. */

</programlisting> Men selv om vi ved noget om _IO_FILE
ville vi ikke drømme om at bruge denne viden i en
end-user applikation!</para>
</footnote>.
</para>

<para>
Det kan ikke understreges nok, at nøglen til succes er kendskab
til funktions-interfacet og de andre teknikker til at indkapsle
de data, der naturligt hører sammen. 
</para>

<sect2 id="sect-sammensatte-datatyper">
<title>Sammensatte datatyper</title>

<para>
Sammensatte datatyper er nyttige, når vi i et program har brug
for at samle informationer om et "objekt i den virkelige verden".
Den engelske betegnelse er <emphasis>aggregate data
types</emphasis>, men det giver også mening at kalde dem for
brugerdefinerede datatyper.
</para>

<para>
Sammensatte datatyper er, som ordet siger, en sammensætning af
forskellige typer data. I C sproget erklæres en sådan datatype
ved hjælp af nøgleordet <emphasis> struct </emphasis>. Det er
selvfølgelig en forkortelse for structure. I andre sprog hedder
det en "record".
</para>

<example id="ex-aggregate">
<title>En struct</title>
<programlisting role="C">
struct tomat_t {
   int typenummer;
   char artsnavn[80];
   int goedningsforbrug;
   int pladskrav;
   int temperaturkrav;
   int saesonpris[24];
};

</programlisting>
</example>

<para>
Når man erklærer en struct efter ovenstående mønster, indsættes
en oplysning i compilerens symboltabel om typens navn, størrelse
samt offset og type på de enkelte elementer.
</para>

<para>
"tomat_t" kaldes en type tag, og den tjener to formål - dels
kan vi senere erklære flere variable af denne type, dels kan vi
erklære en pointer til samme type inden i vores struct. Derved
kan vi opbygge en kæde af elementer. En sådan kæde kaldes en
linked liste på engelsk (se <xref LinkEnd="sect-linked-list">)
</para>

<para>
Derefter kan man definere variable af den pågældende type med
syntaksen:
</para>

<example id="ex-definition">
<title>Definition af en variabel</title>
<programlisting role="C">
struct tomat_t sunglow;
</programlisting>
</example>

<para>
Det er ikke alle programmører, som kan lide denne notation.
Derfor er der mange, som benytter sig af <emphasis> typedef
</emphasis> til at danne nye typebetegnelser.
</para>

<example id="ex-typedef">
<title>Struct type ved hjælp af typedef</title>
<programlisting role="C">
typedef struct tomat_tag {
    int ident;
    char name[80];
    int spacing;
    /* etc - etc. */
} tomat_type, *tomat_ptr;

tomat_type softball;
tomat_ptr current_tomat;

</programlisting>
</example>

<para>
Det er meget rart, at man kan se på ordet tomat_type, at det ikke
er en variabel, men er en type. Ellers må man huske, at et ord
foran et andet <emphasis> skal </emphasis> være en
typebetegnelse. Til gengæld kan det være sværere for compileren
at finde ud af at diagnosticere fejl. I C++ er det altid tilladt
at udelade nøgleordene struct og class, undtagen i erklæringen af
typen.
</para>

<programlisting id="proglist-cplusplus-struct">
tomat_type red_sun;
</programlisting>

<para>
I parentes bemærket er der danske virksomheder, som har haft
enorme ekstraudgifter på at bruge danske betegnelser i
programmer, som skulle eksporteres, så det er nok klogt ved alle
større projekter at erkende babelstårn problematikken og benytte
engelsk, latin eller esperanto.
</para>

<example id="ex-declaration-and-definition">
<title>Erklæring og definition</title>
<programlisting role="C">
struct tomat_ty {
   int identifikation;
   char art[80];
   int goedningsforbrug;
   int pladskrav;
   int temperaturkrav;
   int saesonpris[24];
} sungold;

</programlisting>
</example>

<para>
I eksempel <xref LinkEnd="ex-declaration-and-definition"> er der
både erklæret en type, nemlig <emphasis>tomat_ty</emphasis>, og
en variabel, <emphasis>sungold</emphasis>. Bør kun anvendes i
ultrakorte programmer (stenografi-orienterede;-).
</para>

<para>
Til slut at give et eksempel på et andet udvalg af
informationer om tomater, som fx. kunne være interessant i
tilfælde af at man samlede på tomatbilleder:
</para>

<example id="ex-anderledes-tomat">
<title>Udvælgelse af oplysninger</title>
<programlisting role="C">
struct tomat {
   int loebenummer;
   char beskrivelse[280];
   enum billedtype;
   char fotograf[80];
   enum karakter;
};

</programlisting>
</example>

<para>
Som regel er der langt flere oplysninger, end vi er interesseret
i, sådan rent programmeringsmæssigt. Det er en disciplin for sig
selv at udvælge og vurdere informationernes anvendelighed.
</para>

</sect2>

<sect2 id="sect-interface">
<title>Interface til datatype</title>

<para>
Sæt nu, at vi ikke rigtigt vidste, om vores tomat-beskrivelse
ville kunne holde i hele programmets levetid. Der er flere måder
at håndtere behov for ændringer.
</para>

<para>
Den mest anvendte metode går ud på at isolere repræsentationen af
tomaten fra de dele af programmet, som anvender
tomat-informationer. Det siger sig selv, at dette kræver ekstra
kode. Det er imidlertid med de nye C compilere muligt at optimere
den ekstra kode på samme måde som i C++ - nemlig ved at erklære
en funktion for <emphasis>inline</emphasis>.
</para>

<para>
Derved bliver det muligt at ændre tomat-struct'en uden at ændre
programkode ret mange steder. Får man behov for at konvertere
datatyper eller for at dele repræsentationen af informationer op
på en anden måde, så vil man som regel kunne slippe godt afsted
med det uden større problemer, hvis man anvender denne metode.
</para>

<para>
Hvis behovet <emphasis>kun</emphasis> består i at have flere data
til denne struct, så er det ikke så vanskeligt at udvide en
struct selv om programkoden tilgår de enkelte felter direkte.
Problemer med ændringer bliver først alvorlige, når programmernes
størrelse og kompleksitet bevirker, at ingen længere har det
fulde overblik over flow. Hvilket forekommer.
</para>

</sect2>
<!-- her følger afsnittet om linkede lister -->

