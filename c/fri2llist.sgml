<sect2 id="sect-linked-list">
<title>Den linkede liste</title>
<para>
En af de mere almindelige abstrakte datatyper er den linkede
liste, på dansk en sammenkædet liste. Elementer kædes sammen ved
hjælp af en pointer, således at hvert element peger på det næste.
</para>

<example id="ex-linked-liste-tegning">
<title>Sammenkædet liste</title>
<programlisting id="illu-linked-liste">

+------------+           +-------------+     +--------------+
| data       |           | data        |     | data         |
|     +------+           |      +------+     |      +-------|
|     |næste +---------->|      |næste +---->|      | næste +------+
|     |      |           |      |      |     |      |       |      |
+-----+------+           +------+------+     +------+-------+    __|__
                                                                  ---
                                                                   ~
</programlisting>
<para> Vil i næste version blive erstattet med gimp-grafik! </para>
<para>
Det sidste led i kæden er "sat til jord" - det skal forstås
sådan, at dette element har en "næste" adresse, som er ugyldig,
d.v.s. en NULL pointer.
</para>
</example>

<para>
Et liste-element kan indeholde den eller de datatyper, man har
behov for. Hvis listen skal indeholde elementer af forskellig
størrelse, kan man enten udnytte, at det sidste element i en
struct kan strække sig ud over stuct'ens normale størrelse, eller
man kan benytte sig af en pointer til de data, som har variabel
størrelse. Det sidste er den "pæneste" løsning.
</para>

<FIGURE ID="fig-linklist" FLOAT="1">
<TITLE>Linked liste med pointere fra liste-blok til datablok</TITLE>
<GRAPHIC FILEREF="linklist.&magic;"  SCALE="100"></GRAPHIC>
<INFORMALEXAMPLE>
<para>
Datablokkene har forskellig størrelse og bliver fundet via en
ekstra pointer. Det er sjældent, at dette er nødvendigt, og det
er selvfølgelig ikke så effektivt som en almindelig linked liste.
</para>
</INFORMALEXAMPLE>
</FIGURE>


<para>
Hvis vi fx. skal liste et katalog, kan vi samle de oplysninger,
som vi ønsker at gemme, op i en struct. I nedenstående eksempel
ønsker vi at sortere filerne på i-node nummer. Det kan gøres med
<literal> ls -i | sort </literal>, men for at få nogle ægte
eksempler på anvendelse af struct og pointere er det meget godt
at gå om bag kulisserne og se, hvordan ls programmet egentlig
bærer sig ad.
</para>

<para>
Når man skal finde en funktion i manual - pages, så kan man
benytte man -k (keyword). prøv fx. man -k printf. Der kommer
mange svar-linjer. En af dem siger printf(1) - det er
kommando-linje versionen af printf. Men den vi bruger til C
programmer hedder printf(3). Tallene i parenteserne henviser til
manual-sektioner. Disse sektioner kan man læse mere om med
kommandoen <command> man 7 man </command>.
</para>

<para>
Når der nu nedenfor står readdir(3) er det altså den readdir
funktion, som beskrives i manual - sektion nummer 3, som det
handler om. Pas på readdir(2), som kommer på skærmen hvis man
blot skriver kommandoen <literal> man readdir </literal>.
</para>

<para>
readdir(3) er en POSIX funktion, som læser en entry fra et
katalog og returnerer en pointer til en struct, der indeholder
navn og det tilhørende i-node nummer. Hvis man benytter
i-node-nummeret, er programmet ikke posix-compliant, men det er
der jo ikke noget at gøre ved (og det er ikke så vigtigt her).
</para>

<para>
Før man kan bruge readdir(3) skal man åbne katalog-filen (et
katalog er en fil på linje med alle andre filer, bestående af
filnavne og tilhørende i-node nummer. En fil kan have mange
navne, men i-node nummeret er en entydig definition af de
datablokke, som tilsammen udgør abstraktionen en fil. En fil er
en ordnet sekvens af bytes.)
</para>

<para>
opendir(3) får blot et navn (default ".", current dir, ligesom
programmet <emphasis>ls</emphasis>.) Når den returner, giver den
enten et "håndtag" til dir-filen, i stil med fopen(3). Hvis den
ikke kan finde et katalog med det navn, som vi giver den,
returnerer den NULL. Det er en indikation af en fejlsituation, og
vi lader simpelthen programmet dø med en exitkode, som fortæller,
at det ikke gik godt.
</para>

<para>
Retur typen for opendir(3) er et interessant eksempel på en
struct, som vi får navn på - men som vi rent faktisk ikke ved
noget om. Vi har ikke størrelsen på denne struct, og en erklæring
af et objekt af denne type vil give en oversætter-fejl. 
Stik mod god skik er her et eksempel, som ikke kan oversættes:
</para>

<example id="ex-ukendt-objekt">
<title>Ukendt objekt.</title>
<programlisting role="C">
/* notgood.c, program som ikke kan oversaettes. */
#include &lt;stdio.h>
#include &lt;dirent.h>

main()
{
	DIR dirobjekt;
	printf("Programmet kører ... \n");
	return 0;
}

</programlisting>
</example>

<screen>
<PROMPT>/fri $</PROMPT><USERINPUT>gcc notgood.c</USERINPUT>
notgood.c: In function `main':
notgood.c:8: storage size of `dirobjekt' isn't known
</screen>

<para>
Vi har (forsøgt) at erklære et objekt af typen DIR - men det kan
man ikke, for selv om typen DIR er defineret i &lt;dirent.h>, er
det <emphasis> kun sket som en typedef erklæring af en pointer
til et ukendt objekt.</emphasis>
</para>

<para>
Nedenfor følger så et eksempel på, at man GERNE må erklære et
objekt, som er en pointer til en ukendt genstand (jævnfør en void
pointer).
</para>


<example id="ex-typeloes-pointer">
<title>Pointer til ukendt objekt.</title>
<programlisting role="C">
/* memhog.c, program som allokerer 20MB RAM og venter */
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef struct dummy OBJEKT;
main()
{
	OBJEKT *p2objekt;
	p2objekt = malloc(20 * 1024 * 1024);
	if (p2objekt == NULL)
		printf("Ikke nok memory\n");
	else
		printf("Har allokeret 20MB memory\n");
	getchar();
	return 0;
}

</programlisting>
</example>

<para>
Ovenstående program oversættes uden warning/error. Det kan også
køre. I oversættelses-forløbet registreres blot, at OBJEKT er en
ukendt struct, og så er det tilladt at lave en pointer til den.
Alle forsøg på at erklære et "rigtigt" objekt af denne type og
alle forsøg på pointer-aritmetik (dvs. at skubbe pointeren hen på
næste objekt) vil udløse en fatal oversættelsesfejl, fordi
størrelsen er ukendt.
</para>

<para>
Forresten, nu vi er ved det, programmet bruger faktisk ikke ret
meget ram, fordi det ikke forsøger at skrive til den allokerede
blok. ps -u -C kan vise, hvordan det forholder sig:
</para>

<screen>
<PROMPT>ax@pluto:/udvikl$ </PROMPT> <USERINPUT>ps -u -C</USERINPUT>
USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
root     25170  0.1  0.9 21208  292 ttyp1    S    00:59   0:00 memhog
</screen>

<para>
Kolonnen VSZ viser forbruget af virtuel memory. Virtuel i denne
sammenhæng betyder, at der er reserveret adresser, men ikke
fysisk ram til disse 20 millioner bytes. RSS kolonnen viser
Resident Set Size, d.v.s. hvor meget fysisk RAM der faktisk anvendes.
</para>

<para>
Tilbage til dirlist1.c. Kommer opendir(3) tilbage med en gyldig
pointer (d.v.s. en som ikke er NULL), så kan vi fortsætte med at
kalde readdir(3), indtil <emphasis>den</emphasis> kommer tilbage 
med en NULL pointer.
</para>

<para>
Readdir(3) har sin egen private (static) buffer, og det er derfor
nødvendigt at gemme de oplysninger, som vi ønsker at gemme, i en
buffer. I første version undlader vi at gemme, fordi vi blot
ønsker at kontrollere, at opendir, readdir og closedir fungerer,
sådan som vi forventer.
</para>

<example id="ex-dirlist1">
<title>Listning af filnavne i et katalog</title>
<programlisting role="C">
/* dirlist1.c læser alle navne i et katalog */
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;dirent.h>

int showdir(char *dirname);

main(int argc, char *argv[])
{
	char *dirname;
	if (argc &lt; 2)
		dirname = ".";
	else
		dirname = argv[1];

	return showdir(dirname);
}

int showdir(char *name)
{
	DIR *d;
	struct dirent *dent;

	if ((d=opendir(name)) == NULL)
		return 1;
	while (dent = readdir(d))
		printf("Return from readdir: %s\n",dent->d_name);
	closedir(d);
	return 0;

}

</programlisting>
</example>

<para>
Hvordan kan programmøren nu vide, at navnefeltet i katalog -
entry'en har betegnelsen d_name? Det kan man finde ud af på to
eller tre måder. Først benyttes man (manual) systemet. Hvis dette
ikke indeholder oplysning om readdir(3) funktionen, må man finde
headerfilen i /usr/include. Info systemet (evt. via emacs) kan
altid fortælle om glibc og GNU-C relaterede emner. Hvis dette
ikke er så rart at bladre i (der står for meget), er der ikke
andet at gøre end at finde source-filerne frem til glibc, pakke
ud og se, hvad man kan finde ud af om library funktionerne. Det
er ikke let at læse glibc - kildeteksterne. Det kræver bl.a.
beherskelse af emacs, som kan bruges til at fjerne alle de
#ifdef - styrede multiplatform blokke.
</para>

<para>
struct dirent findes i /usr/include/dirent.h. Det er den
ultimative sandhed her. <command> man readdir(3) </command> kunne
være forældet eller fejlagtig, men header-filen må være korrekt
for at glibc kan kompileres. Men selvfølgelig kan der også være
opstået fejl her, en anden header fil kan have sneget sig ind
(somme tider er det godt at være paranoid!)
</para>

<para>
Struct dirent kan se forskellig ud på forskellige systemer, 
derfor er det, at Posix standarden advarer mod at bruge andet end
navnet. Med navnet kan man såmænd også hive alle andre
oplysninger om filen frem, (se stat(3)).
</para>

<para>
Næste version, dirlist2.c, skal gemme alle navne med tilhørende
i-node nummer (og eventuelt flere andre oplysninger).
</para>

<example id="ex-linked-liste">
<title>Linked liste, oprettelse og gennemløb</title>
<programlisting role="C">
/* dirlist2.c læser og gemmer alle filnavne i et katalog */

#include  ... /* main er den samme som dirlist1.c */


/* et liste element indeholder en pointer til næste element samt data eller
 * som her en pointer til allokeret blok der kan variere i størrelse.
 * Som navnet antyder, kunne man gemme flere oplysninger om hver indgang i
 * kataloget, men her er det kun navnet, som saves. For et mere fuldkomment
 * eksempel på, hvordan man gemmer alle oplysninger om en fil, se fileutils
 * source - eller nogle af de talrige andre eksempler, som kan findes på
 * nettet (fx. metalab.unc.edu - søg efter ydir).
 */

struct dirsav_t {
	char * name;
	struct dirsav_t * next;
};

static struct dirsav_t *createnew();
void insert_list(struct dirsav_t *head, char *data, int len);
void show_list(struct dirsav_t *head);

int showdir(char *name)
{
	DIR *d;
	struct dirent *dent;
	struct dirsav_t *head;

	if ((d=opendir(name)) == NULL)
		return 1;
	head = createnew();
	head->next = NULL;
	while (dent = readdir(d))
		insert_list(head, dent->d_name, strlen(dent->d_name));
	closedir(d);
	show_list(head);
	return 0;

}

</programlisting>
</example>

<para>
Som de ses er showdir funktionen ombygget, så den benytter sig af
et interface til nogle funktioner, som ikke er skrevet endnu. Der
oprettes en liste ved at det første element initialiseres, og
derefter indsættes det læste filnavn, hver gang readdir kaldes.
</para>

<para>
Hvis det kun var filnavnet, vi var interesserede i, ville det
være nemmere at lave et array af character pointere, men her er
det meningen på lidt længere sigt, at vi skal kunne indsætte et
ikke forud kendt antal elementer.
</para>

<example id="ex-liste-funktioner">
<title>Enkel implementering af linked liste</title>
<programlisting role="C">
/* Del 2 af programmet dirlist2.c - her er de tre funktioner, som
 * henholdsvis allokerer et nyt liste-element, indsætter et
 * element og show_list, som gennemløber listen. */

/* createnew() stopper programmet, hvis der ikke er mere ram. Det er den
 * enkleste og mest relevante fejl håndtering (her): Succes eller dø.
 * Et mere sigende navn kunne være mustCreatenew(); */

static struct dirsav_t * createnew()
{
	void *p2l;
	p2l = malloc(sizeof(struct dirsav_t));
	if (!p2l) {
		perror("Could not get memory for listmember");
		exit(254);
	}
	return p2l;
}

/* denne insert funktion er så simpel som mulig. Se evt. dirlist3.c (kommer
 * snart ... */

void insert_list(struct dirsav_t *ptr, char *obj, int len)
{
	struct dirsav_t *e;
				/* der reserveres hukommelse til det
				 * listeelement, som skal indsættes. */
	e = createnew();
	e->next = NULL;
				/* listen gennemløbes for at finde sidste
				 * element. Alternativt kunne man stoppe,
				 * når man nåede det sted, hvor det nye
				 * element passede ind, alfabetisk sorteret. */
	while (ptr->next)
		ptr = ptr->next;
				/* nu indsættes det nye element i den next
				 * pointer, som før var NULL. */
	ptr->next = e;
				/* så allokeres mere memory til den string
				 * eller andre data, som skal gemmes. */
	e->name = malloc(len+1);
				/* til sidst flyttes data over. Det er
				 * callers ansvar, at len er korrekt. */
	memcpy(e->name,obj,len);
}

/* løb gennem listen, spring første element over (for nemheds skyld bliver
 * det første element aldrig brugt til andet end til at pege på det næste)
 * Denne funktion VED at der er tale om en zero delimited character string
 * i namefeltet.
 * */

void show_list(struct dirsav_t *ptr)
{
	while(ptr = ptr->next)
		printf("Filename: %s\n",ptr->name);

}

</programlisting>
</example>

<para>
Eksemplet her egner sig godt til at arbejde videre med.
</para>


</sect2>
</sect1>
</chapter>

