<chapter id="c-intro"><title>Introduktion</title>
<sect1 id="c-prof-vaerksted"><title>Et professionelt værksted</title>
<!--comment
<sect2><title>Du har lige installeret Linux ... </title> -->
<para>
Hvis du har en maskine med Linux i en af de større
distributioner (fx. Red Hat eller Debian) har du samtidig en
samling af de mest avancerede værktøjer til fremstilling af
software.
</para>

<para>
Det er ikke blot en "sandkasse", du sidder med, men
et professionelt udviklingsmiljø. Der er optimerende compiler,
standardiserede libraries, supplerende libraries med et væld af
funktionalitet, debugger, source management med alt, hvad dertil
hører, og oven i det er Linux jo et professionelt afviklingsmiljø
med automatisk jobstart, kommando fortolkere og script sprog i
mange varianter, serverfaciliteter, samt ikke mindst firewall
faciliteter.
</para>

<para>
Det avancerede i denne her sammenhæng ligger ikke i et
smart peg - og - klik interface til en programgenerator. Just for
the record: En programgenerator er et udmærket værktøj i visse
sammenhæng. Med sådan et værktøj kan du kan vælge mellem et
begrænset antal på forhånd programmerede moduler ved hjælp af en
mus, klik og vupti, så har du et resultat bestående af objekter,
der er sat sammen (nogen kalder peg og klik - programmering for
objektorienteret programmering, men det er en fordrejning af
begreber).<footnote><para>TODO: Findes der program generatorer
til Linux? til Postgresql? til Mysql? Gnumeric?
</para></footnote>
</para>

<para>
Nej, det avancerede består i, at du kan styre genereringen
af programkode fuldstændig professionelt. Hvis du fx. ønsker at
skrive en ny og bedre database server, så værsgo', gå i gang. Den
nødvendige dokumentation er til rådighed, og der findes desuden
lærebøger som forklarer om low-level ting og high-performance
problematikker på Linux.
</para>

<para>
Oven i alt dette får du den fordel, at dine Linux
programmer i de fleste tilfælde kan anvendes uden ændringer på
andre Linux systemer, inclusive 64-bit systemer, og med få
ændringer på mange andre Unix systemer som fx. Solaris, AIX,
HP-UX.
</para>

<indexterm><primary>Cygwin</primary></indexterm>
<para>
Mere overraskende er det måske, at man også kan køre
Linux-udviklede programmer på Microsoft NT ved hjælp af
Cygwin systemet fra Cygnus.
</para>

<para>
Det er en væsentlig del af filosofien i GNU og C - sproget,
at man skal kunne genbruge sin kode, hvis hardwaren skal
udskiftes; og det skal den før eller senere! Hardware forgår,
brainware består. Sådan da.
</para>

<para>
Udover C compileren har du med Linux adgang til C++ og
mange andre sprog. 
</para>

<sect2 id="hvad-er-debugger">
<title>Hvad er en debugger?</title>
<para>
Debuggeren er et værktøj, som kan vise, linie for linie,
hvad der sker i et program. Selv om det hedder en debugger, så er
det er ikke så godt at bruge den til at fjerne fejl <footnote id="C-bug">
<para> Det kaldes aflusning eller debugging, bug == insekt, - der
skulle engang være opstået en fejl i en af de første computere
p.g.a.  nogle insekter, som syntes, at der var varmt og rart at
være oven på sådan nogen elektronik-komponenter.  </para>
</footnote>. 
</para>

<para>
Hvis et program er så fejlbehæftet, at man overvejer at anvende
en debugger, så bør man begynde forfra og reimplementere sine
programmer med de nyvundne erfaringer. Ok, der er undtagelser,
hvor man kan lokalisere en vanskelig, periodisk fejl ved at
anvende en debugger med omtanke, men det er ikke noget, som man
skal gøre til en fast vane!
</para>
</sect2>

<sect2 id=bib-eksempel>
<title>Biblioteker - et eksempel</title>
<para>
Det vigtigste er imidlertid, at der med de almindelige
Linux distributioner er et stort arsenal af Open Source
biblioteker til database, netværk, grafik etc.
</para>

<para>
Som et eksempel kan det fremhæves, at der findes Open
Source netværks-biblioteker til implementering af Remote
Procedure Call - programmer (rpc - programmer), både til client
og server TCP/UDP/IP. Det er en teknik, som kan benyttes til at
udføre en "procedure" på en anden computer (som selvfølgelig skal
være forberedt til dette!) Dette er værd at understrege, idet den
meget udbredte PC-software har indført nogle økonomisk betingede
useriøse skel mellem server og klient programmer.
</para>

<para>
Desuden har du adgang til mange gode eksempler på, hvordan
i hvert fald nogle af bibliotekerne anvendes. Kort sagt, hvis du
går i gang, kan du satse på at nå et professionelt niveau på de
områder, som du udvælger.
</para>
</sect2>
<sect2 id="hvordan-i-gang">
<title>Hvordan kommer man igang?</title>
<para>
Hvad gør man så for at komme igang?
</para>

<para>
Hvis der skulle være et mirakel-ord, som er nøgle til
forståelse af computerens magi, så er det ordet
DATA-REPRÆSENTATION.
</para>

<para>
Godt nok følger computerens elektriske signaler de fysiske
love, men computeren er et instrument til at manipulere store
mængder af impulser ud fra nogle få regler valgt af programmøren.
Med andre ord, vi kan tillægge elektriske signaler en betydning.
Et enkelt elektrisk signal kaldes oftest en bit, binary digit.
Otte af dem kaldes en byte eller, mere officielt, en octet.
</para>

<para>
En enkelt bit kan være en besked om at åbne sluserne
for at undgå en oversvømmelse. Eller en prik på en billedskærm.
Eller forskellen mellem et punktum og et komma (i en dårlig
font! Anstrengende for øjnene!)
</para>

<para>
Som regel bruger man flere bits til vigtige beskedder for
at sikre, at man nu også har forstået hinanden rigtigt. Det
kaldes redundans.
</para>

<para>
Bogstaver repræsenteres som regel ved en byte, men ved
anvendelse af Unicode bruges 16 bit eller 2 bytes. Der er også
systemer, som repræsenterer bogstaver ved hjælp af variabelt
antal bytes. Kig fx. på en HTML-side.
</para>
</sect2>
</sect1>

<sect1 id="repraesentering-af-data"><title>Repræsentation af data</title>
<para>
Hvis du ved en masse om computere, så vil du nok finde
dette afsnit overflødigt. Spring straks videre!
</para>

<para>
En computer kan bruges til tekstbehandling, styring af
produktionsmaskineri, til teleudstyr, og, selvfølgelig, til den
"klassiske" lommeregner. Hvor kommer denne fleksibilitet fra? Fra
programmøren, eller mere korrekt: De forskellige applikationer af
computerteknikken beror på muligheden for at repræsentere
information af mange forskellige typer ved hjælp af elektriske
spændinger.
</para>

<para>
Konstruktøren af en harddisk bestemmer f.x., at når man
sætter strøm på ledning 77, så er det en besked til harddisken om,
at den skal begynde en read-operation.
</para>

<para>
De, der konstruerer computeren, bestemmer, hvad de
forskellige elektriske signaler skal få de forskellige dele af
maskineriet til at udføre. Når han én gang har bestemt, at
ledning 77 er read-request, og maskinen er bygget efter hans
anvisninger, så er vi bundet af denne mening med signal 77, men
det kan altså laves om - næste gang, vi konstruerer et harddisk
interface.
</para>

<para>
Den ene dag repræsenterer bit nummer 1000017 en kerne i en
tomat, næste sekund måske et punktum på en skærm, og næste dag
kunne den være en del af en ordre til en harddisk.
</para>

<para>
Hvis du vil i dybden med forståelse af computerens
virkemåde og muligheder, kan du læse fx. Joseph Weizenbaum's
"Computer Power and Human Reason".
</para>

<para>
Datarepræsentation handler om teknikker til at
repræsentere forskellige typer af objekter. For programmøren er
det vigtigere at spørge, hvilke informationer, det egentlig er
interessant at repræsentere. Det kan computeren ikke finde ud af
uden kyndig vejledning fra programmører!
</para>

<para>
Hvordan vælger vi at repræsentere en tomat, hvad vælger vi
at se? Er det prisen, der interesserer os?  Vægten? Udseendet?
Surhed? Arvelige egenskaber? Vi vælger ud fra en ide om, hvad vi
vil med objektet.
</para>
</sect1>

<sect1 id="repraesentering-af-tal"><title>Repræsentation af tal</title>
<para>
Lad os se på, hvordan computeren repræsenterer tal. Det er
vel det, den er bedst til? Jo, måske nok, men alligevel, der er
faktisk en hage eller to ved computerens måde at repræsentere tal
på.
</para>

<para>
Fx. taler vi om heltal, de naturlige tal, tallene fra 0 og
opefter. Eller er det fra 1 og opefter ;-) Nå, i hvert fald så
siger vi, at vi kan repræsentere heltallene med en computers
kalkulator register eller en memory celle. Men det er ikke helt
rigtigt! Det er nemlig kun et udsnit af de naturlige tal, som vi
kan repræsentere. Så ikke engang denne enkle opgave kan en
computer klare så godt som en almindelig dødelig! Forklaring
følger.
</para>

<para>
Et register er en slags tælleværk, der i dag typisk består
af 32 bits - binary digits. De enkelte digits er lavet ved hjælp
af et transistor mønster, der kan være i to tilstande, 
enten i en tilstand, hvor strømmen kan passere, eller også i en
tilstand, hvor strømmen blokeres. Når der er 32 bits, kan de
danne ca. 4 mia. mønstre eller kombinationer af on/off, 0 eller
1. Det er maximum antal kombinationer. Hvis vi altså tæller fra
0, kan vi komme op på 4 mia med et 32-bit register.
</para>

<para>
Det er derfor, at der har været en grænse for filstørrelser
på de almindeligst forekommende filsystemer. Siger 2GB grænsen
dig noget? Det er den største fil på fx. Linux ext2 filsystemer.
Det kunne have været en 4GB grænse, men én af bit'ene er
reserveret til et andet formål, nemlig til angivelse af, om
systemet er i en fejltilstand efter en skrive- eller
læseoperation.  En bit, on/off, svarer altså til en fordobling af
kombinationsmulighederne, se nærmere nedenfor.
</para>

<para>
Bits er altså repræsenteret ved hjælp af elektriske
kredsløb, der kan aflæses af andre kredsløb.
</para>

<para>
Kalkulator registeret, det vigtigste register på den
traditionelt opbyggede CPU, er en slags tælleværk bestående af
bits (i dag som regel 32), som en kilometertæller, som
kan udføre forskellige regnestykker på det tal, den indeholder.
</para>

<para>
En CPU kan have mange kalkulator-registre. De har navne,
ofte noget med R1 og R2, i Intel-arkitekturen (x86 - CPU'er)
hedder de imidlertid EAX, EBX, ECX etc (hvilket er copyrighted!)
Mange af dem kan udføre regnestykker. På Intel 386 arkitekturen
(og Pentium m.v.) kan man dog se en vis fortrinsstilling for EAX
registeret. Men denne bog handler ikke om Intel. Hvis Intels
CPU'er interesserer dig, så hent fra www.intel.com "Intel
Architecture Software Developer's Manual" (det er 3 PDF-filer på
ialt omkring 15 MB), eller find en bog om assemblerprogrammering,
eller prøv at læse den Assembly-HOWTO, som følger med bl.a.
Red Hat Linux.
</para>

<para>
Hvis CPU-en har 32-bit registre, så kan man skrive tal fra
0 til 4 milliarder. Selv om det er mange, er det ikke ALLE de
naturlige tal - de fortsætter jo opefter, mod uendelig, som man
siger. Selv om det heller ikke er muligt at finde noget i
universet, som er uendeligt, man bliver om jeg så må sige træt
inden man når dertil, er det alligevel en mere begrænset
repræsentation af talsystemet, som vi får med en 32-bit computer
<footnote id="C-tid"><para>En lidt mere seriøs beskrivelse af tid,
uendelighed og rum kan man finde i Stephen Hawking's "Brief
History Of Time", nej, ikke Stephen King!</para></footnote>

Metoden til at tælle ved hjælp af bits, som du sikkert kender
eller allerede har regnet ud, kan illustreres med følgende tabel
(med kun 4 bit):
</para>

<para>
 <informaltable frame="all">
   <tgroup cols="5">
<thead>
  <row>
    <entry>ottere</entry>
    <entry>firere</entry>
    <entry>toere_</entry>
    <entry>enere_</entry>
    <entry>værdi med almindeligt 10-talsystem</entry>
  </row>
</thead>
<tbody>
  <row>
    <entry>0</entry>
    <entry>0</entry>
    <entry>0</entry>
    <entry>0</entry>
    <entry> == 0</entry>
  </row><row>
    <entry>0</entry>
    <entry>0</entry>
    <entry>0</entry>
    <entry>1</entry>
    <entry> == 1</entry>
  </row><row>
    <entry>0</entry>
    <entry>0</entry>
    <entry>1</entry>
    <entry>0</entry>
    <entry> == 2</entry>
  </row><row>
    <entry>0</entry>
    <entry>0</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry> == 3</entry>
  </row><row>
    <entry>0</entry>
    <entry>1</entry>
    <entry>0</entry>
    <entry>0</entry>
    <entry> == 4</entry>
  </row><row>
    <entry>0</entry>
    <entry>1</entry>
    <entry>0</entry>
    <entry>1</entry>
    <entry> == 5</entry>
  </row><row>
    <entry>0</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>0</entry>
    <entry> == 6</entry>
  </row><row>
    <entry>0</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry> == 7</entry>
  </row>
</tbody>
   </tgroup>
</informaltable>
</para>

<para>
Som man kan se kan kolonnerne kaldes ENERE, TOERE og FIRERE
i analogi med vores ti-tal system, hvor vi siger, at kolonnerne
repræsenterer enere, tiere og hundreder etc.
</para>

<para>
Hvis vi har brug for mere, kan vi imidlertid godt sætte
flere registre, eller flere memory celler, sammen, så vores tal
kan blive større. Det er forholdsvis enkelt.
</para>

<para>
De negative tal kunne vi repræsentere ved at markere med en
ekstra bit (eventuelt et helt andet sted) at vi skulle gange med
-1. Nogle maskiner kan faktisk skelne mellem +0 og -0! Men det er
ikke populært i dag. Man vælger som regel en anden metode.
</para>

<para>
Man indretter CPU registrene sådan, at når man tæller op,
så bliver 1...1111 til 0...0000 (for ikke at skrive alle 32 bit,
skriver jeg 1...1111.) Det ligner lidt en kilometertæller, som
når den har nået det største tal, den kan vise, går tilbage til
0, altså fx. går fra 99999 til 00000. 

Men altså, det skal forestille, at alle bit er tændt - det kalder
man, at de er sat. Hvis det er et 32-bit register, svarer det til
ca. 4 milliarder. Når man så lægger 1 til, bliver resultatet 0!
Det ligner ikke helt til den verden, vi ønsker at repræsentere
med vores computer programmer. Derfor bør man under programmering
altid være opmærksom på grænserne for de tal, man arbejder med.
Det er imidlertid ikke så slemt, som det lyder.
 <informaltable frame="all">
   <tgroup cols="32">
<tbody>
  <row>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
  </row>
</tbody>
   </tgroup>
</informaltable>
</para>

<para>
Altså, når alle bit er sat, og vi lægger en til, så slukker
de alle sammen. Derfor kunne det være en god ide at lade 1...1111
repræsentere det negative tal -1.
</para>

<para>
</para>

<para>
 <informaltable frame="all">
   <tgroup cols="5">
<thead>
  <row>
    <entry>fortegn</entry>
    <entry>_______</entry>
    <entry>_______</entry>
    <entry>_______</entry>
    <entry>værdi med almindeligt 10-talsystem</entry>
  </row>
</thead>
<tbody>
  <row>
    <entry>1</entry>
    <entry>0</entry>
    <entry>0</entry>
    <entry>0</entry>
    <entry> == -8</entry>
  </row><row>
    <entry>1</entry>
    <entry>0</entry>
    <entry>0</entry>
    <entry>1</entry>
    <entry> == -7</entry>
  </row><row>
    <entry>1</entry>
    <entry>0</entry>
    <entry>1</entry>
    <entry>0</entry>
    <entry> == -6</entry>
  </row><row>
    <entry>1</entry>
    <entry>0</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry> == -5</entry>
  </row><row>
    <entry>1</entry>
    <entry>1</entry>
    <entry>0</entry>
    <entry>0</entry>
    <entry> == -4</entry>
  </row><row>
    <entry>1</entry>
    <entry>1</entry>
    <entry>0</entry>
    <entry>1</entry>
    <entry> == -3</entry>
  </row><row>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>0</entry>
    <entry> == -2</entry>
  </row><row>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry> == -1</entry>
  </row>
</tbody>
   </tgroup>
</informaltable>
</para>

<para>
Som man kan se, nytter det ikke noget her at kalde
kolonnerne for ENERE, TOERE og FIRERE. Hvis man skal give denne
"konvertering af betydningen" et navn, så plejer man at kalde den
2's komplement. Men egentlig er det
2<superscript>32</superscript>'s komplement, d.v.s.
2<superscript>32</superscript>-tal.
</para>

<para>
Det er nok lettere at se det for sig med en illustration.
Man repræsenterer f.x. 1 med en bit i den ene ende. Når man
vender alle bits om, så 0'er bliver til 1 og omvent (inverterer),
og lægger 1 til, så får man bitmønsteret til repræsentation af
-1.
</para>


<example id="ex-tal-0-7">
<title> tallene fra 0 til 7 og 0 til -7.</title>
<programlisting>
   0: 0000, Inverted: 1111, Complement(til 2^4): 0000
   1: 0001, Inverted: 1110, Complement(til 2^4): 1111
   2: 0010, Inverted: 1101, Complement(til 2^4): 1110
   3: 0011, Inverted: 1100, Complement(til 2^4): 1101
   4: 0100, Inverted: 1011, Complement(til 2^4): 1100
   5: 0101, Inverted: 1010, Complement(til 2^4): 1011
   6: 0110, Inverted: 1001, Complement(til 2^4): 1010
   7: 0111, Inverted: 1000, Complement(til 2^4): 1001
</programlisting>
</example>

<para>
Når der er tale om 32 bit heltals repræsentation, er det lettere
at benytte hexadecimal notation. Tallene fra 0-9 skrives som
sædvanlig 0-9, men 10-15 skrives a-f. Det betyder, at man kan
repræsentere 4 bit med ét 'ciffer', hvor ciffer skal forstås som
0-9a-f.
</para>


<example id="ex-numrep1">
<title> tallene fra 0 til 7 og 0 til -7.</title>
<programlisting>
Word: 00000000, Inverted: ffffffff, Complement: 00000000
Word: 00000001, Inverted: fffffffe, Complement: ffffffff
Word: 00000002, Inverted: fffffffd, Complement: fffffffe
Word: 00000003, Inverted: fffffffc, Complement: fffffffd
Word: 00000004, Inverted: fffffffb, Complement: fffffffc
Word: 00000005, Inverted: fffffffa, Complement: fffffffb
Word: 00000006, Inverted: fffffff9, Complement: fffffffa
Word: 00000007, Inverted: fffffff8, Complement: fffffff9
</programlisting>
</example>

<para>
Fortsætter man denne tankegang, så bliver det største tal
med 32 - bit ca. 2 milliarder, og det er stadigvæk en pæn sjat.
</para>

<para>
Grunden til, at Linux ext2 fil systemet ikke kan have
filer, som er større end 2 GB er forresten, at fil write og
access sker via interfaces, som benytter 32 bit størrelser, og
den ene af bit'ene er også her anvendt til fortegn.
</para>

<para>
Et program, som frembringer udskriften ovenfor (fig
<xref LinkEnd="ex-numrep1">) er vist i <xref
LinkEnd="outformat1">.
</para>

<para>
Det er muligt at repræsentere tal på andre måder end 
den her viste. <!-- (TODO: henvisning!) --> Men vigtigere, det er
muligt at repræsentere andet end tal. Bogstaver kan repræsenteres
ved hjælp af tal, den simpleste løsning på en computer med
mulighed for at repræsentere tekst er jo den kendte metode med en
byte pr. bogstav. Det er ikke nok, hvis der også skal være plads
til at repræsentere græske bogstaver, matematiske symboler, og
slet ikke, hvis også forskellige grafiske symboler,
font-beskrivelser etc. skal repræsenteres. Men det er en helt
anden historie.
</para>

<para>
Andre ting, som fx. grøntsager og frugt, må repræsenteres
ved bits og bytes på samme måde som tal og bogstaver. Hvis du er
ny i programmering, vil det klogeste være at afprøve nogle
programmer nu, måske endda bruge 3 - 4 måneder på eksemplerne og
øvelserne i <xref LinkEnd="tour"> kapitlet.
 Hvis du på den anden side kender lidt til programmering og
gerne vil køre tanken om repræsentation til ende, så er der to
begreber, som vi skal tygge lidt på: Simuleringer og modeller.
</para>
</sect1>

<sect1 id="simulering-modeller">
<title>Simulering - Modeller</title>
<para>
For lige at få lidt mere 'real-life' perspektiv på
datarepræsentation, så forestil dig et program, som skal simulere
noget, der foregår i det virkelige liv, matador-spil,
adventure-spil (som på visse punkter forventes at svare til ting,
vi kender fra dagligdagen), eller beregning af en vejrudsigt.
Vind fra vest med lavtryk - hvor ligger grænsen (isobar linien)
for 990 millibar etc.etc. Man kan fx. opdele luftrummet over
Skandinavien i firkanter med hver deres vejr-målinger og beregn
interaktionen mellem firkanterne efter de fysiske love for tryk
udligning, temperaturudvidelser etc. - pyha, godt det ikke skal
udregnes i hånden!
</para>

<para>
Simuleringer er så forskellige. Man kan simulere
reaktionerne på håndtag og visningen i instrumenter i et
flycockpit for at give piloterne øvelse i at betjene
styremekanismerne; eller man kan simulere eller efteligne lydene
fra et spillende symfoniorkester.  Simuleringerne svarer ikke på
alle punkter til virkeligheden, men kan være nyttige og mere
eller mindre tæt på virkeligheden.
</para>

<para>
Hvis vi skulle beregne det mest rentable dyrkningsforløb for
tomater i drivhus, hvad skulle vi så vide om dem? Jeg behøver
ikke spørge, om vi kunne spise resultatet af simuleringen! Men en
ting er sikkert, der skulle mange oplysninger til, de fleste af
dem skulle opsamles ved hjælp af grundige forsøg og målinger, som
ville ende med nogle tal, der repræsenterede egenskaber ved
forløbet.
</para>

<para>
Derimod så ligner et investeringsspil og en investerings
service for bankkunder hinanden så meget, at man kan bruge det
ene program som grundlag for den virkelige service. Her bliver
der blot koblet betalingstransaktioner på spillet, med tilhørende
retsansvar.
</para>

<para>
Kobler vi simuleringerne på virkelige objekter (med passende
teknik, som i sig selv kan være komplicerede computersystemer) kan
computeren anvendes som værktøj til at "styre virkeligheden",
måske bedre, end vi kan gøre det, men til syvende og sidst blot
som vores "forlængede arm".
</para>

<para>
Simulerings- og styringsteknikker hviler på evnen til at
repræsentere begreber og objekter ved hjælp af computerens bits.
Som nævnt er denne repræsentation altid mangelfuld. Den
opfattelse af verden, som måtte ligge til grundlag for
simuleringerne, kaldes en model. Modellen er altså ikke kun
repræsentationen af statiske, ubevægelige, egenskaber, som
tingene har, men også af deres måde at bevæge sig og indgå
forbindelser med hinanden, sådan som fx. de enkelte styrehåndtag
i en flysimulator må reagere på og med hinanden.
</para>

<para>
Men ligesom talrepræsentationen er mangelfuld, så vil
modeller også være mangelfulde. Ikke p.g.a. at der mangler den
syvende eller niende decimal, men fordi der er grænser for, hvor
meget programmøren kan forudse. Havarisituationer,
vejrsituationer, forskellige former for landskabsforhindringer
etc. kan kun i et begrænset antal være repræsenteret i en
computer. På et eller andet tidspunkt kommer man (efter meget
arbejde) formentlig til en model, som tilfredsstiller brugerne af
modellen så meget, at de opfatter modellen som en fuldt funktionel
fremstilling af virkeligheden.
</para>

<para>
Den slags tanker virker specielt tiltrækkende på børn og
reklamefolk. Måske også på fabrikanter af computerspil. Ord som
cybernetics, cyberspace og cyborg spiller på dette element af "en
verden inde i computeren".
</para>

<para>
Man kunne sige, at vi har "mappet", kortlagt, en del af den
virkelige verden ved hjælp af vores computers bits og nogle
programmer, som behandler dem i overensstemmelse med vores
fortolkning.
</para>

<para>
Denne teknik, at "mappe" en mængde af elementer, således at
de repræsenteres af en anden mængde, er den grundlæggende disciplin
for applikationsprogrammører. Alan Turing har omkring 1940-1950
beskrevet det teoretiske grundlag for computerens virkemåde, og hans
arbejde er stadig interessant for programmører, der vil forstå muligheder
og grænser for computerens "indre univers".
</para>
</sect1>
</chapter>

<chapter id="c-programming-start"><title>C Programmering</title>
<sect1 id="tour"><title>Hello-world programmer</title>

<abstract><para>
Hello-world programmer, filter-programmer,
tilstandsprogrammer, netværksprogrammer, client server
programmer, systemprogrammer, databaseprogrammer,
værktøjsprogrammer - betegnelser af praktisk art, ikke
systematiske kategorier.
</para></abstract>

<sect2 id="brohoved">
<title>Et brohoved.</title>
<para>
Det første skridt, som man foretager på en ny maskine, eller
rettere en ny platform for programmeringsarbejde, bør altid være
at skrive det simplest mulige program, der producerer output.
</para>

<para>
Forhåbentlig kender du Kernighan & Ritchies bog, the
C Programming Language. Det første kapitel, den berømte "tour"
gennem C sproget, starter med et program, der skriver "Hello,
World!" på en output - device (altså en skærm-enhed eller
lignende).<footnote><para>
Hvis du ikke kender bogen "The C Programming Language" af Kernighan &
Ritchie, og hvis du ikke er en øvet C programmør, så vil jeg anbefale,
at du køber den og bruger ca. 14 dage til at arbejde kapitel 1 igennem
- lav så mange af de ekstra øvelser, som du kan nå. Nærværende kapitel
er en ikke en erstatning for den oprindelige "tour", men et supplement
eller brush up, som man nu ser det. Man kalder det for learning by doing
eller deduktiv spiralpædagogik; man udleder, hvordan C sproget fungerer
ved at prøve det mange gange og ved at gøre
øvelser lidt sværere hver gang.
</para>

<para>
Har du ikke det grundlag, vil du undre dig over, at bogen
her ikke forklarer noget om de grundlæggende datatyper, om
operatorerne, om flow-konstruktionerne - eller om opdeling af
programmer i moduler. Disse fire dele af ethvert
programmeringssprog bør man jo kende og forstå. (Hvis der er
interesse, skriver vi et appendix A. Crash Course i C.)
</para>

<para>
Det specielle ved Kernighan & Ritchies programeksempler i Kapitel 1 af
den berømte bog er, at programmerne er nyttige. På en kommandolinie kan
de bruges med det samme til endda ret fornuftige og realistiske ting.
Hvis du ikke er fortrolig med kommandolinie syntax, så kan du finde
eksempler i SSLUG-bogen, Friheden til at bruge sin computer.  Det er en
god ide at eksperimentere lidt med de simpleste Unix-programmer, inden
du går videre. Prøv fx. date, cal, uptime, id, who, finger, "echo hej",
strings /usr/bin/ls, file *, ls, pwd, cd, du, df, man gcc, man ld, man
ld.so, ldd /usr/bin/ls osv. (klassiske unix kommandoer).
</para></footnote>
</para>

<para>
Det program kunne man jo så udnævne til stamfaderen for en
hel kategori, nemlig små programmer, som kun udfører en enkelt
funktion. Det kan være det at skrive noget på skærmen. Det kan
være at hente dato-information, så kan vi få bekræftet, om
dato funktionerne opfører sig, som vi forventer, eller ej.
</para>

<para>
Et endnu mere grundlæggende "Hello-world" program er et, som
simpelt hen afslutter med det samme! Sådan et kommer her:
</para>

<example id="ex-hello"><title>HELLO - exitcode</title>
<programlisting role="C">
<literal>
/* frame.c Minimal program til afproevning af exitcode. */

int main()
{
    return 0;
}

/* end of file frame.c */
</literal>
</programlisting>
</example>

<para>
Program-source, kildeteksten består af 8 linier, hvis man
tæller kommentarer og tomme linier med. Aller øverst er der en
kommentar, som fortæller kort hvad meningen med programmet er.
En kommentar startes med "/*" og slutter med "*/".
</para>

<para>
Programmet består af en definition af ét eksternt objekt,
nemlig en funktion, som har navnet "main". Parenteserne efter main
fortæller, at main er et objekt af typen funktion. Parenteserne
kaldes derfor "funktions-operator" <footnote> <para> I K&amp;R(88)
kan man på side 53 finde en tabel over operator præcedens. Deri
kan man finde () øverst, fordi bindingen mellem identifier og ()
er stærkere end bindinger mellem andre operatorer.  </para>
</footnote> Selve koden i main er indrammet i krøllede
parenteser, braces. Koden består af kun én sætning, eller
<emphasis> statement </emphasis>, nemlig 
</para>

<programlisting>
return 0;
</programlisting>

<para>
return er et <emphasis> reserveret ord </emphasis>, d.v.s.
et ord, som compileren er født med at kende. C sproget har 32
reserverede ord.<footnote><para>se appendix A, Crash Course i C.
</para></footnote>
</para>


<para>
Nullet er et "udtryk", (aritmetisk udtryk) med en talværdi.
Vi kunne også have skrevet return 234 eller return 7000143. I
dette tilfælde vil det dog være klogt at holde talværdien på
eller under 255.
</para>

<para>
Eksempler på andre expressions: kroner = timer * timeloen;
hvor det forudsættes at kroner, timer og timeloen er variable,
som indeholder fornuftige værdier. Et expression, som afluttes
med semikolon, kaldes et statement.
</para>

<para>
Hvis der er flere statements i en funktion, udføres de i
rækkefølge, oppefra nedefter.
</para>

<para>
Et kald til en funktion, som fx. flg.: <literal>
abs(-5); </literal> er også et expression, i dette tilfælde med
værdien 5.  Kald til en funktion vil ofte returnere en variabel
af typen heltal <emphasis> integer </emphasis>, og en integer i
et expression kan erstattes af et kald til en funktion, som
returnerer en integer.
</para>

<para>
Det er en konvention, at eksekvering af et program, som
benytter standard library (bibliotek med bl.a. læse og skrive
funktioner) begynder med funktionen <emphasis> main </emphasis>.
Når man kommer til slutningen af denne <emphasis>main</emphasis>
funktion, standser programmet eller "returnerer en
eksit<footnote><para>Dansk retskrivning ser underlig ud her!
</para></footnote> kode til operativsystemet". Denne exit code er
en vigtig meddelelse, eller rettere, det bør den være! Hvis et
program returnerer fra main uden et "return &lt;expression>;" er
det sjusk.
</para>

<para>
Kernighan &amp; Ritchie dropper return statementet en del
gange i <emphasis> bogen </emphasis>, men det er faktisk sjusk
alligevel! De gør det selvfølgelig fordi det er lettere at
forklare et program, hvori der kun er de nødvendigste linier.
</para>

<para>
Exit code bør fortælle, om programmet kunne køre uden fejl,
(d.v.s. uden fejl, der påført af ydre omstændigheder, som fx. at
en datafil mangler).  Det er altså programmørens mulighed for at
signalere til et brugerjob (et script) at "alt er vel" eller
"her opstod en fatal fejl."
</para>

<para>
Hvis programmøren vil fortælle systemet, at der var en fejl,
skrives simpelthen 
</para>

<programlisting>
return 255;
</programlisting>

<para>
Tallet kan i Unix-shell-sammenhæng læses i variabelen $?,
som kan styre flowet i et Unix shell script.<footnote><para>
I Microsoft
miljøer som "errorlevel" der kan bruges af if-sætninger i
batch-filer. </para> </footnote>
Øvelse: Ret, så programmet returnerer 117 og se, om
du kan udskrive shell variabelen $? med kommandoen 
</para>
<programlisting>
echo $?
</programlisting>
<para>
Det lille program ovenfor kunne compileres
<footnote><para>Generer det, hvis jeg staver engelske
computer-udtryk på engelsk? </para></footnote> med flg. kommando:
</para>

<programlisting role="C">
gcc frame.c -o frame
</programlisting>

<para>
Derefter kan det køres fra current directory (i det aktuelle
katalog, eller sagt på en tredie måde, fra det bibliotek, som vi
står i <footnote> <para> Se "Friheden til at programmere"
afsnittet om C sproget, hvis du har brug for lidt mere indføring
i, hvordan man bruger kommandolinien. </para> </footnote> ) med
en kommando som:
</para>

<programlisting role="C">
./frame
   # eller, hvis din PATH variable ender på ':'
frame
</programlisting>

<para>
Eksemplet lider imidlertid af en alvorlig skavank, vi kan
jo næsten ikke se, om programmet rent faktisk kører. Det laver jo
ikke noget! Derfor tilføjer vi en lille output kommando:
</para>

<example id="ex-stdout"><title>Skriv message på standard output.</title>
<programlisting role="C">
<literal>
/* frame2.c Skriv til stdout og afslut. */

#include &lt;stdio.h>

int main()
{
    puts("Hello! Programmet frame2 kører nu...");
    return 0;
}

/* end of file frame2.c */
</literal>
</programlisting></example>

<para>
Her er flere ting, som er værd at lægge mærke til. Dels et
include direktiv, d.v.s. en kommando, som fortæller compileren,
at den skal læse en fil, der hedder stdio.h. Når filnavnet står i
<emphasis> vinkler </emphasis>, så betyder det, at compileren
skal lede der, hvor systemet normalt har sine filer med
erklæringer, "include filerne". På Unix, Linux og andre systemer
er det <filename>/usr/include</filename>, der gennemsøges først.
</para>

<para>
Compileren finder den pågældende file og læser den. Den
indeholder <emphasis>kun type erklæringer</emphasis>.
</para>

<para>
Den erklæring, som vi skal bruge, ser ud som følger:
</para>

<programlisting>
extern int puts (const char *__str);
</programlisting>

<para>
Den kunne dog også have set enklere ud:
</para>

<programlisting>
int puts (char *message);
</programlisting>

<para>
Det kaldes en prototype. Denne gør det muligt for compileren
at checke, at funktionskald vil fungere efter hensigten.
</para>

<para>
Prototypen "int puts(char*)" fortæller, at puts er en
funktion, som returnerer en integer og forventer at få en
character pointer som argument.
</para>

<para>
En prototype for vores main (som burde findes i en af glibc
- systemets header filer) ville hjælpe compileren med at 
kontrollere, om vi overholdt interface mellem vores main og
library startup rutiner.
<footnote>
<para> I glibc2x: se efter
filerne <filename>./sysdeps/elf/start.S</filename> og 
<filename>./sysdeps/generic/libc-start.c</filename>
</para>
</footnote> 
Denne prototype ville se sådan ud:
</para>
<programlisting>
int main(int argc, char *argv[], char *env[]);
</programlisting>
<para>
Det er ikke nødvendigt at at angive et navn, en identifier, på 
argumenterne, kun typen skal angives når vi skriver en prototype.
</para>

<programlisting>
int main(int, char *[], char *[]);
</programlisting>

<para>
Men det er oplagt at finde navne, som giver læseren en hjælp
til at forstå meningen med funktionen. Når vi ikke bruger
parametrene til main, kan vi nøjes med at skrive main(), altså en
tom funktions-parentes.
</para>

<example id="ex-char-ptr"><title>En character pointer</title>
<programlisting role="C">
<literal>
/* frame3.c Demonstration af character pointer. */

#include &lt;stdio.h>

char *message = "Hallo! Programmet frame3 kører nu...";

int main()
{
    puts(message);
    return 0;
}

/* end of file frame3.c */
</literal>
</programlisting></example>
<para>
char *message er erklæring af en variabel. Variabelen er en
character pointer, det vil sige en adresse variabel. Den
initialieseres på samme source linie, som den erklæres. Lad dig
ikke forlede til at tro, at sådan er det også på maskinniveau,
det er simpelthen en praktisk skrivemåde. Det svarer til:
</para>

<programlisting role="C">
char * message;
message = "Hallo etc... ";
</programlisting>

<para>
En literal string, "Hallo etc... "; er ikke en variabel, men er
en besked til compileren om at initialisere et dataområde med den
tekst, som vi nu ønsker os. For at kunne bruge teksten skal vi
enten gemme adressen på den (altså cptr = "Hallo etc...") eller
også give adressen på denne string til den funktion, som skal
bruge den: <literal> puts("Hallo etc.."); </literal>
</para>

<para>
En gengivelse af dette system af RAM-adresser og indhold
kunne tegnes som en reol hvor hver hylde har et indhold, der
enten kan være 4 bytes eller 4 bogstaver, eller én adresse (32
bits).
</para>

<programlisting role="C">
        Adresse               
        eller
        hylde-nr.      Indhold

                    +-------------+
                    |             |
                    |  o !   P    |
           800440   +-------------+
                    |             |
                    |  H a l l    |
           800436   +-------------+
                    |             |
                    |             |
                    +-------------+
                    |             |
                    |             |
                    +-------------+
                    |             |
                    :             :
                    :             :
                    :             :
                    |             |
           120808   +-------------+
                    |             |  Adressevariabel, indeholder
                    |  <800436>   |  adresse på string Hallo! Prog...
           120804   +-------------+
                    |             |
                    |             |
           120800   +-------------+
                    |             |
                    |             |
           120796   +-------------+
                    :             :
                    :             :
                    |             |
                    :             :
                    :             :
                    |             |
</programlisting>


<para>
Det, der skrives på skærmen, er ren og skær tekst, bogstav
for bogstav noget, som ligger i programmet. 
</para>

<para>
Lad os i stedet lave en udregning, og skrive resultatet ud.
Det kunne være et nyttigt program!
</para>

<sect3 id="s3-hello-beregning">
<title>En procentberegning</title>

<example id="ex-hello-beregning"><title>HELLO - beregning.</title>
<programlisting role="C">
<literal>
/* percent.c calculates a percentage of a given number. */

#include &lt;stdio.h>

int main()
{
    int procent = 17;
    int kroner = 100;
    int resultat;

    resultat = kroner * procent / 100;

    printf("resultat er: %d\n", resultat);

    return 0;
}

/* end of file percent.c */
</literal>
</programlisting></example>

<para>
Det er en stor fordel, at resultatet er nemt at kontrollere,
brug simple tal indtil programmet er stabilt.
</para>

<para>
Vi har indført nogle variable - kroner, procent, resultat.
Det er simpelt hen kasser med tal i. Der er straks fyldt værdier
i kasserne.
</para>

<programlisting> 
int kroner = 100;
</programlisting>

<para>
betyder, at vi reserverer en plads til en heltalsvariabel og
straks fylder tallet 100 i.
</para>

<para>
Derefter beregnes resultatet, på samme måde, som man ville
skrive formelen på et stykke papir.
</para>

<programlisting>
resultat = kroner * procent / 100;
</programlisting>

<para>
Resultat er navnet på den "kasse", hvor resultatet skal
gemmes, og den kaldes en "left value", venstre-værdi, fordi den
kan stå på venstre side af et lighedstegn eller assignment
(tildelings) operator. Man kan også sige, at venstre side af
assignment operatoren skal være et udtryk, der kan evalueres som
en adresse. Hvad der måtte ligge af interessante værdier i sådan
en left value forsvinder efter et assignment.
</para>

<para>
<literal>printf()</literal> får at vide, at den skal skrive
variablen "resultat" ud ved hjælp af procent-tegnet efterfulgt af
'd'. Nu får <literal>printf()</literal> ikke én, men
<emphasis>to</emphasis> oplysninger, nemlig format string'en
mellem double quotes, (gåseøjne) og talvariabelen
<emphasis>resultat</emphasis>.
</para>

<programlisting>
"resultat er: %d\n"   <== string-var
"resultat er: %d\n", resultat <== string-var, tal-var
</programlisting>

<para>
Den anden linie kaldes en liste eller en <emphasis>
parameter liste </emphasis>; de to medlemmer er adskilt af et
komma, komma er liste-operator.<footnote><para> Parametre er
oplysninger til en funktion. </para></footnote> 
</para>

<para>
Det er nok lidt for besværligt at rette i programet her,
hver gang jeg vil udføre en procent beregning! Så i stedet laver
vi i næste afsnit et program, som prompter for (beder om input
af) det tal, der skal beregnes procent af.  Dermed forlader vi
"Hello-world" sfæren og bevæger os ind i fejlmulighedernes
paradis, interaktive programmer.
</para>
</sect3>
</sect2>

<sect2 id="prompt-og-input">
<title>Prompt og input</title>
<para>
Input fortjener et kapitel for sig. Men lad os alligevel her
skrive et program, som læser input fra tastaturet, og som godt
nok forventer, at der bliver tastet tal (cifre) ind, men på den
anden side ikke tager skade af, at brugeren indtaster noget helt
andet - eventuelt skubber en bog henover tastaturet, så der kommer
input i store mængder.
</para>

<sect3 id="input-og-beregning">
<title>Input af tal og beregning</title>

<example id="ex-io-ber"><title>Input og beregning.</title>
<programlisting role="C">
<literal>
/* percent2.c ask for a number and calculates a percentage. */

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
    int procent = 17;
    int kroner;
    int resultat;
    char inputlinie[800];

    printf("BEREGNING AF %d %%\n",procent);
    while (printf("Input tal:"), fgets(inputlinie,800,stdin)!=NULL) {
      kroner = atoi(inputlinie);
      resultat = kroner * procent / 100;
      printf("resultat er: %d\n", resultat);
    }
    return 0;
}

/* end of file percent2.c */
</literal>
</programlisting></example>

<para>
I nogle C-library implementationer skal man flushe
printf-output hvis der ikke er en "newline" til sidst:
</para>

<programlisting role="C">
... printf("Input tal:"), fflush(stdout),
</programlisting>

<para>
Denne måde at kæde expressions sammen med
et komma er bestemt ikke den mest pædagogiske. Det er faktisk
grimt! Men når jeg nu har gjort det alligevel, så er det for at
understrege, at C sprogets liste-operator (komma'et) er
anvendelig i mange sammenhæng. Men lad nu være med at skrive for
meget komatøs kode!  
</para>

<para>
Det er værdien af det sidste expression, som er afgørende
for, om expression-listen evaluerer til sand eller falsk.  
</para>

<para>
Input læses af fgets(3). Den skal have 3 oplysninger,
adressen på den buffer, som den må lægge characters i, længden på
bufferen (den læser maximalt længde - 1 og afslutter string med
en null-byte) og den fil, som den skal læse input fra. Her
anvendes "kodeordet" stdin, som er defineret i &lt;stdio.h>.
</para>

<para>
fgets(3) returnerer NULL hvis der ikke er mere input. Dette
kan ske hvis brugeren taster "symbolsk end-of-file", der som
regel sættes til ^D med stty kommandoen. Men hvis input er
omdirigeret, så sker det jo som forventet, når man rammer
slutningen på filen.
</para>

<para>
Der er includeret en fil mere, stdlib.h, som indeholder
prototype til atoi - Ascii TO Integer conversion.<footnote>
<para> Sørg for, at du virkelig ved, hvad ascii er for noget!
</para> </footnote>
</para>

<programlisting>
#define __P(args)  args

extern int atoi __P ((__const char *__nptr));
/* __P(args) er en kommando til præprocessoren, det kaldes
 * en macro, og den har til formaal at goere
 * library funktionerne brugbare sammen med mange
 * forskellige C compilere. Nogle varianter C compilere kan
 * ikke forstå komplicerede prototype erklæringer.
 */
/* derfor svarer denne prototype til:
extern int atoi(const char* string_som_skal_converteres);
 */
</programlisting>

<para>
Det smukke i percent2.c er, at man ikke kan få programmet
til at gå ned ved ondskabsful indtastning, når der promptes for
et tal. Man kan godt få det til at regne forkert, hvis man
indtaster et tal, som er større end 126 mio.  Men dels er fgets()
en robust funktion, som ikke laver buffer overflow, selv om
brugeren indtaster 2 GB data, og <literal> atoi(char*) </literal>
er en robust konverteringsrutine, som ikke brokker sig, hvis
input ikke er cifre.  Hvis man indtaster bogstaver, ignoreres de,
og der returneres 0.
</para>

<para>
88kr. vil blive konverteret til heltallet 88, hvilket svarer
til, hvad man forventer. Senere vil vi lave en
indtastningsruting, som giver brugeren en warning, hvis han ikke
indtaster tal. <!-- TODO -->
</para>

<para>
Det er programmørens ansvar at sørge for den rigtige
længdeangivelse til fgets' anden parameter. Det er lettere at
holde styr på den slags, hvis man benytter preprocessor macro'er
til at definere symboler for konstant-talværdier.
</para>

<programlisting role="C">
#define MAXLINIE 800
char inputlinie[MAXLINIE];

main()
{
    fgets(inputlinie, MAXLINIE, stdin);
    return 0;
}
</programlisting>

<para>
Ikke semikolon i #define linien, det er <emphasis> ikke
</emphasis> et statement.
</para>

<para>
Øvelser for de lidt mere erfarne: Prøv at ændre programmet,
så der anvendes double precision floating point variable. Prøv
også at tilføje en kontrolberegning, som finder ud af, om der har
været overflow. Hvis der er overflow, så skriv en fejlmeddelelse
til brugeren i stedet for at skrive resultatet, men stop ikke
programmet.
</para>

<para>
Prøv også at skriv en version, hvor man kan indtaste
procentsatsen først, eller et, som udskriver værdien af kroner i
både australske, canadiske og US dollar.
</para>

<para>
Lav et program, som udskriver flere valutaer pr. linie i en
tabel, fx.  svarende til kr. 100, 200, 300, 400, 500 ... ) 
</para>
</sect3>
</sect2>

<sect2 id="modular-beregning">
<title>ANSI prototyper og modularisering</title>
<para>
Hvis vi skal omregne kroner til en anden valuta med
mange decimaler og skiftende kurser, så kan det være
berettigelse nok til at lave en lille kursomregner. 
Det er nu mest for at arbejde med et eksempel på, hvordan 
man kan lave en beregningsfunktion, der kan genbruges
i forskellige sammenhæng. For en "euro-funktion" er det
forhåbentlig indlysende, at den vil kunne indgå i bankers
udbetalingsautomater, i faktureringsprogrammer etc.etc.
</para>

<para>
Lad os derfor benytte kursomregning til at forske i den
teknik, som kaldes modularisering. Vi vil gerne ende med at have
et bibliotek, som indeholder omregningsfunktioner af forskellig
slags, med og uden gebyr og afrunding etc, men vi begynder ganske
simpelt med en funktion, som får vores kroner og "afleverer" dollar
(eller Euro<!--&eur;-->); vores udgangspunkt er en tilretning af
<xref LinkEnd="ex-io-ber">.
</para>

<para>
Jeg må indrømme, at jeg efter at have skrevet dette her afsnit syntes,
at det var lidt rigeligt langt! Men grunden til, at jeg lader det stå
er, at jeg har set så mange programmører, der havde svært ved at forstå
mekanikken i funktionskald. Når man forstår hvad der sker i computeren
under et funktionskald, så først kan man udnytte C sprogets fulde
styrke.
</para>

<sect3 id="spaghetti">
<title>Beregning som del af main-koden</title>

<example id="ex-dollar-omregning">
<title>Dollar omregning, spaghetti 
<footnote><para>
Spaghetti er en derogativ betegnelse for en lang, uoverskuelig
liste med programmeringsinstruktioner. 
(Eller er det noget andet?  ;-)
</para>
</footnote> version.
</title>

<programlisting role="C">
/* dollar0.c Input Kroner, beregn Dollar. UDGANGSPUNKT. */

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
    int kurs = 865;
    int kroner;
    int resultat;
    char inputlinie[800];

    printf("OMREGNING FRA KRONER TIL DOLLAR, KURS %d\n",kurs);
    while (printf("Input tal:"),
           fgets(inputlinie,800,stdin)!=NULL) {
      kroner = atoi(inputlinie);
      resultat = kroner * 100 / kurs;
      printf("Kroner %d giver Dollar %d\n", kroner, resultat);
    }
    return 0;
}

/* end of file dollar0.c */
</programlisting>
</example>

<para>
Først trækker vi beregningen ud af programmet og lægger den
i en funktion, som vi kalder kr2dollar.
</para>

</sect3>
<sect3 id="ANSI-prototyper">
<title>ANSI prototyper</title>

<example id="ex-dollar-funktion">
<title>Dollar omregning med beregning i funktion.</title>
<programlisting role="C">
/* dollar1.c Input kroner, call int kr2dollar(int) */

#include &lt;stdio.h>
#include &lt;stdlib.h>

/* vi erklærer nu en prototype for vores funktion. En prototype kan
 * kendes på, at der efter funktionsparentesen er et semikolon - ikke
 * nogen braces, som ville signalere starten af en kodeblok.
 */

int kr2dollar(int);
int kurs = 865;

int main()
{
    int kroner;
    char inputlinie[800];
    int resultat;

    printf("OMREGNING FRA KRONER TIL DOLLAR, KURS %d\n",kurs);
    while (printf("Input tal:"),
           fgets(inputlinie,800,stdin)!=NULL) {
      kroner = atoi(inputlinie);
      resultat = kr2dollar(kroner);
      printf("Kroner %d giver Dollar %d\n", kroner, resultat);
    }
    return 0;
}

int kr2dollar(int kr)
{
    return kr * 100 / kurs;
}

/* end of file dollar1.c */
</programlisting>
</example>

<para>
Bemærk, at main står øverst i programmet. C inviterer til top -
down programmering. Vi kan kalde kr2dollar uden at have nogen
som helst ide om, hvordan vi vil implementere den. Selvfølgelig
er programmet ikke færdigt, før end vi har skrevet den sidste
kode, men i nødsfald kan man somme tider klare sig med en
forsimplet udgave - eller en stub, en tom funktion - der, hvor
man ikke har skrevet al koden.
</para>

<para>
Men funktionen kr2dollar er <emphasis> erklæret </emphasis>
inden den anvendes, det er linien lige neden under #include
direktivet.  Erklæringen er en slags forklaring til compileren
af, hvad det er for en slags funktion. Den bevirker, at
compileren opretter en entry i en symboltabel, så den kan slå
op, hvad "kr2dollar" er for noget, næste gang den forekommer i
kildeteksten. 
</para>

<para>
Det bevirker, at compileren ved, hvad type der kommer ud af
funktionen, det kunne jo være, at det var en flydendetals dims i
stedet for et heltal. (Ja forresten, det synes du nok, at det
burde være!  Det ville være rart med flydende tal for at få
decimaler på, se <xref LinkEnd="ex-dollar-double">. Men strengt
taget kunne vi få en mere præcis beregning ved at anvende
64-bits integers til at repræsentere 100-dele øre. For den
avancerede: Prøv det! Og husk at indsætte et komma (på det
rigtige sted) når du skriver det ud.
</para>

<para>
<literal> kr2dollar() </literal> består af KUN et return
statement. Godt nok skal der regnes lidt, før end return værdien
er klar, det er jo selve ideen i funktionen.
</para>

<para>
I almindelig stenalder C kunne man nøjes med at kalde
funktionen uden at forklare compileren, at det var en funktion,
der returnerede en integer. Det kaldes "implicit integer"
regelen. <footnote><para>Det hænger sammen med, at der 
alle funktioner i de aller første C compilere returnerede
en integer. Funktioner, som returnerer doubles er stadig i
mindretal.</para></footnote>
</para>
</sect3>

<sect3>
<title>Modulariseret udgave af beregningen</title>

<para>
Nu skiller vi beregnings funktionen ud, så den ligger i en
fil for sig selv - den er på vej til at blive en del af vores
"financial library" (;-).
</para>

<para>
Desuden lader vi variabelen "resultat" udgå, for vi kan jo
bare anbringe funktionskaldet der, hvor resultatet skal skrives.
</para>

<example id="ex-dollar-int-main">
<title>Dollar omregning, modul version.</title>
<programlisting role="C">
/* dollar2.c ask for Kroner and call int kr2dollar(int) */

#include &lt;stdio.h>
#include &lt;stdlib.h>

int kr2dollar(int);

int main()
{
    int kroner;
    char inputlinie[800];

    printf("OMREGNING FRA KRONER TIL DOLLAR\n");
    while (printf("Input tal:"),
           fgets(inputlinie,800,stdin)!=NULL) {
      kroner = atoi(inputlinie);
      printf("Kroner %d giver Dollar %d\n", kroner, kr2dollar(kroner));
    }
    return 0;
}
/* end of file dollar2.c */
</programlisting></example>

<para>
Som det kan ses, har vi klippet de nederste 4 linier ud,
hvor funktionen kr2dollar var defineret. Den står nu i en fil,
som vi kalder kr2dollar.c:
</para>

<example id="ex-dollar-funktion-int">
<title>kr2dollar modul.</title>
<programlisting role="C">
/* kr2dollar.c - beregn dollar ud fra kroner */

int kr2dollar(int kr)
{
    int kurs = 865;
    return kr * 100 / kurs;
}
/* end of file kr2dollar.c */
</programlisting></example>

<para>
Kursen er ikke mere tilgængelig i main, vi har
isoleret den, så den kun kan ses i funktionen, som omregner. Det
er en primitiv udgave af et udmærket princip. 
</para>

<para>
Det ville være fint, hvis vi skrev en funktion, som hentede
kursen fra en pålidelig kilde, fx. en eller anden nationalbank
på internettet.  Når vi så skulle bruge kursen, kunne vi kalde
denne funktion. 
</para>

<para>
De to filer kan kompileres på flere forskellige måder:
</para>

<para>
Enten:
</para>

<programlisting>
gcc -Wall dollar2.c kr2dollar.c -o omregning
</programlisting>

<para>
Eller:
</para>

<programlisting>
gcc -Wall -c dollar2.c
gcc -Wall -c kr2dollar.c
gcc dollar1.o kr2dollar.o -o omregning
</programlisting>

<para>
Eller:
</para>

<programlisting>
gcc -Wall -c kr2dollar.c
ar -rv libfinans.a kr2dollar.o
gcc -Wall -c dollar2.c
gcc -Wall dollar1.o -L./ -lfinans
</programlisting>

<para>
Læg lige mærke til, at vi har genereret en library file med
en meget simpel kommando, ar -rv libfinans.a &lt;objectfile> ...
</para>

<para>
Hvis vi skulle glemme prototypen for denne simple beregning,
så vil der ikke opstå fejl. Det skyldes, at vi stadig har regelen
om implicit integer, når vi skriver standard C programmer.
<footnote><para> Reglen kan være meget praktisk for den erfarne
programmør, som i visse situationer kan gøre et program lidt mere
læseligt, fordi der er mindre "støj". <!-- COMMENT: Men der er en
sjov historie om dette religiøse spørgsmål! Bjarne Stroustrup
overvejede, hvordan man dog skulle kunne klare problemerne med
implicit integers og ingen parametre, som før var det samme som,
at alt var tilladt! En dag siger Ritchie til ham, at det skal han
da ikke spekulere på, man kan da godt indføre et krav om, at
parametre skal specificeres. - eller lignende emne, hvor Ritchie
gav ham støtte til at gå videre med sagen. --> </para>
</footnote>
</para>

<para>
Med GNU - C compileren vil man dog få en warning: implicit declaration
of function `kr2dollar'. Det betyder simpelthen, at compileren har
opdaget, at vi kalder kr2dollar, men ikke kan finde den i typetabellen.
Compileren antager at funktionen returnerer en integer. Man får kun
denne warning, hvis man anvender -Wall (Warning level, give us ALL
warnings).
</para>
</sect3>


<sect3>
<title>Modul med return type double</title>

<para>
Lad os nu prøve at definere kr2dollar() som en funktion, der
returnerer en double. Prøv nogle eksperimenter med programmet.
Der er vist nogle forslag.
</para>

<example id="ex-dollar-double"><title>Dollar omregning, double version.</title>
<programlisting role="C">
/* dollar3.c bed om Kroner og call double kr2dollar(double) */

#include &lt;stdio.h>
#include &lt;stdlib.h>

double kr2dollar(double);  /* prøv at udelade denne her! */
/* senere kan vi bruge en include fil:
 * #include "dollar3.h"
 * Bemærk, at der er anvendt double quotes om filnavnet fordi denne fil
 * ligger i current directory.
 */


int main()
{
    double kroner; /* input konverteret */
    char inputlinie[800];

    printf("OMREGNING FRA KRONER TIL DOLLAR\n");
    while (printf("Input tal:"),
           fgets(inputlinie,800,stdin)!=NULL) {
      kroner = strtod(inputlinie, NULL);
      printf("Kroner %10.2f giver Dollar %10.2f\n", kroner, kr2dollar(kroner));
    }
    return 0;
}
/* end of file dollar3.c */
</programlisting></example>

<para>
I ovenstående eksempel er det nødvendigt, at der erklæres en
prototype for kr2dollar. Hvis prototypen udelades, vil gcc, ligesom i
forrige eksempel, stadig <emphasis>kun</emphasis> give en warning,
og endda kun under forudsætning af, at -Wall anvendes! 
</para>

<programlisting id="wrong-type-coersion">
gcc -Wall -c dollar3x.c # version uden prototype for kr2dollar():
pluto:/qf3/attic/don/fri ::gcc -Wall -c dollar3x.c
dollar3x.c: In function `main':
dollar3x.c:16: warning: implicit declaration of function `kr2dollar'
dollar3x.c:16: warning: double format, different type arg (arg 3)
</programlisting>

<para>
Og her kommer så den anden fil med funktionen, som foretager
omregning med double precision floating point parameteren kr.
</para>

<example id="ex-dollar-modul-double">
<title>kr2dollar, return type double, module.</title>
<programlisting role="C">
/* kr2dollar.c - beregn dollar ud fra kroner, double */


double kr2dollar(double kr)
{
    return kr / 8.65; 
}
/* end of file kr2dollar.c */
</programlisting></example>


<para>
Kompilering uden prototype vil som sagt alligevel resultere i en
objektfil, som kan linkes med vores nye finans-library uden at man får
en fejlmeddelelse. Når man kører et sådant program, skriver printf fire
bytes ud som om det var en integer, selv om det altså er en del af en
double precision floating point variabel.
</para>

<para>
Det, som jeg prøver på at demonstrere, er konsekvensen af, at 
ANSI-C specifikationen 
ikke omfatter et krav om typekontrol under link-processen.
Derfor er det nyttigt at tage notits af alle warnings.
</para>

<para>
<literal>strtod(3)</literal> (STRing-TO-Double) er en funktion, som
konverterer en string til double. Denne funktion er mere avanceret end
atoi, idet den kan sætte en fejl-variabel, hvis konverteringen ikke
lykkes, og den kan flytte en pointer hen ad tekst strengen til det
første bogstav, der ikke kunne konverteres. Her bruger vi den imidlertid
på en mere simpel måde, vi giver den blot NULL som anden parameter, så
går det nok alt sammen ...  
</para>

</sect3>
<sect3>
<title>Header filer</title>
<para>
For at automatisere processen med prototyper er det skik og brug at man
laver en header fil til hvert projekt, som man har i gang. I vores
minimal eksempel her:
</para>
<example><title>Header fil for kr2dollar</title>

<programlisting>
/* File: dollar3.h, prototypes for finans-program ... */

double kr2dollar(double kroner);

</programlisting>
</example>

<para>
Denne fil kan includeres i både der, hvor funktionen skal
anvendes, og der, hvor den defineres (programmeres). Det giver
jo kontrol med tingene.
</para>

<para>
Men der er en lignende regel, som tillader, at en integer
defineres 2 gange. Det er straks mere upraktisk og kan ikke
tillades i C++.
</para>

</sect3>
</sect2>
</sect1>



<sect1 id="filter-programmer">
<title>Filter programmer</title>
<para>
Kroner-til-dollar programmet er beregnet til interaktion med
en bruger ved skærmen. Vi vil se på programmer, som er beregnet
til batch kørsel. Først en forklaring. Fordelene er så store, at
man selv i gui-miljøer stadig bruger kommandolinier til den slags
ting. (I øvrigt: Bag ethvert GUI, selv Apple's McIntosh, gemmer
der sig en kommandolinie. Nogle er bare gemt bedre end andre,
hvilket egentlig er et bedrag og sælges under betegnelsen
beskyttelse af/mod brugeren!)
</para>

<para>
Grundlæggende program:
</para>

<example id="simpelt-filter">
<title>Simpelt filter, input til output.</title>
<programlisting role="C">
/* filter0.c */

#include &lt;stdio.h>

int main()
{
    char c;
    while ( (c=getchar()) != EOF)
      putchar(c);
    }
    return 0;
}
</programlisting>
</example>

<para>
Ud over de grundlæggende typer textfiltre, som som vi har
set på her, ville det være nyttigt at se et par eksempler på
filter programmer, som kan konvertere tegnsæt, filtrere
mime-encodede mailfiler, og en slags preprocessor filter, som kan
forstå &lt;tags> og, i første omgang, checker
grundlæggende syntax for sådanne tags, fx. om der er matchende
tags.
</para>

<para>
For nu at begynde med noget, der er til at overse, så lad os
lave et program, som læser en fil med tal og lægger dem sammen
og skriver resultatet. Efterhånden, som vi forbedrer programmet,
kan det blive til en kalkulator, som enten læser regnestykkerne
fra en fil eller fra tastaturet. Det er fascinerende at se et
program, der kan behandle en megabyte datafil på brøkdele af et
sekund.
</para>

<para>
Allerede nu kan det forudses, at den - hvis vi kan "forstå"
negative tal, også ville kunne trække fra.
</para>

<para>
Der findes situationer fra det virkelige liv, hvor sådan et
program kunne være nyttigt. Hvis vi fx. har foretaget et udtræk
fra en stor database med alle telefon taksttelegrammer fra lørdag
24.00 til søndag 06.00, så kan vi beregne den samlede tid og hvor
meget det ville koste at give natterabat. Men også datafiler fra
alle mulige andre situationer ville kunne være input. Normalt vil
man på Unix klare den slags med awk, men hvis man skulle
optimere (fx. p.g.a. store datamængder fra en telefoni-data), så
kunne det blive aktuelt at skrive det rå C program.
</para>

<para>
Vores program vil have en pseudokode nogenlunde sådan her:
</para>

<programlisting>
Så længe der er linier,
  læse næste linie,
  konverter linien til et tal, hvis muligt
     er det ikke et tal, så vis linienr, linie og exit;
  læg tallet til totalen.
Print totalen.
</programlisting>

<para>
Programmet er så simpelt, at vi skriver det i et hug.
</para>

<example id="beregnings-filter">
<title>Filter som konverterer linier med tal til summen af tallene.</title>
<programlisting role="C">
/* summer.c */

#include &lt;stdio.h>
#define MAXL 80000
int main()
{
    char line[MAXL];/* for input */
    char *ptr; /* for strtod konverteringspointer */
    double tal;/* for det laeste tal */
    double sum;/* for totalen */

    while ( (fgets(line,MAXL,stdin) != NULL)
     tal = strtod(line,&amp;ptr)
     sum += tal;
    }
    printf("%g\n",sum);
    return 0;
}
/* end of file summer.c */
</programlisting>
</example>

</sect1>


<sect1 id="parser-filter-programmer">
<title>Parsere set som filter programmer</title>

<para>
Det filter, som jeg tænker på at gennemgå her, kunne man lige så
godt kalde en parser. Men strengt taget - der kommer jo altså
noget input ind fra kun én kilde, og afhængigt af dette spytter
programmet noget andet ud. Der er en årsagssammenhæng fra input
til output. Det samme input vil altid give det samme output.
</para>

<para>
Og hvad er det så? Et WORD count filter! Input er tekst, og
output er blot antallet af ord. Provokation! Er det virkelig et
filter? Ja, for det opfylder jo alle de ovenstående krav. Det
sluger input fra en kilde og omformer det til output, som, ok,
kan være det samme for flere forskellige slags input, men samme
input -- altid samme output. Vi baserer vores program på en
lille bemærkning i den Kernighan &amp; Ritchies berømte tour
version af word count: Nemlig at begrebet "et ord" egentlig bør
forfines, så man kan skelne mellem tal, ord, tegnsætning og
andre tegn.
</para>

<para>
Programmet starter med at være i en tilstand, som vi kalder UDE.
Når vi ikke har læst noget, så må vi være UDE af ord, UDE af tal
UDE af tegnsætning.
</para>
<para>
Vi skal benytte en variabel til at huske denne tilstand, og vi
kalder den status.
</para>
<para>
For at gøre det lettere at læse programmet, lader vi denne
variabel være af enum - typen. Så kan en god compiler holde styr
på, om vi tilskriver den andet end symbolske navne som tilhører
typen. Dog kun med warnings.
</para>

<programlisting>

/*file ordtael.c */

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;ctype.h>

typedef long long _int64;

/* taellere: char, words, num, punc, andet, lines */
_int64 nc, nw, nn, np, na, nl; 

enum status_t { UDE, INDE };

enum status_t status;

int main()
{
    int c;
    while ( (c=getchar()) != EOF) {
        ++nc;
        if (c == '\n')
            ++nl;
        putchar(c);
        if (isspace(c)) {
            status = UDE;
        } else {
            if (ispunct(c))
                ++np;
            if (status == UDE) {
                status = INDE;
                if (isalpha(c)) {
                    ++nw;
                } else if (isdigit(c))
                    ++nn;
                else ++na;
            }
        }
    }
    printf("Antal: chr %Ld, ord: %Ld, tal %Ld, tegn: %Ld, lin %Ld, andet %Ld\n",
            nc, nw, nn, np, nl, na);
    return 0;
}

/* end of file ordtael.c */


</programlisting>

<para>
Det er statusvariabelen, som "husker", om vi er inde i et ord
eller ej. Hvis vi er inde i et ord, så er det nemlig specielt
interessant om vi netop lige nu er ramlet ind i det eller ej.
Hvis vi lige er ramlet ind i det, så betyder det nemlig, at
vores tilstand lige netop nu ændrer sig og derfor bør vi tælle
antal af ord (eller tal, tegnsætning, etc.) op.
</para>

<para>
Det er imidlertid stadig et lidt primitivt program, idet vi
forventer, at når vi kommer ind i et tal, så vil der være
whitespace bagefter. Det er en spændende opgave at ændre dette
program, så det kan håndtere overgang fra tilstand tal til
tilstand tegnsætning, ord eller andet. Det kunne fx. være den
første del af en compiler, som skelnede mellem reserverede ord,
andre ord, tal og tegn.
</para>

<para>
Men lige nu i skrivende stund bliver jeg nødt til at overlade
det til læseren (hallooooo ... er du der?)
</para>

</sect1>

<sect1 id="fejl-og-haandtering">
<title>Fejl og håndteringen af dem.</title>

<sect2 id="fejl-kategorier">
<title>Hvilke slags fejl er interessante</title>
<para>
Det er egentlig ikke så interessant, set fra en programmørs
synspunkt, om en disk bryder sammen. Det kan man nemlig ikke
rigtig gøre noget ved, når det er sket. Den, der skriver drivere
til operativsystemet, ville måske nok kunne lave noget software,
som forudsagde, at hardwaren trængte til service eller
udskiftning. Det er indenfor mulighedernes grænser.
</para>

<para>
Hvis vi skriver et almindeligt filterings program, fx. et,
som konverterer fra MIME/html characters til extended ascii eller
rettere ISO-8859-1, så bør vi altså ikke begynde at lave check af
CPU temperatur, disk tilstand etc. Det hører hjemme et andet sted
og er ikke interessant for vores filterprogram.
</para>
</sect2>
</sect1>


<sect1 id="outformat1">
<title>Flere Hello-world - programmer.</title>
<para>
For at demonstrere styrken af små 10-24 liniers programmer
(Hallo-programmer) kommer her en serie sådanne små særlinge.
</para>

<para>
Her kommer kildeteksten til et program, som kan skrive en
listing af tallene fra 0 til 7, inverteret og som 2's complement.
(Som lovet i <xref LinkEnd="ex-numrep1">).
</para>

<example id="ex-tal-hex">
<title>Tallene fra 0 til 7 i hexadecimal notation.</title>
<programlisting role="C">
/* bitinvert.c viser hexadeximalt tallene fra 0 - 8  */
/* og desuden invertering, og såkaldt 2-s complement */

#include &lt;stdio.h>


char	*thisprg;

int main(int argc, char *argv[])
{
   int jj;

   thisprg = argv[0];

   for (jj=0;jj&lt;8;++jj) {
     printf("Word: %08x, Inverted: %08x, Complement: %08x\n",jj,~jj,~jj+1);
   }
   return 0;
}

/* end bitinvert.c */
</programlisting>
</example>


<sect2 id="OV1">
<title>Øvelser til hele kapitel 1.</title>
<para>
Skriv frame2 om til frame2a, hvor du selv angiver prototypen
for puts, og se, om det kompilerer og eksekverer lige så godt som
frame2.c, der jo bruger headerfilen &lt;stdio.h>
</para>

<para>
Skriv percent.c om, så du også udskriver indholdet af
variablene kroner og procent.
</para>

<para>
Skriv percent.c om, sådan at den beregner 99% af 100
millioner (jo jo, det kan man gøre i hovedet, men det er for at
gøre det nemt at kontrollere resultatet!) Dette er ikke
en helt triviel opgave.
</para>

<para>
Lav en version af programmet, som selv kan finde ud af, om
der er overflow på beregningen. Hint: resultat / procent *
kroner. For den viderekomne kan opgaven løses ved, at man
benytter en assemblerinstruction, som checker for overflow
flaget.
</para>
</sect2>

</sect1>
</chapter>



