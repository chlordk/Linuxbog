<chapter id="c-intro"><title>Introduktion</title>
<sect1 id="c-prof-vaerksted"><title>Et professionelt værksted</title>
<!--comment
<sect2><title>Du har lige installeret Linux ... </title> -->

<para>
      Hvis du har en maskine med Linux i en af de større
distributioner (fx. RedHat eller Debian) har du samtidig en
samling af de mest avancerede værktøjer til fremstilling af
software.

</para><para>

      Det er ikke blot en "sandkasse", du sidder med, men
et professionelt udviklingsmiljø. Der er optimerende compiler,
standardiserede libraries, supplerende libraries med et væld af
funktionalitet, debugger, source management med alt, hvad dertil
hører, og oven i det er Linux jo et professionelt afviklingsmiljø
med automatisk jobstart, kommando fortolkere og script sprog i
mange varianter, serverfaciliteter, samt ikke mindst firewall
faciliteter.

</para><para>

      Det avancerede i denne her sammenhæng ligger ikke i et
smart peg - og - klik interface til en programgenerator. Just for
the record: En programgenerator er et udmærket værktøj i visse
sammenhæng. Med sådan et værktøj kan du kan vælge mellem et
begrænset antal på forhånd programmerede moduler ved hjælp af en
mus, klik og vupti, så har du et resultat bestående af objekter,
der er sat sammen (nogen kalder peg og klik - programmering for
objektorienteret programmering, men det er en fordrejning af
begreber).<footnote><para>TODO: Findes der program generatorer
til Linux? til Postgresql? til Mysql? Gnumeric?
</para></footnote>

</para><para>

      Nej, det avancerede består i, at du kan styre genereringen
af programkode fuldstændig professionelt. Hvis du fx. ønsker at
skrive en ny og bedre database server, så værsgo', gå i gang. Den
nødvendige dokumentation er til rådighed, og der findes desuden
lærebøger som forklarer om low-level ting og high-performance
problematikker på Linux.

</para><para>

      Oven i alt dette får du den fordel, at dine Linux
programmer i de fleste tilfælde kan anvendes uden ændringer på
andre Linux systemer, inclusive 64-bit systemer, og med få
ændringer på mange andre Unix systemer som fx. Solaris, AIX,
HP-UX.

</para><para>

      Mere overraskende er det måske, at man også kan køre
Linux-udviklede programmer på MicroSoft NT ved hjælp af
Cygwin systemet fra Cygnus.
<indexterm><primary>Cygwin</primary></indexterm>

</para><para>

      Det er en væsentlig del af filosofien i GNU og C - sproget,
at man skal kunne genbruge sin kode, hvis hardwaren skal
udskiftes; og det skal den før eller senere! Hardware forgår,
brainware består. Sådan da.

</para><para>

      Udover C compileren har du med Linux adgang til C++ og
mange andre sprog. 

</para>

<sect2 id="hvad-er-debugger">
<title>Hvad er en debugger?</title>
<para>

      Debuggeren er et værktøj, som kan vise, linie for linie,
hvad der sker i et program. Selv om det hedder en debugger, så er
det er ikke så godt at bruge den til at fjerne fejl <footnote>
<para> Det kaldes aflusning eller debugging, bug == insekt, - der
skulle engang være opstået en fejl i en af de første computere
p.g.a.  nogle insekter, som syntes, at der var varmt og rart at
være oven på sådan nogen elektronik-komponenter.  </para>
</footnote>. 

Hvis et program er så fejlbehæftet, at man overvejer at anvende
en debugger, så bør man begynde forfra og reimplementere sine
programmer med de nyvundne erfaringer. Ok, der er undtagelser,
hvor man kan lokalisere en vanskelig, periodisk fejl ved at
anvende en debugger med omtanke, men det er ikke noget, som man
skal gøre til en fast vane!

</para>
</sect2>
<sect2 id=bib-eksempel><title>Biblioteker - et eksempel</title>
<para>

      Det vigtigste er imidlertid, at der med de almindelige
Linux distributioner er et stort arsenal af Open Source
biblioteker til database, netværk, grafik etc.

</para><para>

      Som et eksempel kan det fremhæves, at der findes Open
Source netværks-biblioteker til implementering af Remote
Procedure Call - programmer (rpc - programmer), både til client
og server TCP/UDP/IP. Det er en teknik, som kan benyttes til at
udføre en "procedure" på en anden computer (som selvfølgelig skal
være forberedt til dette!) Dette er værd at understrege, idet den
meget udbredte PC-software har indført nogle økonomisk betingede
useriøse skel mellem server og klient programmer.

</para><para>

      Desuden har du adgang til mange gode eksempler på, hvordan
i hvert fald nogle af bibliotekerne anvendes. Kort sagt, hvis du
går i gang, kan du satse på at nå et professionelt niveau på de
områder, som du udvælger.

</para>
</sect2>
<sect2 id="hvordan-i-gang">
<title>Hvordan kommer man igang?</title>
<para>

      Hvad gør man så for at komme igang?

</para><para>

      Hvis der skulle være et mirakel-ord, som er nøgle til
forståelse af computerens magi, så er det ordet
DATA-REPRÆSENTATION.

</para><para>

      Godt nok følger computerens elektriske signaler de fysiske
love, men computeren er et instrument til at manipulere store
mængder af impulser ud fra nogle få regler valgt af programmøren.
Med andre ord, vi kan tillægge elektriske signaler en betydning.
Et enkelt elektrisk signal kaldes oftest en bit, binary digit.
Otte af dem kaldes en byte eller, mere officielt, en octet.

</para><para>

      En enkelt bit kan være en besked om at åbne sluserne
for at undgå en oversvømmelse. Eller en prik på en billedskærm.
Eller forskellen mellem et punktum og et komma (i en dårlig
font! Anstrengende for øjnene!)

</para><para>

      Som regel bruger man flere bits til vigtige beskedder for
at sikre, at man nu også har forstået hinanden rigtigt. Det
kaldes redundans.

</para><para>

      Bogstaver repræsenteres som regel ved en byte, men ved
anvendelse af Unicode bruges 16 bit eller 2 bytes. Der er også
systemer, som repræsenterer bogstaver ved hjælp af variabelt
antal bytes. Kig fx. på en HTML-side.

</para>
</sect2>
</sect1>

<sect1 id="repraesentering-af-data"><title>Repræsentation af data</title>
<para>

      Hvis du ved en masse om computere, så vil du nok finde
dette afsnit overflødigt. Spring straks videre!

</para><para>

      En computer kan bruges til tekstbehandling, styring af
produktionsmaskineri, til teleudstyr, og, selvfølgelig, til den
"klassiske" lommeregner. Hvor kommer denne fleksibilitet fra? Fra
programmøren, eller mere korrekt: De forskellige applikationer af
computerteknikken beror på muligheden for at repræsentere
information af mange forskellige typer ved hjælp af elektriske
spændinger.

</para><para>

      Konstruktøren af en harddisk bestemmer f.x., at når man
sætter strøm på ledning 77, så er det en besked til harddisken om,
at den skal begynde en read-operation.

</para><para>

      De, der konstruerer computeren, bestemmer, hvad de
forskellige elektriske signaler skal få de forskellige dele af
maskineriet til at udføre. Når han én gang har bestemt, at
ledning 77 er read-request, og maskinen er bygget efter hans
anvisninger, så er vi bundet af denne mening med signal 77, men
det kan altså laves om - næste gang, vi konstruerer et harddisk
interface.

</para><para>

      Den ene dag repræsenterer bit nummer 1000017 en kerne i en
tomat, næste sekund måske et punktum på en skærm, og næste dag
kunne den være en del af en ordre til en harddisk.

</para><para>

      Hvis du vil i dybden med forståelse af computerens
virkemåde og muligheder, kan du læse fx. Joseph Weizenbaum's
"Computer Power and Human Reason".

</para><para>

      Datarepræsentation handler om teknikker til at
repræsenterer forskellige typer af objekter. For programmøren er
det vigtigere at spørge, hvilke informationer, det egentlig er
interessant at repræsentere. Det kan computeren ikke finde ud af
uden kyndig vejledning fra programmører!

</para><para>

      Hvordan vælger vi at repræsentere en tomat, hvad vælger vi
at se? Er det prisen, der interesserer os?  Vægten? Udseendet?
Surhed? Arvelige egenskaber? Vi vælger ud fra en ide om, hvad vi
vil med objektet.

</para>
</sect1>

<sect1 id="repraesentering-af-tal"><title>Repræsentation af tal</title>

<para>

      Lad os se på, hvordan computeren repræsenterer tal. Det er
vel det, den er bedst til? Jo, måske nok, men alligevel, der er
faktisk en hage eller to ved computerens måde at repræsentere tal
på.

</para><para>

      Fx. taler vi om heltal, de naturlige tal, tallene fra 0 og
opefter. Eller er det fra 1 og opefter ;-) Nå, i hvert fald så
siger vi, at vi kan repræsentere heltallene med en computers
calculator register eller en memory celle. Men det er ikke helt
rigtigt! Det er nemlig kun et udsnit af de naturlige tal, som vi
kan repræsentere. Så ikke engang denne enkle opgave kan en
computer klare så godt som en almindelig dødelig! Forklaring
følger.

</para><para>

      Et register er en slags tælleværk, der i dag typisk består
af 32 bits - binary digits. De enkelte digits er lavet ved hjælp
af et transistor mønster, der kan være i to tilstande, 
enten i en tilstand, hvor strømmen kan passere, eller også i en
tilstand, hvor strømmen blokeres. Når der er 32 bits, kan de
danne ca. 4 mia. mønstre eller kombinationer af on/off, 0 eller
1. Det er maximum antal kombinationer. Hvis vi altså tæller fra
0, kan vi komme op på 4 mia med et 32-bit register.

</para><para>

      Det er derfor, at der har været en grænse for filstørrelser
på de almindeligst forekommende filsystemer. Siger 2GB grænsen
dig noget? Det er den største fil på fx. Linux ext2 filsystemer.
Det kunne have været en 4GB grænse, men én af bit'ene er
reserveret til et andet formål, nemlig til angivelse af, om
systemet er i en fejltilstand efter en skrive- eller
læseoperation.  En bit, on/off, svarer altså til en fordobling af
kombinationsmulighederne, se nærmere nedenfor.

</para><para>

      Bits er altså repræsenteret ved hjælp af elektriske
kredsløb, der kan aflæses af andre kredsløb.

</para><para>

      Calculator registeret, det vigtigste register på den
traditionelt opbyggede CPU, er en slags tælleværk bestående af
bits (i dag som regel 32, snart 64), en slags kilometertæller, som
kan udføre forskellige regnestykker på det tal, den indeholder.

</para><para>

      En CPU kan have mange calculator-registre. De har navne,
ofte noget med R1 og R2, i Intel-arkitekturen (x86 - CPU'er)
hedder de imidlertid EAX, EBX, ECX etc (hvilket er copyrighted!)
Mange af dem kan udføre regnestykker. På Intel 386 arkitekturen
(og Pentium m.v.) kan man dog se en vis fortrinsstilling for EAX
registeret. Men denne bog handler ikke om Intel. Hvis Intels
CPU'er interesserer dig, så hent fra www.intel.com "Intel
Architecture Software Developer's Manual" (det er 3 PDF-filer på
ialt omkring 15 MB), eller find en bog om assemblerprogrammering,
eller prøv at læse den Assembly-HOWTO, som følger med bl.a.
RedHat Linux.

</para><para>

      Hvis CPU-en har 32-bit registre, så kan man skrive tal fra
0 til 4 milliarder. Selv om det er mange, er det ikke ALLE de
naturlige tal - de fortsætter jo opefter, mod uendelig, som man
siger. Selv om det heller ikke er muligt at finde noget i
universet, som er uendeligt, man bliver om jeg så må sige træt
inden man når dertil, er det alligevel en mere begrænset
repræsentation af talsystemet, som vi får med en 32-bit computer
<footnote><para>En lidt mere seriøs beskrivelse af tid,
uendelighed og rum kan man finde i Stephen Hawking's "Brief
History Of Time", nej, ikke Stephen King!</para></footnote>

Metoden til at tælle ved hjælp af bits, som du sikkert kender
eller allerede har regnet ud, kan illustreres med følgende tabel
(med kun 4 bit):

</para><para>
      <informaltable frame="all">
        <tgroup cols="5">
          <thead>
            <row>
              <entry>ottere</entry>
              <entry>firere</entry>
              <entry>toere_</entry>
              <entry>enere_</entry>
              <entry>værdi med almindeligt 10-talsystem</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>0</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry> == 0</entry>
            </row><row>
              <entry>0</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry>1</entry>
              <entry> == 1</entry>
            </row><row>
              <entry>0</entry>
              <entry>0</entry>
              <entry>1</entry>
              <entry>0</entry>
              <entry> == 2</entry>
            </row><row>
              <entry>0</entry>
              <entry>0</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry> == 3</entry>
            </row><row>
              <entry>0</entry>
              <entry>1</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry> == 4</entry>
            </row><row>
              <entry>0</entry>
              <entry>1</entry>
              <entry>0</entry>
              <entry>1</entry>
              <entry> == 5</entry>
            </row><row>
              <entry>0</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>0</entry>
              <entry> == 6</entry>
            </row><row>
              <entry>0</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry> == 7</entry>
            </row>
          </tbody>
        </tgroup>
</informaltable>

</para><para>

      Som man kan se kan kolonnerne kaldes ENERE, TOERE og FIRERE
i analogi med vores ti-tal system, hvor vi siger, at kolonnerne
repræsenterer enere, tiere og hundreder etc.

</para><para>

      Hvis vi har brug for mere, kan vi imidlertid godt sætte
flere registre, eller flere memory celler, sammen, så vores tal
kan blive større. Det er forholdsvis enkelt.

</para><para>

      De negative tal kunne vi repræsentere ved at markere med en
ekstra bit (eventuelt et helt andet sted) at vi skulle gange med
-1. Nogle maskiner kan faktisk skelne mellem +0 og -0! Men det er
ikke populært i dag. Man vælger som regel en anden metode.

</para><para>

      Man indretter CPU registrene sådan, at når man tæller op,
så bliver 1...1111 til 0...0000 (for ikke at skrive alle 32 bit,
skriver jeg 1...1111.) Det ligner lidt en kilometertæller, som
når den har nået det største tal, den kan vise, går tilbage til
0, altså fx. går fra 99999 til 00000. 

Men altså, det skal forestille, at alle bit er tændt - det kalder
man, at de er sat. Hvis det er et 32-bit register, svarer det til
ca. 4 milliarder. Når man så lægger 1 til, bliver resultatet 0!
Det ligner ikke helt til den verden, vi ønsker at repræsentere
med vores computer programmer. Derfor bør man under programmering
altid være opmærksom på grænserne for de tal, man arbejder med.
Det er imidlertid ikke så slemt, som det lyder.

      <informaltable frame="all">
        <tgroup cols="32">
          <tbody>
            <row>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
            </row>
          </tbody>
        </tgroup>
</informaltable>

</para><para>

      Altså, når alle bit er sat, og vi lægger en til, så slukker
de alle sammen. Derfor kunne det være en god ide at lade 1...1111
repræsentere det negative tal -1.

</para><para>

</para><para>
      <informaltable frame="all">
        <tgroup cols="5">
          <thead>
            <row>
              <entry>fortegn</entry>
              <entry>_______</entry>
              <entry>_______</entry>
              <entry>_______</entry>
              <entry>værdi med almindeligt 10-talsystem</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry> == -8</entry>
            </row><row>
              <entry>1</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry>1</entry>
              <entry> == -7</entry>
            </row><row>
              <entry>1</entry>
              <entry>0</entry>
              <entry>1</entry>
              <entry>0</entry>
              <entry> == -6</entry>
            </row><row>
              <entry>1</entry>
              <entry>0</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry> == -5</entry>
            </row><row>
              <entry>1</entry>
              <entry>1</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry> == -4</entry>
            </row><row>
              <entry>1</entry>
              <entry>1</entry>
              <entry>0</entry>
              <entry>1</entry>
              <entry> == -3</entry>
            </row><row>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>0</entry>
              <entry> == -2</entry>
            </row><row>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry>1</entry>
              <entry> == -1</entry>
            </row>
          </tbody>
        </tgroup>
</informaltable>

</para><para>

      Som man kan se, nytter det ikke noget her at kalde
kolonnerne for ENERE, TOERE og FIRERE. Hvis man skal give denne
"konvertering af betydningen" et navn, så plejer man at kalde den
2's komplement. Men egentlig er det
2<superscript>32</superscript>'s komplement, d.v.s.
2<superscript>32</superscript>-tal.

</para><para>

      Det er nok lettere at se det for sig med en illustration.
Man repræsenterer f.x. 1 med en bit i den ene ende. Når man
vender alle bits om, så 0'er bliver til 1 og omvent (inverterer),
og lægger 1 til, så får man bitmønsteret til repræsentation af
-1.

</para>


<example id="ex-tal-0-7">
<title> tallene fra 0 til 7 og 0 til -7.</title>
<programlisting>
   0: 0000, Inverted: 1111, Complement(til 2^4): 0000
   1: 0001, Inverted: 1110, Complement(til 2^4): 1111
   2: 0010, Inverted: 1101, Complement(til 2^4): 1110
   3: 0011, Inverted: 1100, Complement(til 2^4): 1101
   4: 0100, Inverted: 1011, Complement(til 2^4): 1100
   5: 0101, Inverted: 1010, Complement(til 2^4): 1011
   6: 0110, Inverted: 1001, Complement(til 2^4): 1010
   7: 0111, Inverted: 1000, Complement(til 2^4): 1001

</programlisting>
</example>

<para>
Når der er tale om 32 bit heltals repræsentation, er det lettere
at benytte hexadecimal notation. Tallene fra 0-9 skrives som
sædvanlig 0-9, men 10-15 skrives a-f. Det betyder, at man kan
repræsentere 4 bit med ét 'ciffer', hvor ciffer skal forstås som
0-9a-f.
</para>
<example id="ex-numrep1">
<title> tallene fra 0 til 7 og 0 til -7.</title>
<programlisting>
Word: 00000000, Inverted: ffffffff, Complement: 00000000
Word: 00000001, Inverted: fffffffe, Complement: ffffffff
Word: 00000002, Inverted: fffffffd, Complement: fffffffe
Word: 00000003, Inverted: fffffffc, Complement: fffffffd
Word: 00000004, Inverted: fffffffb, Complement: fffffffc
Word: 00000005, Inverted: fffffffa, Complement: fffffffb
Word: 00000006, Inverted: fffffff9, Complement: fffffffa
Word: 00000007, Inverted: fffffff8, Complement: fffffff9
</programlisting>
</example>

<para>

      Fortsætter man denne tankegang, så bliver det største tal
med 32 - bit ca. 2 milliarder, og det er stadigvæk en pæn sjat.

</para><para>

      Grunden til, at Linux ext2 fil systemet ikke kan have
filer, som er større end 2 GB er forresten, at fil write og
access sker via interfaces, som benytter 32 bit størrelser, og
den ene af bit'ene er også her anvendt til fortegn.

</para><para>

      Et program, som frembringer udskriften ovenfor (fig
<xref LinkEnd="ex-numrep1">) er vist i <xref
LinkEnd="outformat1">.

</para><para>

      Det er muligt at repræsentere tal på andre måder end 
den her viste. <!-- (TODO: henvisning!) --> Men vigtigere, det er
muligt at repræsentere andet end tal. Bogstaver kan repræsenteres
ved hjælp af tal, den simpleste løsning på en computer med
mulighed for at repræsentere tekst er jo den kendte metode med en
byte pr. bogstav. Det er ikke nok, hvis der også skal være plads
til at repræsentere græske bogstaver, matematiske symboler, og
slet ikke, hvis også forskellige grafiske symboler,
font-beskrivelser etc. skal repræsenteres. Men det er en helt
anden historie.

</para><para>

      Andre ting, som fx. grøntsager og frugt, må repræsenteres
ved bits og bytes på samme måde som tal og bogstaver. Hvis du er
ny i programmering, vil det klogeste være at afprøve nogle
programmer nu, måske endda bruge 3 - 4 måneder på eksemplerne og
øvelserne i <xref LinkEnd="tour"> kapitlet.

      Hvis du på den anden side kender lidt til programmering og
gerne vil køre tanken om repræsentation til ende, så er der to
begreber, som vi skal tygge lidt på: Simuleringer og modeller.

</para>
</sect1>

<sect1 id="simulering-modeller">
<title>Simulering - Modeller</title>

<para>

     For lige at få lidt mere 'real-life' perspektiv på
datarepræsentation, så forestil dig et program, som skal simulere
noget, der foregår i det virkelige liv, matador-spil,
adventure-spil (som på visse punkter forventes at svare til ting,
vi kender fra dagligdagen), eller beregning af en vejrudsigt.
Vind fra vest med lavtryk - hvor ligger grænserne for 990
millibar, (en isobar) etc.etc. Man kan fx. opdele luftrummet over
Skandinavien i firkanter med hver deres vejr-målinger og beregn
interaktionen mellem firkanterne efter de fysiske love for tryk
udligning, temperaturudvidelser etc. - pyha, godt det ikke skal
udregnes i hånden!

     </para><para>

     Med en computer kan man også simulere reaktionerne på
håndtag og visningen i instrumenter i et flycockpit for at give
piloterne øvelse i at betjene styremekanismerne; og man kan
simulere eller efteligne lydene fra et spillende symfoniorkester.
Simuleringerne svarer ikke på alle punkter til virkeligheden, men
kan være nyttige og mere eller mindre tæt på virkeligheden.

     </para><para>

     Hvis vi skulle beregne det mest rentable dyrkningsforløb for
tomater i drivhus, hvad skulle vi så vide om dem? Jeg behøver
ikke spørge, om vi kunne spise resultatet af simuleringen! Men en
ting er sikkert, der skulle mange oplysninger til, de fleste af
dem skulle opsamles ved hjælp af grundige forsøg og målinger, som
ville ende med nogle tal, der repræsenterede egenskaber ved
forløbet.

     </para><para>

     Derimod så ligner et investeringsspil og en investerings
service for bankkunder hinanden så meget, at man kan bruge det
ene program som grundlag for den virkelige service. Her bliver
der blot koblet betalingstransaktioner på spillet, med tilhørende
retsansvar.

     </para><para>

     Kobler vi simuleringerne på virkelige objekter (med passende
teknik, som i sig selv kan være komplicerede computersystemer) kan
computeren anvendes som værktøj til at "styre virkeligheden",
måske bedre, end vi kan gøre det, men til syvende og sidst blot
som vores "forlængede arm".

     </para><para>

     Simulerings og styringsteknikker hviler på evnen til at
repræsentere begreber og objekter ved hjælp af computerens bits.
Som nævnt er denne repræsentation altid mangelfuld. Den
opfattelse af verden, som måtte ligge til grundlag for
simuleringerne, kaldes en model. Modellen er altså ikke kun
repræsentationen af statiske, ubevægelige, egenskaber, som
tingene har, men også af deres måde at bevæge sig og indgå
forbindelser med hinanden, sådan som fx. de enkelte styrehåndtag
i en flysimulator må reagere på og med hinanden.

     </para><para>

     Men ligesom talrepræsentationen er mangelfuld, så vil
modeller også være mangelfulde. Ikke p.g.a. at der mangler den
syvende eller niende decimal, men fordi der er grænser for, hvor
meget programmøren kan forudse. Havarisituationer,
vejrsituationer, forskellige former for landskabsforhindringer
etc. kan kun i et begrænset antal være repræsenteret i en
computer. På et eller andet tidspunkt kommer man (efter meget
arbejde) formentlig til en model, som tilfredsstiller brugerne af
modellen så meget, at de opfatter modellen som en fuldt funktionel
fremstilling af virkeligheden.

     </para><para>

     Den slags tanker virker specielt tiltrækkende på børn og
reklamefolk. Måske også på fabrikanter af computerspil. Ord som
cybernetics, cyberspace og cyborg spiller på dette element af "en
verden inde i computeren".

     </para><para>

     Man kunne sige, at vi har "mappet", kortlagt, en del af den
virkelige verden ved hjælp af vores computers bits og nogle
programmer, som behandler dem i overensstemmelse med vores
fortolkning.

     </para><para>

     Denne teknik, at "mappe" en mængde af elementer, således at
de repræsenteres af en anden mængde, er den grundlæggende disciplin
for applikationsprogrammører. Alan Turing har omkring 1940-1950
beskrevet det teoretiske grundlag for computerens virkemåde, og hans
arbejde er stadig interessant for programmører, der vil forstå muligheder
og grænser for computerens "indre univers".

</para>
</sect1>
</chapter>

<chapter id="c-programming-start"><title>C Programmering</title>
<sect1 id="tour"><title>Hello-world programmer</title>

    <abstract><para>

    Hello-world programmer, filter-programmer,
tilstandsprogrammer, netværksprogrammer, client server
programmer, systemprogrammer, databaseprogrammer,
værktøjsprogrammer - betegnelser af praktisk art, ikke
systematiske kategorier.

     </para></abstract>

     <sect2 id="brohoved"><title>Et brohoved.</title><para>

     Det første skridt, som man foretager på en ny maskine, eller
rettere en ny platform for programmeringsarbejde, bør altid være
at skrive det simplest mulige program, der producerer output.

     </para><para>

     Forhåbentlig kender du Kernighan & Ritchies bog, the
C Programming Language. Det første kapitel, den berømte "tour"
gennem C sproget, starter med et program, der skriver "Hello,
World!" på en output - device (altså en skærm-enhed eller
lignende).<footnote><para>

     Hvis du ikke kender bogEN, og hvis du ikke er en øvet C
programmør, så vil jeg anbefale, at du køber den og bruger ca.
14 dage til at arbejde kapitel 1 igennem - lav så mange af de
ekstra øvelser, som du kan nå. Nærværende kapitel er en ikke en
erstatning for den oprindelige "tour", men et supplement eller
brush up, som man nu ser det. Man kalder det for learning by
doing eller deduktiv spiralpædagogik; man udleder, hvordan C
sproget fungerer ved at prøve det mange gange og ved at gøre
øvelser lidt sværere hver gang.

     </para><para>

     Har du ikke det grundlag, vil du undre dig over, at bogen
her ikke forklarer noget om de grundlæggende datatyper, om
operatorerne, om flow-konstruktionerne - eller om opdeling af
programmer i moduler. Disse fire dele af ethvert
programmeringssprog bør man jo kende og forstå. (Hvis der er
interesse, skriver vi et appendix A. Crash Course i C.)

     </para><para>

     Det specielle ved Kernighan & Ritchies programeksempler i
Kapitel 1 af den berømte bog er forresten, at programmerne er
nyttige. Det vil sige, i et kommandolinie environment kan de
bruges med det samme til endda ret nyttige ting. Hvis du heller
ikke er fortrolig med kommandolinie syntax, bør du straks prøve
alle eksempler i SSLUG-bogen, Friheden til at bruge sin computer.

     </para></footnote>

     </para><para>

     Det program kunne man jo så udnævne til stamfaderen for en
hel kategori, nemlig små programmer, som kun udfører en enkelt
funktion. Det kan være det at skrive noget på skærmen. Det kan
være at hente dato-information, så kan vi få bekræftet, om
funktionerne opfører sig, som vi forventer, eller ej.

     </para><para>

     Et endnu mere grundlæggende "Hello-world" program er et, som
simpelt hen afslutter med det samme! Sådan et kommer her:

<example id="ex-hello"><title>HELLO - exitcode</title>
<programlisting role="C">
<literal>

/* frame.c Minimal program til afproevning af exitcode. */

int main()
{
    return 0;
}

/* end of file frame.c */

</literal>
</programlisting></example>

     </para><para>

     Program-source, kildeteksten består af 8 linier, hvis man
tæller kommentarer og tomme linier med. Aller øverst er der en
kommentar, som fortæller kort hvad meningen med programmet er.
En kommentar startes med "/*" og slutter med "*/".

     </para><para>

     Programmet består af en definition af ét eksternt objekt,
nemlig en funktion, som har navnet "main". Parenteserne efter main
fortæller, at main er et objekt af typen funktion. Parenteserne
kaldes derfor "funktions-operator" <footnote> <para> I K&amp;R(88)
kan man på side 53 finde en tabel over operator præcedens. Deri
kan man finde () øverst, fordi bindingen mellem identifier og ()
er stærkere end bindinger mellem andre operatorer.  </para>
</footnote> Selve koden i main er indrammet i krøllede
parenteser, braces. Koden består af kun én sætning, eller
<emphasis> statement </emphasis>, nemlig 

     <programlisting>
     return 0;
     </programlisting>

     return er et <emphasis> reserveret ord </emphasis>, d.v.s.
et ord, som compileren er født med at kende. C sproget har 32
reserverede ord.<footnote><para>se appendix A, Crash Course i C.
</para></footnote>

     Nullet er et "udtryk", (aritmetisk udtryk) med en talværdi.
Vi kunne også have skrevet return 234 eller return 7000143. I
dette tilfælde vil det dog være klogt at holde talværdien på
eller under 255.

     Eksempler på andre expressions: kroner = timer * timeloen;
hvor det forudsættes at kroner, timer og timeloen er variable,
som indeholder fornuftige værdier. Et expression, som afluttes
med semikolon, kaldes et statement.

     </para><para>

     Hvis der er flere statements i en funktion, udføres de i
rækkefølge, oppefra nedefter.

     </para><para>

     Et kald til en funktion, som fx. flg.: <literal>
abs(-5); </literal> er også et expression, i dette tilfælde med
værdien 5.  Kald til en funktion vil ofte returnere en variabel
af typen heltal <emphasis> integer </emphasis>, og en integer i
et expression kan erstattes af et kald til en funktion, som
returnerer en integer.

     </para><para>

     Det er en konvention, at eksekvering af et program, som
benytter standard library (bibliotek med bl.a. læse og skrive
funktioner) begynder i funktionen main. Når man kommer til
slutningen af denne <emphasis>main</emphasis> funktion, standser
programmet eller "returnerer en eksit<footnote><para>Dansk
retskrivning egner sig altså ikke til computer faglitteratur
</para></footnote> kode til operativsystemet". Denne exit code er
en vigtig meddelelse, eller rettere, det bør den være! Hvis et
program returnerer fra main uden et "return &lt;expression>;" så
er det rigtig sjusk. 

     </para><para>

     Exit code bør fortælle, om programmet kunne køre uden fejl,
(d.v.s. uden fejl, der påført af ydre omstændigheder, som fx. at
en datafil mangler).  Det er altså programmørens mulighed for at
signalere til et brugerjob (et script) at "alt er vel" eller
"her opstod en fatal fejl."

     </para><para>

     Hvis programmøren vil fortælle systemet, at der var en fejl,
skrives simpelthen 

     <programlisting>
     return 255;
     </programlisting>
     
     Tallet kan i Unix-shell-sammenhæng læses i variabelen $?,
som kan styre flowet i et Unix shell script.<footnote><para>
I MicroSoft
miljøer som "errorlevel" der kan bruges af if-sætninger i
batch-filer. </para> </footnote>
Øvelse: Ret, så programmet returnerer 117 og se, om
du kan udskrive shell variabelen $? med kommandoen 

     <programlisting>
     echo $?
     </programlisting>

     </para><para>

     Det lille program ovenfor kunne compileres
<footnote><para>Generer det, hvis jeg staver engelske
computer-udtryk på engelsk? </para></footnote> med flg. kommando:

<programlisting role="C">
     gcc frame.c -o frame
</programlisting>

     Derefter kan det køres fra current directory (i det aktuelle
katalog, eller sagt på en tredie måde, fra det bibliotek, som vi
står i) med en kommando som:

<programlisting role="C">
     ./frame
        # eller, hvis din PATH variable ender på ':'
     frame
</programlisting>

     Se iøvrigt "Friheden til at programmere" afsnittet om C
sproget.

     </para><para>

     Eksemplet lider imidlertid af en alvorlig skavank, vi kan
jo næsten ikke se, om programmet rent faktisk kører. Det laver jo
ikke noget! Derfor tilføjer vi en lille output kommando:

<example id="ex-stdout"><title>Skriv message på standard output.</title>
<programlisting role="C">
<literal>

/* frame2.c Skriv til stdout og afslut. */

#include &lt;stdio.h>

int main()
{
    puts("Hello! Programmet frame2 kører nu...");
    return 0;
}

/* end of file frame2.c */

</literal>
</programlisting></example>

     Her er flere ting, som er værd at lægge mærke til. Dels et
include direktiv, d.v.s. en kommando, som fortæller compileren,
at den skal læse en fil, der hedder stdio.h. Når filnavnet står i
<emphasis> vinkler </emphasis>, så betyder det, at compileren
skal lede der, hvor systemet normalt har sine filer med
erklæringer, "include filerne". På Unix, Linux og andre systemer
er det <ulink URL="file:///usr/include/"> /usr/include </ulink>
, der gennemsøges først.

     </para><para>

     Compileren finder den pågældende file og læser den. Den
indeholder <emphasis>erklæringer</emphasis>.

     </para><para>

     Den erklæring, som skal bruges, ser ud som følger:

     <programlisting>
     extern int puts __P ((__const char *__str));
     </programlisting>

     Den kunne dog også have set enklere ud:

     <programlisting>
     int puts (char *message);
     </programlisting>

     Det kaldes en prototype, eller en type erklæring af en
funktion. Den gør det muligt for compileren at checke, at
funktionskald vil fungere efter hensigten. (Se forslag til
øvelser efter første kapitel, <xref LinkEnd="OV1">.

     En prototype for vores main (som burde findes i en af glibc
- systemets header filer) ville hjælpe compileren med at 
kontrollere, om vi overholdt interface mellem vores main og
library startup rutiner<footnote><para> I glibc2x: se efter
filerne ./sysdeps/elf/start.S og ./sysdeps/generic/libc-start.c
</para></footnote> . Denne prototype kunne se sådan ud:

     <programlisting>
     int main(int argc, char *argv[], char *env[]);
     </programlisting>

     Det er ikke nødvendigt at at angive et navn, en identifier, på 
argumenterne, kun typen skal angives når vi skriver en prototype.

     <programlisting>
     int main(int, char *[], char *[]);
     </programlisting>


Men det er oplagt at finde navne, som giver læseren en hjælp til
at forstå meningen med funktionen. Når vi ikke bruger parametrene
til main, kan vi nøjes med at skrive main(), altså en tom
funktions-parentes.

     </para><para>

     Prototypen "int puts(char*)" fortæller, at puts er en
funktion, som returnerer en integer og forventer at få en
character pointer som argument.

<example id="ex-char-ptr"><title>En character pointer</title>
<programlisting role="C">
<literal>

/* frame3.c Demonstration af character pointer. */

#include &lt;stdio.h>

char *message = "Hallo! Programmet frame3 kører nu...";

int main()
{
    puts(message);
    return 0;
}

/* end of file frame3.c */

</literal>
</programlisting></example>

     </para><para>

     char *message er erklæring af en variabel. Variabelen er en
character pointer. Det vil sige en adresse variabel. Den
initialieseres på samme source linie, som den erklæres. Lad dig
ikke forlede til at tro, at sådan er det også på maskinniveau,
det er simpelthen en praktisk skrivemåde. Det svarer til:

<programlisting role="C">
     char * message;
     message = "Hallo etc... ";

</programlisting>

En literal string, "Hallo etc... "; er ikke en variabel, men er
en besked til compileren om at initialisere et dataområde med den
tekst, som vi nu ønsker os. For at kunne bruge teksten skal vi
enten gemme adressen på den (altså cptr = "Hallo etc...") eller
også give adressen på denne string til den funktion, som skal
bruge den: <literal> puts("Hallo etc.."); </literal>

     </para><para>

     En gengivelse af dette system af RAM-adresser og indhold
kunne tegnes som en reol hvor hver hylde har et indhold, der
enten kan være 4 bytes eller 4 bogstaver, eller én adresse (32
bits).

<programlisting role="C">

        Adresse               
        eller
        hylde-nr.      Indhold

                    +-------------+
                    |             |
                    |  o !   P    |
           800440   +-------------+
                    |             |
                    |  H a l l    |
           800436   +-------------+
                    |             |
                    |             |
                    +-------------+
                    |             |
                    |             |
                    +-------------+
                    |             |
                    :             :
                    :             :
                    :             :
                    |             |
           120808   +-------------+
                    |             |  Adressevariabel, indeholder
                    |  <800436>   |  adresse på string Hallo! Prog...
           120804   +-------------+
                    |             |
                    |             |
           120800   +-------------+
                    |             |
                    |             |
           120796   +-------------+
                    :             :
                    :             :
                    |             |
                    :             :
                    :             :
                    |             |




</programlisting>


     </para><para>

     Det, der skrives på skærmen, er ren og skær tekst, bogstav
for bogstav noget, som ligger i programmet. 

     </para><para>

     Lad os i stedet lave en udregning, og skrive resultatet ud.
Det kunne være et nyttigt program!

     </para><para>

<example id="ex-hello-beregning"><title>HELLO - beregning.</title>
<programlisting role="C">
<literal>

/* percent.c calculates a percentage of a given number. */

#include &lt;stdio.h>

int main()
{
    int procent = 17;
    int kroner = 100;
    int resultat;

    resultat = kroner * procent / 100;

    printf("resultat er: %d\n", resultat);

    return 0;
}

/* end of file percent.c */

</literal>
</programlisting></example>

     Det er en stor fordel, at resultatet er nemt at kontrollere,
brug simple tal indtil programmet er stabilt.

     </para><para>

     Vi har indført nogle variable - kroner, procent, resultat.
Det er simpelt hen kasser med tal i. Der er straks fyldt værdier
i kasserne.

     <programlisting> 
     int kroner = 100;
     </programlisting>

betyder, at vi reserverer en plads til en heltalsvariabel og
straks fylder tallet 100 i.

     Derefter beregnes resultatet, på samme måde, som man ville
skrive formelen på et stykke papir.

     <programlisting>
     resultat = kroner * procent / 100;
     </programlisting>

     Resultat er navnet på den "kasse", hvor resultatet skal
gemmes, og den kaldes en "left value", venstre-værdi, fordi den
kan stå på venstre side af et lighedstegn eller assignment
(tildelings) operator. Man kan også sige, at venstre side af
assignment operatoren skal være et udtryk, der kan evalueres som
en adresse. Hvad der måtte ligge af interessante værdier i sådan
en left value forsvinder efter et assignment.

     </para><para>

     <literal>printf()</literal> får at vide, at den skal skrive
variablen "resultat" ud ved hjælp af procent-tegnet efterfulgt af
'd'. Nu får <literal>printf()</literal> ikke én, men
<emphasis>to</emphasis> oplysninger, nemlig format string'en
mellem double quotes, (gåseøjne) og talvariabelen
<emphasis>resultat</emphasis>.


<programlisting>

     "resultat er: %d\n"   <== string-var


     "resultat er: %d\n", resultat <== string-var, tal-var

</programlisting>

     Den anden linie kaldes en liste eller en <emphasis>
parameter liste </emphasis>; de to medlemmer er adskilt af et
komma, komma er liste-operator.<footnote><para> Parametre er
oplysninger til en funktion. </para></footnote> 

     </para><para>

     Det er nok lidt for besværligt at rette i programet her,
hver gang jeg vil udføre en procent beregning! Så i stedet laver
vi i næste afsnit et program, som prompter for (beder om input
af) det tal, der skal beregnes procent af.  Dermed forlader vi
"Hello-world" sfæren og bevæger os ind i fejlmulighedernes
paradis, interaktive programmer.

     </para></sect2>
     <sect2 id="prompt-og-input">
<title>Prompt og input</title><para>

     Input fortjener et kapitel for sig. Men lad os alligevel
skrive et program, som læser input fra tastaturet, og som godt
nok forventer, at der bliver tastet tal (cifre) ind, men på den
anden side ikke tager skade af, at brugeren indtaster noget helt
andet - eventuelt skubber en bog henover tastaturet, så der kommer
input i store mængder.

<example id="ex-io-ber"><title>Input og beregning.</title>
<programlisting role="C">
<literal>

/* percent2.c ask for a number and calculates a percentage. */

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
    int procent = 17;
    int kroner;
    int resultat;
    char inputlinie[800];

    printf("BEREGNING AF %d %%\n",procent);
    while (printf("Input tal:"), fgets(inputlinie,800,stdin)!=NULL) {
        kroner = atoi(inputlinie);
        resultat = kroner * procent / 100;
        printf("resultat er: %d\n", resultat);
    }
    return 0;
}

/* end of file percent2.c */

</literal>
</programlisting></example>

     </para><para>

     I nogle C-library implementationer skal man flushe
printf-output hvis der ikke er en "newline" til sidst:

     <programlisting role="C">
     ... printf("Input tal:"), fflush(stdout),
     </programlisting>

     Denne måde at sætte 2 expressions, funktionskald, sammen med
et komma er bestemt ikke den mest pædagogiske. Det er faktisk
grimt! Men når jeg nu har gjort det alligevel, så er det for at
understrege, at C sprogets liste-operator (komma'et) er
anvendelig i mange sammenhæng. Men lad nu være med at skrive for
meget komatøs kode!

     </para><para>

     Input læses af fgets(3). Den skal have 3 oplysninger,
adressen på den buffer, som den må lægge characters i, længden på
bufferen (den bruger max længde - 1!) og den fil, som den skal
læse input fra. Her anvendes "kodeordet" stdin, som er defineret
i &lt;stdio.h>.

     </para><para>

     Der er includeret en fil mere, stdlib.h, som indeholder
prototype til atoi - Ascii TO Integer conversion.<footnote>
<para> Sørg for, at du virkelig ved, hvad ascii er for noget!
</para> </footnote>

     </para><para>

     Det smukke i ovenstående stump kode er, at man faktisk ikke
kan få programmet til at gå ned ved ondskabsful indtastning,
når der promptes for et tal. Man kan godt få det til at regne
forkert, hvis man indtaster et tal, som er større end 126 mio.
Men dels er fgets() en robust funktion, som ikke laver buffer
overflow, selv om brugeren indtaster 4GB data, og <literal>
atoi(char*) </literal> er en robust konverteringsrutine, som
ikke brokker sig, hvis input ikke er cifre.  Hvis man indtaster
bogstaver, ignoreres de, og der returneres 0.  88kr. vil blive
konverteret til heltallet 88, hvilket svarer til, hvad man
forventer. Senere vil vi lave en indtastningsruting, som giver
brugeren en warning, hvis han ikke indtaster tal. <!-- TODO -->

     </para><para>

     Det er programmørens ansvar at sørge for den rigtige
længdeangivelse til fgets' anden parameter. Det er lettere at
holde styr på den slags, hvis man benytter preprocessor macro'er
til at definere symboler for konstant-talværdier.

     <programlisting role="C">
     #define MAXLINIE 800
     char inputlinie[MAXLINIE];
     
     main()
     {
         fgets(inputlinie, MAXLINIE, stdin);
         return 0;
     }
     </programlisting>

     Ikke semikolon i #define linien, det er <emphasis> ikke
</emphasis> et statement.

     </para><para>

     Øvelse for den lidt mere erfarne: Prøv at ændre programmet,
så der anvendes double precision floating point variable.

     </para><para>

     Prøv også at skriv en version, hvor man kan indtaste
procentsatsen først, eller benyt rammen til en valuta-omregner.
Lav et program, som udskriver en omregningstabel fra Lire til
Dollar.

     </para>
</sect2>

<sect2 id="generaliser-beregninger">
     <title>Generalisering af beregninger</title>
     <para>

     Kursomregninger følger samme princip som procent
udregninger. Hvis der er mange decimaler og skiftende kurser, er
det berettigelse nok til at lave en lille kursomregner, som -
senere - kunne indgå i et større program, der skal vise beløb på
forskellige måder.

     </para><para>

     Lad os derfor benytte kursomregning til at forske i den
teknik, som kaldes modularisering. Vi vil gerne have en funktion,
som får vores kroner og "afleverer" Dollar (eller
EURO<!--&eur;-->); men vi begynder med en let omrokering af
procent - programmet.

<example id="ex-dollar-omregning">
<title>Dollar omregning, spaghetti version.</title>
<programlisting role="C">

/* dollar0.c Input Kroner, beregn Dollar. UDGANGSPUNKT. */

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
    int factor = 865;
    int kroner;
    int resultat;
    char inputlinie[800];

    printf("OMREGNING FRA KRONER TIL DOLLAR, KURS %d\n",factor);
    while (printf("Input tal:"),
           fgets(inputlinie,800,stdin)!=NULL) {
        kroner = atoi(inputlinie);
        resultat = kroner * 100 / factor;
        printf("Kroner %d giver Dollar %d\n", kroner, resultat);
    }
    return 0;
}

/* end of file dollar0.c */

</programlisting>
</example>

     Først trækker vi beregningen ud af programmet og lægger den
i en funktion, som vi kalder kr2dollar.

<example id="ex-dollar-funktion">
<title>Dollar omregning med beregning i funktion.</title>
<programlisting role="C">

/* percent3a.c Input kroner, call int kr2dollar(int) */

#include &lt;stdio.h>
#include &lt;stdlib.h>

int kr2dollar(int);
int factor = 865;

int main()
{
    int kroner;
    char inputlinie[800];
    int resultat;

    printf("OMREGNING FRA KRONER TIL DOLLAR, KURS %d\n",factor);
    while (printf("Input tal:"),
           fgets(inputlinie,800,stdin)!=NULL) {
        kroner = atoi(inputlinie);
        resultat = kr2dollar(kroner);
        printf("Kroner %d giver Dollar %d\n", kroner, resultat);
    }
    return 0;
}

int kr2dollar(int kr)
{
    return kr * 100 / factor;
}

/* end of file percent3a.c */

</programlisting>
</example>

     Bemærk, at funktionen kr2dollar er "erklæret" eller
forklaret, inden den anvendes. Det er gjort lige under include
direktivet. Det bevirker, at compileren ved, hvad type der kommer
ud af funktionen, det kunne jo være en flydendetals dims i stedet
for et heltal. Ja, netop, flydende tal for at få decimaler
på<xref LinkEnd="ex-dollar-double">! Og så kan compileren faktisk
også konvertere eventuelle tal-parametre til funktionen, så de
får den type, der forventes.  Altså hvis funktionen forventer en
double precision flydende tals variabel, så kan compileren
indsætte kode, der konverterer en integer til double.

     </para><para>

     <literal> kr2dollar() </literal> består af KUN et return
statement. Godt nok skal der regnes lidt, før end return værdien
er klar, det er jo selve ideen i funktionen.

     </para><para>

     Faktisk kunne vi i almindelig stenalder C nøjes med at kalde
funktionen uden at forklare compileren, at det var en funktion,
der returnerede en integer. Det kaldes "implicit integer"
regelen.

     </para><para>

     Men ved at lave en prototype (altså <literal> int
kr2dollar(int); </literal>) sikrer vi os, at der ikke opstår fejl
af den slags, som kan være meget tidsrøvende - og som compileren
er god til at finde.

     </para><para>

     Nu skiller vi beregnings funktionen ud, så den ligger i en
fil for sig selv - den er på vej til at blive en del af vores
"financial library" (;-).

     </para>

<para>

     Desuden lader vi variabelen "resultat" udgå, for vi kan jo
bare anbringe funktionskaldet der, hvor resultatet skal skrives.

<example id="ex-dollar-caller">
<title>Dollar omregning, modul version.</title>
<programlisting role="C">

/* dollar1.c ask for Kroner and call int kr2dollar(int) */

#include &lt;stdio.h>
#include &lt;stdlib.h>

int kr2dollar(int);

int main()
{
    int kroner;
    char inputlinie[800];

    printf("OMREGNING FRA KRONER TIL DOLLAR\n");
    while (printf("Input tal:"),
           fgets(inputlinie,800,stdin)!=NULL) {
        kroner = atoi(inputlinie);
        printf("Kroner %d giver Dollar %d\n", kroner, kr2dollar(kroner));
    }
    return 0;
}
/* end of file dollar1.c */
</programlisting></example>

     Som det kan ses, har vi klippet de nederste 4 linier ud,
hvor funktionen kr2dollar var defineret. Den står nu i en fil,
som vi kalder kr2dollar.c:

<example id="ex-dollar-modul">
<title>kr2dollar modul.</title>
<programlisting role="C">

/* kr2dollar.c - beregn dollar ud fra kroner */


int kr2dollar(int kr)
{
    int factor = 865;
    return kr * 100 / factor;
}
/* end of file kr2dollar.c */
</programlisting></example>

     Kursen, factor, er ikke mere tilgængelig i main, vi har
isoleret den, så den kun kan ses i funktionen, som omregner. Det
er en primitiv løsning. Det ville være bedre, hvis vi kunne hente
kursen fra en data-source, enten input, eller fx. fra en eller
anden server på internettet, og skrive en funktion, der kunne
bruges til at hente kurseni, så vi også kunne vise den i
overskriften.

     </para><para>

     Som det ses, er variabelen "resultat" fjernet. Den er
overflødig.

     </para><para>

     De to filer kan kompileres på flere forskellige måder:

     Enten:
     <programlisting>
     gcc -Wall dollar1.c kr2dollar.c -o omregning
     </programlisting>
     Eller:
     <programlisting>
     gcc -Wall -c dollar1.c
     gcc -Wall -c kr2dollar.c
     gcc dollar1.o kr2dollar.o -o omregning
     </programlisting>
     Eller:
     <programlisting>
     gcc -Wall -c kr2dollar.c
     ar -rv libfinans.a kr2dollar.o
     gcc -Wall -c dollar1.c
     gcc -Wall dollar1.o -L./ -lfinans
     </programlisting>

     Læg lige mærke til, at vi har genereret en library file med
en meget simpel kommando, ar -rv libfinans.a &lt;objectfile> ...
 
     </para><para>

     Hvis vi skulle glemme prototypen for denne simple beregning,
så vil der ikke opstå fejl. Det skyldes, at vi stadig har regelen
om implicit integer hængende, når vi skriver standard C
programmer. <footnote><para> Det kan være meget praktisk for den
erfarne programmør, og kan i visse situationer gøre et program
lidt mere læseligt (der er mindre "støj"). <!-- COMMENT:
Men der er en sjov historie om dette religiøse spørgsmål! Bjarne
Stroustrup overvejede, hvordan man dog skulle kunne klare
problemerne med implicit integers og ingen parametre, som før var
det samme som, at alt var tilladt! En dag siger Ritchie til ham,
at det skal han da ikke spekulere på, man kan da godt indføre et
krav om, at parametre skal specificeres. - eller lignende emne,
hvor Ritchie gav ham støtte til at gå videre med sagen. -->
</para> </footnote>

     </para><para>

     Med de GNU - C compileren vil man dog få en warning
desangående, hvis man anvender -Wall (Warning level, give us ALL
warnings).

     </para><para>

     Hvis man nu havde defineret funktionen kr2dollar, således at
den returnerede double precision floating point typen, så ville
programmet være ubrugeligt, og denne WARNING ville være det
eneste, som antydede, hvad fejlkilden kunne være. Derfor! Brug
compilerens warning - system og gør det til en vane at fundere
over, hvad det egentlig betyder.
<!-- COMMENT: Dette er første gang jeg nævner en decideret fejl.
RET så vi viser double - versionen og sig, at her er prototypen
EN NØDVENDIGHED, ikke en luksus! -->


<example id="ex-dollar-double"><title>Dollar omregning, double version.</title>
<programlisting role="C">

/* dollar1.c ask for Kroner and call double kr2dollar(double) */

#include &lt;stdio.h>
#include &lt;stdlib.h>

double kr2dollar(double);

int main()
{
    double kroner;
    char ptr;
    char inputlinie[800];

    printf("OMREGNING FRA KRONER TIL DOLLAR\n");
    while (printf("Input tal:"),
           fgets(inputlinie,800,stdin)!=NULL) {
        kroner = strtod(inputlinie, &amp;ptr);
        printf("Kroner %d giver Dollar %10.2f\n", kroner, kr2dollar(kroner));
    }
    return 0;
}
/* end of file dollar1.c */
</programlisting></example>

<example id="ex-dollar-ret-type">
<title>kr2dollar, return type double, module.</title>
<programlisting role="C">

/* kr2dollar.c - beregn dollar ud fra kroner, double */


double kr2dollar(double kr)
{
    return kr / 8.65; 
}
/* end of file kr2dollar.c */
</programlisting></example>

     I ovenstående eksempel er det nødvendigt, at der erklæres en
prototype for kr2dollar.

     </para>
</sect2>

<sect2 id="OV1"><title>Øvelser til hele kapitel 1.</title><para>

     Skriv frame2 om til frame2a, hvor du selv angiver prototypen
for puts, og se, om det kompilerer og eksekverer lige så godt som
frame2.c

     </para><para>

     Skriv percent.c om, så du også udskriver indholdet af
variablene kroner og procent.

     </para><para>

     Skriv percent.c om, sådan at den beregner 99% af 100
millioner (jo jo, det kan man gøre i hovedet, men det er for at
gøre det nemt at kontrollere resultatet!) Dette er ikke
en helt triviel opgave.

     </para><para>

     Lav en version af programmet, som selv kan finde ud af, om
der er overflow på beregningen. Hint: resultat / procent *
kroner. For den viderekomne kan opgaven løses ved, at man
benytter en assemblerinstruction, som checker for overflow
flaget.

     </para></sect2></sect1>


<sect1 id="fejl-og-haandtering">
<title>Fejl og håndteringen af dem.</title>

<sect2 id="fejl-kategorier">
<title>Hvilke slags fejl er interessante</title>
<para>
     Det er egentlig ikke så interessant, set fra en programmørs
synspunkt, om en disk bryder sammen. Det kan man nemlig ikke
rigtig gøre noget ved, når det er sket. Den, der skriver drivere
til operativsystemet, ville måske nok kunne lave noget software,
som forudsagde, at hardwaren trængte til service eller
udskiftning. Det er indenfor mulighedernes grænser.

     </para><para>

     Hvis vi skriver et almindeligt filterings program, fx. et,
som konverterer fra MIME/html characters til extended ascii eller
rettere ISO-8859-1, så bør vi altså ikke begynde at lave check af
CPU temperatur, disk tilstand etc. Det hører hjemme et andet sted
og er ikke interessant for vores filterprogram.




</para>
</sect2>
</sect1>


<sect1 id="outformat1"><title>Flere Hello-world - programmer.</title>

<para>

     Her kommer kildeteksten til et program, som kan skrive en
listing af tallene fra 0 til 7, inverteret og som 2's complement.
(Som lovet i <xref LinkEnd="ex-numrep1">).

</para>

<example id="ex-tal-hex"><title>Tallene fra 0 til 7 i hexadecimal notation.</title>
<programlisting role="C">

/* bitinvert.c viser hexadeximalt tallene fra 0 - 8  */
/* og desuden invertering, og såkaldt 2-s complement */

#include &lt;stdio.h>


char	*thisprg;

int main(int argc, char *argv[])
{
   int jj;

   thisprg = argv[0];

   for (jj=0;jj&lt;8;++jj) {
       printf("Word: %08x, Inverted: %08x, Complement: %08x\n",jj,~jj,~jj+1);
   }
   return 0;
}

/* end bitinvert.c */

</programlisting>
</example>





</sect1>
</chapter>
<chapter id="object-orienteret-tankegang"><title>Tankegang bag objektorienteret programmering</title>
<sect1 id="datatyper"><title>Konkrete og abstrakte datatyper</title>
<para>para asd asd asd

     </para><para>

     Er C et objektorienteret sprog? Hvordan kan det være, at der
flere steder står, at et C program er en række definitioner af
eksterne objekter? (external objects?)

     </para><para>

     De fleste sprog har nogle mekanismer, som er rigtigt
objektorienterede, nemlig håndteringen af forskellige numeriske
typer.

     </para><para>

     Vi kan have en integer i en variabel og gange den med en
float og lægge resultatet i en double uden at compileren gider
fortælle, at der skal konverteres. Taber vi præcision ved at
konvertere fra double til integer, vil de fleste compilere give
en warning, men de konverterer dog.

     </para><para>

     Det er egentlig objektorientering i en nøddeskal. Definer
din algoritme (fx. addition) og sørg for, at den kan håndtere
forskellige data, d.v.s. objekter, på en passende måde.  Det
vanskelige ved objektorientering kommer, når man definerer nye
klasser eller objekttyper og så skal til at skrive regler for,
hvordan operatorer skal fungere etc. Som en øvelse i
objekt-orienteret tankegang kan man prøve at definere en struct,
som skal repræsentere brøker, som fx. 2/3, der jo ikke er det
samme som 0.6667.

     </para><para>

     I C++ bliver det muligt at erklære en variabel af typen
broek (eller reference til broek) som fx. nedenstående eksempel

     <programlisting role="C">
     broek andel(2,3);
     afgift = broek(1,8) * andel;
     </programlisting>

     Forudsat, selvfølgelig, at man har defineret typen broek og
tilhørende operationer på en passende måde!

     </para><para>


</para>
</sect1>
<sect1><title>Hvad mere</title>

<para>
      Som nævnt i indledningen er det tanken at følge denne bog
op med flere, som hver især behandler en bestemt type
applikationer.

    </para><para>

      Ud over de grundlæggende typer TEXTfiltre, som man kan se 

      Foreløbig er det database applikationer, browser -
applikationer, 

    </para><para>

</para>

</sect1>
</chapter>
