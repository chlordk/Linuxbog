<!-- $Id$ -->
<chapter id="emulatorer">
<title>Emulatorer</title>
<indexterm><primary>win4lin</primary></indexterm>
<indexterm><primary>Plex86</primary></indexterm>
<indexterm><primary>Emulator</primary><secondary>VMware</secondary></indexterm>
<indexterm><primary>Emulator</primary><secondary>SCO</secondary></indexterm>

<para>
En emulator er et program, som gør det muligt at afvikle programmer
skrevet til en anden computer eller styresystem. Vi vil i dette afsnit 
se på en række forskellige emulatorer, som du kan benytte under Linux.
</para>

<para>
Med hensyn til emulatorer kan Linux køre SCO-programmer
(SCO er en kommerciel Unix-variant) gennem det, der hedder iBCS biblioteket
(Intel Binary Code Standard). Dette giver adgang til en del ekstra
kommercielle database-programmer.
</para>

<para>
Har du en kraftig (gerne 128 Mb RAM) og hurtig PC (gerne mere end 266
MHz Pentium II), kan du <emphasis>købe</emphasis> VMware, som laver en
emuleret processor og kobling til maskinen.  Så kan du køre dine
Windows-programmer samtidig med, at du kører dine Linux-programmer -
og principielt kan alle programmer køre. VMware kræver naturligvis, at
Windows er installeret på computeren.  VMware findes på <ulink
url="http://www.vmware.com">http://www.vmware.com</ulink>
</para>


<para>
Et alternativ er <command>win4lin</command>, som også er på vej
frem. Den kan købes fra <ulink
url="http://www.netraverse.com">http://www.netraverse.com</ulink>.
Win4lin kræver umiddelbart langt færre ressourcer end VMware, men har
også et par begrænsninger, såsom at kerne 2.4 ikke understøttes, der
findes ingen "network neighborhood", man skal samba-mounte (eller nfs-mounte)
netværksdrev, før man starter <command>win4lin</command>, og i
en tabel til <command>win4lin</command> angive, hvordan drevbogstaver
afbildes. Det vil være noget i retning af: C: afbildes til
<filename>/home/bruger/win</filename> M: afbildes til
<filename>/nfs/server/directory</filename> etc. Hukommelse kan
tildeles til Windows fra 20 Mb op til max. 64 Mb.  Der er også
begrænsninger i den grafik, der kan understøttes.
</para>

<para>
Hvor VMware og win4lin er kommercielle pakker, så er et frit projekt
<command>Plex86</command> på vej. Dog er det endnu ikke anvendeligt
og er ekstremt langsomt.
</para>


<figure id="fig-win4lin" float="1">
<title>Windows kører under Linux via win4lin</title>
<graphic fileref="win4lin.&magic;"  scale="40"></graphic>
</figure>


<sect1 id="vmware">
<title>VMware - flere maskiner i én</title>
<indexterm><primary>VMware</primary></indexterm>
<para>
Du kan med programmet VMware (<ulink
url="http://vmware.com">http://vmware.com</ulink>) sætte din maskine
op til at køre flere styresystemer samtidigt. Du kan hente en 30-dages
licens til systemet hos <ulink
url="http://vmware.com">http://vmware.com</ulink>, (og tilsyneladende
forny den en del gange senere, ikke mindst hvis du har en
*.mail ;). Samme sted findes en meget fyldig og logisk opdelt
installationsvejledning, som, efter et par dages eksperimenter, oven i
købet er til at forstå.
</para>

<sect2 id="vmware-fordele">
<title>Fordele ved virtuelle maskiner</title>

<para>
Med de virtuelle maskiner opnår du flere fordele.Samme hardware til
alle styresystemer uanset antal. Jeg har en vane med at bruge
udrangeret udstyr i en junkmaskine til at lege med, men det er ikke
tilfredsstillende at gå fra f.eks. 850MHz PIII til 333 MHz PII. Mulighed
for at suspendere maskiner uden at skulle gennem en boot næste gang de
skal bruges.Muliged for at afteste netværks-programmer uden at skulle
investere en formue i hardware.Mulighed for at lege med nye
distributioner uden at ødelægge den kørende server.  (Der skal nok
være flere gode grunde, men disse var nok til at få mig til lommerne).
</para>

<para>
Selv om du kan sætte en server op i en virtuel maskine til permanent
brug, skal du ikke gøre dette. Virtuelle maskiner er efter min mening
kun velegnet i forbindelser med aftestning. Selv en ældre maskine med
en installeret server (ikke virtuel) er bedre, og så er du også fri
for at få opsætningen på denne maskine forstyrret.
</para>
</sect2>


<sect2 id="vmware-hardwarekrav">
<title>Hardwarekrav</title>

<para>
Det kan stærkt anbefales at afprøve programmet for at se, om det kan
hvad man ønsker, og om ens hardware er hurtig nok til at give et
tilfredsstillende resultat. Ens processor bør efter min mening være
CPU >= 600 MHz, RAM >=128 Mb og harddisken skal have 2-4 Gb plads
pr. virtuel maskine.
</para>

</sect2>

<sect2 id="vmware-vaert">
<title>Valg af værtssystemet</title>

<para>
Ideen med programmet er, at du først installerer dit HOST-styresystem
(Linux, NT4 eller Win2K), og derefter opretter en eller flere
virtuelle maskiner under dette HOST-system, hvori du installerer andre
(eller samme) styresystemer. Installerer du MS eller andre
købe-styresystemer, skal du naturligvis have licens til dem, mere
virtuelt er det trods alt ikke.
</para>

<para>
Det første valg du skal gennemtænke meget grundigt er, hvilket
styresystem der skal være på maskinen (HOST).
</para>

<para>
Det du skal lægge vægt på her er både hvad du normalt bruger din
maskine til, og om al din hardware (også den kommende) er understøttet
af styresystemet. Begge grunde fik mig til at vælge W2K som HOST, da
jeg dels primært arbejder i Delphi, og dels har en hang til mystisk
(ofte alt for dyr) hardware.
</para>

<para>
Den næste overvejelse er hvilke styresystemer, der skal installeres
som GUEST-systemer. Her er valget langt lettere, idet du kan have alt
der vedrører en given virtuel maskine liggende samlet i en folder ( et
dir ), som blot kan slettes, hvis du valgte noget forkert. Du kan
naturligvis også vælge at lade den virtuelle maskine som sådan
overleve, og blot installere noget andet forfra. Det du risikerer ved
fejlvalg er således blot at opsamle unyttige erfaringer, men det kan
jo også have en værdi.
</para>
</sect2>

<sect2 id="vmware-pre-installation">
<title>Inden installationen</title>

<para>
Det er meget vigtigt, at du starter med at installere netværksdrivere
i dit HOST-system umiddelbart efter, du har installeret VMware selv,
og inden du begynder at installere virtuelle maskiner. Har du ikke
dette på plads, vil du hurtigt løbe ind i problemer med at kommunikere
mellem systemerne. Jeg valgte at installere driveren til
Bridget-networking, hvilket senere giver adgang til at gøre de
virtuelle maskiner offentligt tilgængelige. Du kan som alternativ
vælge et lukket netværk, som alene giver adgang til at kommunikere
internt mellem HOST/GUEST-systemer.
</para>

<para>
En anden ting, der skal være på plads er skærmens farvedybde. 16 og 24
bit fungerer ganske enkelt ikke. 8 bit giver hurtigere maskiner rent
grafisk, mens 32 giver flottere udseende.
</para>

<para>
Under W2K kan det være praktisk at tilpasse den indbyggede
DHCP-servers adresseområde. Jeg har valgt at køre alt under 192.168.1.* og
har derfor tilpasset filen
<filename>C:\WINNT\System32\vmnetdhcp.conf</filename>, så der uddeles
adresser i det område:
</para>

<programlisting>
subnet 192.168.1.0 netmask 255.255.255.0 {
    range 192.168.1.210 192.168.1.220;
    option broadcast-address 192.168.1.255;
    option domain-name-servers 192.168.1.200;
    option domain-name "linux.intranet";
}
</programlisting>

<para>
Er det en Windows-HOST, gør det heller ingen skade at køre en
defragmentering på harddisken, så der kommer en sammenhæng i de
datafiler, de virtuelle maskiner skal "leve" i.
</para>
</sect2>

<sect2 id="vmware-deling">
<title>Deling af filer mellem styresystemerne</title>
<para>
Installerer du Win9x på en maskine med NT/W2K som HOST, er
delingsmulighederne via en workgroup helt som mellem de to
styresystemer på to uafhængige maskiner.
</para>

<para>
Har du Linux med i spil, skal du sætte samba op på den, og arbejde med
filflytning fra Windows-siden. Altså:
</para>

<para>
<emphasis>Linux-HOST + Win9X/NT4/W2K-GUEST:</emphasis> Her skal Linux
have samba installeret, og i den/de virtuelle maskiner kan du derefter
kopiere til/fra samba-"drevene".
</para>

<para>
<emphasis>NT/W2K-HOST + Linux-GUEST:</emphasis>
Her skal samba igen
ind på Linux-maskinen, og du kan fra HOST'en hente og gemme filer på
samba-"drevene". Det vil ikke være praktisk at lave en permanent
mapning, da Windows-maskinen jo ikke kan finde den virtuelle samba før
den er sat i gang.
</para>

<para>
Har du en selvstændig Linux-server, kan dens samba-"drev" bruges som
fælles drev for både HOST- og GUEST-systemerne. Dette vil være den
foretrukne løsning for de fleste med en Linux-server, da de filer, der
ligger på serveren jo ikke er så udsat for at gå tabt ved et
systemnedbrud.
</para>

<para>
Der er andre muligheder for fildeling, men disse forekommer mig at
være de mest enkle at håndtere, ikke mindst fordi de allerede er
implementeret mellem min Linux-server og W2K-arbejdspladser.
</para>

</sect2>

<sect2 id="vmware-skaerm">
<title>Skærmopløsning</title>
<para>
Dette emne er meget hardware-afhængigt. Jeg kører med et Matrox Marvel
G400 TV-kort som har diverse forskellige muligheder for
opløsninger. Mit valg har været at sætte værten op til 1152x864, mens
gæsterne kun kører i 1024x768. Det giver plads til at vise gæsterne
i (virtuel) fuld skærm, og dog tillade overskrift og menulinje omkring
dem. Matrox-kortet understøtter desuden virtuelle skærme, så hver af
de virtuelle maskiner kan få sin egen skærm at brede sig i.
</para>

<para>
Andre, nyere skærmkort tillader lignende løsninger.
</para>

<para>
Der kan opstå lidt problemer med opdateringen af skærmene i de
virtuelle maskiner, men jeg tilskriver dem mere Matrox-driveren end
VMware.
</para>
</sect2>

<sect2 id="vmware-reboot">
<title>Reboot/Power off/Suspend</title>
<para>
Det er kun i forbindelse med installationer, at man har behov for at
"slukke" for den virtuelle maskine. Normalt vælger jeg blot at
suspendere den. Det er ganske enkelt herligt at have en fuldt
installeret, kørende SuSE/KDE/Konqueror oppe på under 5 sekunder med
/etc vist med et hav af små ikoner. Det tager omtrent 4 minutter at
lave en boot på min maskine (den har SCSI), så dén med at dual-boote
dur ganske enkelt ikke i dagligt brug.
</para>

<para>
CTRL+ALT+DEL fanges af værten, mens CTRL+ALT+INS oversættes til en
lokal CTRL+ALT+DEL i den af de virtuelle maskiner der har fokus. En
både sjov og logisk løsning, som man går fejl af en del gange i
starten.
</para>

<para>
Med W2K som HOST giver CTRL+ALT+DEL i en virtuel maskine den
sædvanlige logout-dialog, men selv ved valg af CANCEL i denne dialog
ryger tastetrykket CTRL+ALT+DEL til den virtuelle maskine, som
reagerer på det. Det er det man sædvanligvis er interesseret i, så det
kan vel knapt kaldes mere end en skønhedsfejl. Kører den virtuelle
maskine X får man her en mulighed for at fortryde, kører den i en
tekst-konsol, går den i gang med en "reboot -n" uden videre.
</para>
</sect2>

<sect2 id="vmware-focus">
<title>Fokus/prioritet</title>
<para>
VMware fanger fokus enten ved et bestemt tastetryk eller ved et
klik med musen i den virtuelle maskines vindue. Jeg har valgt kun at
bruge musen, det fungerer overbevisende. Man slipper fri igen med
CTRL+ALT+ESC, hvorefter fokus er placeret i HOST-maskinen. Skiftes der
til fuldskærmstilstand er det ligeledes CTRL+ALT+ESC der skal anvendes
for at slippe fri.
</para>

<para>
Der er mulighed for at bestemme, hvordan maskinens ressourcer skal
fordeles mellem de kørende virtuelle maskiner. Normalt vil det være at
foretrække med en høj prioritet til den maskine, der har fokus, og en
lavere til de øvrige. Ressource-prioriteringen kan ændres under drift.
</para>

<para>
Der er mulighed for at tildele større eller mindre mængder RAM til de
virtuelle maskiner. Denne mængde kan der kun ændres på, når den
virtuelle maskine er helt slukket (ikke under suspend, de færreste
styresystemer kan håndtere hot-swap-RAM:).
</para>

<para>
Det er (heldigvis) ikke muligt at starte samme virtuelle maskine op i
flere kopier.
</para>
</sect2>

<sect2 id="vmware-flere">
<title>Flere ens virtuelle maskiner</title>
<para>
Hvis du har fulgt rådet i starten af dette dokument om at installere
hver virtuel maskine i sin egen folder (katalog), kan du endog meget
hurtigt sætte en række ens virtuelle maskiner op. Start med at
installere den første maskine. Luk den virtuelle maskine ned (ellers
vil kopien starte med at køre tjek på disken). Kopiér folderen med
indhold til en ny folder. Ret sti og evt. filnavne i
<filename>.vmx</filename>-filen vha. en simpel teksteditor.
</para>

<para>
Nu har du fået to eller flere ens virtuelle maskiner, og kan blot
starte dem fra en ende af. Du skal dog være opmærksom på, at fysiske
enheder og COM-porte kan give konflikt ved start af flere virtuelle
maskiner, som alle ønsker at starte med f.eks. drev A:
"connected". VMware løser denne konflikt ved at sætte sådanne enheder
til ikke at være forbundet ved boot. De kan derefter aktiveres efter
behov under drift.
</para>
</sect2>

<sect2 id="vmware-vnc">
<title>VMware og VNC</title>
<indexterm><primary>VNC</primary></indexterm>
<indexterm><primary>Fjernstyring af Linux</primary></indexterm>
<indexterm><primary>Fjernstyring af Windows</primary></indexterm>
<indexterm><primary>Windows-programmer under Linux</primary></indexterm>
<indexterm><primary>Linux-programmer under Windows</primary></indexterm>
<para>
Det er rent faktisk muligt at afvikle virtuelle maskiner via VNC (se
også <xref linkend="vnc"/>). Hvis HOST'en kører vncserver + en virtuel
maskine, kan man bearbejde den virtuelle maskine via sin
VNC-forbindelse. Det giver dog en del mere mening at starte vncserver
på både HOST og den/de virtuelle maskiner, da "oversættelsen" fra
virtuel til HOST til VNC er alt for sløv.
</para>

<para>
Altså: Installér og start vncserver på alle de virtuelle
maskiner. Kører den virtuelle maskine Linux, kan du uden videre
minimere den, da VNC alligevel ikke bruger det viste skærmbillede.
</para>

<para>
Brug vncviewer til at vise hver enkelt maskine.
</para>

<para>
Dette dokument skives på en bærbar maskines tastatur en stille
sommeraften på terrassen via VNC til min normale arbejdsplads, som
for øvrigt kører to Win98 og en enkelt SuSE 7.0 i virtuelle
maskiner. Linux'en kører minimeret på sin HOST, men i et andet
VNC-view på den bærbare, mens min normale Linux-server blot for en
ordens skyld kører i et tredie view.
</para>

<para>
Alle maskiner kører med en tilfredsstillende hastighed. Faktisk er
alle en del hurtigere at arbejde på, end hvis jeg havde arbejdet
direkte på den bærbare.
</para>
</sect2>

<sect2 id="vmware-vnc-problem">
<title>Det største problem</title>
<para>
Det største problem ved virtuelle maskiner er, efter min mening, at
finde rundt i dem. Man kan opnå en del ved at lave skrivebordet
forskelligt, både i baggrundsfarve og placering af diverse
paneler. (Her har jeg for første gang fundet en nyttig grund til at
skifte baggrundsfarve;)
</para>

<para>
Vænner man sig til aldrig at slukke, men kun "suspend'e" de virtuelle
maskiner er meget nået mht. utilsigtet afbrydelse.
</para>
</sect2>

<sect2 id="vmware-konklusion">
<title>Konklusion</title>
<para>
VMware er et af de programmer, der på trods af mange års arbejde
indenfor EDB-området, har fået mig til at hæve et øjenbryn i
(blaseret) begejstring. For første gang siden mit første møde med ægte
multitasking i OS/2, er der noget der rykker. Jeg har i mange år haft
elektronisk omskiftning mellem fire maskiner til samme
tastatur/skærm/mus, og er vant til at kunne skifte let mellem dem, men
fleksibiliteten i at kunne se alle samtidigt, og at kunne skifte
mellem dem med et klik er virkelig et fremskridt.
</para>

<para>
Det sker kun en sjælden gang, at min CPU arbejder 100%. Delingen af
processorkraften mellem flere maskiner er derfor ikke noget, der i
større grad generer. Dette, sammenholdt med den virkning at alle
maskiner opdateres samtidigt og gratis hver gang min HOST-maskine
ombygges eller udvides, gør programmet særdeles interessant. Selv om
skattefar mod- og ufrivilligt sponsorerer to trediedele af mine
nyanskaffelser er der jo trods alt den sidste trediedel at tage hensyn
til.
</para>
</sect2>
</sect1>


<sect1 id="dosemu">
<title>DOS-emulatoren dosemu</title>
<indexterm><primary>DOS</primary><secondary>emulering, dosemu</secondary></indexterm>
<indexterm><primary>dosemu</primary><secondary>emulering af DOS</secondary></indexterm>
<indexterm><primary>Emulator</primary><secondary>dosemu, FreeDOS</secondary></indexterm>

<para>
Mangler du specifikke DOS-programmer under Linux, kan du få en
DOS-emulator (<command>dos</command> (konsol-orienteret) og
<command>xdos</command> (X-baseret)), således at du under Linux kan
køre DOS-programmer. Programmet kan sågar køre grafikprogrammer
(f.eks. Windows 3.1) - dog ikke nyere Win32 programmer. Du kan
f.eks. anvende DOS-emulatoren til at køre Gyldendals Røde Ordbøger.
</para>

<para>
DOS-emulatoren består egentlig af to dele. Den ene del gør det muligt
at køre DOS-programmer under Linux, mens den anden del er selve
styresystemet DOS. Der følger en DOS ved navn FreeDOS med, men du kan
i princippet bruge din egen, f.eks. hvis du en gang har købt DOS og
stadig har installationsdisketterne liggende. I det følgende vil vi
dog kun benytte FreeDOS. Begge dele er indeholdt i dosemu-pakken.
</para>

<para>
Lad det være sagt med det samme: Den version af DOS-emulatoren, som
følger med Red Hat virker <emphasis>ikke</emphasis>. Grunden er
den simple, at Red Hat har valgt at benytte den nyeste version. Men
denne version er for udviklere, dvs. den er fuld af fejl og
mangler. Derfor skal du først nedgradere dit system til den stabile
version. Nedenfor ser du, hvordan du gør det:
</para>

<screen>
<prompt>[root@linus root]# </prompt><userinput>rpm -e dosemu-freedos-0.99.10-4</userinput>
<prompt>[root@linus root]# </prompt><userinput>rpm -e xdosemu-0.99.10-4</userinput>
<prompt>[root@linus root]# </prompt><userinput>rpm -e dosemu-0.99.10-4</userinput>
<prompt>[root@linus root]# </prompt><userinput>rpm -i dosemu-0.98.8-1.i386.rpm</userinput>
</screen>

<para>
Filen <filename>dosemu-0.99.8-1.i386.rpm</filename> kan du hente fra <ulink
url="http://www.dosemu.org/">http://www.dosemu.org/</ulink>.
For at få DOS-emulatoren til at virke skal du have DOS installeret.
Nedgraderer du som anvist ovenfor, kan du let få en gratis DOS (FreeDOS). Du
skal blot omdøbe filen <filename>hdimage.first.rpmsave</filename> i
kataloget <filename>/var/lib/dosemu</filename> til
<filename>hdimage.first</filename>.
</para>

<screen>
<prompt>[root@linus root]# </prompt><userinput>cd /var/lib/dosemu </userinput>
<prompt>[root@linus dosemu]# </prompt><userinput>mv hdimage.first.rpmsave hdimage.first</userinput>
</screen>

<para>
Eftersom du under DOS kan rode direkte med hardware (som du ikke kan som
almindelig bruger under Linux), kan kun root køre
DOS-emulatoren. Hvis du ønsker at ændre dette, skal du rette i filen
<filename>/etc/dosemu.users</filename>. Den RPM-fil, som du har
installeret som anvist ovenfor, tillader at alle bruger den, så du skal
ikke rette noget.
</para>

<para>
Under en standard-installation af dosemu-pakken oprettes et billede
af en harddisk. Billedet emulerer C:-drevet. Dette billede finder du
(under Red Hat 6.0) som
<filename>/var/lib/dosemu/hdimage.first</filename>. Det er let at
hente og gemme filer på dette billede fra Linux. Du skal blot føje
linjen
<programlisting>drive g:  file="/var/lib/dosemu/hdimage" offset=8832</programlisting>
til <filename>/etc/mtools.conf</filename>, og nu
kan du bruge <command>mcopy</command>, <command>mdir</command> osv.
</para>

<para>
Vil du vide mere om DOS-emulatoren, er <ulink
url="http://www.dosemu.org">http://www.dosemu.org</ulink> et godt sted 
at begynde. FreeDOS finder du på <ulink
url="http://www.freedos.org">http://www.freedos.org</ulink>
</para>

<figure id="fig-dosemu" float="1">
<title>WordPerfect 5.1 i DOS-emulatoren</title>
<graphic fileref="wp51-dosemu.&magic;"  scale="40"></graphic>
</figure>
</sect1>

<!-- Skrevet af Mikkel Maastrup -->
<sect1 id="WINE">
<title>Kør Windows-programmer med WINE</title>
<indexterm><primary>Wine</primary></indexterm>
<para>
WINE står for "Wine Is Not an Emulator" og det er et program, som
tillader dig at køre MS-DOS- og Windows-programmer under X på enhver
Linux-distribution (og andre UNIX-systemer som f.eks. FreeBSD og
Solaris). Der er endda nogle som er gået i gang med at portere det til
endnu flere operativsystemer som f.eks. BeOS. Som navnet siger er
WINE ikke en emulator og kan derfor kun køre på de Intel x86-baserede
computere (altså ikke på Linux-systemer til f.eks. Macintosh). Mange
hundrede programmører har sørget for at WINE er blevet til. WINE
sørger får at Windows-programmerne virker som om de var lavet til
Linux. Man kan altså f.eks. klippe/klistre mellem et program der
bliver kørt af WINE og så et "normalt" Linux program. WINE er skrevet
i programmeringssproget C og har en frit tilgængelig kildetekst (som så
meget andet Linux-software), og det gør bl.a. at alle kan hjælpe til
med at udvide og rette i programmet.
</para>

<para>
WINE kan faktisk køre
Windows-programmer på Linux uden at have Windows installeret på
computeren. Hvis man har Windows vil WINE dog være i stand til benytte
originale systemfiler og dermed give bedre ydelse. Med WINE følger der
også noget som kaldes Winelib hvilket gør at man kan kompilere sin
Windows-specifikke kildetekst til Linux. Altså, hvis man har lavet et
Windows-program og har kildeteksten, så kan man altså bare oversætte
programmet med en C-oversætter til Linux i stedet for med en til Windows (så
programmet dermed også virker til Linux). Det er der nogle store
firmaer der har gjort, bl.a. Corel. Alle Corels Linux-produkter
benyttede sig altså af WINE, og det gør de vist stadig. Det er dog
ikke perfekt så der skal ofte ekstra arbejde til at tilpasse
programmet før det kan lade gøre.
</para>

<para>
Wine projektet er efterhånden nået rigtigt langt med at emulere windows,
dette gør sig netop på spilområden gældende ved at der efterhånden er en
hel del spil der kan køres under Wine, der er samlet en lille succesliste
på: <ulink url="http://www.3ddownloads.com/index.php3?directory=/linuxgames/">http://www.3ddownloads.com/index.php3?directory=/linuxgames/</ulink>
Denne inkluderer blandt andet spil som StarCraft.
</para>


<sect2 id="hvordan-wine">
<title>Hvordan virker WINE?</title>

<para>
Det sørger som sagt for at man kan køre Windows-programmer, og uden at
have Windows på computeren. Inden vi fortsætter skal vi lige se lidt
på de såkaldte API'er. API står for "Application Program
Interface". Når et program kører, sender det såkaldte "API calls" til
det styresystem, som det bliver kørt på. Et program kan altså gøre brug
af operativsystemets API'er. F.eks. kan
et "API call" være at skrive en fil på en harddisk eller sende output til en
printer. Hvert operativsystem har hver deres "API calls". Det som
WINE gør, er at gå ind og ændre Windows API'erne til Linux API'er. Så
når et Windows-program sender en "Windows-API" gennem WINE, så modtager
Linux en "Linux-API" der har den samme funktion som det API'en burde
have gjort på Windows. Programmet tror altså at det kører på Windows
og Linux tror det modtager informationer fra et Linux-program. Det
som WINE, meget enkelt forklaret gør, er at den starter to
programmer. Det ene er et specielt program der gør at man kan starte
Windows-programmet og det andet er et program som omdanner Windows-API'erne
til Linux-API'er. Det er det WINE går ud på. Altså at omdanne
Windows' API-sæt til Linux' API-sæt. Enhver som har prøvet WINE ved
dog at det er langt fra alle programmer, som kan køre via det. Og
hvordan kan det være? Det er fordi Windows ikke er Open Source
software og derfor kan ingen bare gå hen og finde Windows-API'erne i
kildeteksten. Dokumentationen til Win32 API-kald er heller ikke spor
god og er blevet kritiseret for at være ikke-eksisterende, sparsom og
endda vildledende. WINE-folkenes arbejde er derfor mest baseret på
gæt. Win16 og DOS API-kald skiftes ikke længere ud. Derfor vil
langt de fleste af gamle Windows-programmer virke via WINE. Win32-kald
skifter dog stadigvæk og hvis Microsoft introducerer et nyt
sæt API-kald eller ændrer på dem som findes i forvejen så skal dette
jo også tilføjes. Derfor bliver WINE formodentlig aldrig færdig. Selv
om det startede i 1993, så er der ikke kommet en stabil version
endnu.
</para>
</sect2>

<sect2 id="wine-historie">
<title>Lidt historie</title>

<para>
WINE-projektet startede i 1993 på Usenet newsgroup'en
comp.os.linux. Det var en fyr der hed Eric Youngdale som startede
det. I 1994 blev posten som koordinator for projektet overgivet fra
Bob Amstadt til Alexandre Julliard (som stadig sidder på
posten). Grunden til at WINE-projektet blev startet var (og er stadig)
at langt det meste software bliver udviklet til Windows. Man ønskede
altså at have adgang til den kæmpe mængde software som er blevet lavet
til Windows og samtidig have glæde af Linux' fordele.
</para>

<para>
WINE er stadig ikke færdig, så det er ikke alle programmer som kan
køre via WINE. De fleste ældre programmer burde dog virke.
</para>
</sect2>


<sect2 id="wine-installation">
<title>Installation af WINE</title>
<para>
For at installere WINE, har jeg valgt at bruge WINE Preview 3 fra
firmaet Codeweavers. Dette er en helt normal WINE-udgave som blot er
blevet pakket fint ind, så den nu har grafisk installation og
opsætning.
</para>

<para>
Codeweavers WINE findes kun som .rpm-fil (på <ulink
url="ftp://ftp.codeweavers.com/pub/crossover/office/source/wine.tgz">ftp://ftp.codeweavers.com/pub/crossover/office/source/wine.tgz</ulink>). Hvis
du bruger RedHat, Mandrake og SuSE (samt en del flere) kan du
bruge denne udgave af WINE. Hvis du kører med en
"ikke-rpm"-distribution, som f.eks. Debian, kan du prøve at se på
<ulink url="http://www.winehq.com">http://www.winehq.com</ulink> efter
en Debian-version af WINE.
</para>

<para>
Når du installerer Codeweavers WINE så burde den kunne bruge tidligere
WINE-opsætninger og installerede Windows-programmer. Jeg er dog
ikke sikker på om det går lige godt hver gang, selvom der indtil
videre ikke har været nogle problemer for mig (man ved jo aldrig hvad
der kan ske). Derfor bør du passe ekstra godt på når du installerer
(Codeweavers) WINE, hvis du i forvejen bruger WINE. Du kan risikere at
bruge WINE uden at vide det. F.eks. bruger mange (hvis ikke alle) af
Corels Linux-programmer WINE. Som sagt, er dette blot en vejledning som
følger den metode som jeg brugte. Jeg tager derfor intet ansvar hvis
noget skulle gå galt på din maskine. Der har dog ikke været nogle
store problemer for mig indtil videre. Jeg vil i denne
installationsvejledning fortælle hvordan du kan installere WINE. Jeg
antager at du ikke tidligere har brugt WINE, at du er logget ind som
brugeren tyge (dette navn skal du bare erstatte med dit eget
brugernavn), at du bruger en ".rpm-baseret" distribution og at du ikke
har en Windows-partition på din computer. 
</para>

<para>
Jeg har lavet denne vejledning på en Mandrake 8.0-distribution,
så hvis du bruger en anden distribution end den, kan der godt være
nogle ting som er lidt anderledes. Det skal jeg dog nok gøre dig
opmærksom på, når det kommer.
</para>

<sect3 id="wine-installation-krav">
<title>Hvad kræver WINE af computeren?</title>

<para>
For at køre WINE skal du som minimum have en computer med en
386-processor. Det er som sagt kun muligt at køre WINE på Intel
x86-processorer (altså normale PC'er) og dermed IKKE på computere som
Macintosh.
</para>

<para>
Et UNIX-kompatibelt operativsystem som f.eks. Linux, FreeBSD, Solaris x86. Dog
skal man huske på at Codeweavers WINE kun kommer som .rpm-fil.
Minimum 16 Mb ram. For virkelig at få noget ud af det, anbefales
minimum 64 Mb ram.
</para>

<para>
Et X11 Window System (f.eks. XFree86). Hvis du benytter andet end
XFree86 kan det være lidt problematisk. Hvis det er tilfældet så se på
WINE's web-site.
</para>
</sect3>

<sect3 id="wine-hent">
<title>Få fat på programmet</title>

<para>
På <ulink url="http://www.codeweavers.com/technology/wine/download.php">http://www.codeweavers.com/technology/wine/download.php</ulink> henter du
pakken med WINE Preview 3 (den er på ca. 12 Mb. Altså den der hedder
"Installable Package") og lægger den ind i tyges hjemmekatalog
(/home/tyge).
</para>
</sect3>

<sect3 id="wine-i-forvejen">
<title>Er der WINE i forvejen?</title>
<para>
Først skal du finde ud af om der i forvejen ligger en version af WINE
på din maskine. Det kan der godt gøre selv om du ikke ved det, for
nogle distributioner installerer det automatisk sammen med alt det
andet software. For at finde ud af det, skal du skrive <command>rpm -qa
| grep wine</command> (evt. også <command>rpm -qa | grep
WINE</command>) i et terminalvindue. Hvis der er installeret en
version af WINE i forvejen bør du få et svar som minder lidt om det
her: <literal>wine-20010305-1mdk</literal>. Det er kun hvis du har en
Mandrake-distribution at der står "mdk" til sidst. Der kan være mere end én
pakke, hvis du f.eks. også har en programmørudgave liggende. Hvis du
har det, bør du dog overveje om det er værd at skifte WINE ud.
</para>

<para>
WINE bliver opdateret utrolig tit og en version af WINE der følger med
din distribution kan godt være lidt gammel. Hvis du støder ind i et
problem med den version der ligger der i forvejen, så kan det nogle
gange betale sig at opdatere WINE til den nyeste version. Hvis WINE
derimod virker fint til det formål du skal bruge det til, så er der jo
ingen grund til at fjerne det.
</para>

<para>
Hvis der intet står på skærmen efter et stykke tid så har du ikke WINE
installeret. Hvis det ikke er installeret så spring videre til
"Installation"-afsnittet.
</para>
</sect3>

<sect3 id="wine-afinstallation">
<title>Afinstallering</title>
<para>
Lad os se nærmere på hvordan man afinstaller WINE. Det gøres ved at
logge ind som root og åbne en xterm eller åbne en xterm som ens
normale bruger og skrive su og trykke på enter-tasten og så skrive sit
root-kodeord.
</para>

<para>
Derefter skriver du <command>rpm -e programnavnet-fra-før</command> (i
mit tilfælde <command>rpm -e wine-20010305-1mdk</command>). Hvis du
har mere end én WINE-pakke så gør du bare det samme igen ved at skrive
<command>rpm -e navnet-på-det-andet-program</command>. Nu kan du så
igen skrive <command>rpm -qa | grep wine</command> (og <command>rpm
-qa | grep WINE</command>) og hvis der ingen ting kommer frem på
skærmen (udover en ny linje i konsollen) så er du WINE-fri.
</para>
</sect3>

<sect3 id="wine-ny-installation">
<title>Installation af ny WINE</title>
<para>
Det første du skal gøre er at
gå ind i mappen hvor WINE-pakken ligger med kommandoen <command>cd
/home/tyge</command> (hvis du ikke længere har root-adgang så
skriv først <command>su</command>, og derefter dit root-kodeord, i en xterm).
Her skriver du så <command>rpm -i
codeweavers-wine-20010305-1.i386.rpm</command>. </para>

<para>
Nu kan der ske to ting. Enten installerer den perfekt eller også
fortæller den, at den mangler nogle programmer for at kunne
installere. Den kan f.eks. skrive at den mangler programmet iTcl eller
xmessage eller lignende. Det er så nødvendigt at skaffe pakkerne. Hvis
du har Mandrake 8.0 så kan du bruge deres Software Manager eller du kan
gå på internettet og finde dem. iTcl pakkerne kan du finde på
CodeWeavers web-site. Hvis WINE skriver at du har brug for xmessage så
skal du installere pakken X11R6-contrib eller X11R6-contribs.
</para>

<para>
Når det så er installeret skal du logge ud af root og logge ind som
din normale WINE-bruger. Nu skal du så sætte WINE op. Det gøres via
WineSetup. WineSetup kan enten startes fra systemmenuen eller fra
konsollen, det gør ingen forskel. Hvis du vil starte det fra konsollen
skal du bare skrive winesetup i en xterm. Så kommer der et vindue frem
hvor der er en tegning af Tux der prøver at åbne en vin. Her vælger du
den øverste valgmulighed. Den der hedder
<filename>~/.wine/config</filename> (new, writable). Tryk derefter på
"Next &gt;&gt;".
</para>

<para>
Nu kommer en ny ting i WINE-opsætningsprocessen
frem. Indstillingen af Windows-mappen. Her skal du bare vælge den
mulighed hvor der står (Create a new windows directory:
<filename>/home/tyge/.wine/fake_windows</filename>) være. Tryk
derefter på "Next &gt;&gt;"
</para>

<para>
Nu kommer der et nyt vindue op hvori du kan sætte WINE op. I det følgende
gennemgås systematisk hvert punkt i den venstre side af
opsætningsvinduet: </para>

<sect4 id="wine-basic">
<title>Basic</title>

<itemizedlist mark="bullet">
<listitem>
 <para>
<emphasis>Look & Feel</emphasis>
Vælg hvilket styresystem dine Windows-programmer skal have udseende
efter. Du kan vælge mellem Windows 3.1, Windows 95 eller Windows 98.
 </para>
</listitem>

<listitem> 
 <para>
  <emphasis>Window Mode</emphasis>
  Her kan du vælge hvordan programmerne der bliver kørt med WINE skal
  optræde på dit skrivebord. Vælg mellem tre indstillinger.
 </para>

 <itemizedlist>
  <listitem>
   <para>
<emphasis>Managed:</emphasis> De Windows-applikationer som bliver
kørt, bliver mere integrerede i din X-opsætning, og kommer derfor til
at se flottere og mere "Linux-agtige" ud. Nogle gange kan
Windows-programmerne og X dog ikke helt finde ud af at køre rigtigt
sammen, så nogle gange skaber det problemer, at køre med
"managed". Problemer som man vil kunne undgå hvis man vælger en af de
to andre indstillinger.
   </para>
  </listitem>

  <listitem>
   <para>
<emphasis>Unmanaged:</emphasis> Nu bliver programmet ikke integreret i
din X-opsætning og ser derfor ud som det ville have gjort under
Windows. Her er der ingen problemer med at X kan få programmet til
ikke at køre rigtigt og derfor vil programmer der ikke kan køre som
managed, i nogle tilfælde godt køre som unmanaged. Hvis man vælger
denne indstilling kan man godt køre programmerne som managed uden at
skulle konfigurere WINE igen (læs senere i denne
instruktionsvejledning). Dette virker ikke den modsatte vej. Altså
hvis man har valgt managed kan man ikke køre programmet som unmanaged
uden at skulle konfigurere WINE igen.
   </para>
  </listitem>

  <listitem>
   <para>
<emphasis>Desktop:</emphasis> Her får du mulighed for at åbne dine
Windows-programmer i noget som ligner et Windows skrivebord samt den opløsning
"skrivebordet" skal være. Det skulle efter sigende være det
udseende som flest programmer virker med. Selve "skrivebordet" ser
"managed" ud, mens programmet der kører i skrivebordet ser "unmanaged"
ud. Hver gang du åbner en ny applikation, åbnes der også et nyt
skrivebord. Nogle mennesker foretrækker denne indstilling. Jeg synes
også at den er nyttig til tider, men dog synes jeg at programmerne
generelt kommer til at fylde for meget hvis man ser dem i
skrivebordstilstand og normalt virker programmer fint i både unmanaged og
managed tilstand.
   </para>
  </listitem>
 </itemizedlist>

<para>
På <xref linkend="gozdesktop-fig"/>, <xref linkend="gozmanaged-fig"/> og
<xref linkend="gozunmanaged-fig"/>,  kan du se tre forskellige screenshots
hvor jeg har prøvet at køre Windows-programmet Go!Zilla via WINE under
managed, unmanaged og desktop 640x480.
</para>

<para>
Normalt kan man bare stoppe her ved at trykke på "Finish"-knappen. Så
burde det være klart til brug. Hvis noget går galt, du er nørdet af
natur eller du bare gerne vil rode lidt mere med WINE, så læs videre.
</para>
</listitem>
</itemizedlist>

<figure id="gozdesktop-fig" float="1">
<title>Go!Zilla desktop</title>
<graphic fileref="gozdesktop.&magic;"  scale="60"></graphic>
</figure>

<figure id="gozmanaged-fig" float="1">
<title>Go!Zilla managed</title>
<graphic fileref="gozmanaged.&magic;"  scale="60"></graphic>
</figure>

<figure id="gozunmanaged-fig" float="1">
<title>Go!Zilla unmanaged</title>
<graphic fileref="gozunmanaged.&magic;"  scale="60"></graphic>
</figure>
</sect4>

    <sect4 id="wine-advanced">
     <title>Advanced</title>

     <itemizedlist mark="bullet">
      <listitem>
       <para>
        <emphasis>Drives</emphasis>: Her kan du indstille dine drev.  For
        eksempel kan du angive hvor dit cd-rom-drev ligger, hvor dit
        C:-drev ligger
osv. F.eks. betyder denne linje: "A Floppy /mnt/floppy /dev/fd0" . A =
Windows-drevbogstav. Floppy = type hardware. /mnt/floppy = hvor på
Linux drevet befinder sig. <filename>/dev/fd0</filename> = hardware-stien.
Hvis du er i tvivl om hvorvidt dine hardware-stier er indstillet korrekt
kan du åbne en konsol og skrive <command>emacs /etc/fstab</command>
(du skal dog passe godt på ikke at ændre noget i denne fil, da den er
ret vigtig). F.eks. var D:-drevet på min computer
(<filename>/mnt/cdrom</filename>) automatisk indstillet til at have
hardware-adressen <filename>/dev/hdd</filename> og jeg skulle så selv
ændre det til <filename></filename>/dev/cdrom. Dette gøres ved at
trykke på linjen for det stk. hardware man ønsker og derefter trykke
på knappen "Edit". I det vindue som kommer frem kan man så indstille
det stk. hardware man har valgt.
 </para>

<figure id="winedrives-fig" float="1">
<title>WINE-drev</title>
<graphic fileref="winedrives.&magic;"  scale="60"></graphic>
</figure>

</listitem>



<listitem> 
 <para>
<emphasis>Paths</emphasis>
Her kan du bare se hvor dine falske Windows-mapper (altså de mapper
som WINE selv laver) bliver placeret.
 </para>
</listitem>


<listitem> 
<para>
<emphasis>Look & Feel</emphasis>
Her kan du vælge mellem fire indstillinger:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
<emphasis>Use DGA</emphasis>
Denne indstilling sørger for at det såkaldte DirectDraw arbejder bedre
sammen med X og det kan derfor overtage hele skærmen og køre
programmerne i "full screen" ved maksimal hastighed. Dog har brugen af
DGA også en mindre heldig side. Hvis WINE går ned (crasher) mens det
bruger DGA så kan det ske at computeren fuldstændig standser og det
bliver nødvendigt at skulle genstarte computeren for at få kontrol
over den igen.
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>Use X shared memory</emphasis>
Denne indstilling tillader programmer, som bliver kørt i WINE, at køre
hurtigere end de normalt ville gøre i X. Dog langt fra så hurtigt som
hvis de brugte DGA.
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>DX grab</emphasis>
Hvis man ikke bruger DGA så sørger denne indstilling for at
musemarkøren holder sig inde i WINE-vinduet. Hvis WINE crasher mens
man kører med DX grab så standser computeren ligesom med DGA (her kan
man dog benytte tastaturet og derved få lukket X).
 </para>
</listitem>

<listitem> 
 <para>
  <indexterm>
   <primary>OpenGL</primary>
   <secondary>i WINE</secondary>
  </indexterm>

<emphasis>Double-buffered desktop.</emphasis> Dette har kun betydning
hvis du bruger komandoen <command>wine --desktop</command> til at
starte dine WINE-programmer i stedet for bare at skrive wine.    Det
bestemmer om der skal bruges det såkaldte "double-buffered visual."
Det er noget som de fleste OpenGL-spil skal bruge for at køre
rigtigt. Codeweavers WINE understøtter dog ikke OpenGL, så hvis der
skal spilles 3D-spil via WINE (f.eks. Half-Life), så skal du prøve at
se på den "rigtige" WINE-side.
</para>

<para>
Jeg har kun valgt at have Use DGA og Use X shared memory slået til,
men det er lidt en smagssag.
</para>
</listitem>

</itemizedlist>
</listitem>


<listitem> 
 <para>
<emphasis>DLLs</emphasis>
.DLL-filer er Windows' systemfiler. I denne menu kan du vælge
hvordan WINE skal forholde sig til de systemfiler som det
understøtter. Der er tre muligheder for at vise WINE hvilke
systemfiler der skal bruges fra de forskellige steder. Der er builtin,
native og so. Hvis du ikke har Windows så bør alle filerne stå som
"builtin" bortset fra nogle specielle filer. Bl.a dem der hedder noget
med "glide", bør stå som "so". Codeweavers WINE bør dog selv
indstille dette korrekt. "Builtin" fortæller WINE at systemfilerne
skal findes blandt WINEs "kunstige" .DLL-filer. Altså de systemfiler
som følger med WINE. "So"-filer bruges til programmer som har de samme
API calls under både Windows og Linux (som f.eks. Glide). Ved at vælge
at filerne skal findes "native" kan man (hvis man har en version af
Windows installeret) få WINE til at bruge Windows' systemfiler. På
computeren hvor denne HOWTO er lavet har jeg dog ikke installeret
Windows og beskrivelsen af native-funktionen har jeg derfor valgt at
udelade.
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>Ports</emphasis>
Her kan du indstille hardware-adresserne til dine porte bag på
computeren. Disse porte burde være rigtigt indstillede og du bør
derfor kun rette i dem hvis det ikke virker på din computer.
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>Registry</emphasis>
Her bør alle valgmulighederne bare være slået til. De handler om
hvor WINE kan hente og skrive sine informationer fra og til.
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>Finish</emphasis>
Her kan du se hvordan din WINE-opsætningsfil kommer til at se ud.
Så er der bare tilbage at trykke på "Finish"-knappen nede i højre hjørne.
 </para>
</listitem>


</itemizedlist>

<para>
I denne vejledning valgte vi at bruge en personlig opsætningsfil
og personlig WINE-mappe. Derfor skal du konfigurere WINE for hver
bruger inden du kan benytte WINE, med den nye bruger.
</para>

<para>
Når man skal åbne programmer med WINE kan man normalt bare skrive wine
eksempel.exe i en xterm eller bare dobbeltklikke på ikonet i din
filmanager. Det er dog ikke det eneste mulighed. Man kan ændre WINEs
indstillinger for hvert enkelt program bare ved hjælp af simple
kommandoer. Nedenunder vil jeg fortælle om nogle af de mest
nødvendige.
</para>


<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>wine --desktop YYYxZZZ eksempel.exe</userinput>
</screen>

<para>
Bemærk, at der skal to minus-tegn foran "desktop".
</para>

<para>
Her er kan du fortælle WINE at det skal åbne Windows-programmet i sit
eget lille skrivebord. I stedet for YYYxZZZ skal du indsætte pixlerne
for den størrelse du ønsker vinduet skal fylde. Det er dog ikke bare
hvilke som helst tal, men skal være de normale
skrivebordsstørrelser. F.eks. <command>wine --desktop 800x600
eksempel.exe</command>. Dette er især smart hvis du vil køre programmer
der normalt fylder hele skærmen. Du kan altså få et fuldskærms-program
til at køre i et vindue, f.eks. hvis det normalt bruger en skærmopløsning på
1024x768 pixels. </para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>wine --managed eksempel.exe</userinput>
</screen>

<para>
Her er kan du fortælle WINE at det skal integrere programmet bedre i
din window-manager. Dette gælder selvfølgelig kun hvis du har valgt at
WINE normalt skal åbne programmer "unmanaged."
</para>

<para>
Hvis du vil vide mere om hvordan man starter, installerer og kører
programmer via WINE, så læs videre i næste afsnit.
</para>
</sect4>
</sect3>
</sect2>

<sect2 id="installere-programmer-under-wine">
<title>Installere programmer under WINE</title>
<para>
For at installere et program via WINE er der ikke mange ting der skal
gøres (hvis det virker). Egentlig bør du bare kunne skrive <command>wine
et-eller-andet-program</command> for at installere og køre det, men der er dog
alligvel nogle små ting der skal/kan gøres ud over det.
</para>

<para> 
Her vil jeg vise hvordan man installerer spillet Caesar III via
WINE. Det sker gennem en 13-skridts installationsprocedure som
egentlig kun har betydning hvis du ejer spillet Caesar III. Jeg har dog
taget det med alligvel, så du kan se hvor meget WINE faktisk ligner det
rigtige Windows.
</para>

<orderedlist>
<listitem>
 <para>
Det første du skal gøre er at lægge din Caesar III-cd-rom i cd-rom-drevet.
 </para>
</listitem>

<listitem>
 <para>
 Så skal du åbne en xterm.
 </para>
</listitem>

<listitem>
 <para>
 Montér dit cd-rom-drev ved at skrive <command>mount
 /mnt/cdrom</command> (dette er lavet på en Linux Mandrake-maskine så
 hvis du bruger en anden distribution skal du lige tage højde for at
 dit cd-rom-drev måske ligger i en anden mappe, f.eks. på SuSE).
 </para>
</listitem>

<listitem>
 <para>
 Gå ind i cd-rom'en ved at skrive <command>cd /mnt/cdrom</command> og
 skriv så <command>wine SETUP.EXE</command>
 </para>
</listitem>

<listitem>
 <para>
 Nu starter programmet med at vise et stort Sierra-logo og et lille
vindue der indikerer hvor langt programmet er nået med at indlæse
installations-proceduren.
 </para>
</listitem>

<listitem>
 <para>
 Herefter bliver hele skærmen sort, pånær en tekst i det øvre venstre
 hjørne, hvor der med hvide bogstaver står Caesar III. Så kommer der et
 nyt vindue frem. Det hedder "Welcome" og der står bare lidt
 tekst. Tryk på knappen "Next>".
 </para>
</listitem>

<listitem>
 <para>
 Nu kommer der et vindue frem som hedder "Setup Type". Her kan du
vælge hvor mange af filerne, som skal ligge på computeren og hvor mange
den skal hente fra cd-rom'en. Du kan vælge mellem tre forskellige
muligheder:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
Full Install - Dette kræver 542 Mb fri diskplads.
 </para>
</listitem>
<listitem>
 <para>
Minimum Install - Dette kræver 150 Mb fri diskplads.
 </para>
</listitem>
<listitem> 
 <para>
Standard Install - Dette kræver 330 Mb fri diskplads.
 </para>
</listitem>
</itemizedlist>

<para>
Jeg synes at det er rarest med "Full Install", men det er jo lidt en
smagssag. Vælg den type du gerne vil have og tryk så på knappen
"Next>".
</para>
</listitem>

<listitem>
 <para>
 Så kommer der et vindue der hedder "Choose Destination". Der er
lidt tekst og nedenunder er der en "kasse" hvori der står hvor
Caesar III vil blive installeret. Her plejer der at stå
<filename>C:\SIERRA\Caesar3</filename>.
</para>

<para>
Hvis du hellere vil installere det i en anden folder så tryk på
knappen "Browse..." og vælg der hvor du gerne vil have det placeret
istedet. Til sidst trykker du bare på knappen "Next >".
 </para>
</listitem>

<listitem>
 <para>
Så går installationen i gang og du kan se nogle vinduer som viser
hvor langt installationen er nået. Bagved dem er der flotte
3D-billeder fra det gamle Rom og hvis du tænder for din højttalere kan
du høre noget romer-musik.
 </para>
</listitem>

<listitem>
 <para>
Når filerne er installerede bliver skærmen igen sort med Caesar
III-teksten i venstre hjørne. Så kommer der et vindue der hedder
"Install". Her står lidt tekst og du skal bare trykke på knappen "Ok".
 </para>
</listitem>

<listitem>
 <para>
Der kommer så højst sandsynligt et vindue som også hedder
"Install". Har står der at du ikke har DirectX installeret og der
bliver spurgt om du vil installere det. Her skal du bare trykke på
knappen "Nej".
 </para>
</listitem>

<listitem>
 <para>
Det næste vindue hedder "Display Read Me". Her kan du vælge at
læse readme-filen for Caesar III. Jeg plejer dog bare at trykke på
knappen "Nej".
 </para>
</listitem>

<listitem>
 <para>
 Det sidste vindue hedder "Setup Complete". Der står nogle få
 linjer tekst og du skal bare trykke på knappen "Finish".
 </para>
</listitem>
</orderedlist>


<para>
Så er programmet installeret og nu skal vi se om det virker. Åbn en
xterm og skriv mount /mnt/cdrom (hvis du nu har haft din computer
slukket eller brugt andre cd-rom'er i mellemtiden (dette er lavet på
en Linux Mandrake-maskine så hvis du bruger en anden distribution skal
du lige tage højde for at dit cd-rom-drev måske ligger i en anden
mappe, f.eks. som på SuSE)). Derefter cd
/home/tyge/.wine/fake_windows/SIERRA/Caesar3. Så langt, så godt. Nu
er det lidt forskelligt hvordan du kan starte programmet alt efter
hvilken skærmstørrelse du har. Som du læste tidligere kan du gøre
forskellige ting. Hvis du har en skærmopløsning på 640x480 eller
800x600 pixels, så skal du bare starte programmet ved at skrive wine
c3.exe. Nu burde Caesar III starte i full screen. Hvis du til gengæld har
en skærmopløsning større end det, skal du skrive enten wine --desktop
640x480 c3.exe eller wine --desktop 800x600 c3.exe alt efter hvor stor
en skærmstørrelse du gerne vil have det i. Så starter Caesar III i et
WINE-skrivebord som har størrelse efter de to tal du skrev før
(f.eks. 640x480). Hvis du er i tvivl om, hvad du skal vælge, så kan du
jo bare prøve begge to (dog ikke på samme tid :-).
</para>

<para>
Her kunne denne vejledning vel godt ende, men det gør den ikke. For
hvem gider egentlig skrive
</para>

<programlisting>
 mount /mnt/cdrom
 cd /home/tyge/.wine/fake_windows/SIERRA/Caesar3
 wine --desktop 800x600 c3.exe
</programlisting>

<para>
hver gang hvis der er en nemmere metode? Faktisk kan du gøre sådan at
Caesar III starter præcis som du vil have det, bare ved at skrive
<command>caesar3</command> i en xterm. Det er dog ikke noget som WINE
på forhånd har gjort, næh, det er noget vi selv skal til. Det vi skal
lave hedder et shell-script.
</para>

<para>
Lad os sige, at vi står i vores hjemmekatalog
<filename>/home/tyge</filename>. Det første du skal gøre er at åbne
din foretrukne editor og lave en fil, som hedder
<filename>caesar3</filename>. Hvis du er i tvivl, så åbn en xterm (og
så sørg for at du står i din hjemmekatalog) og skriv så <command>emacs
caesar3</command>. Så kommer editoren Emacs frem og har både lavet og
åbnet filen caesar3. Nu skal du så indtaste følgende i filen:
</para>

<programlisting>
#!/bin/sh
echo "Starter Caesar III"
mount /mnt/cdrom
cd /home/tyge/.wine/fake_windows/SIERRA/Caesar3
wine --desktop 800x600 c3.exe
</programlisting>

<para>
Forklaringen på hvad filen gør kommer her:
</para>

<para>
<command>#!/bin/sh</command> - Her starter dit shell-script
</para>

<para>
<command>echo "Starter Caesar III"</command> - Denne linje skriver
"Starter Caesar III" i xterm'en når den starter. Den er egentlig
ligegyldig men det giver en flot "effekt" og så ved du også at
shell-scriptet faktisk er i gang.
</para>

<para>
<command>mount /mnt/cdrom</command> - Her fortæller du dit cd-rom-drev
at Caesar III-cd'en er i dit cd-rom-drev (dette er lavet på en Linux
Mandrake-maskine så hvis du bruger en anden distribution skal du lige
tage højde for at dit cd-rom-drev måske ligger i en anden mappe,
f.eks. som på SuSE).
</para>

<para>
<command>cd /home/tyge/.wine/fake_windows/SIERRA/Caesar3</command>
- Dette fortæller Linux at den skal gå ind i mappen
<filename>/home/tyge/.wine/fake_windows/SIERRA/Caesar3</filename>.
</para>

<para>
Til sidst skal du indsætte den kode du bruger til at starte Caesar
III. Hvis du bare plejer at skrive wine c3.exe, så skriv det. Jeg bruger
linjen <command>wine --desktop 800x600 c3.exe</command>
</para>

<para>
Nu skal du bare gemme filen og lukke editoren. Hvis du bruger Emacs
kan du gøre det hele via tastaturet. Du trykker
først på "Ctrl"-tasten (og holder den nede) og derefter en gang på x (eller
skrevet kort: Ctrl-x). Tryk så Ctrl-s. Giv så slip fra "Ctrl"-tasten. Nu er
dokumentet gemt. Tryk så først Ctrl-x og derefter Ctrl-c Så har du
lukket det.
</para>

<para>
Nu skal du have aktiveret dit shell-script, for Linux kan ikke bare
starte en tekstfil. Det gør du ved at åbne en xterm og gå ind i
samme mappe, som du har lavet caesar3-filen i (formodentlig i dit
hjemmekatalog). Her skriver du så <command>chmod +x caesar3</command>
Så er den gjort klar. Prøv nu at skrive <command>./caesar3</command> i
en xterm og se om Caesar III starter (og om det står på skærmen). Hvis
det gør det, så virker scriptet. Hvis det ikke virker (og det virkede
da du startede Caesar III "manuelt"), så bør du lige kigge din kode og
instruktionerne her igennem igen og lige tjekke at alt er stavet
rigtigt. Husk at forskellen på store og små bogstaver har en
betydning!
</para>

<para>
Nu skal det så gøres endnu nemmere. I en xterm skriver du følgende
kommandoer:
</para>

<para>
<command>cd /home/tyge</command> - Dette sætter dig ind i Tyges
hjemmekatalog
</para>

<para>
<command>su</command> (skriv derefter dit root-kodeord) - Dette giver
dig root-rettigheder.
</para>

<para>
<command>cp caesar3 /bin</command> - Dette kopierer filen
<filename>caesar3</filename> til mappen <filename>bin</filename>
</para>

<para> 
<command>cd /bin</command> - Dette sætter dig ind i mappen
<filename>/bin</filename>.  Det er her mange af Linux' kommandoer
ligger. Når filen bliver placeret her kan den køres uden at
fortælle filens sti. Altså kan man skrive <command>caesar3</command> 
i stedet for at
skulle skrive <command>/home/tyge/caesar3</command>
</para>

<para>
<command>chmod -R 777 caesar3</command> - Dette
giver alle brugere fuld adgang til filen. Skriv nu <command>exit</command> - Så
vender du tilbage til din normale bruger.
</para>

<para>
Nu kan du så prøve at gå ind i en vilkårlig mappe og skrive
<command>caesar3</command>. Så bør Caesar III starte, helt automatisk.
</para>
</sect2>
</sect1>

<sect1 id="VICE">
 <title>Commodore-emulering</title>

 <indexterm><primary>C64</primary></indexterm>
 <indexterm><primary>emulator</primary>
            <secondary>Commodore 64</secondary></indexterm>

 <para>
  Hvis du som denne bogs forfattere er vild med din gamle Commodore 64, er
  VICE noget for dig. VICE er en forkortelse for "Versatile Commodore 8-bit
  Emulator" (eller måske VIC Emulator). VICE kan emulere Commodore 64,
  Commodore 128, VIC 20 og Commodore PET. Ud over udgaver til Linux (Unix)
  findes VICE til MS-DOS og Windows. VICE er i sandhed en alsidig emulator.
 </para>

<para>
VICE følger ikke med en standard Red Hat-distribution, men du finder
den let på et ftp-site, f.eks. <ulink url="ftp://sunsite.auc.dk">ftp://sunsite.auc.dk</ulink> under Red
Hat-contrib. Installationen kan drille lidt, idet VICE kræver
<filename>libstdc++</filename> version 2.9. Dette bibliotek er
installeret ved en standard-installation, men navnet kan være
forkert. Nedenfor ser du, hvordan du kan installere VICE - du bør
tjekke, hvilket navn <filename>libstdc++</filename> har i
<filename>/usr/lib</filename>.
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>su -</userinput>
Password: 
<prompt>[root@linus root]#</prompt> <userinput>cd /usr/lib</userinput>
<prompt>[root@linus root]#</prompt> <userinput>ln -s libstdc++-2-libc6.1-1-2.9.0.so libstdc++.so.2.9</userinput>
<prompt>[root@linus root]#</prompt> <userinput>rpm -ivh --nodeps vice-1.0-1.i386.rpm</userinput>
</screen>

<para>
Efter installationen er du klar til at bruge VICE. Afhængigt af, hvilken
Commodore-computer, du ønsker at emulere, skal du benytte et af
følgende programmer: <command>x64</command> (Commodore 64),
<command>x128</command> (Commodore 128), <command>xvic</command> (VIC
20) eller <command>xpet</command> (PET).
</para>

<para>
VICE kan emulere lyd og grafik samt ydre enheder, dvs. båndstationer,
diskettestationer (Commodore 1571) og joystick. Din emulator kører i
et selvstændigt vindue under X. Højre og venstre museknap giver dig
menuer til at styre VICE. Bånd og disketter emuleres ved, at du har
indholdet liggende i en fil på din harddisk. Trykker du på venstre
museknap, kan du "attach a disk image" og "attach a tape image",
dvs. du kan vælge, hvilken fil der er dit bånd eller din
diskette. Bånd og disketter gemmes i særlige formater.
</para>

<para>
Det er let at finde gamle spil til f.eks. Commodore 64 rundt om på
internettet. Tjek f.eks. <ulink
url="http://www.c64.com">http://www.c64.com</ulink> som har ca. 2500
liggende.
</para>

<figure id="vice-fig" float="1">
<title>Spillet Soccer</title>
<graphic fileref="vice.&magic;"  scale="40"></graphic>
</figure>
</sect1>

<sect1 id="vnc">
<title>VNC til fjernstyring af dine maskiner</title>

<!-- Dette afsnit er skrevet af Bent Pedersen bentriloquist@my-deja.com -->
<para>
VNC står for Virtual Network Computing. Kender du
programmer som PC Anywhere eller NetOp, som begge kører på
Windows-platformen, så har du en god idé om hvad VNC er: Et program
til fjernstyring af en anden PC med grafisk brugerflade.
Dog kører VNC over TCP/IP, og ikke
andet. VNC består af en server-del, som kører på den maskine du ønsker
at fjernstyre, samt en klient-del, som kører på den maskine du sidder
foran.
</para>

<sect2 id="vnc-ide"> <!-- Af Erling Sjørlund -->
<title>Integration af serveren på arbejdspladsen med VNC</title>
<para>
Hvis du har et lille system med en Linux-server og en eller flere
arbejdspladser med Windows, kan du med VNC få en let og effektiv adgang til
at arbejde med serveren direkte på din arbejdsplads.
Installér først vncserver på din Linux-server. Log ind på serveren med dit
almindelige brugernavn (ikke root), og start vnc-serveren, f.eks. med :1 som
nummer. Log ind under et andet brugernavn og start vncserver igen, her med
:2 som nummer.
</para>

<para>
Hvert nummer har sin egen opsætning, så du kan evt. starte en vncserver til
hvert familiemedlem, efter at du har logget ind på serveren som vedkommende.
Start derefter vncviewer på din arbejdsplads i et vindue, og log ind med det
password du oplyste første gang vncserver blev startet (på Linux-serveren
under det :nummer du bruger). Det letteste er nok at bruge dens IP-nummer,
altså f.eks. 192.168.1.1:1, hvor det sidste :1 skal svare til det nummer du gav
på serveren.
</para>

<para>
Nu har du et miljø, hvor du uden videre kan veksle mellem vinduet med
serverens X-variant og Windows-brugerfladen. Du kan direkte klippe-klistre
tekst mellem Linux- og Windows-programmer, og i det hele taget gøre på
serveren hvad din adgang tillader dig.
Hvis du ikke har behov for at skifte bånd, cd'er, disketter eller lignende
på din server, kan du nu parkere din server så langt væk som muligt, (f.eks. i
kælderen, så den kan bidrage til opvarmningen af huset).
</para>

<para>
Du får nu disse fordele:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
Serveren skal hverken have skærm, mus eller tastatur for at kunne anvendes
fuldt ud.
 </para>
</listitem>
<listitem> 
 <para>
Du kan (mere eller mindre frivilligt) lukke Windows ned på din
arbejdsplads. Næste gang du åbner Windows+vncviewer, vil den kun vise en blå
skærm, hvis det er den farve, du har valgt frivilligt. (Det forudsættes her,
at du ikke sådan går rundt og lukker din server i tide og utide).
 </para>
</listitem>
<listitem> 
 <para>
Du kan arbejde sammen med din mand/kone i den samme skærm uden at skulle
slås om tastatur, mus og overblik. I login-dialogen <!-- (Billede ind
heromkring?) --> klikker du blot på knappen [Options], og afkrydser "Request
shared session" nederst i venstre hjørne. Det, den ene skriver, bliver blandet
ind i det, den anden er i gang med. Skulle I blive trætte af det, (og det kan
ske selv i de bedste forhold), kan man naturligvis også arbejde samtidigt på
hver sin maskine, uden at blande sig sammen. Det kræver blot, at du starter
vncserver flere gange på Linux-serveren med hvert sit :nummer, og logger ind fra
arbejdspladserne med forskellige numre.  </para> </listitem>
<listitem>
 <para>
Har du børn med egen maskine i familien (det har man hørt om), kan du
installere vncserver på deres maskiner, og kigge dem over skulderen, helt
uden at de behøver at opdage det.
På den måde slipper du for at komme alt for tæt på dem, og du ved alt hvad
de gør uden at tale med dem først. Det hele bliver som i de gode gamle dage,
hvor jeg er sikker på, at alle mødre havde et lignende system, der gjorde,
at de næsten altid vidste, hvad deres børn havde gang i.
 </para>
</listitem>
</itemizedlist>

</sect2>



<sect2 id="vnc-installation">
<title>Installation af VNC</title>

<para>
For eksemplets skyld antages, at du ønsker at fjernstyre din
Linux-maskine fra en Windows-maskine. Du skal altså hente en
Linux-server og en Windows-klient.  Man kan også fjernbetjene en
Windows-maskine - selv mens andre sidder ved maskinen. Yderst smart
til support.
</para>

<para>
Først skal VNC-serveren hentes. Det kan gøres fra
<!-- old:
<ulink url="http://www.uk.research.att.com/vnc">http://www.uk.research.att.com/vnc</ulink>, 
/-->
<ulink
url="http://www.realvnc.com/">http://www.realvnc.com/</ulink>
(Version VNC 3.3.7 eller 4.0beta)
som er det sted hvor udviklerne
lægger kildeteksten. Desværre kan man derfra ikke hente RPM-pakker,
men gå til 
<ulink url="http://www.rpmfind.net">http://www.rpmfind.net</ulink>
og søg efter <emphasis>vnc-server</emphasis>.
Version 3.3.3r2 eller nyere kan findes der.
</para>

<para>
VNC-serveren skal installeres som root:
</para>

<screen>
<prompt>[root@linus root]# </prompt><userinput>rpm -Uvh vnc-server-3.3.3r2-4.i386.rpm</userinput>
</screen>
</sect2>

<sect2 id="vnc-server-start">
<title>Start en server</title>
<para>
vncservers man-side oplyser følgende:
</para>

<programlisting>
vncserver [:number] [-geometry widthxheight] [-depth depth] 
 [-pixelformat rgbNNNbgrNNN] [-name desktop-name] [Xvnc-options]
</programlisting>

<para>
Der er altså mange options, men du behøver kun ganske få for at komme i gang.
</para>

<para>
Et eksempel på start af VNC-server:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>vncserver :1 -geometry 800x600 -depth 8</userinput>
</screen>

<para>
hvilket betyder: Lav en ny X-desktop med størrelsen 800x600 pixels og
8 bits pr. pixel (=256 farver) og lyt på TCP/IP 5801. 5801? Ja, for
VNC lægger automatisk 5800 til det nummer man angiver, og bruger det
som port-nummer. 
</para>

<para>
Du kan bruge en hvilket som helst størrelse du ønsker, også skæve
størrelser som f.eks. 200x500, hvis du ønsker det. Vær opmærksom på,
at jo større desktop du bruger, desto mere skal der sendes på nettet,
og det giver reduceret hastighed. 
En mulig opløsning kunne være 800x600x8bpp til VNC-serveren, selv om
den fysiske desktop kører 1024x800x16bpp. Ved at vælge denne mindre
opløsning giver det 3,5 gange mindre trafik.
</para>

<para>
Desuden er et baggrundsbillede også vejen til langsom hastighed, så
brug en ensfarvet baggrund i stedet for dine feriebilleder.
</para>

<para>
Første gang du starter vncserver, skal du angive et password. Dette
password skal du opgive, når du senere forsøger at forbinde dig til
maskinen. Hvis du ønsker at ændre passwordet kan du blot køre
programmet vncpasswd.
</para>

<para>
Når du vil lukke din VNC-server igen foregår det sådan:

</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>vncserver -kill :1</userinput>
</screen>

</sect2>

<sect2 id="vnc-opsaetning">
<title>Opsætning</title>

<para>
Bruger du f.eks. Gnome som dekstop,
er det en fordel at bruge en anden Window Manager når kobler op til VNC.
Et valg kunne være IceWM der føles en lille smule hurtigere,
og hver lille smule hastighed tæller.
</para>

<para>
Af dokumentationen fremgår det at <command>vncserver</command> bruger
<filename>$HOME/.vnc/xstartup</filename> som startfil. Det er altså
stedet, hvor sådanne ændringer skal laves.
Et eksempel på en ændret xstartup kan se således ud:
</para>

<programlisting>
#!/bin/sh
xrdb $HOME/.Xdefaults &
exec icewm
</programlisting>

<para>
Hvis du i stedet ønskede at bruge Gnome, så skulle linjen med exec
icewm ændres til <command>exec gnome-session</command> og tilsvarende
anvender KDE <command>exec startkde</command>. Dette kræver
selvfølgelig, at IceWM, Gnome og/eller KDE er installeret i forvejen.
Det kan også være at du bliver nødt til at angive hele stien til
de kommandoer der startes.
</para>

<para>
Bemærk i øvrigt at standard window manager for VNC er
<command>twm</command>, som vel kun de færreste ønsker at bruge.
</para>
</sect2>

<sect2 id="vnc-klienten">
<title>Klienten</title>
<para>
  Der findes klienter til både Windows og Linux. Da disse er oversat specifikt
  til det relevante system er de mindre processorkrævende. Men den smarteste
  klient er dog den til Java.
</para>

<para> 
  Har du en browser, der kan snakke Java, så gå ind
  på: <filename>http://x.x.x.x:5801</filename>. 
  Her angiver du brugernavn og adgangskode
  hvorefter du i din browser kan fjernstyre maskinen.       
</para>

<figure id="vnc1-fig" float="1">
<title>VNC - hvor en Linux-maskine styres fra en Internet Explorer fra Windows</title>
<graphic fileref="vnc1.&magic;"  scale="40"></graphic>
</figure>

<figure id="vnc2-fig" float="1">
<title>VNC - hvor en Windows-maskine styres fra en Linux-maskine via Netscape</title>
<graphic fileref="vnc2.&magic;"  scale="40"></graphic>
</figure>

</sect2>

<sect2 id="vnc-pas-paa">
<title>Pas på din sikkerhed</title>

<para>
Bemærk at <command>vncserver</command> giver brugeren af klienten de
samme rettigheder, som den konto der startede den.  Er du logget ind
som "guest" når du starter <command>vncserver</command>, får alle der
logger på via en vnc-klient "guest"-rettigheder.  Af hensyn til
sikkerheden bør du derfor ikke starte den som root, og det er også
klogt at huske nedlukning af vncserver, når den ikke skal bruges.
 </para>

<para>
Bemærk også, at hvis du har startet vncserver direkte i en konsol på
serveren, så bliver den ved at køre, også selv om du har forsøgt logout.
</para>

<para>
VNC er en åbning af et potentielt sikkerhedshul - i hvertfald er
versioner op til og med 3.3.3 slet ikke sikre, jfr. Weekly Linux
Security Digest 2001/01/22-2001/01/28. I de ældre versioner kan man
bryde ind i trafikken mellem server og klient. Generelt skal man ikke
lukke op for services man ikke selv kan overskue konsekvenserne af, hvis man
er koblet til et usikkert netværk.
</para>
</sect2>
</sect1>

<!--  skrevet af Mads Sabroe Jensen (sorteslyngel/på/get2net.dk) -->
<sect1 id="psx">
<title>Playstation emulering</title>
<indexterm><primary>Playstation emulering</primary></indexterm>
<indexterm><primary>Sony Playstation emulering</primary></indexterm>
<indexterm><primary>PCSX</primary></indexterm>
<indexterm><primary>FPSe</primary></indexterm>
<indexterm><primary>ePSXe</primary></indexterm>

<para>
Hvis du gerne vil spille dine yndlings playstation spil i Linux, kan
det sagtens lade sig gøre. Der findes tre gode Playstation emulatorer:
PCSX, FPSe og ePSXe. Da Playstation emulering er lidt tungt at køre
bør man have minimum en Pentium 2 maskine med et hardware acceleret
grafikkort som for eksempel TNT 2 eller lignende. Fælles for de tre emulatorer er
at de benytter sig af et såkaldt "plugin system". ePSXe og PCSX bruger
det samme system og FPSe benytter sig af sit eget. Med disse plugins
kan man for eksempel vælge at bruge en software renderer eller bruge sit nye
grafikkort ved hjælp af en MesaGL plugin.</para>

<figure id="wipeout-fig" float="1">
<title>Wipeout spillet under Playstation emulator på Linux</title>
<graphic fileref="wipeout.&magic;" scale="60"></graphic>
</figure>

<para> 
Der findes en guide til ePSXe på
<ulink url="http://hjem.get2net.dk/familien_sabroe/linux.html">http://hjem.get2net.dk/familien_sabroe/linux.html</ulink>. Emulatorerne kan hentes fra
<ulink url="http://www.ngemu.com">http://www.ngemu.com</ulink>, hvor man har lavet pakker med selve emulatoren
og de bedste plugins. BIOS'en er dog ikke inkluderet da SONY har
copyrighten på den.
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
<emphasis>ePSXe</emphasis> :
Er den mest kompatible emulator af disse tre. Den behøver dog en
playstation BIOS for at kunne fungere. Der findes en masse plugins til
den, blandt andet en MesaGL plugin hvis dit grafikkort understøtter
MesaGL.
 </para>
</listitem>
<listitem> 
 <para>
<emphasis>FPSe</emphasis> :
Var indtil version 0.08 open source. Den nuværende 0.09 version er
ikke open source men er ellers en udmærket emulator - der mangler dog
nogle ordentlige plugins til den da den understøtter et andet plugin
system end ePSXe og PCSX. Der findes for eksempel ikke nogle plugins der
udnytter hardware acceleret grafikkort. Den behøver desuden en
playstation BIOS for at kunne fungere.
 </para>
</listitem>
<listitem> 
 <para>
<emphasis>PCSX</emphasis> :
Er en ganske god emulator. Den er open source og er rimlig kompatibel
med de fleste playstation spil. Man behøver ikke en Playstation BIOS -
dog er PCSX mest kompatibel hvis man har en. Da PCSX benytter sig af
samme plugin system som ePSXe, findes der ligeledes en masse nyttige
plugins til PCSX.
 </para>
</listitem>
</itemizedlist>
</sect1>

<sect1 id="gameboy">
<title>Gameboy &amp; Gameboy Advanced</title>
<para>
Med Visualboy Advanced er det muligt at køre Gameboy og Gameboy
Advanced spil i Linux. 
</para>

<para>
Emulatoren kan hentes fra
<ulink url="http://vba.ngemu.com/">http://vba.ngemu.com/</ulink>. Visualboy
Advanced kræver minimum en Pentium 3 500 mhz maskine for at køre
Gameboy advanced spil og for de ældre Gameboy spil er hardware kravene
mindre.
</para>

<figure id="gameboy-fig" float="1">
<title>Visualboy Advanced kører Mario Cart Super Circuit</title>
<graphic fileref="Gameboy.&magic;" scale="60"></graphic>
</figure>
</sect1>

<sect1 id="nintendo-emulator">
<title>Mupen64: Nintendo 64 emulator</title>
<para>

Mupen64 er en emulator der muliggør, at man kan spille Nintendo64
spil under Linux. Den kan hentes fra <ulink url="http://mupen64.emulation64.com">http://mupen64.emulation64.com</ulink>,
hvor der findes oversatte versioner.
</para>

<para>
Kildekoden findes der også, hvis
man selv har mod på at oversætte den. Emulatoren benytter sig af et
plugin system, hvor man fra Mupen64's hjemmeside kan downloade
forskellige plugins til grafik, lyd, controller, etc.
</para>

<figure id="Mupen64-fig" float="1">
<title>Mupen64</title>
<graphic fileref="mupen64.&magic;" scale="60"></graphic>
</figure>

</sect1>
</chapter>
