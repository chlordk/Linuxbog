<?xml version='1.0' encoding='ISO-8859-1' ?>
<!-- $Id$ -->
<!-- Jacob mener at en shell skal hedde kommandofortolker -->
<!-- Peter mener at en shell bør være kendt af læseren -->
<!-- Peter og Jacob er ikke altid enige om sprog-brug :-) -->

<chapter id="kommandofortolkere-linux">
 <title>Linux i tekst-modus</title>

 <indexterm><primary>kommandofortolker</primary></indexterm>
 <indexterm><primary>shell</primary></indexterm>

 <indexterm><primary>Unix</primary></indexterm>
 <indexterm><primary>kommandolinie</primary></indexterm>

 <para>
  Linux er et unix-lignende styresystem med alle dets fordele og
  ulemper. Unix' historie går tilbage til slutningen af 1960'erne,
  hvor en gruppe forskere ved AT&amp;T's forskningslaboratorium
  eksperimenterede med computerens uanede muligheder.
 </para>

 <para>
  Dengang Unix var ungt var der ikke noget, der hed grafiske
  brugergrænseflader og mus. Næh, brugeren sad foran en tekstterminal
  og tastede alle kommandoer ind. Denne noget primitive måde at
  arbejde med en computer på, genfinder vi i moderne Unix, og eftersom
  Linux er et unix-lignende styresystem, har du naturligvis også i
  Linux mulighed for at indtaste kommandoerne på dit tastatur.
  Begynder du at bruge Linux seriøst, vil du dog nok finde ud af, at
  tekst-kommandoerne ikke er en primitiv arbejdsform - men på en lang
  række områder langt mere effektivt og hurtigere end at klikke sig
  frem.  I dette kapitel vil vi gennemgå en del af grundlaget for at
  bruge Linux i tekst-modus.
 </para>

 <para>
  Nu må du ikke tro, at det kun er af gammel vane, at unix-brugere
  taster deres kommandoer ind på en kommandolinie; faktisk er det
  muligt at udføre endda meget komplekse opgaver med meget lidt
  tastearbejde. Det skyldes, at der med Unix altid følger et hav af
  hjælpeprogrammer. Lad os give dig et eksempel - bare rolig, vi
  forventer ikke, at du allerede nu kan gennemskue, hvordan det
  fungerer, men vi vil bare vise dig, hvor lidt tastearbejde der skal
  til for at udføre store opgaver. Lad os antage, at du har en
  hjemmeside liggende på maskinen
  <filename>www.andeby.dk</filename>. Du er en produktiv person med
  mange interesser, så din hjemmeside består af mange HTML-filer. En
  dag flytter du, og din hjemmeside skal skifte maskine - din nye
  maskine hedder <filename>www.kongeh.org</filename>. Dit problem er,
  at du skal rette alle henvisninger på dine sider. I Unix (og dermed
  også Linux) kan det gøres ganske let ved at udføre kommandoen (du
  skal ikke gøre det):

  <indexterm>
   <primary>find</primary>
  </indexterm>
  <indexterm>
   <primary>kommandooversigt</primary>
   <secondary>find</secondary>
  </indexterm>

  <indexterm>
   <primary>xargs</primary>
  </indexterm>
  <indexterm>
   <primary>kommandooversigt</primary>
   <secondary>xargs</secondary>
  </indexterm>

  <indexterm>
   <primary>perl</primary>
  </indexterm>
  <indexterm>
   <primary>kommandooversigt</primary>
   <secondary>perl</secondary>
  </indexterm>

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>find -iregex '.*html?' |\
xargs perl -i -pe 's/www\.andeby\.dk/www.kongeh.org/gi'</userinput>
</screen>
 </para>

 <para>
  Når du udfører kommandoen, bliver alle filer, som ender på "html"
  (bl.a. også "HTML" og "htm"), fundet (<command>find</command>). Du
  benytter et program ved navn <command>perl</command> til at foretage
  selve søg-og-erstat-proceduren. Dette eksempel er nok lidt for
  avanceret til vores bog her, men vi håber, at du nu kan se, hvor
  kraftfuld en enkel kommandolinie kan være i Unix.
 </para>

 <sect1 id="virtuel-konsol">
  <title>Virtuelle konsoller</title>

  <indexterm>
   <primary>virtuelle konsoller</primary>
  </indexterm>

  <indexterm>
   <primary>konsol</primary>
   <secondary>virtuel</secondary>
  </indexterm>

  <indexterm>
   <primary>tekst-modus</primary>
  </indexterm>

  <para>
   Når du vil styre Linux ved at skrive kommandoer i stedet for at
   være afhængig af en grafisk brugergrænseflade er det en mulighed at
   logge direkte ind med skærmen i ren tekst-modus.  Hvis du sidder
   ved en linux-maskine der er i grafik-modus, kan du typisk gå over
   til ren tekst-modus ved at taste Ctrl-Alt-F1.  Det tastetryk
   bringer dig over til et helt andet skærmbillede, der er uafhængigt
   af det du så før (et tryk på Ctrl-Alt-F7 eller Ctrl-Alt-F8 burde
   bringe dig tilbage igen).  Over på ren-tekst-skærmbilledet burde
   der stå noget i stil med "login:" efterfulgt af en blinkende cursor
   (prøv ellers at taste Return eller Enter en enkelt gang for at få
   det frem).  Her kan du ganske som ovre på det grafikbaserede
   skærmbillede logge ind på maskinen ved at indtaste dit brugernavn
   og din adgangskode, men når du logger ind på det tekstbaserede
   skærmbillede er det eneste du får en såkaldt "prompt" eller
   "kommandolinie".  Afhængig af opsætningen af din konto vil den
   kunne se lidt forskellig ud, men dette er en mulighed:

<screen>
<prompt>[anne@linus ~]$ </prompt>
</screen>

   Her kan du skrive kommandoer til systemet.  I første omgang er den
   vigtigste kommando nok <command>logout</command>, som du bruger til
   at logge ud igen, så skærmbilledet er klart til en anden bruger
   (eller bare til en anden gang).
  </para>

  <para>
   På et typisk linux-system vil Ctrl-Alt-F1, Ctrl-Alt-F2, og så
   videre indtil til Ctrl-Alt-F6 bringe dig til seks forskellig
   tekstbaserede skærmbilleder, mens Ctrl-Alt-F7 og nogle gange også
   Ctrl-Alt-F8 vil bringe dig til grafikbaserede skærmbilleder.  Disse
   syv eller otte forskellige skærmbilleder kaldes systemets virtuelle
   konsoller.  En fordel ved at have flere virtuelle konsoller er at
   forskellige brugere kan bruge den samme skærm uden at de behøver at
   lukke de programmer de har i gang når de bytter.
  </para>
 </sect1>

 <sect1 id="terminalen">
  <title>Terminalvinduer</title>

  <para>
   Hvis du ikke er meget for kun at arbejde med tekstbaserede
   programmer (de er for eksempel ikke praktiske til at vise billeder)
   har du brug for at kunne få en kommandolinie frem inde i det
   grafikbaserede system (der hedder "X" eller "X Window System" på et
   almindeligt linux-system).  Når du er logget ind gør du det ved at
   starte et terminalemuleringsprogram.  Det mest udbredte er
   <command>xterm</command> men hvis du bruger KDE eller Gnome kan du
   med fordel benytte henholdsvis <command>konsole</command> eller
   <command>gnome-terminal</command> i stedet for, da de er lidt bedre
   integrerede i de to skrivebordssystemer.
  </para>

  <para>
   Man får typisk startet et terminalemuleringsprogram ved at klikke
   på en ikon med en muslingeskal eller en sort skærm, eller ved at
   vælge et menupunkt der hedder noget i stil med "Konsole",
   "Terminal" eller "xterm".
  </para>

  <para>
   <indexterm>
    <primary>xterm</primary>
   </indexterm>
   <indexterm>
    <primary>kommandooversigt</primary>
    <secondary>xterm</secondary>
   </indexterm>

   Med Linux skal du hyppigt køre programmer med en stribe parametre,
   som skal indtastes. Derfor er <command>xterm</command> vigtig at
   kende.  Programmet <command>xterm</command> er et simpelt grafisk
   program, hvor du kan skrive kommandoer til den valgte
   kommandofortolker.  Typisk vil <command>bash</command> være sat til
   at være din standard-kommandofortolker.  Senere i dette kapitel ser
   vi nærmere på alternativerne.
  </para>

  <para>
   Der er et par funktioner i <command>xterm</command>, som er uhyre
   nyttige at kende. Tryk Ctrl og venstre/midterste museknap over en
   <command>xterm</command> for at sætte en række indstillinger,
   f.eks. om der skal være rullebjælke på vinduets kant og
   lignende. Ctrl og højre musetast anvendes til at ændre
   skriftstørrelsen efter behov.  Du skal også vide, at du kan
   afslutte din kommandofortolker (<command>bash</command>), dvs. den
   fortolker, som håndterer hvad du skriver af kommandoer, ved at
   trykke <command>Ctrl-D</command> eller skrive
   <command>exit</command>.
  </para>

  <figure id="xterm-fig" float="1">
   <title>Eksempel på <command>xterm</command></title>
   <graphic fileref="xterm.&magic;" scale="40"></graphic>
  </figure>

  <para>
   Både til Gnome og KDE findes der særlige programmer, som i
   funktionalitet minder om <command>xterm</command>. Til Gnome findes
   f.eks. <command>gnome-terminal</command>. Ved at benytte
   <command>gnome-terminal</command>, når du bruger Gnome, får du en
   mere ensartet brugergrænseflade. Du vil endvidere bemærke en række
   menupunkter øverst i vinduet. Her kan du indstille din
   <command>gnome-terminal</command> på mange forskellige måder.  Du
   kan for eksempel have et billede som baggrund i stedet for en
   ensfarvet baggrund.  Til KDE findes der tilsvarende
   <command>konsole</command>.
  </para>

  <para>
   Når du indtaster kommandoer på en kommandolinie, benytter du dig af
   et program, som i daglig tale omtales kommandofortolkeren, skallen
   eller (på danglish) shellen. Der findes mange forskellige
   kommandofortolkere, men BASH (Bourne Again SHell) er den mest
   udbredte under Linux. Kommandofortolkere fortolker hvad du skriver,
   og udfører de kommandoer, du ønsker.
  </para>

... terminalvinduer

, hvor du kan arbejde med forskellige ting i tekstmodus.
 i tekst på maskinens konsol.

   Nu skal du til at lære kommandoer til Linux. I starten af dette
   kapitel har du faktisk benyttet to kommandoer uden at vide det -
   nemlig <command>touch</command> og <command>rm</command> (mere om
   dem senere i kapitlet).  Det sted, hvor du i den simple tekstmode
   skrev disse kommandoer, kalder vi for konsollen. Linux-konsollen er
   i virkeligheden ikke så primitiv, som den umiddelbart ser ud til.
  </para>

  <para>
   <indexterm><primary>Alt-F1</primary></indexterm>
   <indexterm><primary>Ctrl-Alt-F1</primary></indexterm>

   Der er faktisk mere end én konsol. Konsolsystemet består af en
   række virtuelle konsoller. Du skifter mellem dem ved at trykke på
   Alt og en funktionstast mellem F1 og F7, hvor "Alt-F7" dog er
   tilbage til den grafiske X skærmflade, hvis den er startet op. Hvis
   du står i X og skal tilbage til de tekstbaserede konsoller, skal du
   bruge "Ctrl-Alt-F1" op til "Ctrl-Alt-F6". Linux er et ægte
   multitasking-system, så du kan bare logge ind på flere terminaler
   og arbejde. I hver konsol kører der en skal, som fortolker dine
   kommandoer. Linux er - som vi allerede har sagt mange gange - meget
   fleksibelt, så faktisk kan du have forskellige kommandofortolkere
   kørende i forskellige konsoller!
  </para>
 </sect1>



  <sect2 id="vigtigt-om-terminalen">
   <title>Vigtig viden om terminal-vinduet</title>

   <para>
    Vi kan også fra starten fortælle dig, at store og små bogstaver
    ikke er det samme for filnavne.  Du kan også godt bruge meget
    lange filnavne, og der er ikke den samme DOS-opbygning med
    fil-endelser på maksimalt tre bogstaver
    (<filename>CONFIG.SYS</filename> osv.). I modsætning til Microsoft
    Windows vises alle filer med <filename>*</filename> og ikke
    <filename>*.*</filename> - dertil kommer skjulte filer, som
    starter med et punktum <filename>.*</filename> - det er ret
    vigtigt.
   </para>

   <para>
    Du skal også lege lidt med tasterne pil-op og pil-ned, som løber
    igennem de gamle kommandoer igen. Ctrl-A og Ctrl-E bruges til at
    gå til starten og slutningen af en linie.
   </para>

   <para>
    <indexterm><primary>tabulator</primary></indexterm>

    Kommando- og filudvidelsesfunktionerne er utroligt rare, hvis man
    vil slippe for at skrive lange program- og filnavne igen og igen.
    Når man har skrevet starten på et program- eller filnavn kan man
    ved at trykke på tabulatortasten få kommandofortolkeren til at
    gætte hvad man mener.  Hvis der kun er én mulighed fylder
    kommandofortolkeren resten af navnet på. Er der flere muligheder,
    kan du trykke endnu en gang på tabulatortasten for at få vist alle
    mulighederne.
   </para>

   <para>
    Hvis du skriver

    <indexterm>
     <primary>touch</primary>
    </indexterm>
    <indexterm>
     <primary>kommandooversigt</primary>
     <secondary>touch</secondary>
    </indexterm>

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>tou&lt;TAB&gt; sikke_et_langt_filnavn</userinput>
</screen>

    skulle det gerne blive til

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>touch sikke_et_langt_filnavn</userinput>
</screen>

    <indexterm><primary>Kommando-udfyldning</primary></indexterm>

    idet der ikke er andre kommandoer, der begynder med 'tou'
   </para>

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>rm sik&lt;TAB&gt;</userinput>
</screen>

   <para>
    Det fungerer i øvrigt ved, at kommandofortolkeren i første "ord"
    leder efter en kommando eller et program den kender gennem
    systemvariablen <literal>PATH</literal> eller i den sti, som
    angives foran selve kommandoen.  Efter kommandoen ledes der efter
    filnavne i det angivne bibliotek.
   </para>
  </sect2>
 </sect1>

<sect1 id="shells-under-Linux">
<title>Kommandofortolkere under Linux</title>

<para>
Man kan se hvilke kommando-fortolkere som findes på systemet ved at se
i <filename>/etc/shells</filename>. Hvis man efterinstallerer en
ekstra kommando-fortolker på systemet, da er det vigtigt at man husker
at tilføje den fulde sti til den nye kommando-fortolker til 
<filename>/etc/shells</filename>, da der ellers vil være problemer med
hvis man kører en ftp-server (man får ikke lov til at logge ind).
</para>

<para>
På en SuSE-maskine kan <filename>/etc/shells</filename> se ud som
følger - om de alle rent faktisk er installerede er ikke garanteret.
Oftest følger alle med Linux-distributionerne.
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>cat /etc/shells</userinput>
/bin/ash
/bin/bash
/bin/bash1
/bin/csh
/bin/false
/bin/ksh
/bin/sh
/bin/tcsh
/bin/true
/usr/bin/csh
/usr/bin/ksh
/usr/bin/passwd
/usr/bin/bash
/usr/bin/rbash
/usr/bin/tcsh
/usr/bin/zsh
</screen>

<para>
I det følgende går vi nærmere ind i flere af de kommandofortolkere man
typisk anvender. For at afsløre en masse, så er der nogle som 
anvender <command>tcsh</command>, mens langt de fleste anvender
<command>bash</command>. Kun få anvender de ældre
<command>csh</command> og <command>ksh</command>, eller den
nye <command>zsh</command>.
</para>

<para>
Du kan altid vælge en ny kommando-fortolker ved at skrive navnet
i din nuværende kommando-fortolker.
</para>

<indexterm>
 <primary>bash</primary>
</indexterm>
<indexterm>
 <primary>kommandooversigt</primary>
 <secondary>bash</secondary>
</indexterm>

<indexterm>
 <primary>tcsh</primary>
</indexterm>
<indexterm>
 <primary>kommandooversigt</primary>
 <secondary>tcsh</secondary>
</indexterm>

<indexterm>
 <primary>zsh</primary>
</indexterm>
<indexterm>
 <primary>kommandooversigt</primary>
 <secondary>zsh</secondary>
</indexterm>


<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>zsh</userinput>
<prompt>anne@linus:~></prompt>
</screen>

<para>
Bemærk i anden linie er zsh-kommando-linien startes på en anden måde
end vist i den første linie (med <command>bash</command>). På den måde
ser man direkte den første forskel på kommando-fortolkerne. Man kan i
øvrigt sætte denne "prompt" op som man selv ønsker det. Er man blevet
glad for en ny kommando-fortolker, da kan man selv ændre det så denne
starter op som forvalgt. 
</para>

<indexterm>
 <primary>chsh</primary>
</indexterm>
<indexterm>
 <primary>kommandooversigt</primary>
 <secondary>chsh</secondary>
</indexterm>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>chsh -s /bin/tcsh</userinput>
Changing login shell for anne.
Password: <userinput>dit password skrives her</userinput>
Shell changed.
</screen>

<para>
Ændringen træder i kraft næste gang du logger ind på maskinen.
Du kan også se i <filename>/etc/passwd</filename> at der er 
indsat en ny kommando-fortolker yderst til højre i den linie, hvor
dit login-navn er vist (dette virker dog ikke med NIS).
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>grep anne /etc/passwd</userinput>
anne:x:500:100:Anne Linuxbruger:/home/anne:/bin/tcsh
</screen>

<sect2 id="unix-bash">
<title>GNU Bourne Again Shell (bash)</title>

<para>
Bash er den klart mest populære kommando-fortolker i Linux-verdenen.
Dette er heller ingen tilfældighed - dels er den forvalgt på så godt
som alle Linux-systemer, men bash fortjener også dette - den er rigtig
god.
</para>

<para>
 Ved login læses filen <filename>~/.bash_profile</filename> (eller
 <filename>~/bash_login</filename> eller
 <filename>~/.profile</filename>), og hver gang et terminal-vindue
 startes vil filen <filename>~/.bashrc</filename> blive læst og udført.
 Endelig er det muligt at få filen <filename>~/.bash_logout</filename> udført
 når man stopper en kommando-skal - her er det muligt at indlægge kommandoer som
 rydder op etc.
</para>

<para>
Bash udmærker sig dels ved at være kompatibel med den gamle
kommando-fortolker <command>sh</command>, men i høj grad på dens rigdom på 
både programmeringmuligheder (til scripts) og også på funktioner som interaktiv
kommadofortolker.
</para>

<para>
Med pil-op/ned kan med genfinde de forrige kommandoer og man kan endda søge sig tilbage til 
en kommando man engang har udført i Bash ved at trykke 
<command>Ctrl-r STARTEN-AF-DEN-GAMLE-KOMMANDO</command>. Med
yderligere tryk på <command>Ctrl-r</command> vil man gense andre ældre kommandoer der også 
passer med starten af den kommando man har skrevet. Det er bare smart!
</para>

<para>
Med tabulator kan (ligesom i tcsh) få ekspanderet fil/katalog-navne svarende til den 
begyndelse af navnet man skriver. Man kan således med 
<command>cat /e&lt;tabulator&gt;/sh&lt;tabulator&gt;</command> få ekspanderet
sig til <command>cat /etc/shells</command> uden at få skrevet ret meget.
</para>

<para>
Aliaser er nemme at sætte op i Bash. Opret filen <filename>~/.alias</filename> og indskriv
aliaser efter skemaet <literal>alias ALIAS-NAVN="kommando"</literal>. Hvis man senere vil se 
hvilke aliaser man anvender kan <command>alias</command> vise dem alle.
</para>

<programlisting>
alias ll="ls -al"
alias sa="ssh-add ~/.ssh/id_dsa"
</programlisting>

<para>
Kommandoprompten kan sættes nøjagtig efter egen smag efter et stort udbud af
muligheder. I denne bog har vi valgt at få vist brugernavn (\u), maskinnavn (\h) 
og nuværende katalog (\w), men man kan nemt vælge om som vist nedenfor. 
Udseende af prompten ændres direkte ved at sætte variablen <literal>PS1</literal>.
Her ændrer vi til at vise brugernavn (\u) og tidspunktet (\T).
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt> <userinput>echo $PS1</userinput>
[\u@\h:\w] 
<prompt>[anne@linus ~]$ </prompt> <userinput>export PS1="\u (\T):"</userinput>
<prompt>anne 10:01:12 :</prompt>
</screen>

<para>
<emphasis>Tip:</emphasis> Vil du have farver på din promt, så kunne du
læse <ulink url="http://www-106.ibm.com/developerworks/linux/library/l-tip-prompt/">http://www-106.ibm.com/developerworks/linux/library/l-tip-prompt/</ulink>.
</para>

</sect2>

<sect2 id="unix-csh">
<title>Csh</title>

<para>
En af de gamle kommando-fortolkere som i praksis findes på alle
UNIX-maskiner er <command>csh</command> - "the Berkeley UNIX C shell".
Tcsh skal ses som en naturlig videreudvikling af Csh, dvs. de to
kommando-fortolkere deler måden at sætte miljø-variable: 
<command>setenv VARIABEL VÆRDI</command>. Csh kan også som Tcsh gætte
slutningen af en kommando, hvis der kun er en mulig slutning.  Med Csh
skal man dog (på andre UNIX-systemer) trykke på escape-tasten for at få 
det til at virke.
</para>

<para>
Til alle praktiske formål er Tcsh at foretrække fremfor Csh, hvorfor vi
ikke skal beskæftige os videre med Csh.
</para>

</sect2>

<sect2 id="unix-tcsh">
<title>Tcsh</title>

<para>
Tcsh er en af de meget populære kommando-fortolkere i UNIX-verdenen,
da den tilbyder de samme gode muligheder som bash, og er
tilbagekompatibel med den aldrende csh-kommandofortolker, der typisk
findes på alle UNIX-maskiner.
</para>

<para>
Tcsh er god på mange måder. Man kan ligesom
bla. <command>bash</command> få ekspanderet filnavne, hvis blot man
skriver starten af dem og derefter trykker på tabulator-knappen. Og i
modsætning til de andre Bash kan man let selv justere
filnavnsekspansionen, så det kun er de relevante filer der bliver
foreslået.
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>ls -al /etc/sh&lt;TAB&gt;</userinput>
-rw-r--r--    1 root     root          185 sep 28  2000 /etc/shells
</screen>

<para>
I eksemplet er vist hvordan man ikke behøver at skrive hele filnavnet. 
Skulle der være flere filer som passer med starten af det man skriver, vil
alle muligheder blive vist og man må fylde lidt flere bogstaver på før 
kommandofortolkeren automatisk kan gætte resten. Tricket med at trykke
tabulator kan anvendes hele tiden.
</para>

<para>
Skulle man få brug for at udføre en af de forrige kommandoer igen, da
trykker man blot på pil op (og ned) for at gå igennem de forrige mange
kommandoer. Det er i praksis en funktion man anvender meget. Anvend
Ctrl-a og Ctrl-e for at gå til starten hhv. slutningen af linien.
</para>

<para>
Tcsh har også en smart mulighed for at kun vise de filer som passer med
det program man først har skrevet. Står man i et katalog hvor der er flere
hundrede filer, man kun en Postscript-fil, da kan man nemt få valgt den
til visning i programmet <command>gv</command>.
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>gv TAB&gt;</userinput>
eps/ folder.ps ekstra/
</screen>

<para>
Selvom der er masser af andre filer, så vil <command>tcsh</command>
filtrere filerne intelligent, da den ved at første argument efter
<command>gv</command> kun kan være en Postscript-fil - evt. i et af
underkatalogerne. Tcsh kan sættes op til at genkende alle programmers
filtyper. I bogens eksempler på <ulink url="http://www.sslug.dk/linuxbog/unix/eksempler/shells/tcsh">http://www.sslug.dk/linuxbog/unix/eksempler/shells/tcsh</ulink> kan findes <filename>dot.complete.tcsh</filename>, som viser hvordan
mange programmer er tilpasset.
</para>

<para>
Aliaser er nemme at sætte op i Tcsh. Opret filen <filename>~/.alias</filename> og indskriv
aliaser efter skemaet <literal>alias ALIAS-NAVN "kommando"</literal>. Hvis man senere vil se 
hvilke aliaser man anvender kan <command>alias</command> vise dem alle.
</para>

<para>
Tcsh vil ved login læse og køre filen
<filename>~/.login</filename> en gang. For hver gang
en terminal startes op vil filen <filename>~/.tcshrc</filename>
læses og udføres. På denne måde kan den personlige opsætning
styres.
</para>

<para>
Variable sættes i Tcsh med <command>setenv VARIABELNAVN
VÆRDI</command>.  Bemærk at der bare er et mellemrum mellem variablens
navn og den værdi den skal tildeles. Man kan se om en variabel er
defineret ved at se på indholdet af
<literal>${?VARIABELNAVN}</literal>:
<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>echo ${?PRINTER}</userinput>
0
</screen>
1 betyder at variablen er defineret og 0 at den ikke er defineret.
</para>

<para>
Til sammenligning kan vi så prøve at tildele variablen
<literal>PRINTER</literal> navnet på vores foretrukne printer:
<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>setenv PRINTER lp1</userinput>
<prompt>[anne@linus ~]$ </prompt><userinput>echo ${PRINTER}</userinput>
lp1
<prompt>[anne@linus ~]$ </prompt><userinput>env | grep PRINTER</userinput>
PRINTER=lp1
</screen>
</para>

<para>
Tcsh har i øvrigt et lille irriterende problem - har man installeret
et nyt program kan dette ikke findes i den nuværende
kommando-fortolker, da denne har "cashet" information om programmer da
denne startede op. Vil man slette cashen kan man anvende kommandoen
<command>rehash</command>.
</para>

<para>
På <ulink url="http://www.sslug.dk/linuxbog/unix/eksempler/shells/tcsh">http://www.sslug.dk/linuxbog/unix/eksempler/shells/tcsh</ulink>
kan findes et forslag til følgende <filename>~/.tcshrc</filename>.
På samme URL kan findes et forslag til <filename>~/.login</filename>.
</para>

<example id="eks-dot-tcshrc">
<title>Eksempel på en .tcshrc-fil</title>
<screen>
#!/bin/tcsh
# User .tcshrc file (/bin/tcsh initialization).
# Peter Toft 2002 

# Omgåelse af en fejl i Red Hat 7.X
unset dspmbyte

# Anvend ssh til rsync
setenv RSYNC_RSH ssh

#Dansk tastaturopsætning og danske tekster i programmerne
setenv LC_ALL da_DK
setenv LANG da

# Led efter programmer i de følgende steder.
set path = ( /bin /usr/bin /usr/local/bin /usr/X11R6/bin )

if ( ! $?prompt ) exit  # Kommandofortolkeren er interaktiv

set history = 500       # 500 af de forrige kommandoer huskes
set savehist            # Number to save across sessions
set autolist            # List choices in name completion
set correct = cmd       # Checks spelling of commands

# Kommando-prompt med login-navn maskine og sti
set prompt  = "%{^[[1m%}${user}@`hostname`%/>%{^[[0m%} " 

# Findes en ~/.alias-fil med aliaser, da køres denne
if ( -e ~/.alias ) source ~/.alias

# Findes en ~/.complete.tcsh-fil, da køres denne
if ( -e ~/.complete.tcsh ) source ~/.complete.tcsh
</screen>
</example>

<para>
Flere forslag til at skrive en <filename>~/.tcshrc</filename> kan findes på
<ulink url="http://tcshrc.sourceforge.net">http://tcshrc.sourceforge.net</ulink>.
</para>

</sect2>

<sect2 id="unix-ksh">
<title>Korn Shell (ksh)</title>

<para>
En af den halv-gamle kommando-fortolkere med et ret avancerete
scripting-muligheder er Korn Shell (ksh). Denne følger typisk med de
kommercielle UNIX-varianter, men ikke med Linux. Der er udviklet en
erstatning for <command>ksh</command> til Linux med navnet
<command>pdksh</command> (Public Domain ksh). Denne anvendes dog ikke
ret mange steder.
</para>
</sect2>

<sect2 id="unix-zsh">
<title>Zsh</title>

<para>
Zsh er en af de mest avancerede kommando-fortolkere der findes. Den
ligner Ksh, men har mange fordele over denne.  Som med Tcsh kan man
selv indstille filnavnsekspansionen. Desuden er dens scriptsprog
POSIX-kompatibelt.
</para>

<screen>
<prompt>anne@linus:~% </prompt><userinput>ls -al /etc/sh&lt;TAB&gt;</userinput>
-rw-r--r--    1 root     root          185 sep 28  2000 /etc/shells
</screen>

<para>
En rigtig smart ting som ingen af de andre kommandofortolkere har er
et specielt jokertegn, <literal>**</literal>, der betyder
underkataloger i i en vilkårlig dybde:
<screen>
<prompt>anne@linus:~% </prompt><userinput>ls **/*.png</userinput>
foldere/linux_på_dansk/friheden.png  foldere/sslug-folder/tux.png
images/anne.png                      linuxbog/front.png
images/hanne.png                     linuxbog/sslug.png
</screen>
</para>

<para>
Systemvariable sættes med <command>export VARIABELNAVN=VÆRDI</command>,
mens almindelige variable bare sættes med
<command>VARIABELNAVN=VÆRDI</command>:
<screen>
<prompt>anne@linus:~% </prompt><userinput>export PRINTER=minlpr</userinput>
<prompt>anne@linus:~% </prompt><userinput>echo ${PRINTER}</userinput>
minlpr
<prompt>anne@linus:~% </prompt><userinput>huskeseddel=/tmp/husk</userinput>
<prompt>anne@linus:~% </prompt><userinput>echo ${huskeseddel}</userinput>
/tmp/husk
</screen>
</para>

<para>
Zsh bruger op til otte opsætningsfiler, hvoraf de fire ligger i ens
eget hjemmekatalog, og de fire andre ligger i
systemopsætningskataloget:
<orderedlist>
 <listitem><para>
  <filename>/etc/zshenv</filename>   (læses altid)
 </para></listitem>

 <listitem><para>
  <filename>~/.zshenv</filename>     (læses altid)
 </para></listitem>

 <listitem><para>
  <filename>/etc/zprofile</filename> (læses ved login)
 </para></listitem>

 <listitem><para>
  <filename>~/.zprofile</filename>   (læses ved login)
 </para></listitem>

 <listitem><para>
  <filename>/etc/zshrc</filename> (læses ved login og ved interaktiv brug)
 </para></listitem>

 <listitem><para>
  <filename>~/.zshrc</filename> (læses ved login og ved interaktiv brug)
 </para></listitem>

 <listitem><para>
  <filename>/etc/zlogin</filename> (læses ved login)
 </para></listitem>

 <listitem><para>
  <filename>~/.zlogin</filename>   (læses ved login)
 </para></listitem>
</orderedlist>
</para>

<para>
Første gang man starter en zsh op, har man overhovedet ingen regler
for fuldstændiggørelse af kommandoer og filnavne. Det kan man ændre på
ved at køre den indbyggede kommando <command>compinstall</command>
(det kan være nødvendigt at lave en <command>autoload -U
compinstall</command> først). Du bliver så præsenteret for et
primitivt menusystem, hvor du kan konfigurere fuldstændiggørelsen. I
første omgang vil du nok kunne klare dig med standardindstillingerne.
</para>

<para>
Hvis de 500-600 fuldstændiggørelsesregler zsh kommer med som standard
ikke er nok, kan man selvfølgelig lave flere. Hvis man f.eks. vil have
zsh til kun at foreslå <filename>.ogg</filename>- og
<filename>.mp3</filename>-filer når man har skrevet
<command>music123</command>, kan man lægge fælgende fil:
<programlisting>
#compdef music123

_files -g '*.(ogg|mp3)'
</programlisting>
i <filename>/usr/local/share/zsh/site-functions/</filename>.  <!--
Hvor lægger man personlige funktioner? - HCG --> Den første linie
fortæller at denne funktion skal bruges når det er argumenter til
<command>music123</command> der fuldstændiggøres, og den anden linie
at kun filer der passer til det angivne mønster skal bruges.
</para>

<para>
Man kan naturligvis bladre tilbage gennem sine gamle kommandoer med
pil op/ned, og ændre i en kommando inden man udfører den igen. Til
dette formål kan man både få Emacs- og vi-tastebindinger, hvis end
<filename>$EDITOR</filename>- eller
<filename>$VISUAL</filename>-variabel er sat til en af tingene vælger
zsh automatisk de tilsvarende tastebindinger.
</para>

<para>
Der er eksempler på hvordan de fire brugerdefinerede filer kan se ud i
bogens eksempler
(<ulink url="http://www.sslug.dk/linuxbog/unix/eksempler/shells/zsh/">http://www.sslug.dk/linuxbog/unix/eksempler/shells/zsh/</ulink>).
<!-- Jacob burde kommentere disse -->
</para>

<para>
Zshs hjemmeside findes SunSite.dk, hvor man også kan finde en
brugsanvisning:
<ulink url="http://zsh.sunsite.dk/Guide/">http://zsh.sunsite.dk/Guide/</ulink>.
</para>
</sect2>

<sect2 id="unix-sh">
<title>Bourne Shell (sh)</title>

<para>
En af de ældste kommando-fortolkere til UNIX-familien er Bourne Shell
(<command>sh</command>). Den har reelt kun den fordel at alle
UNIX-maskiner har den installeret, og dermed er det en god måde at
lave portabel kode i Bourne Shell, men som standard kommando-fortolker
er Bourne Shell alt for skrabet og har slet ikke de smarte egenskaber,
der findes i de nyere kommando-fortolkere.
</para>

<para>
Ligesom <command>bash</command>, <command>zsh</command> og
<command>ksh</command> sættes miljø-variable med export.
<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>sh</userinput>
<prompt>sh-2.05$</prompt> <userinput>export dd=3</userinput>
<prompt>sh-2.05$</prompt> <userinput>echo $dd</userinput>
3
</screen>
</para>

</sect2>
</sect1>

<sect1 id="videre-med-shells">
<title>Læs videre om emnet</title>
<para>
Der er udgivet masser af bøger om kommandofortolkere - i høj grad fra
forlaget O'Reilly - se mere på <ulink
url="http://www.oreilly.com">http://www.oreilly.com</ulink>.  
Bøgerne kan f.eks. købes fra Polyteknisk boghandel i Lyngby eller andre
velassorterede boghandlere.
</para>

<para>
På Internettet kan følgende steder være af interesse:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
<ulink url="http://www.faqs.org/faqs/unix-faq/shell/shell-differences/">http://www.faqs.org/faqs/unix-faq/shell/shell-differences/</ulink>
 </para>
</listitem>
<listitem> 
 <para>
<ulink url="http://www.nscp.umd.edu/shells.html">http://www.nscp.umd.edu/shells.html</ulink>
 </para>
</listitem>
<listitem> 
 <para>
<ulink url="http://www.computerbits.com/archive/1997/1100/lnx9711.html">http://www.computerbits.com/archive/1997/1100/lnx9711.html</ulink>
 </para>
</listitem>
</itemizedlist>


</sect1> 
</chapter>
