<?xml version='1.0' encoding='UTF-8' ?>


<chapter id="basal-unix">
 <title>Basal Unix</title>

 <!-- her bør der nok lige komme en introduktion til kapitlet -->

 <sect1 id="filtraet">
  <title>Hvad ligger hvor på en Linux-maskine</title>

  <indexterm>
   <primary>filer</primary>
   <secondary>placering af</secondary>
  </indexterm>

  <para>
   En af de ting der karakteriserer Unix (og måske i endnu højere grad
   Linux) er en idé om at alle ressourcer der er tilgængelige på
   systemet skal kunne betragtes på samme måde - som filer. Det gælder
   både egentlige filer på harddiske i computeren, selve harddisken
   (praktisk når den skal formatteres), systemets virtuelle konsoller,
   hukommelsen i computeren, tilsluttede apparater, etc. I Linux er
   selv opsætningsparametre til kernen og kernens status tilgængelige
   som filer. De eneste væsentlige ressourcer der ikke er tilgængelige
   som regulære filer i Linux er netværkskortene.
  </para>

  <para>
   Når filer har så stor betydning i Unix, er det vigtigt at vide lidt
   om hvor de forskellige filer findes henne i systemet.
  </para>

  <para>
   Linux har en meget velorganiseret måde at gemme forskellige filer.
   Den bygger primært på at man fordeler filer efter funktion og kun
   sekundært på hvilke programpakker de tilhører.
   Der er kataloger til delte biblioteker, nogle til programmer, og
   andre kataloger til brugerdata.  Dette afsnit bygger på <!--
   MANGLER: Henvisning til FHS --> »Linux File-System Hierarchy
   Standard« (FHS) der er en standard som de forlag der udgiver
   linuxdistributioner har aftalt, for at det skal være lettere for
   programhuse og individuelle programmører at pakke én udgave at et
   program der vil virke på alle de forskellige linuxdistributioner
   (der overholder FHS).
  </para>

  <table>
   <title>Oversigt over filtræet.</title>

   <indexterm><primary>Filtræet</primary></indexterm>

<tgroup cols="2" align="char">
<thead>
<row>
<entry>Filtræ
</entry>

<entry>
Forklaring
</entry>

</row>
</thead>

<tbody>

<row>
<entry><filename>/</filename></entry> 
<entry>Toppen af katalogstrukturen.</entry>
</row>

<row>
<entry><filename>/bin</filename></entry> 
<entry>Her er de mest nødvendige systemkommandoer gemt.</entry> 
</row>

<row>
<entry><filename>/boot</filename></entry> 
<entry>Dette katalog er reserveret til systemkernen,
men nogle Linux-distributioner vælger at placere kernen i roden, dvs.
<filename>/</filename>.</entry>
</row>

<row>
<entry><filename>/dev</filename></entry> 
<entry>Indeholder alle device-filer, dvs. adgang til alle enheder
såsom harddiske, cd-rom-drev, diskette, mus, tastatur og printer
går igennem dette .</entry>
</row>

<row>
<entry><filename>/etc</filename></entry> <entry>Dette katalog
indeholder systemopsætningsfilerne, såvel som filerne, der er
ansvarlige for systemets opstart, og grafiksystemets opsætning.</entry>
</row>

<row>
<entry><filename>/home</filename></entry> 
<entry>Dette er kataloget for alle brugerkonti. <!-- Ja, Linux giver
mulighed for, at mange personer kan arbejde på den samme
computer samtidig &ndash; uden at blande dem sammen. --> Linux er et
flerbrugerstyresystem.  Vi kan anbefale, at man opretter en bruger til de mest
normale jobs og <emphasis>kun</emphasis> bruger root til
administration, da du som root ved en fejl kan komme til at slette
vigtige filer, hvilket ville være umuligt som almindelig bruger.
</entry>
</row>

<row>
<entry><filename>/lib</filename></entry> 
<entry>Indeholder systemets delte
filer. Linux sparer hukommelse ved at lægge
kode, som bruges af mange programmer, ind i en fil, kaldet "shared
library"<!-- &ndash; svarende til DLL'er i Windows-->. På
den måde vil der kun eksistere én kopi af filen i hukommelsen,
når den bliver brugt.
</entry>
</row>

     <row>
      <entry><filename>/opt</filename></entry>

      <entry>
       Er reserveret til installation af valgfrie
       programpakker.  SuSE placerer store
       programpakker som KDE og StarOffice i
       <filename>/opt</filename>, så hvis du installerer SuSE skal du
       derfor sørge for, at dette katalog har en del plads.
      </entry>
     </row>

     <row>
      <entry><filename>/lost+found</filename></entry>

      <entry>
       <!-- Du har måske prøvet at bruge Norton Utilities til at genskabe
       en fil, som er tabt i en defekt del af harddisken. Vær mere
       rolig under Linux. -->  Hvis harddisken laver fejl, vil systemet
       selv forsøge at genskabe filerne, og hvis det ikke kan finde ud
       af, hvor i filtræet filen var placeret, vil den blive placeret
       i <filename>/lost+found</filename>.
      </entry>
     </row>

     <row>
      <entry><filename>/mnt</filename></entry>

      <entry>
       Hvis du vil have adgang til en cd-rom, et ZIP-drev eller en
       diskette, er det som regel i denne del af filsystemet, du får
       adgang til dem.
      </entry>
     </row> 


     <row>
      <entry><filename>/proc</filename></entry>

      <entry>
       Dette katalog indeholder dynamisk opdaterede oplysninger om de
       kørende programmer og Linux-kernens status.
      </entry>
     </row>

     <row>
      <entry><filename>/root</filename></entry> 

      <entry>Systemadministratorens hjemmekatalog.</entry>
     </row>

     <row>
      <entry><filename>/sbin</filename></entry>

      <entry>
       Her ligger de programmer der generelt kun er brugbare for
       systemadministratoren og er nødvendige for at systemet
       fungerer.  <!-- løst oversat fra FHS' beskrivelse af "/sbin",
       "/usr/sbin" og "/usr/local/sbin" -->
      </entry>
     </row>

     <row>
      <entry><filename>/tmp</filename></entry>

      <entry>
       Beregnet til midlertidige filer.  De fleste programmer lægger
       automatisk midlertidige filer her.  Som regel sletter systemet
       dem, når det starter op.
      </entry>
     </row>

     <row>
      <entry><filename>/usr</filename></entry> 

      <entry>
       Her ligger delte data og programmer der ikke ændres og ikke er
       specifikke for lige netop den specifikke maskine.  I principet
       skal <filename>/usr</filename> efter at styresystemet er
       installeret monteres som et filsystem der kun kan læses fra og
       ikke skrives til.  <!-- løst oversat fra FHS' overordnede
       beskrivelse af "/usr" -->
      </entry>
     </row>

     <row>
      <entry><filename>/usr/local</filename></entry> 

      <entry>
       Her kan systemadministratoren installere programmer og data
       der specifikke for maskinen.  På systemer der overholder
       <glossterm linkend="def-linux-standard-base">Linux Standard
       Base</glossterm> vil <filename>/usr/local</filename> ikke blive
       overskrevet ved systemopgraderinger.  <!-- løst oversat fra
       FHS' beskrivelse af "/usr/local" -->
      </entry>
     </row>

     <row>
      <entry><filename>/var</filename></entry>

      <entry>
       Indeholder datafiler hvis indhold ændres mens systemet er i
       drift.  Det er for eksempel post- og printerkøer, logfiler og
       administrative data.  <!-- løst oversat fra FHS' beskrivelse af
       "/var" -->
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Der kan være yderligere dele af filtræet, såsom en Windows-disk som
   man ofte giver tilgang til via <filename>/dos</filename> eller
   <filename>/dosc</filename>.
  </para>


<para>
Læs i øvrigt 
<ulink url="http://www.pathname.com/fhs/announce-2.0.html">http://www.pathname.com/fhs/announce-2.0.html</ulink>
for mere information om filers placering.
</para>

</sect1> <!-- sect1 filtraet -->


 <sect1 id="vis">
  <title>Se indholdet af filer og kataloger</title>

  <indexterm>
   <primary>vis indholdet af filer</primary>
  </indexterm>

<indexterm>
 <primary>cat</primary>
</indexterm>

<indexterm>
  <primary>more</primary>
</indexterm>

<indexterm>
 <primary>less</primary>
</indexterm>

<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>cat</secondary>
</indexterm>

<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>less</secondary>
</indexterm>

<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>more</secondary>
</indexterm>

<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>cat</tertiary>
</indexterm>

<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>less</tertiary>
</indexterm>

<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>more</tertiary>
</indexterm>

  <para>
   Indtil nu har du arbejdet med filer, men du har stadig ikke set på
   deres indhold. Indholdet af tekstfiler kan let vises. Kommandoen
   <command>cat</command> viser indholdet af en fil, f.eks. kan du se
   indholdet af <filename>passwd</filename> ved at skrive:

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>cat passwd</userinput>
daemon:*:2:2:daemon:/sbin:
adm:*:3:4:adm:/var/adm:
lp:*:4:7:lp:/var/spool/lpd:
sync:*:5:0:sync:/sbin:/bin/sync
shutdown:*:6:0:shutdown:/sbin:/sbin/shutdown
halt:*:7:0:halt:/sbin:/sbin/halt
mail:*:8:12:mail:/var/spool/mail:
news:*:9:13:news:/var/spool/news:
uucp:*:10:14:uucp:/var/spool/uucp:
operator:*:11:0:operator:/root:
games:*:12:100:games:/usr/games:
gopher:*:13:30:gopher:/usr/lib/gopher-data:
ftp:*:14:50:FTP User:/home/ftp:
nobody:*:99:99:Nobody:/:
tyge:x:501:501:Tyge Brahe&comma;,&comma;,:/home/tyge:/bin/bash
</screen>
  </para>

<para>
<command>cat</command> er, som du ser, meget let at bruge, men
kommandoen har en dårlig side: Hvis filens indhold fylder mere end en
skærmside, kommer filen alt for hurtigt over skærmen, og bagefter ser du
kun den sidste side (dvs. det antal linjer, som kan vises på din
skærm). Du kan dog se nogle få sider tilbage ved at bruger Shift+PageUp.
<!--  er det ikke afhængigt af ens (virtuelle) konsol?  -->
Kommandoerne <command>less</command> og
<command>more</command> er derfor mere velegnede, da det er muligt
at bladre frem og tilbage i filen. Kommandoen viser en side ad gangen,
og du kan bladre frem ved at trykke på <keycap>f</keycap>
(eng. "forward") eller mellemrum og tilbage ved at trykke på
<keycap>b</keycap> (eng. "backward"), og i <command>less</command>
kan pil op og ned også anvendes. Det er også muligt at søge ved at 
taste <keycap>/</keycap> efterfulgt af den tekst man leder efter og
<keycap>return</keycap>.  Søgningen gentages ved
tryk på <keycap>n</keycap> (eng. "next"). Man afslutter både <command>less</command> og <command>more</command> ved at 
trykke <keycap>q</keycap> (eng. "quit").
</para>
</sect1>

 <sect1 id="mv-rm">
  <title>Oprette, kopiere, flytte og slette filer og kataloger</title>

  <indexterm>
   <primary>filer</primary>
   <secondary>flytte</secondary>
  </indexterm>

  <indexterm>
   <primary>kataloger</primary>
   <secondary>flytte</secondary>
  </indexterm>

  <indexterm>
   <primary>filer</primary>
   <secondary>omdøbe</secondary>
  </indexterm>

  <indexterm>
   <primary>kataloger</primary>
   <secondary>omdøbe</secondary>
  </indexterm>

  <indexterm>
   <primary>flytte filer</primary>
  </indexterm>

  <indexterm>
   <primary>flytte kataloger</primary>
  </indexterm>

  <indexterm>
   <primary>omdøbe filer</primary>
  </indexterm>

  <indexterm>
   <primary>omdøbe kataloger</primary>
  </indexterm>

  <para>
   <indexterm>
    <primary>mv</primary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>mv</secondary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>Grundlæggende kommandobeskrivelse</secondary>
    <tertiary>mv</tertiary>
   </indexterm>

   Du har allerede set, hvordan du kan kopiere filer og se indholdet
   af dem. Nu kan det tænkes, at du finder ud af, at en fil skal have
   et andet navn, dvs. den skal omdøbes. Til det formål har du
   kommandoen <command>mv</command> (eng. "move"):

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>cp passwd nyFil</userinput>
<prompt>[tyge@hven ~]$ </prompt><userinput>mv nyFil megetNyFil</userinput>
<prompt>[tyge@hven ~]$ </prompt><userinput>ls -l</userinput>
-rw-rw-r--   1 tyge    tyge         652 Jul 14 22:32 passwd
-rw-rw-r--   1 tyge    tyge         652 Jul 14 22:34 megetNyFil
</screen>

   Først tager vi med <command>cp</command> en kopi af filen
   <filename>passwd</filename> som vi kalder
   <filename>nyFil</filename>.  Bagefter omdøber vi
   <filename>nyFil</filename> til <filename>megetNyFil</filename>.
   Som kommandoens navn antyder, kan den mere end bare omdøbe filer;
   den kan flytte dem til andre steder i filsystemet.
  </para>

  <para>
   Her flytter vi for eksempel filen <filename>megetNyFil</filename>
   til kataloget <filename>MitKatalog</filename>:

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>mkdir MitKatalog</userinput>
<prompt>[tyge@hven ~]$ </prompt><userinput>mv megetNyFil MitKatalog</userinput>
<prompt>[tyge@hven ~]$ </prompt><userinput>cd MitKatalog</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls -l</userinput>
-rw-rw-r--   1 tyge    tyge         652 Jul 14 22:34 megetNyFil
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>cd ..</userinput>
<prompt>[tyge@hven ~]$ </prompt><userinput>ls -l</userinput>
drwxrwxr-x   2 tyge    tyge        1024 Jul 14 22:34 MitKatalog
-rw-rw-r--   1 tyge    tyge         652 Jul 14 22:32 passwd
</screen>
  </para>

  <para>
   <indexterm>
    <primary>slette filer</primary>
   </indexterm>

   <indexterm>
    <primary>filer</primary>
    <secondary>slette</secondary>
   </indexterm>

   <indexterm>
    <primary>rm</primary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>rm</secondary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>Grundlæggende kommandobeskrivelse</secondary>
    <tertiary>rm</tertiary>
   </indexterm>

   Nu kan det tænkes, at du vil slette filen
   <filename>megetNyFil</filename>. Kommandoen <command>rm</command>
   er lige det, du mangler <command>rm</command> (eng. "remove"):

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>cd MitKatalog</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls -l</userinput>
-rw-rw-r--   1 tyge    tyge         652 Jul 14 22:34 megetNyFil
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>rm megetNyFil</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls -l</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt>
</screen>
  </para>

  <para>
   Du skal være meget forsigtig med at bruge <command>mv</command> og
   <command>rm</command>, idet der ikke er nogen mulighed for at
   fortryde.  Hvis du vil blive spurgt, om det er rigtigt, at du vil
   flytte/slette, kan du bruge tilvalget <literal>-i</literal>, så det
   ovenstående eksempel bliver til:

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>rm -i megetNyFil</userinput>
rm: remove almindelig fil 'megetNyFil'? 
</screen>

   Her kan du så svare <keycap>j</keycap> for ja, og
   <command>n</command> for nej.
  </para>

  <note id="unix-kommandoer-alias">
   <title>Kommandogenveje</title>

   <indexterm>
    <primary>alias</primary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>alias</secondary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>Grundlæggende kommandobeskrivelse</secondary>
    <tertiary>alias</tertiary>
   </indexterm>

   <para>
    Det kan være praktisk at lave en genvej til en kommando med nogle
    bestemte tilvalg (et alias), så man ikke bliver nødt til at huske
    på tilvalgene hver gang man bruger kommandoen.  Det er for
    eksempel en god idé at lave aliaser svarende til <command>rm
    -i</command> og <command>mv -i</command> som man lægger ind i
    stedet for <command>rm</command> og <command>mv</command>, så man
    altid bliver spurgt inden man kommer til at slette noget ved at
    skrive <command>rm en_fil</command> eller lignende.
   </para>

   <para>
    <command>alias rm='rm -i'</command> gør for eksempel at når du
    senere skriver <command>rm et-eller-andet</command>, så laver
    kommandofortolkeren det om til <command>rm -i
    et-eller-andet</command> før det bliver udført.
   </para>

   <para>
    Det kan også være rart at kunne køre <command>ls</command> med
    tilvalget <literal>-l</literal> let.  Typisk laver man til det
    formål aliaset <command>ll</command>:
<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>alias ll='ls -l'</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ll</userinput>
-rw-rw-r--   1 tyge    tyge         652 Jul 14 22:34 megetNyFil
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls</userinput>
megetNyFil
</screen>
   </para>

   <para>
    Hvis du vil have Bash til at huske dine kommandogenveje fra gang
    til gang, bør du skrive dem ind i filen <filename>~/.bashrc</filename>:
<programlisting>
alias rm='rm -i'
alias mv='mv -i'
alias ll='ls -l'
</programlisting>
   </para>
  </note>

  <para>
   I visse tilfælde opstår der filer med i havelåger (#), mellemrum og
   andre specielle tegn i.  Hvis man vil slette dem, kan man med
   fordel skrive navnene i citationstegn:
<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>rm -i '#en sær fil#'</userinput>
rm: remove almindelig fil '#en sær fil#'? 
</screen>
  </para>

  <para>
   <indexterm>
    <primary>oprette filer</primary>
   </indexterm>

   <indexterm>
    <primary>filer</primary>
    <secondary>oprette</secondary>
   </indexterm>

   <indexterm>
    <primary>touch</primary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>touch</secondary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>Grundlæggende kommandobeskrivelse</secondary>
    <tertiary>touch</tertiary>
   </indexterm>

   Du kan også oprette nye (tomme) filer med kommandoen
   <command>touch</command>, som tillige ændrer tidsstemplet på filen,
   hvis den allerede var der i forvejen:

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>touch myXYZoptioner.txt</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls -l</userinput>
-rw-rw-r--   1 tyge    tyge           0 Jul 14 22:39 myXYZoptioner.txt
<prompt>[tyge@hven MitKatalog]$ </prompt>
</screen>
  </para>

  <para>
   Hvis du så venter et par minutter og udfører
   <command>touch</command> igen, så vil du se, at tidsstemplet
   ændres: <!-- (brug pil-op et par gange) -->

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>touch myXYZoptioner.txt</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>ls -l</userinput>
-rw-rw-r--   1 tyge    tyge           0 Jul 14 22:42 myXYZoptioner.txt
<prompt>[tyge@hven MitKatalog]$ </prompt>
</screen>
  </para>

  <para>
   <indexterm>
    <primary>links</primary>
   </indexterm>

   <indexterm>
    <primary>lænker</primary>
   </indexterm>

   <indexterm>
    <primary>henvisninger</primary>
   </indexterm>

   <indexterm>
    <primary>ln</primary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>ln</secondary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>Grundlæggende kommandobeskrivelse</secondary>
    <tertiary>ln</tertiary>
   </indexterm>

   Endelig skal vi også se på hvordan man kan lave henvisninger (eng.
   "links").  Hvis du har brug for at en fil, for eksempel
   <filename>myXYZoptioner.txt</filename> også optræder med et andet
   navn, så kan du altid lave en symbolsk henvisning (eng. "symbolic
   link") til filen fra det andet navn:

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ln -s myXYZoptioner.txt o.txt</userinput>
</screen>

   Her satte vi <filename>o.txt</filename> til at være en symbolsk
   henvisning til <filename>myXYZoptioner.txt</filename>.  Det betyder
   at hvis du nu giver et program besked om at gøre noget ved filen
   <filename>o.txt</filename>, så vil det i virkeligheden være filen
   <filename>myXYZoptioner.txt</filename> programmet arbejder med.
  </para>

  <para>
   Med <command>ls</command> kan du se at <filename>o.txt</filename>
   er en symbolsk henvisning og ikke en rigtig fil:

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls -l o.txt</userinput>
lrwxrwxrwx  1 tyge tyge  4 jul 15 20:35 o.txt -> myXYZoptioner.txt
</screen>
  </para>

  <para>
   Endelig kan det nævnes at man ud over symbolske henvisninger også
   kan laves direkte henvisninger (eng. "hard links").  Effekten er
   langt hen ad vejen den samme, men direkte henvisninger er begrænset
   til at fungere indenfor samme filsystem og er bundet til selve
   filerne og ikke til deres navne.
  </para>

<!--  `rename` findes i to forskellige udgaver - det skal med
  <para>
   <indexterm>
    <primary>rename</primary>
   </indexterm>

   En smart kommando til at ændre filnavne, er
   <command>rename</command>, som ofte, men ikke altid, findes på Unix
   og Linux-systemer.  Skal du ændre filnavne systematisk, f.eks. alle
   ".htm"-filer til ".html", så kan du bruge:
<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>rename htm html *</userinput>
</screen>
  </para>
-->

 </sect1>

 <sect1 id="joker-redir-kanaler">
  <title>Jokertegn, omdirigering og kanaler</title>

  <para>
   Vi vil i dette afsnit se på et par af systemets mere smarte
   funktioner, som gør livet lettere for dig som bruger.
  </para>

  <sect2 id="joker">
   <title>Jokertegnene</title>

   <indexterm>
    <primary>jokertegn</primary>
   </indexterm>

   <indexterm>
    <primary>*</primary>
    <secondary>jokertegn</secondary>
   </indexterm>

   <indexterm>
    <primary>?</primary>
    <secondary>jokertegn</secondary>
   </indexterm>

   <para>
    Forestil dig, at du har mange filer, som du gerne vil slette. Du
    kan naturligvis skrive <command>rm den_ene_fil den_næste_fil den
    tredje_fil</command> (osv.) med hvert enkelt navn, men bare med
    5-10 filer bliver du hurtigt træt af det.  Redningen er
    jokertegnene <literal>*</literal> og <literal>?</literal>.
   </para>

   <para>
    Lad os antage, at du har tre filer i et katalog, og at du gerne
    vil slette dem alle. For øvelsens skyld opretter vi først filerne
    med <command>touch</command>-kommandoen og sletter dem derefter.
    Nedenfor ser du hvordan:

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>touch aaa abc ccc</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls</userinput>
 aaa  abc   ccc  
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>rm *</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt>
</screen>

    Asterisken (<literal>*</literal>) er et jokertegn som her
    betyder <emphasis>alle filer</emphasis>.  Hvis du i stedet havde skrevet
    <literal>a*</literal>, ville det betyde alle filer som
    begynder med <literal>a</literal>.

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>touch aaa abc ccc</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls</userinput>
 aaa  abc   ccc
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>rm a*</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls</userinput>
 ccc
<prompt>[tyge@hven NytKatalog]$ </prompt>
</screen>
   </para>

   <para>
    Asterisken (<literal>*</literal>) betyder helt generelt nul eller
    flere tegn i et filnavn.  For eksempel betyder
    <literal>a*b</literal> alle filer, der begynder med
    <literal>a</literal> og slutter på <literal>b</literal>,
    hvilket vil inkludere filerne <filename>ab</filename>,
    <filename>aDuErGodb</filename>, men ikke en fil med navnet
    <filename>abe</filename>.
   </para>

   <para>
    Ligesom asterisken fungerer spørgsmålstegn
    (<literal>?</literal>) også som jokertegn.  Et spørgsmålstegn
    står for et (og netop et) vilkårligt tegn i et filnavn.
   </para>

   <example id="unix-jokertegn-asterisk-og-spoergsmaalstegn">
    <title>Kombination af flere jokertegn</title>

    <para>
     Som et eksempel på hvordan jokertegnene kan kombineres med
     hinanden beder vi <command>ls</command> om at give os en liste
     med alle de filer i kataloget <filename>/usr/bin</filename>, hvis
     tredje bogstav er et z:
<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls /usr/bin/??z*</userinput>
/usr/bin/mozilla  /usr/bin/size86  /usr/bin/unzip
/usr/bin/size     /usr/bin/tgz     /usr/bin/unzipsfx
</screen>
    </para>
   </example>

   <para>
    Da det er kommandofortolkeren og ikke de enkelte kommandoer der
    tager sig af at fortolke jokertegnene, kan man bruge præcist de
    samme mønstre til at angive samlinger af filer til alle
    programmer på systemet.
   </para>

<!--
<para>
Det er værd at bemærke, at jokertegn ekspanderes af 
kommandofortolkeren &ndash; <emphasis>ikke</emphasis> af
applikationen. Det har bl.a. den store fordel, at jokertegn altid
fungerer &ndash; og fungerer konsistent på tværs af applikationer.
</para>
-->

<para>
Et meget simpelt eksempel: Et katalog indeholder 3 filer:
<filename>fil1</filename>, <filename>fil2</filename> og
<filename>ccc</filename>. Skriver du: <command>ls f*</command>, vil
kommandofortolkeren først ekspandere f* og derefter kalde
<command>ls</command> med: <command>ls fil1 fil2
</command>. Output fra <command>ls f*</command> er blot: 

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>touch fil1 fil2</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls</userinput>
ccc   fil1   fil2
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls f*</userinput>
fil1   fil2
</screen>
og <command>ls</command> laver således et yderst banalt arbejde.
</para>

   <para>
    <indexterm>
     <primary>diff</primary>
    </indexterm>

    <indexterm>
     <primary>Kommandooversigt</primary>
     <secondary>diff</secondary>
    </indexterm>

Men der er flere muligheder i dette. Et eksempel: For at se forskellen
mellem <filename>fil1</filename> og <filename>fil2</filename> kan
du skrive: <command>diff fil1 fil2</command>. Men du kan også nøjes
med at skrive: <command>diff fil?</command> og så lade 
kommandofortolkeren regne ud at 
<literal>f*</literal> betyder <literal>fil1 fil2</literal>. 
Da de to filer er ens (de er begge tomme), så 
er der ingen forskel, og derfor intet at vise:

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>diff f*</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt>
</screen>
   </para>

   <para>
    Somme tider kan denne konsekvente ekspansion af jokertegn dog være
    en ulempe.  For eksempel:  Et katalog indeholder 2 filer:

<screen>
<prompt>[tyge@hven film]$</prompt> <userinput>ls</userinput>
dogme95.zip      film_index.html
</screen>
   </para>

   <para>
    <indexterm>
     <primary>unzip</primary>
    </indexterm>

    <indexterm>
     <primary>Kommandooversigt</primary>
     <secondary>unzip</secondary>
    </indexterm>

    Du kan også bruge zip-filer under Unix, og du kan se indholdet af
    zip-filen ved f.eks. at skrive:

<screen>
<prompt>[tyge@hven film]$</prompt> <userinput>unzip -v d*</userinput>
Archive:  dogme95.zip
Length Method Size Ratio Date    Time   CRC-32   Name
------ ------ ---- ----- ----    ----   ------   ----
 14853 Defl:N 5224 65%  10-27-98 16:12 944a4af4 festen.html
 14844 Defl:N 5401 64%  11-14-98 19:53 e55c1636 idioterne.html
  1941 Defl:N 1024 47%  03-12-99 22:12 5ecb7d23 mifune.html
------       ----- ---                           -----
 31638       11649 63%                          3 files
</screen>
   </para>

<para>
Nu vil vi pakke <filename>festen.html</filename> ud af zip-filen. Det
er den eneste fil i zip-filen, der starter med <filename>f</filename>,
så under DOS kunne man blot skrive: <command>unzip d*
f*</command>. Men prøver man det under Unix, går det galt:  
</para>

<screen>
<prompt>[tyge@hven film]$</prompt><userinput> unzip d* f*</userinput>
Archive:  dogme95.zip
caution: filename not matched:  film_index.html
</screen>

<para>
Hvorfor det? Fordi der i kataloget i forvejen ligger en fil, der
matcher <filename>f*</filename>, så vil kommandofortolkeren ekspandere
<emphasis>både</emphasis> <filename>d*</filename>  og
<filename>f*</filename> og kalde <command>unzip</command> med:
<command>unzip dogme95.zip film_index.html</command>. 
</para>

<para>
Du bliver som minimum nødt til at skrive: <command>unzip d*
fe*</command>. Der er ingen fil i kataloget, der matcher
<filename>fe*</filename>, så kommandofortolkeren vil kun ekspandere
<filename>d*</filename> og kalde unzip med: <command>unzip dogme95.zip
fe*</command>. Det overlades nu til <command>unzip</command> at ekspandere
<filename>fe*</filename>.
</para>

<para>
Alternativt kan man sætte en '\' foran stjernen og derved
fortælle kommandofortolkeren at stjernen ikke skal ekspanderes.
Altså: <command>unzip d* f\*</command>
</para>

<para>
Se også næste afsnit om regulære udtryk.
</para>

<para>
<indexterm><primary>?</primary></indexterm>
Det skal også nævnes, at hvis du kun vil finde et tegn, så brug et
spørgsmålstegn. Vil du f.eks. finde alle filer aaa, baa, caa osv. men
ikke caaa, så kan du bruge følgende

<screen>
<prompt>[tyge@hven MitKatalog]$</prompt> <userinput>touch aaa baa caa caaa</userinput>
<prompt>[tyge@hven MitKatalog]$</prompt> <userinput>ls </userinput>
aaa   baa   caa   caaa   ccc   fil1   fil2
<prompt>[tyge@hven MitKatalog]$</prompt> <userinput>ls ?aa</userinput>
aaa   baa   caa
</screen>
   </para>

   <note id="unix-globbing-og-regexp">
    <title>"Globbing" og regulære udtryk</title>

    <para>
     Jokertegnene <literal>?</literal> og <literal>*</literal> er en
     lille del af et større system til at danne mønstre for filnavne.
     Dette system kaldes "globbing".  Du kan finde en detaljeret
     gennemgang af hvordan man bruger "globbing" i bøgerne »Unix in a
     Nutshell« og »Linux in a Nutshell«.
    </para>

    <para>
     Det er vigtigt ikke at komme til at blande "globbing" sammen med
     det system man i Unix bruger til at danne mønstre for tekst i al
     almindelighed &ndash; regulære udtryk (eng. "regular
     expressions").  Regulære udtryk er et væsentligt stærkere system
     end "globbing", men de bruges altså sædvanligvis ikke til mønstre
     for filnavne.

     <!--  Er det fordi regulære udtryk er en nyere idé end globbing?  -->
    </para>
   </note>
  </sect2>

  <sect2 id="unix-globbing">
   <title>"Globbing"</title>

   <indexterm>
    <primary>globbing (mønstre for filnavne)</primary>
   </indexterm>
   
   <para>
    Jokertegnene <literal>?</literal> og <literal>*</literal> (omtalt
    i <xref linkend="joker"/>) er de grundlæggende elementer i
    "globbing".
   </para>

   <para>
    På kommandolinjen i for eksempel Bash kan man bruge noget der minder om
    regulære udtryk der kaldes "globbing".  Med
    "globbing" kan du f.eks. liste alle dine filer, der slutter med
    bogstavet a ved at skrive <command>ls *[a]</command>.  For at
    liste filer der <emphasis>ikke</emphasis> slutter på a skrives
    <command>ls *[^a]</command>.  Det er vigtigt at skelne regex og
    globbing fra hinanden.
   </para>


   <table id="unix-globbing-oversigt">
    <title>Oversigt over "globbing"</title>

    <tgroup cols="2" align="char">
     <thead>
      <row>
       <entry>Syntaks</entry>
       <entry>Beskrivelse</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>*</entry>
       <entry>Svarer til nul eller flere vilkårlige tegn.</entry>
      </row>

      <row>
       <entry>?</entry>
       <entry>Svarer til netop ét vilkårligt tegn</entry>
      </row>

      <row>
       <entry>[a-d]</entry>
       <entry>
        Svarer til et af tegnene <literal>a</literal>,
        <literal>b</literal>, <literal>c</literal> eller
        <literal>d</literal>.  Men pas på.  Nogle systemer kan
        ignorere forskelle mellem store og små bogstaver og regne med
        enten det danske eller det latinske alfabet.
       </entry>
      </row>

      <row>
       <entry>[^a-d]</entry>
       <entry>
        Svarer til alt andet end tegnene <literal>a</literal>,
        <literal>b</literal>, <literal>c</literal> eller
        <literal>d</literal>.
       </entry>
      </row>

      <row>
       <entry>{Skåne,Sjælland,Hven}</entry>
       <entry>
        Svarer til netop én af strengene <literal>Skåne</literal>,
        <literal>Sjælland</literal> og <literal>Hven</literal>.
       </entry>
      </row>

      <row>
       <entry>*foo??ba[rz]{fubar,qux}*quux</entry>

       <entry>
        <para>
         <!-- Tak Ole Tange. Tak, det er rigeligt! /chlor --> Svarer
         til nul eller flere vilkårlige tegn, efterfulgt af strengen
         <literal>foo</literal>.  Så to vilkårlige tegn efterfulgt af
         strengen <literal>ba</literal> og et af tegnene
         <literal>r</literal> eller <literal>z</literal>.  Dernæst
         en af strengene <literal>fubar</literal> eller
         <literal>qux</literal> efterfulgt af ingen eller flere
         vilkårlige tegn og så strengen <literal>quux</literal> til
         sidst.  Med dette udtryk ses det (let) at man kan finde
         filnavnene <filename>foo++barquxquux</filename> og
         <filename>XYZfoo77bazfubarYESquux</filename> i én og samme
         søgning.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 id="regexp">
   <title>Regulære udtryk</title>

   <indexterm>
    <primary>regulære udtryk</primary>
   </indexterm>

   <para>
    Mange programmer (blandt andre <command>ed</command>,
    <command>egrep</command>, Emacs, Perl, PHP,
    <command>sed</command>, <command>slocate</command> og
    <command>vi</command>) understøtter et meget effektivt system til
    søg-og-erstat af tekst efter angivne mønstre.  Dette system kaldes
    <emphasis>regulære udtryk</emphasis> (eng. "regular expressions").
   </para>

   <table id="unix-regulaere-udtryk-oversigt">
    <title>Oversigt over regulære udtryk</title>

    <tgroup cols="2" align="char">
     <thead>
      <row>
       <entry>Syntaks</entry>
       <entry>Beskrivelse</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>.*</entry>
       <entry>Svarer til nul eller flere vilkårlige tegn.</entry>
      </row>

      <row>
       <entry>.</entry>
       <entry>Svarer til netop ét vilkårligt tegn</entry>
      </row>

      <row>
       <entry>[a-d]</entry>
       <entry>
        Svarer til et af tegnene <literal>a</literal>,
        <literal>b</literal>, <literal>c</literal> eller
        <literal>d</literal>.  Men pas på.  Nogle systemer kan
        ignorere forskelle mellem store og små bogstaver og regne med
        enten det danske eller det latinske alfabet.
       </entry>
      </row>

      <row>
       <entry>[^a-d]</entry>
       <entry>
        Svarer til alt andet end tegnene <literal>a</literal>,
        <literal>b</literal>, <literal>c</literal> eller
        <literal>d</literal>.
       </entry>
      </row>

      <row>
       <entry>(Skåne|Sjælland|Hven)</entry>
       <entry>
        Svarer til netop én strengene <literal>Skåne</literal>,
        <literal>Sjælland</literal> og <literal>Hven</literal>.
       </entry>
      </row>

      <row>
       <entry>.*foo..ba[rz](fubar|qux).*quux</entry>

       <entry>
        <para>
         <!-- Tak Ole Tange. Tak, det er rigeligt! /chlor --> Svarer
         til nul eller flere vilkårlige tegn, efterfulgt af strengen
         <literal>foo</literal>.  Så to vilkårlige tegn efterfulgt af
         strengen <literal>ba</literal> og et af tegnene
         <literal>r</literal> eller <literal>z</literal>.  Dernæst
         strengen en af strengene <literal>fubar</literal> eller
         <literal>qux</literal> efterfulgt af nul eller flere
         vilkårlige tegn og så strengen <literal>quux</literal> til
         sidst.  Med dette udtryk ses det (let) at man kan finde
         filnavnene <filename>foo++barquxquux</filename> og
         <filename>XYZfoo77bazfubarYESquux</filename> i én og samme
         søgning.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!-- Nedenstående er fra Claus Sørensens referat efter
 Ole Tanges foredrag 2000-05-09 -->
<table id="regex-def">
<title>Definition af regulære udtryk</title>
<tgroup cols="2" align="char">
<thead><row>
 <entry>RegEx</entry>
 <entry>Beskrivelse</entry>
</row></thead>
<tbody>

<row>
 <entry>[tegn]</entry>
 <entry>Tegn der skal matches</entry>
</row>

<row>
 <entry>RE1RE2</entry>
 <entry>To forskellige regulære udtryk efter hinanden</entry>
</row>

<row>
 <entry>RE*</entry>
 <entry>Regulære udtryk skal passe nul eller flere gange</entry>
</row>

<row>
 <entry>RE?</entry>
 <entry>Regulære udtryk skal passe nul eller én gang. De regulære udtryk 
        som følger POSIX-standarden benyttes dog "RE\?". Se f.eks. 
        nedenstående eksempel med <command>slocate</command>.
</entry>
</row>

<row>
 <entry>RE+</entry>
 <entry>Regulære udtryk skal passe én eller flere gange</entry>
</row>

<row>
 <entry>RE1|RE2</entry>
 <entry>Det ene eller det andet udtryk</entry>
</row>

<row>
 <entry>(RE)</entry>
 <entry>Gruppe som bl.a. kan benyttes som variabel. I <command>vi</command>, 
        <command>emacs</command> og <command>sed</command> er det dog 
        "\(RE\)".</entry>
</row>

<row>
 <entry>^</entry>
 <entry>Start af linje</entry>
</row>

<row>
 <entry>$</entry>
 <entry>Slutning af linje</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
For at gøre det nemmere at skrive og læse regulære
udtryk, har man indført nogle forkortelser.
Den "rigtige" syntax for at matche bogstavet 'a',
er ved at skrive '[a]', men her kan man i stedet
blot skrive 'a' (uden anførselstegn).
</para>

<!-- forkortelser -->
<table id="regex-fork">
<title>Forkortelser af regulære udtryk</title>
<tgroup cols="2" align="char">
<thead><row>
 <entry>RegEx</entry>
 <entry>Beskrivelse</entry>
</row></thead>
<tbody>

<row>
 <entry>a = a{1} = [a] = [a]{1}</entry>
 <entry>Matcher tegnet 'a' én gang</entry>
</row>

<row>
 <entry>[\0-\m\o-\377] = .</entry>
 <entry>Matcher alle tegn undtagen \n</entry>
</row>

<row>
 <entry>[*] = \*</entry>
 <entry>Matcher tegnet '*'</entry>
</row>

<row>
 <entry>[abcd] = [a-d]</entry>
 <entry>Matcher en række tegn</entry>
</row>

<row>
 <entry>[\0-ac-\377] = [^b]</entry>
 <entry>Undlader at matche et tegn 'b'</entry>
</row>

<row>
 <entry>\d = [0-9]</entry>
 <entry>Matcher tallene 0-9</entry>
</row>

<row>
 <entry>[a][a][a] = aaa = a{3}</entry>
 <entry>Matcher serien af tre ens tegn 'aaa'</entry>
</row>

<row>
 <entry>[a][a][a]? = aaa? = a{2,3}</entry>
 <entry>Matcher serien af to til tre ens tegn 'a'</entry>
</row>

<row>
 <entry>a* = a{0,}</entry>
 <entry>Matcher ingen eller mange tegn 'a'</entry>
</row>

<row>
 <entry>a+ = aa* = a{1,}</entry>
 <entry>Matcher et eller mange tegn 'a'</entry>
</row>

<row>
 <entry>a? = a{0,1}</entry>
 <entry>Matcher ingen eller et tegn 'a'</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
Et simpelt eksempel på brug af ovenstående, kunne
være at matche en datoer i filen <filename>regex</filename>.
Herunder ses en del af fil, hvor nogle linjer kun
har en dato, og andre dato og en tekst.
Datoen er skrevet i ISO-8601 formatet, som også
kan udtrykkes som YYYY-MM-DD (&Aring;&Aring;&Aring;&Aring;-MM-DD).
</para>

<programlisting>
# En kommentar 2002-12-01
2002-12-27
2002-12-28 Linus Torvalds 33
</programlisting>

<para>
For at få listen over alle linjer der ikke indeholder
en kommentar, skrives så:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>egrep "^[^#]" regex</userinput>
2002-12-27
2002-12-28 Linus Torvalds 33
</screen>

<para>
Ovenstående giver nok ikke helt det ønskede resultat,
i tilfælde af at der er skrevet noget i filen der er en ugyldig dato.
Mere rigtigt vil det derfor være at matche datoerne.
Da der kan forekomme datoer i kommentarer, så skal
et match starte først på linjen, hvilket matches med '^'.
Dernæst skal første tegn være et tal.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>egrep "^[0-9]" regex</userinput>
2002-12-27
2002-12-28 Linus Torvalds 33
</screen>

<para>
Match af fire tal, kan enten skrives som:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>egrep "^[0-9][0-9][0-9][0-9]" regex</userinput>
</screen>

<para>
eller lidt mere overskueligt:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>egrep "^[0-9]{4}" regex</userinput>
</screen>

<para>
Et lidt mere præcist dato-match der både tjekker
år, måned og dag bliver så:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>egrep "^[0-9]{4}-[0-9]{2}-[0-9]{2}" regex</userinput>
</screen>

<para>
En mere løs form, hvor der kun matches tegn og bindestreger,
der er nem at læse, kunne være:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>egrep "^....-..-.." regex</userinput>
</screen>

<para>
Vil man kun have de linjer hvor der alene står en dato,
indsættes et '$'-tegn der angiver slutning af linje.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>egrep "^[0-9]{4}-[0-9]{2}-[0-9]{2}$" regex</userinput>
2002-12-27
</screen>

<para>
Det modsatte match hvor der kun vises linjer med dato og kommentar,
kan så fås ved at angive at der skal være et eller flere tegn efter
datoen. Det kan gøres ved at indsætte '.+'.
Ikke alle programmer forstår '+', så man kan også skrive '..*'
for at få det samme resultat.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>egrep "^[0-9]{4}-[0-9]{2}-[0-9]{2}.+$" regex</userinput>
2002-12-28 Linus Torvalds 33
</screen>

<para>
I datoer anvendes ret få tal, da der for eksempel kun er 12 måneder,
og maksimum 31 dage i en måned. Hvis man dertil også kun
ønsker årstal imellem 2000 og 2099, kan dette skrives som:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>egrep "^20[0-9]{2}-[01][0-9]-[0-3][0-9]" regex</userinput>
2002-12-27
2002-12-28 Linus Torvalds 33
</screen>

<para>
Da der kun er 12 måneder, kan dette matches lidt mere præcist
ved at tage højde for at andet tal kun kan være 0-9 hvis første
tal er et 0. Er første tal 1, kan andet tal kun være 0-2.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>egrep "^20[0-9]{2}-(0[0-9]|1[0-2])-[0-3][0-9]" regex</userinput>
2002-12-27
2002-12-28 Linus Torvalds 33
</screen>

<para>
De ovenstående eksempler viser så dels hvordan man kan skrive
forskelligt og få det samme output, og dels at man meget nemt
kan komme til at matche upræcist.
Netop med datoer er det meget komplekst at lave det fuldstændige
match, der også tager højde for skudår, så mindre kan i mange
tilfælde gøre det.
</para>

<para>
Et meget brugt regulært udtryk i tekst-programmer,
er udtrykket der bytter om på to ord.
Som eksempel kunne opgaven være at bytte "Linus Torvalds"
om til "Torvalds, Linus" i hele dokumentet.
Der skal så laves en søgning der dels matcher hvert ord,
men også 'fanger' ordene og lægger dem ind i variable.
Her bruges () til at 'fange' ordet og efterfølgende
kan 'fangsterne' findes i nummererede variable 1, 2, 3 osv.
</para>

<example id="regex-diff">
<title>Notation af regulære udtryk i forskellige programmer</title>

<para>
<emphasis>Perl</emphasis>:
<programlisting>
s/(Linus) (Torvalds)/$2, $1/
</programlisting>
</para>

<para>
<emphasis>Emacs</emphasis>:

<programlisting>
M-x replace-regexp RET
\(Linus\) \(Torvalds\) RET
\2, \1 RET
</programlisting>
</para>

<para>
<emphasis>vi</emphasis>:

<programlisting>
:%s/\(Linus\) \(Torvalds\)/\2, \1/g
</programlisting>
</para>

<para>
<emphasis>PHP</emphasis>:
<programlisting>
$a = preg_replace("/(Linus) (Torvalds)/", "\\2, \\1", $a);
</programlisting>
</para>

<para>
<emphasis>sed</emphasis>:
<programlisting>
sed 's/\(Linus\) \(Torvalds\)/\2, \1/'
</programlisting>
</para>

</example>

<para>
Der er altså en lille forskel i de forskellige programmer
på brugen af regulære udtryk, men princippet er det samme.
</para>

<!-- Eksempel -->

<para>
Et lille praktisk og anvendeligt eksempel er at finde
alle de filer på dine diske som enten ender på 
'.htm' eller '.html'.
I regulære udtryk betyder '.' alle tegn undtaget \n
så der skal en '\' foran.
Med 'l\?' angives det, at der enten skal være et 'l' eller intet tegn.
'$' angiver slutning på filnavnet (altså linjen).
Med <filename>slocate</filename> gøres dette således:
</para>

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>slocate -r '\.html\?$'</userinput>
</screen>

<para>
Et eksempel på et regulært udtryk kunne være at finde
alle brugernavne på systemet, som har brugergruppe-privilegier
under 100.
<filename>/etc/passwd</filename> indeholder oplysningerne.
</para>

<programlisting>
..
halt:*:7:0:halt:/sbin:/sbin/halt
..
</programlisting>

<para>
Brugernavn 'halt' tilhører gruppe '0' som angivet i fjerde kolonne.
I Perl kunne kommandoen se således ud:
</para>

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>perl -ne '/^[^:]+:[^:]+:[^:]+:..?:/ and print' /etc/passwd</userinput>
</screen>

<para>
Idéen i ovenstående er at gå tre kolonner frem, og se om der
står et eller to tegn imellem kolon.
Hvis udtrykket matches skal det printes ud.
'/' er skille-tegnet.
Der skal matches fra første tegn på linjen '^'.
'[^:]+:' betyder match et eller flere tegn som ikke
er kolon, frem til næste kolon.
Første match vil så være 'halt:'.
Dette kolonne-match er gentaget tre gange.
'..?:' matcher et eller to tegn, efterfulgt af kolon.
Da der kun står tal i denne kolonne, er det kun '0'-'9'
og '10'-'99' der vil blive listet.
</para>

<para>
Skal man matche det samme mange gange, måske flere end
tre, kan man bruge gentagelsesoperatoren {n},
hvor n er et range.
I førnævnte eksempel blev blokken '[^:]+:' gentaget
tre gange. Da det er en blok skal der parenteser omkring
før det virker: '([^:]+:){3}'.
Den færdige linje ser nu således ud:
</para>

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>perl -ne '/^([^:]+:){3}..?:/ and print' /etc/passwd</userinput>
</screen>

<para>
'.' matcher ethvert tegn og vil man være sikker på at
det kun er tal der bliver matchet, skal man skrive '[0-9]' i
stedet for '.'.
I Perl er '[0-9]' også forkortet til '\d' (eng: decimal number) 
så udtrykket kunne også se således ud:
</para>

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>perl -ne '/^([^:]+:){3}\d\d?:/ and print' /etc/passwd</userinput>
</screen>

<para>
Hjemmeopgaven er nu at forklare hvad '[^#]+#' og '[^;]+;' matcher.
Ekstraopgaven er '[^:]?:' og '[^:]*:'.
</para>

<para>
Beskrivelse af regulære udtryk kan findes i manualsiderne med kommandoen
<command>man 7 regex</command>.
</para>

<para>
Læs mere om regulære udtryk på
<ulink url="http://zez.org/article/articleview/11/1/">http://zez.org/article/articleview/11/1/</ulink>
</para>

</sect2><!-- regex -->


<sect2 id="redirect">
<title>Omdirigering</title>
<indexterm><primary>Redirection</primary></indexterm>
<indexterm><primary>&gt;</primary></indexterm>
<indexterm><primary>&lt;</primary></indexterm>
<indexterm><primary>&gt;&gt;</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>&gt;</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>&gt;</tertiary>
</indexterm>

<para>
Det er ikke altid hensigtsmæssigt at få outputtet fra en
kommando skrevet direkte på skærmen. Hvis du skriver
<command>ls /usr/bin</command>, vil du forstå hvorfor. Derfor er
det muligt at omdirigere output (eng. "redirect"). Til det formål
bruger du tegnet <command>&gt;</command> til at omdirigere outputtet til en
fil.</para>

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>ls /usr/bin &gt; usrbin.dir</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>less usrbin.dir</userinput>
</screen>

<para>
Andre gange har man brug for at tilføje nye linjer til en fil, hvilket 
sker ved at benytte to større-end-tegn efter hinanden 
<command>&gt;&gt;</command>. Dette bruges især til logfiler.
</para>

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>date &gt;&gt; tidsstempel</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>date &gt;&gt; tidsstempel</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>cat tidsstempel</userinput>
lør jul 29 17:03:29 CEST 2000
lør jul 29 17:03:31 CEST 2000
</screen>

<para>
Tilsvarende kan nogle programmer og kommandoer fødes med
indholdet af en fil ved at bruge <command>&lt;</command>
</para>

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>cat &lt; usrbin.dir</userinput>
</screen>

<para>
Hvilket dog i tilfældet med <command>cat</command> er det samme 
som <command>cat usrbin.dir</command>.
</para>

<para>
Du kan også sende skreven tekst ind til et program som forventer
tastetryk. Nedenstående lille program svarer "y" på et spørgsmål som
"Interaktivkommando", beder brugeren at svare på.
</para>


<programlisting>
#!/bin/sh
Interaktivkommando &lt;&lt;EOF
y
EOF
</programlisting>


</sect2>

  <sect2 id="kanaler">
   <title>Kanaler</title>

   <indexterm>
    <primary>kanal</primary>
   </indexterm>

   <indexterm>
    <primary>| (kanal)</primary>
   </indexterm>

   <indexterm>
    <primary>pipe</primary>
   </indexterm>

   <indexterm>
    <primary>kommandooversigt</primary>
    <secondary>| (kanal)</secondary>
   </indexterm>

   <indexterm>
    <primary>kommandooversigt</primary>
    <secondary>grundlæggende kommandobeskrivelse</secondary>
    <tertiary>| (kanal)</tertiary>
   </indexterm>

<para>
Som du så i det foregående afsnit, kan du omdirigere uddata til en
fil.  Nu kan du med rette spørge hvorfor du skal omdirigere til en
fil, hvis du kun skal se på den én gang? Svaret på dit spørgsmål er
ligefremt: Det behøver du heller ikke. Du kan nemlig anvende en
kanal.  I Linux betyder det, at uddata fra et
program bruges som inddata til et andet.  Lad os give et lille
eksempel:

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ls /usr/bin | less</userinput>
</screen>
</para>

<para>
Den lodrette streg (<command>|</command>) sætter en kanal op, så
uddata fra <command>ls /usr/bin</command> kanaliseres videre og
bruges som inddata til <command>less</command>. Det er naturligvis
muligt at sætte en hel række kanaler op efter hinanden og på den
måde slippe for en masse midlertidige filer.
</para>

   <para>
    På amerikansk kaldes denne slags kanaler for »pipes«.
   </para>
  </sect2>

<sect2 id="grep">
<title>Programmet grep</title>
<indexterm><primary>grep</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>grep</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>grep</tertiary>
</indexterm>
<para>Ofte vil du fra kommandoer som <command>cat</command>,
<command>ls</command> og <command>find</command> få alt for meget
information, og oftest ved du godt, at det kun er en begrænset del af
de viste linjer tekst, du er interesseret i. Hvis du f.eks. kun
skal bruge de linjer af <filename>/etc/passwd</filename>, der indeholder
navnet "tyge", kan du bruge <command>grep</command> til at
begrænse outputtet med.
</para>

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>cat /etc/passwd | grep tyge </userinput>
tyge:x:501:501:Tyge Brahe,,,,:/home/tyge:/bin/bash
</screen>

<para>
Du kan også bruge de forskellige i kombination. Eksemplet her 
finder filer i <filename>/usr/bin</filename> som begynder med p 
og indeholder ordet mail i filnavnet. 
</para>

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>ls /usr/bin | grep ^p | grep mail</userinput>
patch-metamail
pilot-mail
printmail
procmail
</screen>

<para>
Hvilket også kunne have være gjort med kommandoen 
<command>ls /usr/bin | grep ^p.*mail</command>
</para>

</sect2>
</sect1>

<sect1 id="process">
<title>Proces-kontrol</title>
<indexterm><primary>ps</primary></indexterm>
<indexterm><primary>processer</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>ps</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>ps</tertiary>
</indexterm>
<para>
Når du starter et program op, bliver det til et kørende
program. Et kørende program kaldes i Unix-sammenhænge for en
proces (eng. "process"). Hver proces har en unik indikator, som er et
heltal. Vi kalder denne indikator for PID, hvilket kommer af det engelske
"Process IDentifier".
</para>

<sect2 id="ps">
<title>ps viser processer</title>
<para>
Hvis du vil se hvilke programmer du har kørende, kan du bruge
kommandoen <command>ps</command>. <command>ps</command> er en
forkortelse for "process".
</para>

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt> <userinput>ps</userinput>
  PID TTY STAT TIME COMMAND
  435  2   S   0:00 /bin/login -- tyge
  436  2   S   0:00 -bash
  447  2   R   0:00 ps
<prompt>[tyge@hven MitKatalog]$ </prompt>
</screen>

<para>
Ovenstående dialog viser, at der er et kørende program
(<command>ps</command>) og to sovende
(<command>/bin/login</command> og <command>bash</command>). At et
program er kørende, ser du ved, at der under
<filename>STAT</filename> står et "R" (for "running"), mens et sovende
program i status-feltet har et "S" (for "sleeping"). En sovende
proces er en proces, som er blevet startet, men ikke er aktiv, og
nu står og venter på at blive aktiveret. Feltet, hvor der står
<filename>TTY</filename>, viser, fra hvilken terminal programmet blev
startet. I Linux kan du skifte mellem flere virtuelle konsoller, og
hver virtuel konsol opfattes som en terminal.</para>

<para>
Det skal nævnes at <command>ps</command> kun viser processer med samme
tty (samme terminal) som <command>ps</command>, og du kan anvende
<command>ps aux</command> til at se alle processer.
</para>

<para>
Vil du se <emphasis>alt</emphasis> hvad der kører på maskinen og
se hvilke programmer, der kalder hinanden, da kan
</para>

<screen>
<prompt>[tyge@hven MitKatalog]$</prompt> <userinput>ps auxfww</userinput>
USER PID %CPU %MEM VSZ  RSS    TTY  STAT START TIME COMMAND
.... forkortet
tyge 2930 0.0  3.4 19544 6548  ?    S    21:05  0:00 kdeinit: Running...
tyge 2960 0.1  6.0 22760 11484 ?    S    21:05  0:15  \_ kdeinit: kwin
tyge 3086 0.1  6.9 24940 13192 ?    S    21:07  0:14  \_ kdeinit: konsole -icon konsole -miniicon konsole
tyge 3088 0.0  0.8  2868 1628 pts/1 S    21:07  0:01  |   \_ -bin/tcsh
tyge 3116 1.2  4.6 11660 8972 pts/1 S    21:07  1:59  |   |   \_ emacs mandrake.sgml
tyge 4131 0.0  0.9  3224 1820 pts/1 S    23:33  0:00  |   |   \_ zsh
tyge 4142 0.0  0.7  2732 1516 pts/1 S    23:33  0:00  |   |       \_ -csh
tyge 4167 0.0  0.8  2848 1604 pts/1 S    23:33  0:00  |   |           \_ bash
tyge 4172 0.0  0.7  2728 1512 pts/1 S    23:33  0:00  |   |               \_ -sh
tyge 4197 0.0  0.7  2672 1408 pts/1 S    23:33  0:00  |   |                   \_ -csh
</screen>

<para>
I eksemplet er vist en "syg" konstruktion, hvor sidste linje viser at man har startet
<command>csh</command> op i <command>sh</command>, som igen er startet
op i <command>bash</command>, som igen...  Vil man vide hvilke af
processerne der indeholder et søgeord &ndash; f.eks. ens eget login-navn, da
kan man filtere med
<command>ps auxfww | grep S&Oslash;GEORD</command>.
</para>
</sect2>

<sect2 id="top">
<title>Få et bedre overblik ved at bruge top</title>
<indexterm>
<primary>top</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>top</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>top</tertiary>
</indexterm>
<para>Som du så i foregående afsnit, kan <command>ps</command>
bruges til at få et overblik over, hvilke processer du har
kørende. Problemet er, at du kun får et statisk billede. Hvis du
er interesseret i et mere dynamisk billede af din computers processer,
kan du bruge programmet <command>top</command>. <command>top</command>
opdaterer skærmen hvert femte sekund. Ved at trykke på "i" skifter
du mellem "non-idle"-modus og almindelig modus. I "non-idle"-modus ser du
kun de processer, som er aktive, mens du i almindelig modus ser alle.
Du afslutter <command>top</command> ved at trykke på
"q".</para>

<para><command>top</command> leverer mange oplysninger, og derfor er
det spændende at bruge programmet. Endvidere er det værd at
læse programmets man-page.</para>
</sect2>

<sect2 id="baggrunden">
<title>At køre programmer i baggrunden</title>
<indexterm><primary>Baggrundsprocesser</primary></indexterm>
<indexterm>
 <primary>fg</primary>
</indexterm>
<indexterm>
 <primary>&amp;</primary>
</indexterm>
<indexterm>
 <primary>^z</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>fg</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>fg</tertiary>
</indexterm>
<indexterm>
 <primary>bg</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>bg</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>bg</tertiary>
</indexterm>
<para>
Alle de kommandoer, vi har præsenteret dig for i dette
kapitel, har taget meget kort tid at udføre. Antag, at du ønsker
at køre et program eller kommando, som tager en time at udføre. Hvis
du nu startede programmet op på kommandolinjen, kunne du ikke
udføre andre kommandoer i en time, da du ikke kunne komme til at
taste nye kommandoer ind. Det er naturligvis ikke så smart, især
ikke da Linux er et ægte multitasking styresystem!</para>

<para>
Du kan løse dit ventetidsproblem ved at udføre
programmet eller kommandoen i baggrunden. For at udføre et program i
baggrunden sætter vi et <command>&amp;</command> efter kommandoen.
Et program der tager noget tid at køre, hvis du har mange filer,
er <command>updatedb</command>. <command>updatedb</command> opretter
den database der bruges af <command>locate</command>, og det tager
typisk lang tid at køre denne kommando.
</para>

<screen>
<prompt>[root@hven root]$ </prompt><userinput>updatedb &amp;</userinput>
[1] 7446
<prompt>[root@hven root]$ </prompt><userinput>ps</userinput>
  PID TTY          TIME CMD
 7413 pts/2    00:00:00 su
 7416 pts/2    00:00:00 bash
 7446 pts/2    00:00:00 updatedb
 7447 pts/2    00:00:00 slocate
 7448 pts/2    00:00:00 ps
<prompt>[root@hven root]$ </prompt><userinput>cat /proc/loadavg</userinput>
1.14 1.02 0.50 1/113 7479
[1]+  Done                    updatedb
<prompt>[root@hven root]$ </prompt>
</screen>

<para>
Programmet eller kommandoen kører nu samtidig
med at du kan indtaste og udføre nye kommandoer. Grunden til vi
siger, at programmet kører i baggrunden er, at du ikke sidder med
det ved din konsol (som vi så kalder for forgrunden).
Så mens <command>updatedb</command> kører i baggrunden, kan vi
så kører kommandoen <command>ps</command> og se processen.
Efter at have tastet en del andre kommandoer, her illustreret
ved <command>cat /proc/loadavg</command>, er <command>updatedb</command>
færdig med at køre, og kommer ud og skriver "Done".
Her er det så baggrundsprocess nummer [1] der er færdig med at køre.
<command>&amp;</command>-kommandoen bruges på direkte fra
kommandolinjen og inde i shell-scripts.
</para>

<para>
Glemte du <command>&amp;</command> sidst på kommandolinjen, så kan du
trykke Ctrl-z og så har du suspenderet jobbet (eng. "suspended"). Med
<command>fg</command> 
(eng. "foreground") og <command>bg</command> (eng. "background") kan
du styre hvad der er aktivt.
</para>

<screen>
<prompt>[root@hven root]$ </prompt><userinput>updatedb</userinput>
(tast Ctrl-z)
[1]+  Stopped                 updatedb
<prompt>[root@hven root]$ </prompt><userinput>bg</userinput>
[1]+ updatedb &amp;
<prompt>[root@hven root]$ </prompt>
</screen>

<para>
Har du fået sat et job igang i baggrunden, som du gerne
vil stoppe, skal du først tilbage til programmet med
<command>fg</command>. Tast dernæst Ctrl-c for at stoppe
programmet.
</para>

<screen>
<prompt>[root@hven root]$ </prompt><userinput>updatedb &amp;</userinput>
[1] 7446
<prompt>[root@hven root]$ </prompt><userinput>fg</userinput>
updatedb
(tast Ctrl-c)
<prompt>[root@hven root]$ </prompt>
</screen>

<para>
Ctrl-z kan med fordel bruges mange steder. Det kunne være indefra
dit post-program eller din tekst-editor.
Situationen er at du sidder og er igang med at skrive et script, og så
vil du lige prøve det. Efter afprøvning vil du tilbage samme sted
i editoren, og stå det samme sted med markøren.
Herunder er vist at editoren startes. Så tastes Ctrl-z og scriptet
afprøves, hvilket giver en fejl.
Til slut tilbage til editoren med kommandoen <command>fg</command>.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>vi entest</userinput>
(inde i editoren tastes Ctrl-z)
<prompt>[tyge@hven ~]$ </prompt> <userinput>./entest</userinput>
entest: line 4: syntax error: unexpected end of file
<prompt>[tyge@hven ~]$ </prompt> <userinput>fg</userinput>
</screen>

<para>
Det er muligt at have flere programmer kørende i baggrunden samtidigt.
Det kan hurtigt blive lidt uoverskueligt at gøre det, men det vil i
nogle tilfælde være en fordel.
For overskueligehedens skyld anvendes i det følgende blot kommandoen
<command>sleep</command>, der holder en pause på nogle sekunder
for så at returnerer til prompten.
Ved at starte <command>sleep 100</command> og <command>sleep 200</command>
skulle det være lidt nemmere at følge med i hvilket program man vender
tilbage til. Herunder starter vi så de to kommandoer, og vender så
tilbage til 
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>sleep 100 &amp;</userinput>
[1] 7533
<prompt>[tyge@hven ~]$ </prompt><userinput>sleep 200 &amp;</userinput>
[2] 7534
<prompt>[tyge@hven ~]$ </prompt><userinput>fg</userinput>
sleep 200
</screen>

<para>
Ovenstående er helt som ønsket, hvis det altså er process 2 man vil
tilbage til.
Hvis man i stedet vil tilbage til process 1, skal kommandoen
<command>%1</command> bruges, hvilket angiver baggrundsprocess
nummer 1.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>sleep 100 &amp;</userinput>
[1] 7533
<prompt>[tyge@hven ~]$ </prompt> <userinput>sleep 200 &amp;</userinput>
[2] 7534
<prompt>[tyge@hven ~]$ </prompt> <userinput>%1</userinput>
sleep 100
</screen>

<para>
Og selvfølgelig kan man starte flere programmer samtidigt på
kommandolinjen og lægge dem alle i baggrunden, så de
stadig kører samtidigt.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>sleep 100 &amp; sleep 200 &amp;</userinput>
[1] 7550
[2] 7551
<prompt>[tyge@hven ~]$ </prompt>
</screen>

<para>
Er du startet op i grafisk tilstand og gerne vil starte et
grafisk program, men ikke lige vil flytte hånden over til musen
og bruge menuerne, så er det:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>gimp &amp;</userinput>
</screen>

</sect2><!-- id="baggrunden" -->

<sect2 id="koerflere">
<title>Kør flere programmer efter hinanden</title>
<indexterm><primary>Start flere programmer efter hinanden</primary></indexterm>
<indexterm><primary>;</primary></indexterm>
<indexterm><primary>&amp;&amp;</primary></indexterm>
<indexterm><primary>&gt;</primary></indexterm>
<indexterm><primary>md5sum</primary></indexterm>

<para>
Ofte har man brug for at køre flere programmer efter hinanden flere gange
på kommandolinjen.
Nu kan man jo blot taste pil op et par gange, og køre kommandoen igen.
Som eksempel er det følgende to kommandoer vi vil kører gentagende gange.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>date&gt;foo</userinput>
<prompt>[tyge@hven ~]$ </prompt> <userinput>md5sum foo</userinput>
7643ce159d2b9269e21cdd1fb88f79ba  foo
<prompt>[tyge@hven ~]$ </prompt>
</screen>

<para>
Ovenstående kunne løses ved at lave et script med disse to linjer,
men det er lidt meget at gøre ud af det, når scriptet ikke senere skal bruges til noget.
I stedet kan man sætte et <command>;</command> (semikolon) imellem,
og derved først køre det ene program, efterfulgt af det andet.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>date&gt;foo ; md5sum foo</userinput>
6d1a33063a8eba547c278a9776b7b59d  foo
<prompt>[tyge@hven ~]$ </prompt>
</screen>

<para>
I ovenstående eksempel sker der nok ikke nogen fejl &ndash; tror vi.
Nu kunne man være så uheldig at filen <filename>foo</filename>
var skrivebeskytte, hvilket gør at der ikke bliver skrevet nye data til filen.
Dette beyder så at det ikke giver mening efterfølgende at køre <command>md5sum</command>.
Først et eksempel på hvor galt det kan gå.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>date&gt;foo ; md5sum foo</userinput>
bash: foo: Permission denied
6d1a33063a8eba547c278a9776b7b59d  foo
<prompt>[tyge@hven ~]$ </prompt> <userinput>date&gt;foo ; md5sum foo</userinput>
bash: foo: Permission denied
6d1a33063a8eba547c278a9776b7b59d  foo
<prompt>[tyge@hven ~]$ </prompt>
</screen>

<para>
Problemet er at kommandoen <command>md5sum</command> bliver kørt, til
trods for at det gik galt med den forgående kommando.
Som vist bliver der hele tiden udregnet den samme md5-sum, hvilket ikke var meningen.
Dette kan løses ved i stedet at bruge kommandoen <command>&amp;&amp;</command>.
Derved bliver den næste kommando kun kørt, hvis den første gik godt.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>date&gt;foo &amp;&amp; md5sum foo</userinput>
bash: foo: Permission denied
<prompt>[tyge@hven ~]$ </prompt>
</screen>

<para>
Et mere praktisk eksempel på ovenstående vil være at kompilere en Linux-kerne.
Først <command>make dep</command>, så <command>make</command>, så osv. osv.
Men de efterfølgende kommandoer må kun køres hvis den forgående gik godt.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>cd /usr/src/linux</userinput>
<prompt>[tyge@hven linux]$ </prompt> <userinput>make dep &amp;&amp; make &amp;&amp; make install</userinput>
</screen>

<para>
Eksemplet med <command>make</command> vil man både bruge på kommandolinjen
og i shell-scripts.
Et andet eksempel som typisk kun ville blive brugt i shell-scripts,
kunne være først at teste om en fil eksiterer, og i herefter gøre noget
med den.
</para>

<programlisting>
#! /bin/sh
[ -e foo ] &amp;&amp; md5sum foo
</programlisting>

<para>
Mange syntes ikke om den måde at skrive det på,
og det er nok også nemmere at læse det,
hvis der i stedet står:
</para>

<programlisting>
#! /bin/sh
if [ -e foo ]; then
	md5sum foo
fi
</programlisting>

<para>
Kommandoen <command>[</command> er blot et symlink til <command>test</command>.
Læs om den under <command>man test</command>.
</para>

</sect2><!-- id="koerflere" -->

<sect2 id="subshell">
<title>Start en sub-shell på kommandolinjen</title>
<indexterm>
 <primary>( )</primary>
</indexterm>
<indexterm>
 <primary>Sub-shell</primary>
</indexterm>

   <para>
    Når man starter en ny kommandofortolker, får man nye omgivelser
    (eng. environment) som programmet køres i.  Dette ses når man har et
    kommandofortolkerprogram hvor systemvariable ændres eller tilføjes, eller
    der skiftes til et andet katalog.  Når programmet er færdigt med at køre,
    er alt tilbage ved det gamle.  Til tider kan det være nemmere ikke at
    skulle oprette et program først, men blot skrive det hele direkte på
    kommandolinjen.  Først et lille simpelt eksempel som et program, der
    først skifter til kataloget <filename>/tmp</filename> og dernæst lister
    filerne.  Tricket er, at når programmet er færdigt med at køre, står vi
    igen i samme katalog som vi kaldte programmet fra.

<programlisting>
#! /bin/sh
cd /tmp ; ls
</programlisting>
   </para>

   <para>
    For at gøre det samme på kommandolinjen skal der blot paranteser omkring:

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>(cd /tmp ; ls)</userinput>
</screen>
   </para>

   <para>
    Det eneste "ødelæggende" der skete ved ovenstående, var at der blev
    skiftet til et andet katalog, men det kunne også være en variabel der
    blev ændret:

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>(cd /tmp ; PATH=. ; min_test)</userinput>
</screen>
   </para>

<para>
Et mere praktisk eksempel der er besværligt at løse uden brug af "()",
kan illustreres ved noget hvor der skal holdes en pause.
Som vist før kan man blot udskifte det som står imellem paranteserne
med et script, hvilket i det følgende ikke er praktisk.
</para>

<para>
Vil man gerne vide lidt om hvordan en web-server er sat op,
kan dette gøres med <command>telnet</command> og brug af HTTP-protokollen.
Først åbnes en forbindelse til port 80.
Når man får en forbindelse, indtastes HEAD-kommandoen og så venter man indtil
der kommer et svar.
Manuelt gøres det således:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>telnet www.sslug.dk 80</userinput>
Trying 130.228.2.150...
Connected to ns.sslug.dk (130.228.2.150).
Escape character is '^]'.
<userinput>HEAD / HTTP/1.0</userinput>

HTTP/1.1 200 OK
Date: Wed, 24 Jul 2002 07:21:16 GMT
Server: Apache/1.3.26 (Unix) (Red-Hat/Linux) OpenSSL/0.9.5a PHP/3.0.18
Last-Modified: Wed, 24 Jul 2002 04:45:00 GMT
Connection: close
Content-Type: text/html; charset=iso-8859-1

Connection closed by foreign host.
</screen>

<para>
Bemærk at efter <command>HEAD</command> skal der tastes ENTER to gange.
Her kunne man være fristet til at kanalisere HEAD-kommandoen direkte til
<command>telnet</command>, men det går ikke da forbindelsen bliver lukket
inden der kommer ouput retur fra web-serveren.
En lille pause på et par sekunder med <command>sleep</command> løser problemet,
men så skal kommandoen indkapsles med ().
Det færdige eksempel er så:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>(echo -e "HEAD / HTTP/1.0\n"; sleep 2) | telnet www.sslug.dk 80</userinput>
</screen>

<para>
Som før nævnt, kan det der står i parantes skrives i et script:
</para>

<programlisting>
#! /bin/sh
echo -e "HEAD / HTTP/1.0\n"
sleep 2
</programlisting>

</sect2><!-- id="subshell" -->

<sect2 id="procsubst">
<title>Proces substituering</title>
<indexterm><primary>&lt;( )</primary></indexterm>
<indexterm><primary>Process Substitution</primary></indexterm>
<indexterm><primary>Output til fil</primary></indexterm>
<indexterm><primary>Temporær fil</primary></indexterm>
<para>
Man kommer til tider ud for at man bliver 
nødt til at oprette midlertidige filer, der senere
skal bruges af et andet program.
Nogle programmer kan kun tage filer som input,
og hvis output kommer fra en proces, skal der gøres noget andet.
Disse midlertidige filer skal til slut slettes,
hvilket ofte ikke er noget problem.
Med kommandoen <command>&lt;()</command> kan man
undgå dette midlertidige trin.
</para>

<para>
Programmer såsom <command>tar</command>, <command>diff</command>
og <command>comm</command> skal bruge filer som input på
kommandolinjen.
Er input til disse programmer så noget der kommer fra en proces,
vil man typisk gemme dette i en midlertidig fil.
Her er et eksempel på hvordan det kunne se ud med et shell-script:
</para>

<programlisting>
#! /bin/sh
# Find filer der skal tages backup af:
find | egrep "\.c$" > temp
# 'tar' filerne nævnt i 'temp'
tar cvf backup.tar -T temp
# Ryd op
rm -f temp
</programlisting>

<para>
Ovenstående program er måske overskueligt, men man skal
stadig huske at fjerne midlertidige filer, og man skal
finde på et godt midlertidigt navn til sin
<filename>temp</filename>-fil.
I stedet for at oprette en midlertidig fil, kan man tage
output fra <command>find</command> og lave dette om til
noget der for <command>tar</command> ligner en fil.
Med <command>&lt;()</command> (processubstituering) bliver det så:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>tar cvf backup.tar -T &lt;(find | egrep "\.c$")</userinput>
</screen>

<para>
<command>tar</command> opfatter <command>&lt;()</command> som en fil, og behandler
den på denne måde.
Lad os lige prøve at se om ikke systemet selv kan forklare hvad
en <command>&lt;()</command> er.
Hvis nu <command>&lt;()</command> er en fil, så ville man kunne
skrive filnavnet ud på skærmen.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>echo &lt;(true)</userinput>
/dev/fd/63
</screen>

   <para>
    Her ses at der bare oprettes noget der ligner en midlertidig fil et
    eller andet sted, som <command>bash</command> selv holder styr på.
    Hvis man så har to gange <command>&lt;()</command> på kommandolinjen,
    kan <command>bash</command> stadig håndtere det:

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>echo &lt;(true) &lt;(true)</userinput>
/dev/fd/63 /dev/fd/62
</screen>
   </para>

   <para>
    <command>&lt;()</command> ser ud som en fil, men er rent faktisk
    en <emphasis>kanal</emphasis>, hvilket er mere effektivt end at
    bruge en fil.  Følgende kommandoer giver lidt yderligere
    information:

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ls -l &lt;(true)</userinput>
lr-x------    1 tyge  tyge      64 Jul 25 20:15 /dev/fd/63 -> pipe:[100342]
<prompt>[tyge@hven ~]$ </prompt><userinput>stat &lt;(true)</userinput>
  File: "/dev/fd/63" -> "pipe:[100408]"
  Size: 64              Blocks: 0          IO Block: 0      Symbolic Link
Device: 3h/3d   Inode: 419070015   Links: 1
Access: (0500/lr-x------)  Uid: (  506/    tyge)   Gid: (  512/    tyge)
Access: Fri Jul 25 20:16:21 2002
Modify: Fri Jul 25 20:16:21 2002
Change: Fri Jul 25 20:16:21 2002
</screen>
   </para>

   <para>
    Ovenstående eksempel med <command>tar</command> kan selvfølgelig
    løses på mange andre måder, hvor <command>&lt;()</command> ikke er
    nødvendigt. Til gengæld skulle det lille eksempel være nemmere at
    forstå.  Et mere drilsk eksempel kan laves med
    <command>comm</command>, der er et program til at sammenligne
    filer.  Ved almindelig brug anvendes det således:

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>comm fil-1 fil-2</userinput>
</screen>
   </para>

   <para>
    Nu kan man være så uheldig at de filer der skal undersøges er
    uddata fra for eksempel <command>grep</command>.  Uden brug af
    <command>&lt;()</command> kunne et shell-script se således ud:

<programlisting>
#! /bin/sh
grep foo test1 &gt; fil-1
grep foo test2 &gt; fil-2
comm fil-1 fil-2
rm -f fil-1 fil-2
</programlisting>
   </para>

   <para>
    Omskrevet med <command>&lt;()</command> bliver det blot en enkelt
    linje:

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>comm &lt;(grep foo test1) &lt;(grep foo test2)</userinput>
</screen>
   </para>

   <para>
    For mere information om <emphasis>processubstituering</emphasis>
    (eng. "process substitution") se <ulink
    url="http://www.tldp.org/LDP/abs/html/process-sub.html">http://www.tldp.org/LDP/abs/html/process-sub.html</ulink>
   </para>
  </sect2>

  <sect2 id="kill">
   <title>Dræb en proces</title>

   <indexterm>
    <primary>stop</primary>
    <secondary>et program</secondary>
   </indexterm>

   <indexterm>
    <primary>afliv</primary>
    <secondary>et program</secondary>
   </indexterm>

   <indexterm>
    <primary>kill</primary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>kill</secondary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>Grundlæggende kommandobeskrivelse</secondary>
    <tertiary>kill</tertiary>
   </indexterm>

   <para>
    Nu kan det ske, at du har fået startet et program, som du bliver
    træt af. Du vil altså gerne afbryde det, inden det er kørt
    færdigt. Unix-verdenen er barsk, for man taler ikke om at afbryde
    en proces, men om at slå den ihjel (eng. "kill"). Når du vil slå
    en proces ihjel, kan du bruge kommandoen
    <command>kill</command>. Som argument til <command>kill</command>
    giver du PID. Nedenfor er vist et eksempel.

<screen>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ps</userinput>
  PID TTY STAT TIME COMMAND
  435  2   S   0:00 /bin/login -- tyge
  436  2   S   0:00 -bash
  447  2   R   0:00 ps
  585  2   R   2:34 ls
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>kill 585</userinput>
<prompt>[tyge@hven MitKatalog]$ </prompt><userinput>ps</userinput>
  PID TTY STAT TIME COMMAND
  435  2   S   0:00 /bin/login -- tyge
  436  2   S   0:00 -bash
  763  2   R   0:00 ps
</screen>
   </para>

   <para>
    Det skal også nævnes, at enkelte gange kan en proces være kørt
    helt i skoven, og så må du tage kraftigere skyts i brug. I stedet
    for <command>kill PROCESNUMMER</command> kan du bruge
    <command>kill -9 PROCESNUMMER</command>.  Forskellen er at
    <command>kill</command> som standard sender en besked til
    programmet om at det skal stoppe, mens man med <command>kill
    -9</command> beder linuxkernen om at tage sig af at stoppe
    programmet.
   </para>
  </sect2>
 </sect1>

<sect1 id="miljoevar">
<title>$variable, export og env</title>
<indexterm><primary>env</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>env</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>env</tertiary>
</indexterm>
<indexterm><primary>export</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>export</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>export</tertiary>
</indexterm>
<indexterm><primary>systemvariable</primary></indexterm>
<indexterm><primary>miljø-variable</primary></indexterm>
<indexterm><primary>environment-variable</primary></indexterm>
<indexterm><primary>variable</primary></indexterm>
<indexterm><primary>$</primary></indexterm>
<indexterm><primary>$PATH</primary></indexterm>
<indexterm><primary>$HOME</primary></indexterm>
<indexterm><primary>$SHELL</primary></indexterm>
<indexterm><primary>$DISPLAY</primary></indexterm>
<indexterm><primary>PATH</primary></indexterm>
<indexterm><primary>HOME</primary></indexterm>
<indexterm><primary>SHELL</primary></indexterm>
<indexterm><primary>DISPLAY</primary></indexterm>

<para>
I Unix (og dermed Linux) bruger man ofte systemvariable (eng. "environment
variables") til at gemme vigtig opsætningsinformation for de enkelte
programmer eller for hele systemets virkemåde. Prøv f.eks. at
skrive:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>env</userinput>
PWD=/home/tyge/linuxbog
VENDOR=intel
PAGER=less
.
.
.
</screen>

<para>
Der kom mange linjer, som alle er formateret "VARIABEL=V&AElig;RDI".
Linjen "PWD" betyder f.eks. at jeg nu står i kataloget
<filename>/home/tyge/linuxbog</filename>. De fleste er sat af
systemet, mens brugeren kan vælge at tilføje nye eller overskrive de
eksisterende. Typisk vil dette ske i <filename>~/.profile</filename>
hvis brugeren anvender <command>bash</command>-shellen. Lad os se om
det er tilfældet:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>env | grep SHELL</userinput>
SHELL=/bin/bash
</screen>

<para>
En nem måde at se alle variable på er at skrive:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>echo $&lt;TAB&gt;&lt;TAB&gt;</userinput>
$BASH            $HOME            $OPTERR          $SECONDS
$BASH_VERSINFO   $HOSTNAME        $OPTIND          $SHELL
$BASH_VERSION    $HOSTTYPE        $OSTYPE          $SHELLOPTS
$COLORS          $IFS             $PATH            $SHLVL
$COLUMNS         $LANG            $PIPESTATUS      $TERM
$DIRSTACK        $LESSOPEN        $PPID            $UID
$ENV             $LINENO          $PROMPT_COMMAND  $USER
$EUID            $LINES           $PS1             $USERNAME
$GROUPS          $LOGNAME         $PS2             $_
$HISTCMD         $LS_COLORS       $PS4             $ftp_proxy
$HISTFILE        $MACHTYPE        $PWD             $http_proxy
$HISTFILESIZE    $MAIL            $QTDIR           $langfile
$HISTSIZE        $MAILCHECK       $RANDOM          $sourced
</screen>

<para>
Man kan også se <command>set</command> eller
<command>printenv</command> for flere eksempler på bash-variable.
</para>

<para>
Skal man så bruge den variabel i en udprintning, f.eks. på skærmen,
anvendes $VARIABEL til at tilgå værdien:
</para>

<indexterm>
 <primary>echo</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>echo</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>echo</tertiary>
</indexterm>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>echo "Jeg bruger $SHELL"</userinput>
Jeg bruger /bin/bash
</screen>

<para>
Vil du sætte systemvariable, så er syntaksen <command>export VARIABEL=V&AElig;RDI</command>.
</para>

<para>
Lad os se på et par af de meget anvendte variable.
$HOME (eller $USER) Beskriver stien til en brugers hjemmekatalog. Ofte
er denne sat til <filename>/home/BRUGERNAVN</filename>
</para>

<para>
 <literal>$PATH</literal> er en liste med de kataloger kommandofortolkeren
 skal gennemsøge for at finde et program, hvis man ikke eksplicit angiver den
 fulde sti til det. Ofte har en normal bruger ikke "<filename>/sbin</filename>"
 i sin <literal>$PATH</literal> mens systemadministratoren har.
</para>

<para>
For at rette i $PATH se <filename>/etc/profile</filename> hvis
ændringerne skal gælde alle brugere. Man kan også skrive "export
PATH=$PATH:/home/mig/bin" Hvis man gerne vil have at ens shell også
skal søge efter de programmer man har lagt i
<filename>/home/mig/bin</filename>.
</para>

<para>
$DISPLAY angiver hvilken X-server man vil have at et program skal vises
på. Når du starter X, binder skærmen sig til 0:0 normalt på Ctrl + Alt
+ F7, man kan starte en ny X-server på 0:1 (F8) med <command>startx --
:1</command> hvis man har lyst til det.
</para>

</sect1>

<sect1 id="rette-tekstfiler">
<title>Rette i tekstfiler</title>

<indexterm>
 <primary>Rette i tekstfiler</primary>
</indexterm>
<indexterm>
 <primary>tekstfiler</primary>
</indexterm>
<indexterm>
 <primary>nedit</primary>
</indexterm>
<indexterm>
 <primary>Editorer</primary>
 <secondary>nedit</secondary>
</indexterm>
<indexterm>
 <primary>kwrite</primary>
</indexterm>
<indexterm>
 <primary>Editorer</primary>
 <secondary>kwrite</secondary>
</indexterm>
<indexterm>
 <primary>gedit</primary>
</indexterm>
<indexterm>
 <primary>Editorer</primary>
 <secondary>gedit</secondary>
</indexterm>
<indexterm>
 <primary>gnp</primary>
</indexterm>
<indexterm>
 <primary>Editorer</primary>
 <secondary>gnp</secondary>
</indexterm>
<para>
Indtil videre har du set, hvordan du kan manipulere filer, men det er
ofte meget nyttigt at kunne redigere i en tekstfil. 
Se <xref linkend="editorer"/> 
for en omtale af nogle af de editorer der findes til Linux/Unix i tekstmodus.
</para>
</sect1>

<sect1 id="Unix-mere">
<title>Flere Unix-kommandoer</title>

<para>
I dette appendiks vil vi gennemgå en række Unix/Linux-kommandoer.
Gennemgangen er overfladisk, men du kan finde flere
oplysninger i programmernes brugsanvisninger. Desuden er 
<ulink url="http://www.sslug.dk/artikler/begyndertips.html">http://www.sslug.dk/artikler/begyndertips.html</ulink>
et godt sted at få mere information.
</para>

<sect2 id="Unixapp-redirect">
<title>Mere om omdirigering</title>


<para>
Linux (som Unix) arbejder med følgende input/output terminologi:
</para>
<indexterm>
 <primary>stdout</primary>
</indexterm>
<indexterm>
 <primary>stderr</primary>
</indexterm>
<para>
<itemizedlist mark="bullet">
  <listitem>
    <para>Standard input (<filename>stdin</filename>). Normalt tastaturet.</para>
  </listitem>
  <listitem>
    <para>Standard output(<filename>stdout</filename>). Normalt skærmen.</para>
  </listitem>
  <listitem>
    <para>Standard error (<filename>stderr</filename>). Normalt skærmen.</para>
  </listitem>
</itemizedlist>
</para>

<para>
Vi har før været inde på, at <filename>stdout</filename> kan omdirigeres med <command>&gt;</command>.
<command>cat fil1 fil2 &gt; fil3</command> vil samle indholdet af filerne
<filename>fil1</filename> og <filename>fil2</filename> i filen
<filename>fil3</filename>.
</para>

<para>
Da måden, du omdirigerer på, er afhængig af valg af kommandofortolker,
er det en god idé at undersøge dette nu. Prøv med:
</para>


<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>env | grep ^SHELL | cut -d/ -f3</userinput>
</screen>


<para>
Svaret skulle gerne være <command>bash</command>, <command>zsh</command>,
<command>csh</command> eller <command>tcsh</command>. Det kan være, at du
anvender en anden skal &ndash; der findes mange. Hvis det er tilfældet, kan du se i
brugsanvisningen for den aktuelle kommandofortolker (<command>man SKALLENS_NAVN</command>).
</para>

<para>
Hvis du selv starter en ny skal (enten fra kommandolinjen eller i et program),
er det ikke sikkert, at ovenstående metode virker. Prøv derfor at skrive
<command>ps</command>.  En liste over de kørende processer vil da
blive udskrevet til skærmen. Den nederste proces, der ender på "sh",
angiver din skal &ndash; normalt.
</para>

<para>
Fælles for Bourne-Again Shell (<command>bash</command>) og C-Shell er
følgende: Lad os antage, at filen <filename>fil3</filename> indeholder
information, vi ønsker at bevare. Vi vil tilføje (append) indholdet af
<filename>fil1</filename> og <filename>fil2</filename> til
<filename>fil3</filename>. Det gøres ved:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>cat fil1 fil2 &gt;&gt; fil3</userinput>
</screen>

<indexterm>
 <primary>sendmail</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>sendmail</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>sendmail</tertiary>
</indexterm>
<para>
Indholdet af en fil kan også anvendes som argument(er)
til en kommando. F.eks. vil følgende kommando sende indholdet af filen
<filename>megenRos</filename> til SSLUG's webmastere:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>sendmail www_admin@sslug.dk &lt; megenRos</userinput>
</screen>

<para>
Linux skelner (som Unix) mellem normale uddata
(<filename>stdout</filename>) og fejluddata (<filename>stderr</filename>).
Til tider kan det være rart kun at omdirigere det ene sæt meddelelser.
</para>

<para>
Specielt for <command>bash</command> gælder følgende: Omdirigering af
<filename>stdout</filename> (1) og <filename>stderr</filename> (2) i
<command>bash</command> er forholdsvis simpel.
</para>

<para>
Hvis kun fejlmeddelelserne fra en kommando &ndash; her <command>ls</command> -
ønskes:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt>  <userinput>ls  1> /dev/null</userinput>
</screen>

<para>
Hvis kun <filename>stdout</filename> ønskes vist og fejlmeddelelserne
skal sendes til en fil:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>ls 2> fejlfil </userinput>
</screen>

<para>
Og endelig, hvis du ønsker at akkumulere fejlmeddelelser i en fil, kan
<command>&gt;&gt;</command> anvendes &ndash; f.eks.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>ls 2&gt;&gt; fejlfil</userinput>
</screen>

<para>
De to skaller <command>csh</command> og <command>tcsh</command>
adskiller sig fra <command>bash</command> på følgende måder. Når du omdirigerer med
<command>&gt;</command> eller <command>&gt;&gt;</command>, er det kun
<filename>stdout</filename>, der omdirigeres. Hvis
<filename>stderr</filename> skal med, skal du anvende
<command>&amp;</command> efter
omdirigeringen. <filename>stderr</filename> kan ikke omdirigeres
alene, men med lidt krumspring lykkedes det alligevel:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ls -l /* | tee &gt;&amp; fil1 | diff fil1 - &gt;fejlFil</userinput>
</screen>

<para>
Ovenstående kommando sender både <filename>stderr</filename> og
<filename>stdout</filename> til filen <filename>fil1</filename>.
</para>
</sect2>



<sect2 id="Unixapp-who">
<title>Hvem er logget ind?</title>
<indexterm><primary>who</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>who</secondary>
</indexterm>
<indexterm><primary>who am i</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>who am i</secondary>
</indexterm>
<indexterm><primary>w</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>w</secondary>
</indexterm>
<indexterm><primary>finger</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>finger</secondary>
</indexterm>
<para>
Hvis du ønsker at vide, hvilke brugere der er logget på samme computer
som dig, bruger du kommandoen <command>who</command>. Du vil så få en
liste med brugere, der har logget ind, og fra hvilken (virtuel) terminal
de er koblet til. Denne kommando har ikke den store værdi, med mindre
du arbejder i et flerbruger-system. Arbejder du i et større netværk,
kan det være, at <command>rwho</command> virker. <command>rwho</command>
viser dig, hvem der er logget ind på hvilke computere i netværket.
Dette kræver dog at både klient og server kører rwho-dæmonen.
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>who</userinput>
tyge     tty1     Dec 21 17:25
tyge     pts/0    Dec 21 17:26
tyge     pts/1    Dec 21 17:26
tyge     pts/2    Dec 21 17:26
katja    pts/5    Dec 21 17:31 (k5.sslug)
</screen>

<para>
Dette viser at brugeren tyge er logget ind via konsollen tty1, og har
sidenhen (kl. 17:26) åbnet tre terminalvinduer &ndash; under X. Brugeren
katja er også logget ind på maskinen kl. 17:31 fra maskinen "k5.sslug"
og har kun et terminal-vindue (pts/5) åbent.
</para>

<para>
Man kan få mere information end blot antal terminaler ved at skrive 
</para>

<screen>                 
<prompt>[tyge@hven ~]$</prompt> <userinput>w</userinput>
  5:35pm  up  7:20,  8 users,  load average: 0.14, 0.15, 0.10
USER  TTY      FROM     LOGIN@  IDLE   JCPU   PCPU  WHAT
tyge  tty1     -        5:25pm  9:40   1.26s  0.03s  /bin/sh /usr/X1
tyge  pts/0    -        5:26pm  7:03   2.50s  2.50s  /usr/bin/pine
tyge  pts/1    -        5:26pm  9:01   0.04s  0.04s  /bin/cat
tyge  pts/2    -        5:26pm  3:48   0.40s  0.40s  -bin/tcsh
katja pts/5    k5.sslug 5:31pm  3:13   0.37s  0.37s  -tcsh
tyge  pts/6    -        5:33pm  1.00s  0.25s  0.04s  w
</screen>


<para>
Man får igen samme information om de to brugere som er logget ind, men
der er mere information her. Man kan også se hvor lang tid de enkelte
terminalvinduer har været urørte under "IDLE" og under "WHAT" kan man
se om der kører et program i den enkelte terminal. I terminalen pts/0
kører der eksempelvis pine &ndash; dvs. et e-post program.
</para>

<para>
En anden vej at udvide information er at skrive 
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>who am i</userinput>
k6.sslug!tyge     pts/6    Dec 21 17:33
</screen>

<para>
Resultatet er at man får maskin-navnet "k6.sslug" på den maskine man
sidder ved og dernæst kommer brugernavnet. Det er meget nyttigt hvis
man f.eks. anvender DHCP eller logger meget ind fra en maskine til
mange andre over netværket.
</para>

<para>
Det næste vi ser på er finger, som giver lidt ekstra
informationer. Man skriver "finger BRUGERNAVN" for at se information
om BRUGERNAVN. Man får information tilbage om brugeren er logget ind
på maskinen og man kan også se brugerens rigtige navn under
"Name:"-feltet.

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>finger katja</userinput>
Login: katja                            Name: Katja B
Directory: /home/katja                  Shell: /bin/tcsh
On since Fri Dec 21 17:31 (CET) on pts/5 from k5.sslug
   11 minutes 9 seconds idle
     (messages off)
No mail.
No Plan.
</screen>
</para>

   <para>
    Hvis man vil have en oversigt over alle der er logget ind på systemet
    kan det klares ved blot at køre <command>finger</command> uden nogle
    kommandolinjetilvalg.
   </para>

<para>
Finger læser filerne; <filename>~/.plan</filename> og
<filename>~/.project</filename>. Er man systemadministrator (root) kan
<command>last</command> og <command>lastlog</command> også give
seneste login information.
</para>

<para>
Nu har vi set et par forskellige måder til at få information om
hvilke brugere som anvender maskinen. En nem måde at få kontakt til
en anden bruger på maskinen er at anvende "talk" (dette kræver at
talk-dæmonen er installeret og startet). Men "talk BRUGERNAVN" kan
man få en ICQ-lignende chat-session i gang hvor skærmen deles i
to. Er brugeren logget ind i flere terminaler kan man anføre et
ekstra argument til kommandoen "talk BRUGERNAVN TERMINAL", hvor
terminal en af de terminaler, som BRUGERNAVN anvender &ndash; ovenfor kan
brugeren "katja" findes på pty/5.
</para>
</sect2>

<sect2 id="Unixapp-find">
<title>Søg og du skal finde</title>
<indexterm><primary>find</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>find</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>find</tertiary>
</indexterm>
<para>
<command>find</command> bruges til at finde filer med. Syntaksen er:
<command>find</command> hvorfra hvad [handling]. Ikke alle
Linux/Unix-varianter kræver 3. argument. Lad os se nærmere på argumenterne.
</para>

<itemizedlist mark="bullet">
<listitem>
<para>
1. argument, hvorfra:
  <itemizedlist mark="bullet">
  <listitem>
    <para><filename>./</filename> angiver aktuelt katalog.</para>
  </listitem>
  <listitem>
    <para><filename>~/</filename> angiver hjemmekatalog.</para>
  </listitem>
  <listitem>
    <para><filename>/</filename> angiver roden.</para>
  </listitem>
  <listitem>
    <para><filename>/usr</filename> angiver <filename>usr</filename> og alt under.</para>
  </listitem>
</itemizedlist>
</para>
</listitem>
<listitem>
<para>
2. argument, hvad:
  <itemizedlist mark="bullet">
  <listitem><para>
    <programlisting>-name foo</programlisting> med navnet <filename>foo</filename>
  </para></listitem>
  <listitem><para>
    <programlisting>-type d</programlisting> som er et katalog.
  </para></listitem>
</itemizedlist>
</para>
</listitem>

<listitem>
<para>
3. argument, [handling]:
  <itemizedlist mark="bullet">
  <listitem><para>
    <programlisting>-print</programlisting> udskriver, hvor filen er fundet
  </para></listitem>
  <listitem><para>
    <programlisting>-ls</programlisting> udfører <command>ls -l</command> på
    søgeresultatet
  </para></listitem>
  <listitem><para>
    <programlisting>-exec cmd {}\;</programlisting> udfører kommandoen
    <command>cmd</command> på søgeresultatet.
  </para></listitem>
  <listitem><para>
    <programlisting>-ok</programlisting> som <programlisting>exec</programlisting> men spørger først.
  </para></listitem>
  </itemizedlist>
</para>
</listitem>
</itemizedlist>

<para>
Som et sødt lille eksempel på hvor smart <command>find</command> er,
så kan vi tælle det totale antal af linjer i en række HTML-tekstfiler, der
ligger spredt i nogle underbiblioteker.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>(find . -name "*.html" -exec cat {} \;) | wc -l</userinput>
</screen>

</sect2>


<sect2 id="Unixapp-touch">
<title>Hvordan ændres datomærkningen?</title>

<indexterm>
 <primary>touch</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>touch</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>touch</tertiary>
</indexterm>
<para>
Kommandoen <command>touch</command> anvendes til at oprette tomme
filer eller til at ændre tidspunktet for sidste modifikation.
</para>

<para>
Lad os antage, at filen <filename>minFil</filename> eksisterer, og
filen <filename>minIkkeEksisterendeFil</filename> ikke gør, da vil
<command>touch minFil</command> sætte tiden for sidste modifikation af
filen til det aktuelle klokkeslet. Kommandoen <command>touch
minIkkeEksisterendeFil</command> vil oprette en tom fil med
navnet <filename>minIkkeEksisterendeFil</filename>.
</para>

</sect2>

<sect2 id="Unixapp-file">
<title>Hvilken filtype?</title>

<indexterm>
 <primary>file</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>file</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>file</tertiary>
</indexterm>
<para>
Kommandoen <command>file</command> forsøger at gætte, hvilken filtype
der er givet som argument. Hvis <command>file</command> tror, at det er
en ascii-fil, vil <command>file</command> læse de 512 første tegn og
forsøge at gætte programmeringssproget.
</para>

<para>
<command>file</command> gætter desværre forkert fra tid til anden og
kan f.eks. ikke genkende filer, der indeholder programmer, som er
skrevet i Pascal eller Lisp.
</para>
</sect2>

<sect2 id="Unixapp-date">
<title>Tid og dato</title>
<indexterm>
 <primary>date</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>date</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>date</tertiary>
</indexterm>
<para>
<command>date</command> udskriver den aktuelle dato og
det aktuelle klokkeslet.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>date</userinput>
 lør jan 16 17:50:55 CET 1999
</screen>
<indexterm>
 <primary>cal</primary>
</indexterm>
<indexterm>
 <primary>Kalender</primary>
 <secondary>cal</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>cal</secondary>
</indexterm>
<para>
<command>cal</command> er en hel lille kalender.
Uden argument udskrives kalenderen for den aktuelle måned.
Med et argument (tal) regnes argumentet for et årstal. Vær i øvrigt
opmærksom på, at <command>cal</command> er &Aring;r 2000-klar,
dvs. <command>cal 99</command> udskriver kalenderen for år 99, mens <command>cal
1999</command> skriver kalenderen for 1999.
</para>

<para>
Med 2 argumenter regnes det første som måned og det andet som
årstal. Det er værd at bemærke, at <command>cal</command> antager, at
skiftet fra den julianske kalender til den gregorianske kalender skete 
i september 1752, hvilket passer til engelske forhold 
(i katolske lande skete det i 1582
og i Danmark i år 1700).
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>cal 12 1991</userinput>
   December 1991
Su Mo Tu We Th Fr Sa
 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31
<prompt>[tyge@hven ~]$ </prompt><userinput>cal 9 1752</userinput>
   September 1752
Su Mo Tu We Th Fr Sa
       1  2 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
</screen>
</sect2>

<sect2 id="Unixapp-sort">
<title>Sortering</title>
<indexterm>
 <primary>sort</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>sort</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>sort</tertiary>
</indexterm>

  <para>
   <command>sort</command> sorterer en fil linje for
   linje. <command>sort</command> kan også flette flere filer samtidig
   med at indholdet sorteres. Omdirigering af <command>sort</command>
   til en fil er mulig med tilvalget "-o". <command>sort fil1 fil2
   &gt; fil1</command> vil give et pudsigt resultat: Da
   <filename>stdout</filename> omdirigeres til
   <filename>fil1</filename>, som eksisterer i forvejen, slettes
   <filename>fil1</filename>, og en ny, tom <filename>fil1</filename>
   oprettes. Når <filename>fil1</filename> og
   <filename>fil2</filename> flettes og sorteres, vil
   <filename>fil1</filename> være tom. Derfor vil kun indholdet af
   <filename>fil2</filename> komme med i <filename>fil1</filename> -
   kryptisk &ndash; prøv selv! Husk blot, at <command>sort</command> er den
   eneste (standard) kommando, hvor <filename>stdout</filename>
   omdirigeres med tilvalget "-o".
</para>

<para>
Men <command>sort</command> kan mere: En fil kan være inddelt i
poster, f.eks. filen <filename>navne</filename>.
</para>
<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>cat navne</userinput>
   poul nyrup 52
   holger beck-nielsen 90
   william gates 55
   torvalds linus ??
</screen>

<para>
Lad os illustrere <command>sort</command> ved en række eksempler.
<command>sort +1 navne</command> vil sortere på efternavn (første felt
er felt 0). <command>sort +2-n navne</command> vil sortere numerisk
på hattestørrelse. <command>sort -r navne</command> vil sortere i
omvendt rækkefølge.
</para>
<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>sort +2 -n -r navne</userinput>
  torvalds linus 91.2
  holger beck-nielsen 90
  william gates 55
  poul nyrup 52
</screen>
</sect2>


<sect2 id="diff">
<title>diff</title>

<para>
<command>diff</command> udskriver forskellen mellem to filer. Lad os
se på filerne <filename>fil1</filename> og <filename>fil2</filename>.
</para>
<indexterm>
 <primary>diff</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>diff</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>diff</tertiary>
</indexterm>
<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>cat fil1 </userinput>
  Per
  Poul
  Bent
<prompt>[tyge@hven ~]$ </prompt> <userinput>cat fil2 </userinput>
  Per
  Bjarne
<prompt>[tyge@hven ~]$ </prompt> <userinput>diff fil1 fil2 </userinput>
  2,3c2
  &lt; Poul   (oversat: ud går Poul)
  &lt; Bent   (oversat: ud går Bent)
  &gt; Bjarne (oversat: ind kom Bjarne)
</screen>

<example id="ex-diff-dir">
<title>diff mellem hele katalog-strukturer</title>
<para>
Kommandoen <command>diff</command> er faktisk ret smart. Man kan endda få 
den til at finde alle rettelser lavet mellem to kataloger, hvor der laves
rekursiv søgning. Har man f.eks. katalogerne 
<filename>tux-ny</filename> og
<filename>tux</filename> og skal vide hvad der er lavet om fra 
<filename>tux</filename> til
<filename>tux-ny</filename>, så skriver man 
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>diff -ur --new-file tux tux-ny</userinput>
diff -ur --new-file tux/README tux-ny/README
--- tux/README    Sun Jan  6 00:24:23 2002
+++ tux-ny/README Sun Jan  6 00:22:13 2002
@@ -1,5 +1,3 @@
-Dette katalog indeholder tekster svarende til
-bogen, hvis vi har ment dette er relevant.

 Seneste bøger kan findes på
 &linuxbogurl;
</screen>

<para>
Parameteren <literal>u</literal> giver en pænere diff-fil med en
rimelig syntaks (unified diff). Parameteren <literal>r</literal>
betyder rekursiv søgning ned i katalog-strukturen og endelig så er 
<literal>--new-file</literal> med for at sørge for at nye filer også
kommer med.
</para>

</example>
</sect2>

  <sect2 id="patch">
   <title>Lappe på filer</title>

   <indexterm>
    <primary>lapper</primary>
   </indexterm>

   <indexterm>
    <primary>patch</primary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>patch</secondary>
   </indexterm>

   <indexterm>
    <primary>Kommandooversigt</primary>
    <secondary>Grundlæggende kommandobeskrivelse</secondary>
    <tertiary>patch</tertiary>
   </indexterm>

   <para>
    Vi fortsætter ud fra <xref linkend="ex-diff-dir"/>.  Hvad der nu er smart er
    at en anden bruger, <literal>tyge</literal>, der har den gamle
    katalog-struktur <filename>tux</filename>, og denne skal opgraderes med
    ændringerne fra brugeren <literal>tyge</literal>. Først gemmer
    <literal>tyge</literal> ændringerne i en fil, <filename>lap</filename> og
    sender denne til <literal>tyge</literal>:

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>diff -ur --new-file tux tux-ny &gt; lap</userinput>
</screen>
   </para>

   <para>
    Brugeren <literal>tyge</literal> kan derefter tage filen og køre
    <command>patch</command> for at få opdateret underkataloget
    <filename>tux</filename>:

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>patch -p0 -u &lt; lap</userinput>
patching file tux/README
</screen>
   </para>

   <para>
    Nye filer skabes og slettede filer forsvinder automatisk. Det er på
    denne måde rettelser og tilføjelser (lapper) til Linux-kernen distribueres.
   </para>
  </sect2>

<sect2 id="cat-og-uniq">
<title>cat, uniq, wc og cmp</title>

<indexterm><primary>uniq</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>uniq</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>uniq</tertiary>
</indexterm>

<indexterm><primary>cat</primary></indexterm>
<indexterm><primary>cmp</primary></indexterm>
<indexterm><primary>wc</primary></indexterm>

<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>cmp</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>cmp</tertiary>
</indexterm>

<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>wc</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>wc</tertiary>
</indexterm>


<para>
<command>uniq</command> fjerner ens linjer, der kommer efter hinanden,
hvilket illustreres nedenfor.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt>  <userinput>cat per3 </userinput>
  Per
  Per
  Per
<prompt>[tyge@hven ~]$ </prompt> <userinput>uniq per3</userinput>
  Per
</screen>

<para>
<command>cmp</command> sammenligner filer og stopper læsningen af
filerne, når <command>cmp</command> finder en forskel.
</para>

<para>
<command>wc</command> står for Word Count, og som navnet antyder,
tæller den ord i en fil. <command>wc</command> har nogle tilvalg:
"-l", "-w" og "-c" for Lines, Words og Characters.
</para>

<para>
 Vil du vide, hvor mange linjer en fil indeholder, skriver du
 <command>wc -l fil</command>. <command>wc</command> er særlig god
 sammen med andre kommandoer og <command>|</command> (kanaler),
 f.eks. vil nedenstående kommando tælle op, hvor mange filer, der er i
 kataloget <filename>/usr/bin</filename>
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>ls /usr/bin | wc -l</userinput>
  1208
</screen>

<para>
Eller hvis du vil vide, hvor mange kataloger der er i
<filename>/etc</filename>:

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>find /etc -type d -maxdepth 1 | wc -l</userinput>
  23
</screen>

Forklaringen er som følger: <command>find /etc</command> finder alle filer og
kataloger under <filename>/etc</filename>.  Tilvalget <literal>-type d</literal> gør at kun kataloger bliver vist.  Og tilvalget <literal>-maxdepth 1</literal>
gør at søgningen bliver begrænset til <filename>/etc</filename> (ellers ville
<filename>/etc</filename>s underkataloger og underkatalogers underkataloger også
blive gennegået).  Uddata fra <command>find</command> kommer som standard
med et filnavn per linje.  <command>wc -l</command> tæller
antallet af linjer den modtager.
</para>
</sect2>

<sect2 id="Unixapp-tail">
<title>Hoved og hale af filer</title>
<indexterm><primary>tail</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>tail</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>tail</tertiary>
</indexterm>
<indexterm><primary>head</primary></indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>head</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>head</tertiary>
</indexterm>
  <para>
   <command>tail</command> &ndash; uden tilvalg &ndash; udskriver de 10 sidste
   linjer af en fil, "-5" vil udskrive de 5 sidste linjer, og "+8" vil
   udskrive fra og med linje 8 i en fil. Lad os se på et eksempel.
  </para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>cat sang</userinput>
    Jeg bærer med smil min byrde,
    jeg drager med sang mit læs;
    jeg er som den vilde hyrde,
    der genner sit kvæg på græs.
<prompt>[tyge@hven ~]$ </prompt> <userinput>tail -2 sang</userinput>
    jeg er som den vilde hyrde,
    der genner sit kvæg på græs.
</screen>

   <para>
    <command>tail</command> har et meget nyttig "f"-tilvalg. Den får
    <command>tail</command> til løbende at vise de sidste 10 linjer af
    en fil, f.eks. vil du med <command>tail -f
    /var/log/messages</command> kunne følge med i, hvad alle
    system-dæmoner og lignende rapporterer.
   </para>

   <para>
    <command>head</command> svarer til <command>tail</command>, men i
    stedet for slutningen af en fil, er det begyndelsen.
    <command>head</command> &ndash; uden tilvalg &ndash; udskriver de 10 første
    linjer af en fil. Tilvalg kan gives som for
    <command>tail</command>.
   </para>
  </sect2>

  <sect2 id="Unixapp-cut">
   <title>"cut" og "paste"</title>

<indexterm>
 <primary>cut</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>cut</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>cut</tertiary>
</indexterm>

<indexterm>
 <primary>paste</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>paste</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>paste</tertiary>
</indexterm>

  <para>
   <command>cut</command> tager det, du specificerer i tilvalg, ud af
    en linje, dvs. -cx-y: tager fra tegn nr. x til tegn nr. y på hver
    linje i den specificerede fil. Er der kun ét tal, tages kun dette
    tegn ud.  -fx-y er som for c, men her drejer det sig om felter, og
    -d'X' angiver felt-separatoren.
</para>

<para>
Vil du se, hvilke brugere der har adgang til systemet, så prøv:
<command>cat /etc/passwd | cut -d':' -f1</command>
</para>

<para>
<command>paste</command> samler filer lodret, hvor
<command>cat</command> samler (kan samle) filer vandret. Lad os se på
følgende eksempel. Du ønsker nu at samle to filer,
<filename>navne</filename> og <filename>iq</filename>, således at
linje 1 fra <filename>navne</filename> efterfølges af linje 1 fra
<filename>iq</filename> (uden at dette dog skulle være konkluderende,
for såvidt angår de tilfældige sammenstillinger af for- og efternavne
samt tal).
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>cat navne</userinput>
      poul nyrup 52
      holger beck-nielsen 90
      william gates 55
      torvald linus ??
<prompt>[tyge@hven ~]$ </prompt> <userinput>cat iq</userinput>
      50
      230
      120
      ??
<prompt>[tyge@hven ~]$ </prompt> <userinput>paste navne iq</userinput>
      poul nyrup 52 50
      holger beck-nielsen 90 230
      william gates 55 120
      torvald linus ?? ??
</screen>

</sect2>

<sect2 id="Unixapp-tr">
<title>Søg og du skal erstatte</title>
<indexterm>
 <primary>tr</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>tr</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>tr</tertiary>
</indexterm>
<para>
<command>tr</command> erstatter det første argument med det andet.
<command>tr</command> er en lidt speciel sag. Den forventer, at få
input fra <filename>stdin</filename>. Derfor må du bruge følgende
fremgangsmåde, hvis du vil erstatte noget i <filename>fil1</filename>,
og skrive indholdet til <filename>fil2</filename>. Hvis du ønsker, at
alle små tegn skal erstattes med store, skulle følgende kunne lade sig
gøre:
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>tr '[a-z,æ,ø,å]' '[A-Z,&AElig;,&Oslash;,&Aring;]' &lt; fil1 &gt; fil2</userinput>
</screen>

</sect2>


<sect2 id="xargs">
<title>xargs</title>
<para>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>xargs</secondary>
</indexterm>
<indexterm><primary>xargs</primary></indexterm>
En af de meget nyttige kommandoer er <command>xargs</command>, som kan 
bruges som kobling mellem en kommando der giver en række filnavne, hvor
der skal udføres en speciel kommando på hver af de filer. Som eksempel
kan vi prøve at få antal linier i alle filer der ender på 
<filename>.sgml</filename>.
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>ls  *.sgml</userinput>
indhold.sgml
mandrake.sgml
unix.sgml
</screen>

<para>
Hvis man prøver at kanalisere filnavnet ind i <command>wc</command>, så går det
galt
</para>


<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>ls *.sgml | wc --lines</userinput>
3
</screen>

<para>
Det der kommer som svar er at der er tre filer i <command>ls</command>-kommandoen. I stedet
bruger vi <command>xargs</command>
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>ls  *.sgml | xargs -i= wc --lines =</userinput>
 700 indhold.sgml
 232 mandrake.sgml
1232 unix.sgml
</screen>

<para>
Programmet <command>xargs</command> får her filnavnene ind, og kører en kommando for 
<emphasis>hver</emphasis> af strengene. Argumentet <literal>-i=</literal>
betyder at i den efterfølgende kommandoer skal lig-med (=) erstattes med en af de tekst-strenge 
(her er det et filnavn). Kommandoen er her <command>wc --lines =</command>, som viser antal 
linier i filnavnet <filename>=</filename>, dvs. det som kommer fra <command>ls</command>-kommandoen.
</para>

<para>
Der der i det nuværende katalog er tre filer, så er det nemt at vise hvad der egentlig bliver udført
at ovenstående <command>xargs</command>-kommando:
</para>

<screen>
wc --lines indhold.sgml
wc --lines mandrake.sgml
wc --lines unix.sgml
</screen>


<para>
Det skal nævnes at anvendelsen af lig-med i eksemplet ikke er essentiel. Man kan også anvende
et andet special-tegn.
</para>

</sect2>



<sect2 id="Unixapp-andre">
<title>Andre Unix-kommandoer</title>
<para>
<indexterm>
 <primary>Tabel over kommandoer</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Tabel over kommandoer</secondary>
</indexterm>

<indexterm><primary>find</primary></indexterm>
<indexterm><primary>whoami</primary></indexterm>
<indexterm><primary>who</primary></indexterm>
<indexterm><primary>passwd</primary></indexterm>
<indexterm><primary>su</primary></indexterm>
<indexterm><primary>echo</primary></indexterm>
<indexterm><primary>chown</primary></indexterm>
<indexterm><primary>date</primary></indexterm>
<!--indexterm><primary>xhost</primary></indexterm-->
<indexterm><primary>lpr</primary></indexterm>
<indexterm><primary>lpq</primary></indexterm>
<indexterm><primary>lprm</primary></indexterm>
<indexterm><primary>tar</primary></indexterm>
<indexterm><primary>compress</primary></indexterm>
<indexterm><primary>gzip</primary></indexterm>
<indexterm><primary>bzip2</primary></indexterm>
<indexterm><primary>bunzip2</primary></indexterm>
<indexterm><primary>diff</primary></indexterm> 
<indexterm><primary>free</primary></indexterm>
<indexterm><primary>df</primary></indexterm>
<indexterm><primary>du</primary></indexterm>
<indexterm><primary>sort</primary></indexterm>
<indexterm><primary>ssh</primary></indexterm>
<indexterm><primary>gunzip</primary></indexterm>

<table>
<title>Oversigt over de mest anvendte andre Unix-kommandoer.</title>
<tgroup cols="2" align="char">
<thead>
 <row>
  <entry>Kommando</entry>
  <entry>Forklaring</entry>
 </row>
</thead>
<tbody>

<row>
 <entry>find</entry> 
 <entry>Find fil(er). Anvend f.eks. <command>find /usr -name "*.gif"</command>
      til at finde alle filer under biblioteket <filename>/usr</filename>, der ender
      på <filename>.gif</filename>. Prøv også <command>locate FILNAVN</command>.
 </entry>
</row>

<row>
 <entry>whoami</entry>
 <entry>Viser hvilket brugernavn-navn der arbejdes under.
 </entry>
</row>

<row>
 <entry>who</entry>
 <entry>Viser hvem der er logget ind på maskinen.</entry>
</row>

<row>
 <entry>passwd</entry>
 <entry>Skift adgangskode.</entry>
</row>

<row>
 <entry>su</entry>
 <entry>Skift bruger-identitet.</entry>
</row>

<row>
 <entry>echo</entry>
 <entry>Kommandoen <command>echo "TEKST"</command>
      skriver teksten på skærmen.</entry>
</row>

<row>
 <entry>chown</entry>
 <entry>&AElig;ndrer ejerskabet af filer.</entry>
</row>

<row>
 <entry>date</entry>
 <entry>Viser dato og tid.</entry>
</row>

<!-- her fra -->
<!--row>
 <entry>xhost</entry>
 <entry>Anvendes til at tillade/begrænse andre maskiner at
      koble til maskinens X-server, dvs. om de må vise grafik
      på skærmen. Anvend <command>xhost +</command> til at tillade alle
      maskiner at vise grafik på maskinen. Anvend tilsvarende
      <command>xhost -maskinnavn</command> til at forhindre, at den
      pågældende maskine viser grafik.
 </entry>
</row-->

<row>
 <entry>lpr</entry>
 <entry>Print ordre. Anvend <command>lpr -Pprinternavn filnavn</command>
      for at printe på printeren <command>printernavn</command>. De enkelte
      printere er defineret i filen <filename>/etc/printcap</filename>.
      De aktuelle printere kan være såvel lokale som netprintere.
 </entry>
</row>

<row>
 <entry>lpq</entry>
 <entry>Printerkø forespørgsel. Anvend <command>lpq -Plp</command> til
      at vise, hvor langt printeren <command>lp</command> er med at
      printe ud.
 </entry>
</row>

<row>
 <entry>lprm</entry>
 <entry>Anvendes til at fjerne printjobs, som ikke er skrevet endnu.
      Se muligheder med <command>man lprm</command>.
 </entry>
</row>

<row>
 <entry>tar</entry>
 <entry>Anvendes til at pakke flere filer sammen til
      en. Anvend f.eks. <command>tar cvf tfil.tar fil1 fil2</command> for at
      pakke <filename>fil1</filename> og <filename>fil2</filename> sammen til filen <filename>tfil.tar</filename>.
      Tilsvarende kan filen pakkes ud med <command>tar xvf tfil.tar</command>. </entry>
</row>

<row>
 <entry>compress</entry>
 <entry>Pakker filer ind/ud. Anvend
      <command>compress filnavn</command> til at pakke filen til <filename>
      filnavn.Z</filename>. Tilsvarende anvendes <command>uncompress</command> til at pakke ud. </entry>
</row>

<!-- her fra -->
<row>
 <entry>gzip</entry>
 <entry>Andet og bedre pakkeprogram, der
      anvender <filename>.gz</filename> som
      slutning af filnavn. Tilsvarende findes
      <command>gunzip</command> til at pakke ud.
      Normalt ses også filtypen <filename>.tgz</filename>,
      som er en <filename>tar</filename> fil, hvor der efterfølgende er anvendt
      <command>gzip</command>.
 </entry>
</row>
<!-- her til -->
<row>
 <entry>bzip2</entry>
 <entry>Andet og bedre pakkeprogram, der
      anvender <filename>.bz2</filename> som
      slutning af filnavn. Tilsvarende findes
      <command>bunzip2</command> til at pakke ud.
      Normalt ses også filtypen <filename>.tar.bz2</filename>,
      som er en <filename>tar</filename> fil, hvor der efterfølgende er anvendt
      <command>bzip2</command>.
 </entry>
</row>

<row>
 <entry>diff</entry>
 <entry>Sammenligner to filer og rapporterer forskellene.
 </entry>
</row>

<row>
 <entry>free</entry>
 <entry>Viser, hvor meget hukommelse der er
      brugt, og hvor meget der er til rådighed.
 </entry>
</row>

<row>
 <entry>df</entry>
 <entry>Viser, hvor meget diskplads der er
      brugt, og hvor meget der er til rådighed
      på samtlige diske.
 </entry>
</row>

<row>
 <entry>du</entry>
 <entry>Viser status over, hvor meget diskplads
      der er brugt under det sted, hvor du står i filtræet.
 </entry>
</row>

<row>
 <entry>sort</entry>
 <entry>Sorterer linjerne i en tekstfil.
 </entry>
</row>

<row>
 <entry>ssh</entry>
 <entry><command>ssh saltholm.sslug.dk date</command> 
 betyder, at du udfører kommandoen
<command>date</command> på maskinen
<literal>saltholm.sslug.dk</literal>, dvs. en anden Unix-maskine.
Linux kan udføre kommandoer på andre maskiner og så vise
grafik (og tekst) på din egen maskine.
</entry>
</row>

<row>
 <entry>
  <command>telnet</command>
 </entry>
 <entry>
  Opretter en ukrypteret netværksforbindelse til en anden maskine.  Nyttig
  til afprøvning og fejlsøgning af netværksforbindelser.
 </entry>
</row>

<row>
 <entry>
  <command>ping</command>
 </entry>
 <entry>
  Undersøger om der er forbindelse til en anden maskine.  Nyttig
  til afprøvning og fejlsøgning af netværksforbindelser.
 </entry>
</row>

<row>
 <entry>
  <command>traceroute</command>
 </entry>
 <entry>
  Viser hvilke maskiner forbindelsen til en anden maskine går over.  Nyttig
  til afprøvning og fejlsøgning af netværksforbindelser.
 </entry>
</row>

</tbody>
</tgroup>
</table>
</para>
  </sect2>
 </sect1>

<sect1 id="shell-script">
<title>Shell script</title>
<indexterm><primary>Shell script</primary></indexterm>

<para>
Skal man udføre mange kommandoer efter hinanden eller
vil man have en anden bruger til at gøre det, 
kan det med fordel betale sig at lære at skrive shell scripts.
I <xref linkend="koerflere"/> blev vist hvordan man afvikler
flere kommandoer efter hinanden på kommando-linjen, men er det mere kompliceret
eller der er 20 kommandoer, så vil et shell script med
fordel kunne bruges.
</para>

<para>
I dette kapitel har vi medtaget nogle få almindelige kommandoer.
En mere udførlig gennemgang findes på:
<ulink url="http://www.tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html">http://www.tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html</ulink> .
</para>

  <example id="shell-hello">
   <title>Simpelt kommandofortolkerprogram</title>

   <indexterm>
    <primary>kommandofortolkerprogram</primary>
    <secondary>simpelt</secondary>
   </indexterm>
 
   <para>
    Alle kommandoer man kan udføre på kommandolinjen, kan også udføres i et
    kommandofortolkerprogram (eng. »shell script«).  Et
    kommandofortolkerprogram er blot en tekstfil der starter med at angive
    hvilken kommandofortolker der skal bruges til at køre det.  Resten af
    tekstfilen indeholder kommandoer til kommandofortolkeren.  For at
    styresystemet skal betragte filen som et program, skal den gøres kørbar
    (med <command>chmod</command>).  Her er der et simpelt eksempel, der bare
    skriver »Hej med dig.«:

<programlisting>
#! /bin/sh
echo Hej med dig.
</programlisting>
   </para>

   <para>
    Hvis de to linjer står i filen "<filename>hej</filename>", så gør du den
    kørbar med kommandoen:
<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>chmod +x hej</userinput>
</screen>
   </para>

   <para>
    Når du har gjort filen kørbar, så er den et program og kan køres som
    enhver anden kommando (næsten):

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>./hej</userinput>
Hej med dig.
</screen>

    <literal>./</literal> fortæller din kommandofortolker at det er et program
    der ligger i det katalog du står i, og ikke et kommandofortolkeren skal
    lede efter i kommandostien (systemvariablen "<literal>PATH</literal>").
   </para>

   <para>
    Hvis du bare udfører kommandoen i filen "<filename>hej</filename>" direkte
    på kommandolinjen får du samme resultat:

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>echo Hej med dig.</userinput>
Hej med dig.
</screen>
   </para>

   <para>
    I dette eksempel valgte vi at bruge "<filename>/bin/sh</filename>" som
    fortolker til programmet.  Alternativt kunne fortolkeren blandt andet
    have været <filename>/bin/bash</filename>,
    <filename>/usr/bin/gnuplot</filename> (så ville
    "<command>echo</command>"-kommandoen dog ikke blive forstået) eller
    <filename>/bin/zsh</filename>.  Henvisningen til fortolkeren
    <emphasis>skal</emphasis> skrives på første linje i filen.
   </para>

   <para>
    Bemærk de første 4 tegn i filen er "<command>#! /</command>".  Det er
    Unix-koden for at der bruges en fortolker til at køre dette program.  I
    dette tilfælde er det så <command>sh</command> der er placeret i
    kataloget <filename>/bin/</filename>.
   </para>
  </example><!-- shell-hello -->

<sect2 id="shell-flere-kom">
<title>Flere kommandoer</title>
<indexterm><primary>Shell script</primary><secondary>flere kommandoer</secondary></indexterm>
<para>
Et af formålene med scripts er at køre flere kommandoer.
Har man kun to kommandoer der skal køres, og det kun er dig selv der skal
køre dem, kan man blot køre dem efter hinanden på kommando-linjen
ved at angive et ; imellem kommandoerne.
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>echo "Hello, world" ; echo "Hej, verden"</userinput>
Hello, world
Hej, verden
</screen>

<para>
I et shell-script kan dette så enten skrives som:
</para>

<programlisting>
#! /bin/sh
echo "Hello, world" ; echo "Hej, verden"
</programlisting>

<para>
eller med en ny linje imellem hver kommando:
</para>

<programlisting>
#! /bin/sh
echo "Hello, world"
echo "Hej, verden"
</programlisting>

<para>
Bemærk at <emphasis>;</emphasis> blot betyder det samme som en ny linje
med en ny kommando.
I de følgende eksempler vil ; blive brugt flittigt, men det er egentlig
kun for at få scriptet til at se pænere ud og blive mere læseligt.
</para>

<para>
Hvor ; kan bruges til at skrive flere kommandoer på den samme linje,
kan det lige nævnes at \ kan bruges til at dele en meget lang linje op i flere
linjer, så den bliver mere læselig.
Dette kræver at \ står til sidst på linjen, og der må ikke være et mellemrum
eller andet tegn efterfølgende.
</para>

<programlisting>
#! /bin/sh
echo "Hello, " \
 "world"
</programlisting>

<para>
I de følgende afsnit vil blive brugt lidt mere besværlige
funktioner. Når det scriptet ikke vil som du vil, kan det
ofte hjælpe lidt ved at få skrevet ud hvad der sker undervejs.
Indsæt <command>set -x</command> for at se hvilke kommandoer
der bliver udført.
</para>

<programlisting>
#! /bin/sh
set -x
echo "Hello, world"
</programlisting>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
+ echo 'Hello, world'
Hello, world
</screen>


</sect2><!-- shell-flere-kom -->

  <sect2 id="shell-var">
   <title>Variable</title>

   <indexterm>
    <primary>Shell script</primary>
    <secondary>variable</secondary>
   </indexterm>

   <para>
    I shell script kommer man tit ud for at skulle bruge den samme
    værdi eller tekst flere gange. Her kan man med fordel bruge en
    variabel til at gemme værdien i.  Variabelnavne kan både skrives
    med majuskler og minuskler, men de fleste skriver kun
    variabelnavne med majuskler.

<programlisting>
#! /bin/sh
VERSION="0.1.2"
echo "Dette er version $VERSION af programmet."
echo $VERSION
</programlisting>
   </para>

   <para>
    Skal der være bogstaver eller tal lige efter variablen, er det
    nemmest at sætte et par {} omkring.  Hvis ikke der sættes {}
    omkring variablen, vil fortolkeren opfatte den efterfølgende tekst
    som en del af variablens navn.  Alternativt kunne man skrive to
    linjer, men det kan til tider ikke lade sig gøre.

<programlisting>
#! /bin/sh
VERSION="0.1.2"
echo "Dette er version ${VERSION}beta af programmet."
</programlisting>
   </para>

   <para>
    Længden af en streng fås med <emphasis>${#NAVN}</emphasis>.

<programlisting>
#! /bin/sh
echo "\$PATH indeholder ${#PATH} tegn"
</programlisting>
   </para>

   <para>
    Er en variabel ikke nødvendigvis allerede blevet tildelt en værdi,
    kan man angive en standardværdi
    (<literal>${VARIABELNAVN:-STANDARDV&AElig;RDI}</literal>) eller tildele
    den en standardværdi
    (<literal>${VARIABELNAVN:=STANDARDV&AElig;RDI}</literal>):

<programlisting>
#! /bin/sh
unset FLOPPY # $FLOPPY har ingen værdi nu.
echo "Data skrives til ${FLOPPY:-/dev/fd0}"
echo "\$FLOPPY er stadig tom: '$FLOPPY'"
echo "Hvis \$FLOPPY er tom, så tilskriv: '${FLOPPY:=/dev/fd0}'"
echo "Nu har \$FLOPPY en værdi: '$FLOPPY'"
</programlisting>
   </para>

   <para>
    Og når scriptet køres:

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>./hello</userinput>
Data skrives til /dev/fd0
$FLOPPY er stadig tom: ''
Hvis $FLOPPY er tom, så tilskriv: '/dev/fd0'
Nu har $FLOPPY en værdi: '/dev/fd0'
</screen>
   </para>

   <para>
    Som et mere praktisk eksempel, kan vi skrive et program der enten
    monterer en diskette fra det første diskettedrev
    (<filename>/dev/df0</filename>) eller fra det diskettedrev
    programmet får på kommandolinjen:
<programlisting>
#! /bin/sh
# Et mere praktisk eksempel hvor der enten bruges
# kommando-parameter eller default:
# (Du skal selvfølgelig selv slette 'echo')
echo mount ${1:-/dev/fd0} /mnt/floppy
</programlisting>
   </para>

   <para>
    Vi afprøver det her både med og uden en kommandolinjeparameter:

<screen>
<prompt>[tyge@hven ~]$ </prompt><userinput>./hello</userinput>
mount /dev/fd0 /mnt/floppy
<prompt>[tyge@hven ~]$ </prompt><userinput>./hello /dev/fd1</userinput>
mount /dev/fd1 /mnt/floppy
</screen>
   </para>

   <para>
    Variable kan splittes og manipuleres på forskellige måder med de
    indbyggede kommandoer.  Nogle foretrækker de eksterne programmer
    såsom <command>cut</command> og <command>sed</command>, men de
    indbyggede kommandoer kan ofte klare opgaven.  Skal man have fat i
    en del af en tekststreng, kan dette gøres med
    ${VAR:&lt;start&gt;:&lt;antal&gt;}, første tegn starter ved 0
    (nul):

<programlisting>
#! /bin/sh
TEKST=abcdef
echo "Skriv kun 'bcd': ${TEKST:1:3}"
echo "Man kan også regne: ${TEKST:1:10-7}"
</programlisting>
   </para>

   <para>
    Skal en del af en variabel udskiftes med noget andet, bruges en
    substituering.  Herunder er det de først forekommende 3 tegn 'bcd'
    der udskiftes med 1 tegn 'X':

<programlisting>
#! /bin/sh
TEKST=abcdefabcdef
echo "Udskift 'bcd' med 'X': ${TEKST/bcd/X}"
</programlisting>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Udskift 'bcd' med 'X': aXefabcdef
</screen>
   </para>

   <para>
    Skal alle forekomster af et eller flere tegn udskiftes bruges
    »//«:

<programlisting>
#! /bin/sh
TEKST=abcdefabcdef
echo "Udskift alle 'bcd' med 'X': ${TEKST//bcd/X}"
</programlisting>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Udskift alle 'bcd' med 'X': aXefaXef
</screen>
   </para>

   <para>
    Den første del af en tekst-streng kan slettes ved brug af '#'.
    Den tekst der skal fjernes, kan evt. matches ved brug af globbing,
    på samme måde som man kan liste filer med <command>ls</command>:
    *?[].  Dette kan for eksempel bruges til at slette den første del af
    hostname.

<programlisting>
#! /bin/sh
echo "Fuldt hostname: ${HOSTNAME}"
echo "Uden maskinnavn: ${HOSTNAME#hven.}"
</programlisting>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Fuldt hostname: hven.sslug.dk
Uden maskinnavn: sslug.dk
</screen>
   </para>

<para>
Rigtig smart bliver det ved brug af globbing,
hvor man kan fjerne alt frem til det første punktum.
</para>

<programlisting>
#! /bin/sh
echo "Fuldt hostname: ${HOSTNAME}"
echo "Uden maskinnavn: ${HOSTNAME#*.}"
</programlisting>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Fuldt hostname: hven.sslug.dk
Uden maskinnavn: sslug.dk
</screen>

<para>
En mere 'grådig' variant kan fjerne frem til
den sidste forekomst af punktum.
Her er det så '##' der skal bruges.
</para>

<programlisting>
#! /bin/sh
echo "Fuldt hostname: ${HOSTNAME}"
echo "Uden maskinnavn og domæne: ${HOSTNAME##*.}"
</programlisting>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Fuldt hostname: hven.sslug.dk
Uden maskinnavn og domæne: dk
</screen>

<para>
På samme måde som den første del af en tekst-streng
kan fjernes, kan den sidste del fjernes med %.
</para>

<programlisting>
#! /bin/sh
echo "Fuldt hostname: ${HOSTNAME}"
echo "Uden TLD: ${HOSTNAME%.*}"
</programlisting>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Fuldt hostname: hven.sslug.dk
Uden TLD: hven.sslug
</screen>

<para>
Og den mere 'grådige' variant,
hvor kun maskinnavn er tilbage ved brug af %%.
</para>

<programlisting>
#! /bin/sh
echo "Fuldt hostname: ${HOSTNAME}"
echo "Uden TLD: ${HOSTNAME%%.*}"
</programlisting>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Fuldt hostname: hven.sslug.dk
Kun maskinnavn: hven
</screen>

<para>
Et andet praktisk eksempel hvor den sidste del
af tekst-streng skal fjernes, er ved filnavne.
Har man en bunke filer der skal konverteres fra
fx 'gif' til 'jpg', men beholde det samme filnavn,
kan en lille løkke klare det.
</para>

<programlisting>
#! /bin/sh
for FIL in *.gif; do
	echo "Konverterer ${FIL} til ${FIL%.*}.jpg"
	convert ${FIL} ${FIL%.*}.jpg
done
</programlisting>

<para>
Og kør scriptet:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Konverterer otto.gif til otto.jpg
Konverterer axel.gif til axel.jpg
</screen>

<para>
Skal man splitte en tekststreng der er adskildt af et tegn,
kan det gøres på flere måder.
Nogle vil nok foretrække den mere behændige kommando
<command>cut</command>, men det kan gøres direkte
med de indbyggede kommandoer i shell.
I det forgående er beskrevet hvordan ${X#*.} kan slette
starten af en tekst der matcher <emphasis>#*.</emphasis>.
Kommandoen ${X%%.*} sletter den sidste del der matcher
<emphasis>%%.*</emphasis>.
Hvis disse to regler kombineres lidt, kan tekststrengen
splittes ved for eksempel tegnet punktum.
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>echo "Første del: ${HOSTNAME%%.*}"</userinput>
Første del: hven
<prompt>[tyge@hven ~]$</prompt> <userinput>echo "Resten: ${HOSTNAME#*.}"</userinput>
Resten: sslug.dk
</screen>

<para>
Nu mangler vi så blot at gå ind i en løkke,
indtil alle dele adskildt af '.' er skrevet ud.
Til det formål skal vi bruge kommandoen
<emphasis>while</emphasis>, hvilket vi kommer tilbage til.
Ved det sidste element i listen går det galt,
for da er der ikke noget punktum tilbage der kan slettes.
Derfor kan løkken stoppes når både <emphasis>REST</emphasis>
og <emphasis>DEL</emphasis> er ens.
Sådan kan det gøres:
</para>

<programlisting>
#! /bin/sh
REST=$HOSTNAME
DEL=""
while [ "$REST" != "$DEL" ]; do
        echo "Rest: '$REST'"
        DEL=${REST%%.*}  # slet bagfra til sidste forkomne punktum
        REST=${REST#*.}  # slet frem til og med første punktum
        echo "Del : '$DEL'"
done
</programlisting>

<para>
Og kør scriptet:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Rest: 'hven.sslug.dk'
Del : 'hven'
Rest: 'sslug.dk'
Del : 'sslug'
Rest: 'dk'
Del : 'dk'
</screen>

<para>
Hvis du lige fjerne den linje der skriver $REST ud,
så er det nok noget nær det du gerne vil have.
</para>

<para>
Læs mere om streng-manipulering med
<command>man bash</command> under "Parameter Expansion".
</para>

</sect2><!-- shell-var -->

<sect2 id="shell-parametre">
<title>Parametre til script</title>
<indexterm><primary>Shell script</primary><secondary>parametre</secondary></indexterm>
<para>
De fleste kommandoer eller programmer i UNIX kan startes med parametre på
kommando-linjen, og få programmet til at opfører sig lidt anderledes.
Parametre nummeres fra 1 og opefter, hvor ${0} er programmet selv.
</para>

<programlisting>
#! /bin/sh
echo "Dette program hedder: ${0}"
echo "Første parameter: ${1}"
echo "Anden parameter: ${2}"
</programlisting>

<para>
Programmet kan så afprøves:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello Hello world</userinput>
Dette program hedder: ./hello
Første parameter: Hello
Anden parameter: world
</screen>

<para>
Skal du vide hvor mange parametere der er på kommando-linjen,
ligger denne værdi i den specielle variabel $#.
</para>

<programlisting>
#! /bin/sh
echo "Antal parametre: $#"
echo "Første parameter: $1"
echo "Anden parameter: $2"
</programlisting>

<para>
Alle parametre til et script kan skrives ud på flere forskellige måder.
Med <command>$*</command> skrives alle parametre ud, 
adskilt af indholdet af den specielle variabel <emphasis>IFS</emphasis>.
Med <command>$@</command> skrives alle parametre ud som enkeltstående
strenge.
For at prøve de følgende eksempler, skal der to parametre på når du kalder
scriptet, hvoraf det ene skal være en tekst med to ord og " omkring.
</para>

<programlisting>
#! /bin/sh
echo "Alle parametre: $*"
IFS=","
echo "Alle parametre, nu adskilt af komma: $*"
echo "Alle parametre er adskilt af mellemrum: $@"
</programlisting>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello Hej "Linus Torvalds"</userinput>
Alle parametre: Hej Linus Torvalds
Alle parametre, nu adskilt af komma: Hej,Linus Torvalds
Alle parametre er adskilt af mellemrum: Hej Linus Torvalds
</screen>

<para>
Et program der kører under Linux har tildelt et
<emphasis>proces-id</emphasis> &ndash; et nummer.
Det er de numre som ses med for eksempel <command>ps</command>
og <command>pstree -p</command>.
Skal man stoppe et program der kører, kan det
gøres ved brug af dette proces-id.
Proces-id på det script der kører,
findes i variablen <emphasis>$$</emphasis>.
Denne værdi kan gives videre til et andet program
eller script, men i dette eksempel vil vi blot stoppe
scriptet selv.
</para>

<programlisting>
#! /bin/sh
echo "Dette script har proces-id: $$"
echo "Det kan også ses med 'ps' kommandoen:"
ps | grep $$
kill $$
</programlisting>

<para>
Starter man et program i baggrunden, så man har
to programmer kørende samtidigt, kan det være
interessant pludseligt at stoppe programmet
i baggrunden.
Proces-id for baggrundsprogrammer findes i
<emphasis>$!</emphasis> variablen.
</para>

<programlisting>
#! /bin/sh
# Start et program i baggrunden der tager tid
sleep 10 &amp;
echo "'sleep' har proces-id: $!"
echo "Det kan også ses med 'ps' kommandoen:"
ps | grep $!
kill $!
</programlisting>

<para>
For mere information om de specielle variable,
se da <command>man bash</command> og søg efter
"<emphasis>Special Parameters</emphasis>" .
</para>

</sect2><!-- shell-parametre -->

<sect2 id="shell-if">
<title>if</title>
<indexterm><primary>Shell script</primary><secondary>if</secondary></indexterm>
<para>
Betingelser for et program eller et script er næsten uundgåeligt.
Den mest brugte kontrol-struktur er <command>if</command>,
som i den simpleste form ser således ud, hvor kommandoer der
skal udføres er rykket ind for at gøre det mere læseligt:
</para>

<programlisting>
#! /bin/sh
if true; then
	echo "Værdien er sand"
	echo "Man kan skrive flere linjer her"
fi
</programlisting>

<para>
Først skal det bemærkes at <command>true</command> ikke er en specielt
indbygget kommando i fortolkeren. <command>true</command> er et program
der kaldes, og hvis det returnerer 0, er værdien sand.
<command>if</command> har selvfølgelig også en <command>else</command>.
</para>

<programlisting>
#! /bin/sh
if true; then
	echo "Værdien er sand"
else
	echo "Værdien er falsk"
fi
</programlisting>

<para>
I <xref linkend="shell-flere-kom"/> blev ; nævnt som et tegn der
bruges til at adskille kommandoer.
Som det ses herover, er der sat et ; ind foran <command>then</command>,
hvilket lige så godt kunne stå på næste linje.
De fleste der skriver shell-scripts foretrækker dog at skrive det
på ovenstående måde, selvom det ved første øjekast ser lidt
underligt ud med en ; efter ].
</para>

<para>
Parametren til <command>if</command> er altså et program der kaldes,
og så udføres enten kommandoerne efter <command>then</command>
eller efter <command>else</command>.
</para>

<para>
<command>if</command> bruges altid sammen med et andet program
der enten returnerer sand eller falsk. 
Ofte er det kommandoen <command>[</command> eller <command>test</command>
<command>if</command> bruges sammen med,
hvilket er beskrevet i <xref linkend="shell-test"/>.
</para>

</sect2><!-- shell-if -->

<sect2 id="shell-test">
<title>Test [</title>
<indexterm><primary>Shell script</primary><secondary>test [</secondary></indexterm>
<para>
Til test for om noget er sandt eller falsk,
bruges slet og ret programmet <command>test</command>.
I shell-scripts vil man dog ofte ikke skrive <command>test</command>,
men derimod bruge det symbolske link <command>[</command>.
Når man bruger [ sammen med if, tror mange til at starte med,
at [ er en del af kommandoen til if, men det er altså et selvstændigt
program.
Når man har valgt at lave et symbolsk link til test,
skyldes det blot at det er mere læseligt med [.
Prøv kommandoen <command>ls -l /usr/bin/[</command> .
</para>

<para>
En meget brugt kommando med [,
er at undersøge om en fil eksisterer.
Dette gøres med parametren '-e'.
</para>

<programlisting>
#! /bin/sh
if [ -e foo ]; then
	echo "Ja, filen 'foo' findes."
else
	echo "Nej, filen 'foo' findes ikke."
fi
</programlisting>

<para>
Er det kun hvis filen ikke findes, at der skal gøres noget,
bruges not-kommandoen <command>!</command>.
</para>

<programlisting>
#! /bin/sh
if [ ! -e foo ]; then
	echo "&Aring;h-nej, filen 'foo' findes ikke."
fi
</programlisting>

<para>
Bemærk at der i ovenstående eksempel er brugt en hel del
mellemrum ved <command>if [ ! -e foo ]</command> .
<emphasis>Alle</emphasis> disse mellemrum skal være der,
ellers kommer der mange underlige fejl der er svære at få øje på.
I andre programmeringssprog vil du nok undlade nogle af
mellemrumene, men ingen kan undværes i dette eksempel.
</para>

<para>
<command>test</command> har et væld af muligheder, hvor
vi kun viser de mest brugte her.
For yderligere information om [ kaldes <command>man test</command> .
</para>

<programlisting>
#! /bin/sh
if [ -z "$1" ]; then
	echo "Fejl! Første parameter findes ikke (zero)."
fi

if [ ! -z "$1" ]; then
	echo "Første parameter findes, og er: $1"
fi

if [ -n "$1" ]; then
	echo "Første parameter findes (non-zero), og er: $1"
fi

if [ -x foo ]; then
	echo "Programmet 'foo' findes, og du kan køre det."
fi

TEKST="Ja"
if [ "$TEKST" = "Ja" ]; then
	echo "Tekstsvaret var 'Ja'."
fi

NUMMER=3
if [ $NUMMER -eq 3 ]; then
	echo "Heltallet i variablen \$NUMMER er 3"
else
	echo "\$NUMMER er lig med $NUMMER"
fi

if [ $NUMMER -lt 4 ]; then
	echo "\$NUMMER er mindre end 4"
fi

if [ $NUMMER -gt 0 -a $NUMMER -lt 4 ]; then
	echo "\$NUMMER er større end 0 og mindre end 4"
fi

if [ $# -le 2 ]; then
	echo "Der er 2 eller færre parametre på kommando-linjen"
fi
</programlisting>

<para>
[ kan også bruges i en mere kort form,
hvis det kun er en enkelt kommando der efterfølgende
skal udføres.
Ved at sætte &amp;&amp; ind, køres den anden kommando,
hvis første kommando var sand.
Læs mere om &amp;&amp; i <xref linkend="koerflere"/>.
</para>

<programlisting>
#! /bin/sh
[ -e foo ] &amp;&amp; echo "Filen 'foo' findes"
</programlisting>

<para>
Læs mere om ovenstående parametre til [ i
<command>man test</command>, eller <command>man bash</command>
under "CONDITIONAL EXPRESSIONS".
</para>

</sect2><!-- shell-test -->

<sect2 id="shell-case">
<title>Case</title>
<indexterm><primary>Shell script</primary><secondary>case</secondary></indexterm>
<para>
Skal man undersøge mange forskellige tekst-strenge,
kan det nemt blive uoverskueligt med <command>if</command>-kommandoer.
Med <command>case</command> kan man nemt undersøge en hel række
og gøre noget forskelligt ved hver situation.
Herunder et simpelt eksempel der undersøger hvilket
HOSTNAME der er på systemet.
</para>

<programlisting>
#! /bin/sh
case $HOSTNAME in
	(hven.sslug.dk)
		echo "Vi er på Hven"
		;;
	(saltholm.sslug.dk)
		echo "Vi er på Saltholm"
		;;
	(*)
		echo "Vi er et andet sted: $HOSTNAME"
		;;
esac
</programlisting>

<para>
Ved kørsel på dit system får du nok et andet svar, fx:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Vi er et andet sted: peberholm.sslug.dk
</screen>

<para>
I stedet for at matche teksten helt præcist, kan man
bruge <emphasis>globbing</emphasis> som med filnavne:
</para>

<programlisting>
#! /bin/sh
case $1 in
	(ventilatore)
		echo "Match på 'ventilatore'"
		;;
	(ventil*)
		echo "Match på 'ventil*': $1"
		;;
	(ven*)
		echo "Match på 'ven*': $1"
		;;
	(*)
		echo "Ingen match: $1"
		;;
esac
</programlisting>

<para>
Herefter kan forskellige ord så prøves af:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Ingen match:
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello ventilator</userinput>
Match på 'ventil*': ventilator
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello vender</userinput>
Match på 'ven*': vender
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello world</userinput>
Ingen match: world
</screen>

<para>
Der er et mere avanceret eksempel med <command>case</command>
i <xref linkend="shell-while"/> der er kombineret med <command>while</command>.
</para>

</sect2><!-- shell-case -->

  <sect2 id="shell-psubst">
   <title>Processubstituering</title>

   <indexterm>
    <primary>Shell script</primary>
    <secondary>processubstituering</secondary>
   </indexterm>

   <indexterm>
    <primary>Shell script</primary>
    <secondary>proceserstatning</secondary>
   </indexterm>

<para>
Man kan komme ud for at skulle bruge output fra et program
til et andet program.
Dette kan gøres enten ved bruge af <command>`kommando`</command>
eller <command>$(kommando)</command>.
De to måder at gøre det på, udfører det samme.
En simpel forklaring på hvornår processubstituering med fordel
kan bruges, er hvis man først skal finde en fil og dernæst
vil vide hvor stor filen er.
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>which mount</userinput>
/bin/mount
<prompt>[tyge@hven ~]$</prompt> <userinput>ls -ho /bin/mount</userinput>
-rwsr-xr-x    1 root          67K Feb 26  2002 /bin/mount*
</screen>

<para>
Nu gør vi det samme, men denne gang 'gribes' output
fra which, og bruges som parameter til ls.
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>ls -ho `which mount`</userinput>
-rwsr-xr-x    1 root          67K Feb 26  2002 /bin/mount*
</screen>

<para>
Og sidder du ved et fremmed tastatur hvor det ikke lige
er til at finde tegnet <command>`</command>, så brug <command>$()</command>.
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>ls -ho $(which mount)</userinput>
-rwsr-xr-x    1 root          67K Feb 26  2002 /bin/mount*
</screen>

<para>
I shell scripts ser man ofte at output fra et andet 
program bliver gemt i en variabel.
Det kunne være et filnavn der er dannet ud fra dags dato.
</para>

<programlisting>
#! /bin/sh
DATO=$(date -I)
FIL="backup-$DATO.tar.gz"
echo "Dagens backup gemmes i: $FIL"
tar czvf $FIL /home
</programlisting>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Dagens backup gemmes i: backup-2002-12-31.tar.gz
</screen>

<para>
Mere information om kommando erstatning findes i
<command>man bash</command> under
<emphasis>Command Substitution</emphasis>.
</para>

</sect2><!-- shell-psubst -->

<sect2 id="shell-for">
<title>For-løkker</title>
<indexterm><primary>Shell script</primary><secondary>for-løkker</secondary></indexterm>
<para>
For-løkker kan udføres på flere måder i shell scripts.
Det kan være en liste af ord, liste af filnavne eller et 
matematisk udtryk.
Den simpleste måde er en liste af ord.
</para>

<programlisting>
#! /bin/sh
for NAVN in Tyge Otto Axel; do
	echo "Han hedder $NAVN"
done
</programlisting>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Han hedder Tyge
Han hedder Otto
Han hedder Axel
</screen>

<para>
En liste af ord kan også stamme fra et andet program,
hvor hvert ord så behandles for sig.
Kommandoen <command>date</command> giver som udganspunkt
en liste af ord og tal.
</para>

<programlisting>
#! /bin/sh
date
for TEKST in $(date); do
	echo "Del-streng: $TEKST"
done
</programlisting>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Tue Dec 31 23:59:59 CET 2002
Del-streng: Tue
Del-streng: Dec
Del-streng: 31
...
</screen>

<para>
For-løkker kan også bruges med fil-navne.
Har man en masse filer der skal gøres noget med,
skal man stå i katalog hvor filerne er, og så
lave en globbing med for eksempel <emphasis>*.html</emphasis>.
</para>

<programlisting>
#! /bin/sh
for FIL in *.html; do
	echo "Filnavn er: $FIL"
	# Her gøres noget med filen.
	lynx -dump $FIL | lpr -o page-left=36
done
</programlisting>

<para>
Når der så er filerne <filename>index.html</filename> og <filename>tyge.html</filename>
bliver resultatet:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Filnavn er: index.html
Filnavn er: tyge.html
</screen>

<para>
Er det udvalgt liste af filer der skal gøres noget med,
fx kopieres eller installeres, kan man skrive det pænt
og organiseret.
</para>

<programlisting>
#! /bin/sh
# Husk: \ til sidst på linjen, betyder at teksten
# fortsætter på næste linje.
FILER="\
index.html \
tyge.html \
otto.html \
"
for FIL in $FILER; do
	if [ -e $FIL ]; then
		echo "Filnavn er: $FIL"
	fi
done
</programlisting>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
Filnavn er: index.html
Filnavn er: tyge.html
Filnavn er: otto.html
</screen>

<para>
En for-løkke kan selvfølgelig også være en simpel talrække.
Herunder udskrives blot tallene 1 til og med 4.
</para>

<programlisting>
#! /bin/sh
for (( N=1; N&lt;5; N++ )); do
	echo "Tal $N"
done
</programlisting>

<para>
En anden måde man kan lave lange talrækker er ved brug
af kommandoen <command>seq</command>.
Herunder udskrives blot tallene 1 til og med 4.
</para>

<programlisting>
#! /bin/sh
for N in $(seq 1 1 4); do
	echo "Tal $N"
done
</programlisting>

<para>
En af fordelene ved <command>seq</command> er at tallene
kan formateres, for eksempel med nuller foranstillet:
</para>

<programlisting>
#! /bin/sh
for N in $(seq -f "%04g" 1 1 4); do
	echo "Tal $N"
done
</programlisting>

<para>
Resultat:
</para>

<screen>
<prompt>[tyge@hven ~]$</prompt> <userinput>./hello</userinput>
0001
0002
0003
0004
</screen>

</sect2><!-- shell-for -->

<sect2 id="shell-while">
<title>Løkke, while</title>
<indexterm><primary>Shell script</primary><secondary>while</secondary></indexterm>
<indexterm><primary>while</primary></indexterm>

<para>
<command>while</command> bruges til at blive ved med at udføre nogle
kommandoer, sålænge en betingelse er opfyldt.
Et simpelt eksempel der blot skriver det samme hele tiden:
</para>

<programlisting>
#! /bin/sh
while true; do
	# Skriv sekunder
	date +%S
done
</programlisting>

<para>
Et mere avanceret eksempel der tager parametre fra
kommandolinjen og gør noget forskelligt med hver
parameter:
</para>

<programlisting>
#! /bin/sh
while [ $# -gt 0 ]; do
	case $1 in
		--help)
			echo "Her er hjælpen"
			exit 0
			;;
		-f)
			# Næste parameter er filnavn
			# Det hentes frem med 'shift'
			shift
			FIL=$1
			;;
		*)
			echo "Ukendt parameter: $1"
			exit 1
			;;
	esac
	shift
done
</programlisting>

<para>
Ovenstående eksempel er inspireret af shell-scriptet
<filename>/sbin/mkbootdisk</filename>.
</para>

</sect2><!-- shell-while -->

<sect2 id="shell-let">
<title>Regne, heltal</title>
<indexterm><primary>Shell script</primary><secondary>regne</secondary></indexterm>

<para>
Ved brug af dobbelt-paranteser kan regneoperationer udføres
direkte, og det er ikke nødvendigt at bruge <command>$</command>
foran variable.
Er er nogle eksempler:
</para>

<programlisting>
#! /bin/sh
(( N=1 ))
echo "Antal filer: $(( N+2 ))"
(( N += 1))
let N += 1

(( N = 5 ))
while (( N -= 1 ))
do
	echo "$N"
done
</programlisting>

</sect2><!-- shell-let -->

<!--
<sect2 id="shell-function">
<title>Funktioner</title>
<indexterm><primary>Shell script</primary><secondary>funktioner</secondary></indexterm>

<para>

</para>

<programlisting>
#! /bin/sh
function skriv {
	echo $1
}
skriv "Hello"
</programlisting>
</sect2>--><!-- shell-function -->

<sect2 id="shell-read">
<title>read, input fra bruger</title>
<indexterm><primary>Shell script</primary><secondary>read</secondary></indexterm>
<indexterm><primary>read</primary></indexterm>
<para>
En nem måde at lave interaktive programmer er ved hjælp af 
shell-kommandoen <command>read</command>.
Med <command>read</command> kan man indlæse input fra brugeren
i en variabel, der så efterfølgende kan bruges i scriptet.
En simpel måde at bruge <command>read</command> er ved
at lave et ophold i et script, hvor brugeren så enten kan
vælge at taste Enter eller Ctrl-C.
</para>

<programlisting>
#! /bin/sh
echo "Tast Enter for at slette filen"
read
rm -f hello.world
</programlisting>

<para>
<command>read</command> har mulighed for selv at skrive
en ledetekst, og så bliver scriptet lige en linje mindre:
</para>

<programlisting>
#! /bin/sh
read -p "Tast Enter for at slette filen"
rm -f hello.world
</programlisting>

<para>
<command>read</command> er nok mest brugt til at indlæse
input fra brugeren, og det kan gøres så simpelt på en 
kommandolinje hvor der indlæses til variablen "NAVN":
</para>

<screen>
<prompt>[tyge@hven ~]$ </prompt> <userinput>read -p "Navn: " NAVN</userinput>
Navn: Tycho
<prompt>[tyge@hven ~]$ </prompt> <userinput>echo $NAVN</userinput>
Tycho
</screen>

<para>
Ovenstående ser ud på samme måde i et script:
</para>

<programlisting>
#! /bin/sh
read -p "Navn: " NAVN
echo "Navnet er: $NAVN"
</programlisting>

<para>
Man kan undlade at angive hvilken variabel der skal indlæses
til, og i stedet bruge den som <command>read</command> selv
sætter. Navnet på den er <literal>REPLY</literal>.
Scriptet kunne så se således ud:
</para>

<programlisting>
#! /bin/sh
read -p "Navn: "
echo "Navnet er: $REPLY"
</programlisting>

<para>
En anden parameter man kan give <command>read</command> er hvor
mange tegn der skal indlæses.
Det gøres med parametren <command>-n #</command>.
Det kunne for eksempel bruges på følgende simple måde:
</para>

<programlisting>
#! /bin/sh
read -n 1 -p "Tast en vilkårlig tast for at forsætte"
</programlisting>

<para>
<command>read</command> giver en returkode ved kørsel.
Hvis man afslutter indtastning med Enter er returkoden
"0" og afslutter man med Ctrl-D er den "1".
"0" svarer til "true" og "1" til false, og det kan kombineres 
med for eksempel while. Se følgende eksempel:
</para>

<programlisting>
#! /bin/sh
echo "Indtast navne. Tast Ctrl-D for at afslutte."
while read NAVN; do
	echo $NAVN
done
</programlisting>

<para>
I ovenstående eksempel er det reelt EOF (End-Of-File) der
får løkken til at stoppe.
Dette kan også bruges hvis input kommer fra et andet
program. I eksemplet kommer input fra <command>ls</command>
og kanaler så over til <command>read</command>.
Det ser nok ud til at det er <command>while</command> der
modtager input, men det er altså <command>read</command>
der udføre indlæsningen.
</para>

<programlisting>
#! /bin/sh
ls | while read FILNAVN; do
	echo "Filens navn er: $FILNAVN"
done
</programlisting>

<para>
<command>read</command> kan også indlæse data fra
første linje i en fil.
</para>

<programlisting>
#! /bin/sh
read FIRSTLINE &lt; foo.bar
echo $FIRSTLINE
</programlisting>

<para>
Her har nu været gennemgået eksempler som har beskrevet
hvordan <command>read</command> kan bruges til de mest
almindelige ting.
Skal det være mere "poppet" med farver og styring
af skærmposition, så kan det gøres med ANSI-koder.
For at bruge ANSI-koder skal man sende en ESCAPE til
terminalen. Det er vist herunder med <emphasis>^[</emphasis>,
hvilket kan fås i editoren <command>vi</command> ved først
at tast Ctrl-V og så Esc.
</para>

<programlisting>
#! /bin/sh
read -p "<emphasis>^[</emphasis>[41mDit navn: " NAVN
echo "<emphasis>^[</emphasis>[0mNavn er: $NAVN"
</programlisting>

<para>
Inden du kaster dig ud i at bruge ANSI-koder er det
nok klogest at se på programmet <command>dialog</command>
som nok kan bruges til mange af de ting du gerne vil.
</para>

</sect2><!-- shell-read -->

</sect1><!-- shell-script -->

<sect1 id="videre-med-Unix">
<title>Videre med Linux</title>

<para>
Vi har vist en masse Linux-kommandoer, men 
dermed skal du ikke tro, at vi har vist dig alle muligheder i
Linux.  Dette kapitel yder på ingen måde Linux og Unix retfærdighed.
Der er meget at lære, men fordelen er, at du hele tiden lærer
noget nyt, men ikke behøver at være ekspert for at komme i gang. Der
findes naturligvis et hav af bøger om Unix generelt &ndash; både gode og
dårlige.
</para>

<para>
Vi vil her anbefale tre: 
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
<emphasis>Unix</emphasis> af Dave Taylor og James C. Armstrong,
forlaget IDG. Er udkommet i år 2001 på dansk.
 </para>
</listitem>
<listitem>
 <para>
Göran
Andersons bog på svensk (<ulink url="http://www.sslug.dk/gnulinux">http://www.sslug.dk/gnulinux</ulink>)
 </para>
</listitem>
<listitem> 
 <para>
<emphasis>Introduktion til Unix</emphasis>
af Knud Jørgen Kirkegaard og Torben Krog, Teknisk Forlag. </para>
</listitem>
</itemizedlist>

  <para>
   Desuden kan du måske have glæde af John Ray: <emphasis>Linux på 10
   minutter</emphasis> fra IDG, som dog er noget overfladisk. Tilsvarende
   kan du måske også have glæde af <emphasis>Linux for dummies</emphasis>
   af Phil Hughes, som er udkommet på IDG. Begge bøger er oversat til dansk.
  </para>
 </sect1>
</chapter>
