<!-- $Id$ -->
<CHAPTER ID="frihedensysadm">
<TITLE>Systemadministration af et enkeltbrugersystem</TITLE>

<indexterm><primary>Systemadministration</primary></indexterm>
<indexterm><primary>root</primary></indexterm>

<PARA>
Systemadministration er alle de opgaver, som handler om
at vedligeholde hardware og software på en computer.
</PARA>

<sidebar>
<para>
Der er en del mere om systemadministration i bogen "Linux - Friheden
til systemadministration".
</para>
</sidebar>

<PARA>
I Unix-verdenen består systemadministration ofte i at rette i en
masse forskellige opsætningsfiler. Opsætningsfilerne er rene
tekstfiler, og det vigtigste værktøj til systemadministration er
en tekst-editor såsom <command>vi</command>. Red Hat har lavet om på
dette: Der findes nu administrationssoftware, som er grafisk. Under
overfladen bruges dog stadig rene tekstfiler. Vi vil i dette kapitel
primært benytte os af Red Hats grafiske værktøjer.
</PARA>

<PARA>
Systemadministration foretages af systemadministratoren, dvs. af
brugeren <FILENAME>root</FILENAME>, som også kaldes for
superbrugeren (eng. "super user"). Du kan enten logge ind som
<FILENAME>root</FILENAME> eller skifte til denne med
programmet <command>su</command> (ordet hemmelig vises ikke på skærmen).
</PARA>

<indexterm>
 <primary>su</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>su</secondary>
</indexterm>
<indexterm>
 <primary>root</primary>
</indexterm>
<SCREEN>
<PROMPT>[anne@linus ~]$ </PROMPT><USERINPUT>su - root</USERINPUT>
Passwd: <USERINPUT>hemmelig</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT>
</SCREEN>

<PARA>
Ved at skrive "<userinput>su - root</userinput>" i stedet for blot
"<userinput>su root</userinput>" sikrer vi os, at alt er glemt om
brugeren (<FILENAME>anne</FILENAME>), som skiftede til
systemadministrator ("<userinput>su</userinput>" og "<userinput>su
root</userinput>" er i øvrigt det samme). Typisk har en bruger en del
opsætning, f.eks. omkring e-post, og denne opsætning bør du ikke
"kende" til som <filename>root</filename>. Bemærk også, at prompten
ændrede sig, da du blev <filename>root</filename>. Dollar-tegnet
blev til et hash-tegn. Da root har lov til alt på maskinen, bør du
være meget omhyggelig med, om du er root eller almindelig
bruger. Måske tror du, at det er smart at være root og kunne alt 
- det er forkert! Som root kan du komme til at skrive <userinput>rm -rf
/</userinput>, og så er hele dit Linux-system væk! For
ikke at risikere at lave unødige fejl, bør du lave en brugerkonto til dig
selv, også selv om du har root-adgangskoden. Skift kun til superbruger, hvis
det er absolut nødvendigt, og skift tilbage til din almindelige brugerkonto
hurtigst muligt.
</PARA>

<PARA>
Der eksisterer to varianter af Unix: System V (udtales "system fem")
og BSD (Berkeley Software Distribution). For en almindelig bruger er der
ikke den store forskel; den ligger hovedsagelig i, hvor de
forskellige opsætningsfiler er placeret i filsystemet, og hvordan
startsekvensen (engelsk: "boot") foregår. Red Hat (og de fleste
Linux-distributioner) har valgt side og hører til
System V familien, men låner lidt fra BSD.
</PARA>

<SECT1 ID="Mount">
<TITLE>Få adgang til andre diskdrev, cd-rom og diskettedrev</TITLE>
<indexterm>
 <primary>mount</primary> 
</indexterm>
<indexterm>
 <primary>Kommandooversigt, Samba</primary>
 <secondary>mount</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>mount</tertiary>
</indexterm>
<sect2 id="mounte-filsystemer">
<title>Montering af filsystemer</title>

<para>
For at kunne tilgå et filsystem under Linux skal det monteres
(eng. "mount") som et katalog i det filtræ, som er blevet
genereret af init-processen under opstarten.
</para>

<para>
<indexterm><primary>/etc/fstab</primary></indexterm>
rodfilsystemet monteres direkte mens kernen starter.
Herefter vil systemet automatisk montere de filsystemer, der
er angivet i filen <filename>/etc/fstab</filename>, og som har en
parameter, der fortæller at filsystemet skal monteres under opstarten.
<indexterm><primary>mount</primary></indexterm>
</para>

<SCREEN>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>mount -a</USERINPUT>
</SCREEN>

<para> 
vil montere de relevante filsystemer i
<filename>/etc/fstab</filename>. Denne kommando udføres under
starten af et af de programmer, der findes i kataloget
<filename>/etc/rc.d/</filename>. Derfor vil disse filsystemer være
tilgængelige fra starten. Senere kan man så manuelt montere de ekstra
filsystemer, der måtte være behov for.
</para>

<para>
Eksempel på <filename>/etc/fstab</filename>:
</para>

<screen>
#device mountpoint(dir) type   option dump fsck
/dev/hda2  /           ext2    default             1 1
/dev/hda3  /usr        ext2    default             1 2
/dev/hda4  /home       ext2    default             1 2
/dev/fdO   /mnt/floppy ext2    noauto,rw,user,exec 0 0
/dev/cdrom /mnt/cdrom  iso9660 noauto,ro,user,exec 0 0
none       /proc       proc    default             0 0
</screen>

<para>
Parameterforklaring:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
  defaults (rw, suid, dev, exec, auto, nouser, asunc)
 </para>
</listitem>
<listitem> 
 <para>
  rw (read-write)
 </para>
</listitem>
<listitem> 
 <para>
  ro (read-only)
 </para>
</listitem>
<listitem> 
 <para>
  user (tillader en alm. bruger at montere filsystemet - forudsætter 
   noexec, nosuid, nodev)
 </para>
</listitem>
<listitem> 
 <para>
  noauto (kan kun monteres eksplicit, dvs. at
  <command>mount -a</command> vil ikke montere filsystemet).
 </para>
</listitem>
</itemizedlist>

<para>
<indexterm><primary>fsck</primary></indexterm>
<indexterm><primary>dump</primary></indexterm>
De to sidste tal på linien henviser dels til dump-kommandoen, der
benytter tallet til at sammenligne med antallet af dage, siden der
sidst blev taget backup af filsystemet, således at systemadministratoren
kan informeres. Se i øvrigt online-manualen for kommandoen
<command>dump</command>. Den sidste parameter på linien benyttes af
kommandoen <command>fsck</command> til at afgøre, om filsystemer kan
checkes parallelt under opstarten (boot). Root-filsystemet (
dvs. <filename>/</filename> ) checkes altid først. De andre
filsystemer kan checkes parallelt (multitasking er jo understøttet i
Linux), men der er ingen fordel i at checke flere filsystemer på samme
fysiske disk samtidig, da det vil resultere i overflødig flytning af
læsehovedet og dermed slid og spild af tid. En parameter på nul (0) eller ingen
parameter (f.eks. floppy og cd-rom) betyder, at filsystemet ikke checkes. 
</para>

<para>
Se i øvrigt online-manualen for kommandoerne <command>fsck</command>,
<command>dump</command> og <command>mount</command> (brug
<command>man fsck</command> osv.)
</para>

<para>
Mount-kommandoen er generelt kun beregnet for systemadministratoren,
med mindre der står "user" i device-feltet i filen
<filename>/etc/fstab</filename>.
</para>

<para>
Formatet for mount-kommandoen er:
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>mount -t type device mount-point</USERINPUT>
</SCREEN>

<para>
Eksempler:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
  1) Montering af harddisk:
 </para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>mount -t ext2 /dev/hda2 /mnt/disk</USERINPUT>
</SCREEN>

 <para>
 monterer diskafsnittet <filename>/dev/hda2</filename> som kataloget
 <filename>/mnt/disk</filename>.
 </para>
</listitem>

<listitem> 
 <para>
 2) Montering af diskette til Linux-filer (med ext2-filsystem)
 </para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>mount -t ext2 /dev/fd0 /mnt/floppy</USERINPUT>
</SCREEN>

 <para>
 Alternativ 1:
 </para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>mount /dev/fd0</USERINPUT>
</SCREEN>

<para>
henter resten af oplysningerne fra <filename>/etc/fstab</filename>.
</para>

 <para>
 Alternativ 2:
 </para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>mount /mnt/floppy</USERINPUT>
</SCREEN>

 <para>
 henter ligeledes resten af oplysningerne fra <filename>/etc/fstab</filename>.
 </para>
</listitem>

<listitem> 
 <para>
 3) Montering af diskette til DOS-filer (msdos)
 </para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>mount -t msdos /dev/fd0 /mnt/floppy</USERINPUT>
</SCREEN>
</listitem>

<listitem> 
 <para>
 4) Montering af diskette til Windows-filer (vfat)
 </para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>mount -t vfat /dev/fd0 /mnt/floppy</USERINPUT>
</SCREEN>

</listitem>

<listitem> 
 <para>
 5) Montering af cd-rom (i iso9660-format)
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>mount -t iso9660 /dev/cdrom /mnt/cdrom</USERINPUT>
</SCREEN>

 <para>
 Alternativ 1: 
 </para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>mount /dev/cdrom</USERINPUT>
</SCREEN>

<para>
henter resten af oplysningerne fra <filename>/etc/fstab</filename>.
</para>

 <para>
 Alternativ 2: 
 </para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>mount /mnt/cdrom</USERINPUT>
</SCREEN>

 <para>
 henter ligeledes resten af oplysningerne fra <filename>/etc/fstab</filename>.
 </para>
</listitem>
</itemizedlist>

<para>
 Det omvendte af at montere et filsystem, er at afmontere
 (eng. "unmount") filsystemet. At afmontere et filsystem har to
 virkninger:
</para>

 <itemizedlist mark="letter">
  <listitem>
  <para>  
   Det skriver alle data til den fysiske disk.
  </para>  
  </listitem>
  <listitem>
  <para>  
   Derefter er filsystemet ikke længere til rådighed.
   fra dets <emphasis>mount point</emphasis>.
  </para>  
  </listitem>
 </itemizedlist>

<para>
 Afmontering af et filsystem sker med kommandoen "umount"
 (bemærk: kun med ét "n").
</para>

<para>
Eksempel:
</para>

<indexterm>
 <primary>umount</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>umount</secondary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>Grundlæggende kommandobeskrivelse</secondary>
 <tertiary>umount</tertiary>
</indexterm>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>umount /dev/fd0 #(afmonterer disketten)</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>umount /mnt/floppy #(afmonterer disketten)</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>umount /dev/cdrom #(afmonterer disketten)</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>umount /mnt/cdrom #(afmonterer cd-rom)</USERINPUT>
</SCREEN>

<para>
<indexterm><primary>sync</primary></indexterm>
<emphasis>Vigtigt!</emphasis> Det er vigtigt at bemærke, at man ikke
kan/skal fjerne diskette eller andre ydre medier, der er monteret, før
<command>umount</command> er kørt, idet der så kan mangle dele af de data,
der er skrevet til mediets filsystem, og det kan medføre store
problemer. Man kan tvinge systemet til at foretage en synkronisering
vha. kommandoen <command>sync</command>, idet alle filsystembuffere
så skrives til mediet. Kommandoen <command>umount</command> gør det samme.
</para>

<para>
Kommandoen <command>umount</command> kræver, at der ikke er
nogen, der arbejder på det filsystem man vil afmontere,
dvs. hvis du står i <filename>/mnt/cdrom</filename> hvor din cd-rom
er monteret, så kan du ikke afmontere den. 
</para>

<para>
På samme måde vil kommandoen <command>mount</command> give
fejlmeddelelsen "device already mounted", hvis man glemmer at
afmontere et filsystem, når der forsøges med et nyt filsystem.
</para>

<para>
En meget vigtig pointe er at root-brugeren kan montere alt, mens den
almindelige bruger kun kan montere de enheder, der specifikt er nævnt med
et "user"-flag i <filename>/etc/fstab</filename>. Typisk vil man kun
give brugere adgang til at montere løse enheder som diskette og cd-rom,
og hvis man er forsigtig, giver man kun de brugere, der har fysisk adgang
til maskinen lov til at læse og skrive disketter og cd-rom'er. Det gøres
ved at lade disse enheder høre til en brugergruppe, der kun består af
de lokale brugere, og så slå skrive- og læserettigheder fra for alle andre
end enhedernes ejer og gruppe. Se 
<command>man chgrp</command>, <command>man chmod</command> og 
<command>man usergrp</command> for information om
hvordan det gøres.
</para>
</sect2>

<sect2 id="usb-mount">
<indexterm><primary>USB</primary><secondary>kamera</secondary></indexterm>
<indexterm><primary>USB</primary><secondary>memory-key</secondary></indexterm>
<indexterm><primary>memory-key</primary><secondary>USB</secondary></indexterm>
<indexterm><primary>kamera</primary><secondary>USB</secondary></indexterm>

<title>Montering af USB-enheder</title>
<para>
USB er ved at blive en populær måde at koble eksterne enheder på
computeren, såsom printere, kameraer og memory-keys (fra 8MB og op til 1
GB nøgleringe).
</para>

<para>
Vi skal her se på hvordan man får adgang til en USB memory-key, og
samme fremgangsmåde kan anvendes til kameraer såsom Olympus UZ2100 og
HP Photosmart 610.
</para>

<para>
Jeg har på min laptop fat i min USB-nøglering
ved at have følgende linie i min <filename>/etc/fstab</filename>
</para>

<screen>
/dev/sda1 /mnt/usb auto noauto,owner,user,rw 0 0
</screen>

<para>
Som root skrives <command>mkdir /mnt/usb</command> for at lave
monteringspunktet.
</para>

<para>
Derefter vil kommandoerne
<command>mount /mnt/usb</command> og
<command>umount /mnt/usb</command> virke fint - og brugeren har nu
læse <emphasis>og</emphasis> skriverettigheder til drevet.
</para>

<para>
<emphasis>Tip:</emphasis> I <xref linkend="autofs"> er vist hvordan man får
monteret en eksterne USB-nøglering automatisk når dette er påkrævet.
</para>

<para>
Det kræver nok at din Linuxkerne kan se nøgleringen. Dette kan du se
ved at skrive <command>cat /proc/scsi/usb-storage-0/0</command> eller 
<command>cat /proc/scsi/usb-storage-0/1</command>. Dette
skulle gerne vise at det er en "IBM USB memory key" (eller hvad der nu
er det rigtige). Bemærk at det åbenbart kræver SCSI emulering - og det
skal være en ret ny kerne. Det virker f.eks. ikke direkte i Red Hat
7.2, mens det virker fint med Red Hat 7.3.
</para>

<para>
<emphasis>Tip:</emphasis> For dem som selv vil
oversætte Linux-kernen til at understøtte en "IBM USB memory key" så
kræves modulerne "usbdevfs", "hub" og "usb-storage".
</para>

<para>
Det sidste spørgsmål er naturligt hvordan jeg så fandt ud af at det er
<filename>/dev/sda1</filename> som kan monteres. Til dette kan
programmet <command>hwbrowser</command> anvendes (kræver at
<filename>hwbrowser.*rpm er installeret)</filename>. Start
<command>hwbrowser</command> i et terminal-vindue og angiv
root-adgangskoden for at detektere hardware i maskinen.
</para>

<indexterm><primary>hwbrowser</primary></indexterm>
<indexterm><primary>hardware</primary><secondary>dektektion af hardware</secondary></indexterm>


<FIGURE ID="hwbrowser-fig" FLOAT="1">
<TITLE>hwbrowser anvendes til at detektere hardware</TITLE>
<GRAPHIC FILEREF="hwbrowser.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<para>
Under "Hard Drives" bør man nu kunne se at
<filename>/dev/sda1</filename> er en harddisk på 32 MB, hvis man har
memory sticken inde.
</para>

<FIGURE ID="hwbrowser2-fig" FLOAT="1">
<TITLE>hwbrowser anvendes til at detektere hardware</TITLE>
<GRAPHIC FILEREF="hwbrowser2.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<para>
<emphasis>Tip:</emphasis> Et andet trick med USB er at læse filer i
<filename>/proc/bus/usb/devices</filename> - her skal man kunne se 
at USB-enheden er fundet.
</para>

<para>
<emphasis>Tip:</emphasis> Alternativt så sæt din USB-enhed på maskinen
og kør <command>dmesg</command>. Typisk vi de nederste linier sige at
der er fundet en enhed <filename>/dev/sda</filename>,
<filename>/dev/sda1</filename>, <filename>/dev/sdb1</filename> eller 
<filename>/dev/sdc1</filename>. Prøv så at køre (som root) 
<command>mount /dev/sda /mnt</command>,
<command>mount /dev/sda1 /mnt</command>,
<command>mount /dev/sda2 /mnt</command>,
<command>mount /dev/sdb /mnt</command>,
<command>mount /dev/sdb1 /mnt</command> osv. indtil der er bid.
Mange USB-enheder kan findes på denne måde - men det er ikke 
indlysende hvilken USB-devicefil den enkelte USB-enhed ender under.
</para>


<para>
<emphasis>Tip:</emphasis> Med KDE kan du trykke højre muse-tast på din
baggrund og vælge "Create new" -> "CDROM device" eller på dansk "Opret
ny" -> "CD/DVD-ROM-enhed" og under device/enhed vælges nu den enhed
(<filename>/dev/sda1</filename>) som passer.
</para>

</sect2>

<sect2 id="mount-cd-rom">
<TITLE>cd-rom</TITLE>
<indexterm><primary>cd-rom</primary></indexterm>
<para>
Først en gang Linux-gymnastik, som kun skal gøres én gang på din maskine.
Skift til systemadministratorrettigheder ved at skrive <command>su -</command>.
Kontrollér, at dit cd-rom-drev er fundet og tillad alle at læse fra det:
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>ls -al /dev/cdrom</USERINPUT>
lrwxrwxrwx   1 root  root  3 Sep  4 14:31 /dev/cdrom -> hdd
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>chmod a+r /dev/hdd</USERINPUT>
</SCREEN>

<para>
Lad os tage en anden måde at opnå det samme for brugeren "anne".
Kontrollér, at dit cd-rom-drev er fundet, tillad alle i gruppen floppy
at læse fra det og føj derefter "anne" til gruppen floppy:
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>ls -al /dev/cdrom</USERINPUT>
lrwxrwxrwx   1 root  root  3 Sep  4 14:31 /dev/cdrom -> hdd
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>chgrp floppy /dev/hdd</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>chmod g+r /dev/hdd</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>chmod o-rwx /dev/hdd</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>usermod -G floppy anne</USERINPUT>
</SCREEN>


<para>
I eksemplerne er <filename>/dev/cdrom</filename> en henvisning til
<filename>/dev/hdd</filename>, dvs. cd-rom-drevet sidder på den
sekundære IDE-bus som slave (typisk situation). Se også <xref
linkend="redhatpartitioner">. Du skal ændre
<command>chgrp</command>- og <command>chmod</command>-kommandoerne, så
de svarer til den enhed dit cd-rom-drev sidder på, og
<command>usermod</command>-kommandoen skal ændres, så det er dit brugernavn
der bruges.
</para>

<para>
Redigér filen <filename>/etc/fstab</filename> med
<command>vi /etc/fstab</command> eller lignende. Du har sikkert
en linie, der starter med <filename>/dev/cdrom</filename>. Den skal du
ændre til
</para>

<SCREEN>
/dev/cdrom    /mnt/cdrom   iso9660  noauto,ro,user,exec   0 0
</SCREEN>

<para>
Hvis du <EMPHASIS>ikke</EMPHASIS> finder en linie, som ligner ovenstående, 
kan det være fordi supermount er installeret, så du automatisk får 
adgang til dit cd-rom- og diskettedrev, hvilket bl.a. Mandrake 
benytter. I så fald skal du ikke ændre noget i 
<filename>/etc/fstab</filename> og gå videre til næste afsnit.
</para>

<para>
Første kolonne viser den enhed (<filename>/dev/cdrom</filename>),
som du vil kunne tage fat i.  Næste kolonne viser det
sted i filtræet, hvor den skal kunne ses. I eksemplet har vi valgt
<filename>/mnt/cdrom</filename>.
</para>

<para>
Tredje kolonne beskriver filformatet, her er det iso9960 til en cd-rom.  
Fjerde kolonne indeholder
nøgleord, der beskriver egenskaber ved cd-rom-drevet. 'noauto' betyder,
at cd-rom-drevet ikke automatisk monteres, når maskinen startes op. 'ro'
betyder at man kun kan læse fra drevet (engelsk: "read-only"). 'user' gør det muligt at montere cd-rom'er som
almindelig bruger. 'exec' gør det muligt at køre Linux-programmer fra
cd-rom. Betydningen af de to nuller kan du finde frem til ved at udføre
kommandoen <command>man mount</command>.
</para>

<para>
Nu er du klar til at afprøve det. Stop som root ved at trykke Ctrl-D i
den terminal, du arbejder i. Læg f.eks. din Red Hat-cd-rom i dit 
cd-rom-drev, og skriv
</para>

<SCREEN>
<PROMPT>[anne@linus ~]$ </PROMPT> <USERINPUT>mount /mnt/cdrom</USERINPUT>
</SCREEN>

<para>
Nu bør du kunne skrive <userinput>df /mnt/cdrom</userinput> for at se, hvor
meget data der ligger på skiven. Du kan nu kopiere og læse fra din cd-rom.
Når du er færdig med at læse din cd-rom, kan du ikke bare tage den ud. Du skal
først skrive
</para>

<SCREEN>
<PROMPT>[anne@linus ~]$ </PROMPT> <USERINPUT>umount /mnt/cdrom</USERINPUT>
</SCREEN>

<para>
Du skal også vide, at du sagtens kan bruge
f.eks. <filename>/cdrom</filename> som stedet, du monterer din cd-rom. Du
skal bare først lave biblioteket med <userinput>mkdir /cdrom</userinput>
og gentage ovenstående med den nye sti. Endelig findes der systemer til
Linux (Automount, Supermount og AMD), hvor du mere eller mindre direkte 
kan lægge
din cd-rom i drevet og få adgang til data uden at skulle bruge
specielle kommandoer, men det skal sættes op særskilt.
</para>
</sect2>

<sect2 id="mount-DOSdisk">
<TITLE>Læse DOS/Windows-diskdrev</TITLE>
<indexterm><primary>DOS</primary><secondary>læsning af diskdrev</secondary></indexterm>
<indexterm><primary>Windows</primary><secondary>læsning af diskdrev</secondary></indexterm>
<indexterm><primary>/etc/fstab</primary></indexterm>
<para>
Tilsvarende, som med cd-rom-drevet, kan du automatisk føje dine
DOS/Windows-diskdrev til Linux-filtræet, som f.eks. <filename>/dosc/</filename>
og/eller <filename>/dosd/</filename>. Start med at lave de kataloger,
du skal bruge (her vises for disk C og D):
</para> 

<SCREEN>
<PROMPT>[anne@linus ~]$ </PROMPT><USERINPUT>su</USERINPUT>
Passwd: <USERINPUT>hemmelig</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT><userinput>mkdir /dosc</userinput>
<PROMPT>[root@linus /root]# </PROMPT><userinput>mkdir /dosd</userinput>
</SCREEN>


<para>
Redigér filen <filename>/etc/fstab</filename> med <userinput>pico -w
/etc/fstab</userinput> eller lignende. Under installationen har du
måske sat dine DOS/Windows-diskdrev ind, så de kan ses fra Linux, men her
er alligevel et eksempel på <filename>/etc/fstab</filename>.
</para>

<SCREEN>
/dev/hda1    /dosc   msdos  defaults,umask=000   0 0
/dev/hda2    /dosd   vfat   defaults,umask=000   0 0
</SCREEN>

<para>
Den første linie tager <filename>/dev/hda1</filename>, dvs. første
partition på den første IDE-disk, som her antages at være en
MS-DOS-formateret partition, og lægger den ind som
<filename>/dosc</filename>.  Tilsvarende med
<filename>/dev/hda2</filename>, dvs. anden partition på den første
IDE-harddisk, som her antages at være en vfat-formateret partition,
dvs. en Windows-partition, hvor der anvendes lange filnavne. 
</para>

<para>
Vi har her skrevet <literal>umask=000</literal>, som vil gøre at alle
brugere kan læse og skrive alle filer på <filename>/dosc</filename> og 
<filename>/dosd</filename>. Dvs. alle kan også slette systemet. Vurdér
selv om dette er acceptabelt på dit system.
</para>

<para>
Når du genstarter computeren vil du automatisk have adgang til dine
DOS/Windows-partitioner. Vil du prøve om det virker med det samme,
behøver du ikke at genstarte computeren. Du kan bare skrive
<command>mount -a</command> i et terminalvindue. Det er unødvendigt
at genstarte Linux for at gennemføre en triviel ændring, som man
typisk skal i Windows.
</para>
</sect2>


<sect2 id="mount-floppy">
<TITLE>Diskettedrev</TITLE>
<indexterm><primary>Disketter</primary></indexterm>
<indexterm>
 <primary>mdir</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mdir</secondary>
</indexterm>
<indexterm>
 <primary>mcopy</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mcopy</secondary>
</indexterm>
<indexterm>
 <primary>mcd</primary>
</indexterm>
<indexterm>
 <primary>Kommandooversigt</primary>
 <secondary>mcd</secondary>
</indexterm>
<para>
For at kunne læse dine DOS-disketter skal du gentage ovenstående
med få ændringer (<filename>msdos</filename> i stedet for
<filename>iso9660</filename> og <filename>rw</filename> i stedet for
<filename>ro</filename>). Der er dog en langt nemmere måde: Installér
RPM-pakken <filename>mtools</filename> fra din Red Hat cd-rom (dette er
nøjere beskrevet under RPM i næste afsnit).
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>rpm -i mtools*.rpm</USERINPUT>
</SCREEN>

<para>
Giv læse- og skriveadgang til <filename>/dev/fd0</filename>:
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>chmod a+rwx /dev/fd0</USERINPUT>
</SCREEN>

<para>
Med <userinput>man mtools</userinput> kan du se, at du reelt har fået de
gamle MS-DOS-kommandoer, som bare har fået et m foran. Du kan bruge
<command>mdir</command>, <command>mcopy</command>,
<command>mcd</command> osv. Du kan endda bruge <filename>a:</filename>
som i MSDOS. For at kopiere hele disketten til det bibliotek, du står i,
skal du skrive:
</para>

<SCREEN>
<PROMPT>[anne@linus ~]$ </PROMPT> <USERINPUT>mcopy a:* .</USERINPUT>
</SCREEN>

<para>
Med mtools har du også mulighed for at bruge lange filnavne, der
passer med Windows 95, og du skal ikke tænke på
<command>mount</command> og <command>umount</command>. Rigtig nyttige
programmer.
</para>
</sect2>

<sect2 id="autofs">
<title>Automatisk montering af ydre enheder med autofs</title>
<indexterm><primary>automount</primary></indexterm>
<indexterm><primary>autofs</primary></indexterm>
<indexterm><primary>Montering af cd-rom og diskette - automatisk</primary></indexterm>

<para>
I Red Hat og SuSE er der mulighed for automatisk at få monteret
eksterne enheder, såsom cd-rom og diskettedrev. Det er nemt
- du skal blot installere autofs-pakken. I Mandrake benyttes supermount, 
som er endnu smartere.
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>rpm -ivh autofs-*.rpm</USERINPUT>
</SCREEN>

<para>
Sørg først for at autofs startes op i den "runlevel", du normalt
arbejder i (oftest 3, hvilket i øvrigt står i
<filename>/etc/inittab</filename>). Det gøres ved at starte
<command>control-panel</command> og vælge ikonet med trafiklys på -
eller direkte starte <command>tksysv</command> op. Du føjer blot
autofs til runlevel 3.
</para>

<para>
Derefter skal du se i <filename>/etc/auto.master</filename>, der viser,
at <filename>/misc</filename> nu er under kontrol af automontøren.
Går du ned i <filename>/misc</filename>, bliver der monteret enheder
automatisk. Der er et tidsudløb på 60 sekunder i standardopsætningen -
dvs. 60 sekunder efter du har besøgt f.eks. din cd-rom, vil maskinen
automatisk køre <command>umount</command> for dig.  Filen
<filename>/etc/auto.misc</filename> er så der, hvor du skriver hvilke
af dine eksterne enheder der automatisk skal monteres.  Filen kan
f.eks. se ud som følger, for at din cd-rom og dit diskettedrev automatisk
monteres i  <filename>/misc/cdrom</filename> hhv.
<filename>/misc/floppy</filename>
</para>

<screen>
cdrom     -fstype=iso9660,ro               :/dev/cdrom
floppy    -fstype=auto,umask=0             :/dev/fd0
usb       -fstype=auto,gid=401,umask=007   :/dev/sda1
</screen>

<para>
Bemærk at filsystemet <filename>/misc/floppy</filename> på
floppy-disken (dvs. <filename>/dev/fd0</filename>) detekteres
automatisk (pga. auto), og at filsystemet monteres med læse og skrive
rettigheder for alle (pga. umask=0). Tilsvarende er indsat adgang til
en USB nøglering, men her har vi vist at gruppen af brugere i gruppe
401 (dette defineres i filen <filename>/etc/group</filename>) har fuld
læse og skrive rettigheder (pga. umask=007), mens "others" har ingen adgang.
</para>

<para>
Der er mange muligheder her, og er du doven, kan du endda lave en lænke
fra roden, så <filename>/cdrom</filename> peger på
<filename>/misc/cdrom</filename>, og du kan så anvende
<filename>/cdrom</filename> til at læse filer fra din
cd-rom. Tilsvarende kan det gøres for <filename>/floppy</filename>. Har
du problemer med rettigheder, læs lige de forrige afsnit.
</para>

<para>
<emphasis>Tip:</emphasis> SuSE 6.4 har via
<filename>/etc/auto.net</filename> lavet mulighed for at man kan gå
direkte ind på netværkets andre filservere (hvor dette er
tilladt). Via <filename>/net/dykker.kongeh.dk/home/dykker</filename>
får man adgang til kataloget <filename>/home/dykker</filename> på
maskinen dykker.kongeh.dk, hvis dette er eksporteret korrekt.
</para>

</sect2>

<sect2 id="smbmount">
<title>Montering af SAMBA/Windows-drev</title>
<indexterm><primary>smbmount</primary></indexterm>
<indexterm><primary>smbmount</primary></indexterm>
<indexterm><primary>SAMBA-drev</primary></indexterm>
<indexterm><primary>Windows-drev fra nettet</primary></indexterm>

<para>
Mange steder har man en Windows-filserver, eller en Linux-maskine med SAMBA
(se bogen "Linux - friheden til systemadministration"), som eksporterer
netværksdrev til Windows-maskiner. Denne kan Linux-maskinen sagtens anvende
til at få adgang til data.
</para>

<para>
Brugeren root kan montere en SMB-share (SHARE_NAVN) fra maskinen SERVER_NAVN
på Linux-maskinens katalog <emphasis>/mnt/smb_katalog</emphasis> ved at
skrive følgende.
</para>

<SCREEN>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>mount -t smbfs -o username=BRUGERNAVN,password=MIT_PASSWORD //SERVER_NAVN/SHARE_NAVN /mnt/smb_katalog</USERINPUT>
</SCREEN>
<!--$ Gerne et eksempel, af kød og blod, helst med forklaring $ -->
<para>
Der findes også kommandoerne <command>smbmnt</command> og
<command>smbmount</command>, som basalt set kan det samme, men de kan
anvendes til at brugere selv kan montere Windows-shares (dette kræver
dog at der køres <command>chmod +s /usr/bin/smb*</command>, hvilket
svækker system-sikkerheden noget).
</para>

</sect2>
</SECT1>



<SECT1 ID="lydkort">
<TITLE>Et lydkort</TITLE>
<indexterm><primary>Lydkort</primary></indexterm>
<PARA>Mange mennesker har lydkort i deres computer, og Linux understøtter
naturligvis en række af de lydkort, som du kan
købe til en personlig computer. For at lette opsætningen af
lydkort følger der med Red Hat et simpelt, men godt program til
dette formål: <command>sndconfig</command>. I dette afsnit vil du
se, hvor let det er. Lydkortet, vi bruger som eksempel, er et
Plug-n-play SoundBlaster 32 fra Creative Labs.</PARA>

<PARA>Du starter programmet ved at taste
<command>sndconfig</command> på kommandolinjen (som root). Programmet er
designet til at køre i tekst-tilstand, og du kan selv vælge, om du
vil benytte dig af en <command>xterm</command> eller bruge
konsollen. Første skærmbillede ser ud som vist nedenfor.
</PARA>

<FIGURE ID="sndconfig-start" FLOAT="1">
<TITLE>Første skærmbillede i
<command>sndconfig</command></TITLE>
<GRAPHIC FILEREF="sndconfig-start.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<PARA>Du fortsætter ved at trykke på ENTER. Det næste
skærmbillede, som du ser nedenfor, fortæller, hvilket lydkort
<command>sndconfig</command> har fundet, i dette tilfælde et
SoundBlaster 32 - som forventet. Du bør naturligvis tjekke, om
programmet finder det rigtige.
</PARA>

<FIGURE ID="sndconfig-2" FLOAT="1">
<TITLE>Hvilket lydkort finder <command>sndconfig</command>?</TITLE>
<GRAPHIC FILEREF="sndconfig-2.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<PARA>Det tredje skærmbillede tillader, at du vælger et
lydkort. Hvis nu <command>sndconfig</command> ikke har været i
stand til at finde dit lydkort, kan du nu vælge det rette. Vi
vælger naturligvis vores SoundBlaster 32 lydkort. Du kan bevæge
markøren vha. piletasterne, og du flytter markøren ned til OK og CANCEL
ved at trykke på TAB-tasten.
</PARA>

<FIGURE ID="sndconfig-3" FLOAT="1">
<TITLE>Der vælges et lydkort</TITLE>
<GRAPHIC FILEREF="sndconfig-3.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<PARA>
Det er nu tid til at vælge indstillinger for lydkortet. Her er det
typisk lettest, hvis du kender dem på forhånd, så du ikke behøver at
gætte dig frem. Det er reelt de samme oplysninger, som du i Microsoft
Windows 95 finder under "egenskaber for enheder".
</PARA>

<FIGURE ID="sndconfig-4" FLOAT="1">
<TITLE>Indstillinger for lydkortet vælges</TITLE>
<GRAPHIC FILEREF="sndconfig-4.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<PARA>Når du har valgt de rigtige indstillinger, vil
<command>sndconfig</command> afspille en kort lydsekvens for
dig. Når du hører den, betyder det, at lydkortet er korrekt
konfigureret.
</PARA>

<FIGURE ID="sndconfig-5" FLOAT="1">
<TITLE>En lydsekvens afspilles</TITLE>
<GRAPHIC FILEREF="sndconfig-5.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<para>Gik det helt galt med dit lydkort, kan det være, at du ikke
har den rette Linux-kerne og modulerne til det. Du kan
læse videre i de følgende afsnit om, hvordan kernen oversættes.
Se også på <ulink
url="http://www.alsa-project.org/">http://www.alsa-project.org/</ulink>
hvis dit lydkort ikke er understøttet direkte.
</para>
</SECT1>


<sect1 id="grafik-3D">
 <title>Linux og 3D-kort</title>

 <indexterm><primary>3D-grafikkort</primary></indexterm>
 <indexterm><primary>grafikkort</primary><secondary>3D</secondary></indexterm>

 <para>
  <indexterm>  
   <primary>3D-grafik</primary>  
   <secondary>OpenGL</secondary>
  </indexterm>  

  <indexterm>
   <primary>OpenGL</primary>
  </indexterm>

  <indexterm>  
   <primary>Mesa</primary>    
  </indexterm>  

  Som så mange andre styresystemer understøtter også Linux 3D-kort. I Linux
  bliver 3D-grafikken håndteret af et system der hedder OpenGL. SGI har nu
  udgivet OpenGL under en fri licens. Inden det skete var det meget
  almindeligt at frie programmer brugte den frie OpenGL-efterligning Mesa.
 </para>

 <para>
  OpenGL er et grafisk standardbibliotek, som bruges til at kommunikere med
  3D-grafikkort. OpenGL blev udviklet af SGI (tidligere Silicon Graphics) til
  brug i deres grafiske arbejdsstationer. OpenGL blev introduceret i 1992 og
  er med tiden blevet et af de mest brugte programmeringsgrænseflader for både
  to- og tre-dimensionel grafik. I dag bliver OpenGL varetaget af en uafhængig
  sammenslutning af firmaer inden for 3D-branchen.
 </para>

 <para>
  Hvis man ønsker at skrive styrerutiner til et 3D-grafikkort, som gør brug
  af OpenGL-teknologien, kræver det, at man betaler for en licens og for en
  bekræftelse af at styrerutinerne implementerer OpenGL korrekt.
 </para>

 <para>
  Linux-brugere har alligevel mulighed for at bruge OpenGL i form af Mesa.
  For at bruge 3D-grafikkort i Linux bliver man først nødt til at installere
  de Mesa-styrerutiner, som passer til ens grafikkort. Mesa understøtter (på
  nuværende tidspunkt) følgende grafikchips:

  <itemizedlist>
   <listitem>
    <para>
     3Dfx Voodoo1, Voodoo2, Voodoo Rush, Voodoo Banshee, Voodoo3
    </para>
   </listitem>

   <listitem>
    <para>
     nVidia (bruges i TNT-kort)
    </para>
   </listitem>

   <listitem>
    <para>
     Amiga Warp3D
    </para>
   </listitem>

   <listitem>
    <para>
     (Matrox G200, styrerutinerne til dette kort kommer med en modificeret
     udgave af Mesa)
    </para>
   </listitem>
  </itemizedlist>
 </para>

 <para>
  Når det er gjort, vil programmer, som skal bruge 3D-kortet, bruge
  Mesa-biblioteket. Du kan læse mere om Mesa på <ulink
  url="http://www.mesa3d.org/">http://www.mesa3d.org/</ulink> og om OpenGL på
  <ulink url="http://www.OpenGL.org/">http://www.OpenGL.org/</ulink>.
 </para>

 <para>
  Som du kan se er det desværre langt fra alle 3D-grafikkort, som understøttes
  i Linux. Det skyldes, at kun få grafikkortfabrikanter offentliggør en
  komplet beskrivelse af deres kort. Det gør at man ikke kan udnytte alle
  kortets funktioner, og kortets ydelse vil derfor være under det niveau man
  ser i Windows, hvor firmaet typisk selv har skrevet styrerutinerne til
  kortet. Desuden er mange af forfatterne til styrerutinerne almindelige
  programmører ofte uden den helt store tekniske indsigt, hvilket selvfølgelig
  også påvirker udviklingsarbejdet.
 </para>

<para>
De bedst understøttede 3D-kort er nok 3Dfx-kortene. Der kommer
heldigvis hele tiden nye drivere, først og fremmest til de store
fabrikanters 3D-kort.
</para>

<sect2 id="grafik-3dinstallation">
<title>Installation af 3D-grafikkort under Linux</title>

<sect3 id="grafik-3dfxinstallation">
<title>3Dfx</title>
<para>
3Dfx var blandt de første 3D-kort, som blev tilgængelige for Linux-brugere.
Det skyldes at 3Dfx-kortene kører med et system, som hedder
Glide, der har været ret nemt at få overført til Linux.  Der findes to
forskellige typer af Glide-drivere til Linux:
</para>

<para>
Der findes en, som understøtter Voodoo1, Voodoo2 og
Voodoo Rush. Se mere på  <ulink
url="http://www.3dfxgamers.com/downloads.htm">http://www.3dfxgamers.com/downloads.htm</ulink>
og <ulink url="http://glide.xxedgexx.com/3DfxRPMS_vb_glibc.html">http://glide.xxedgexx.com/3DfxRPMS_vb_glibc.html</ulink>.
</para>

<para>
Og en der understøtter Voodoo Banshee og Voodoo3 kan findes
på  <ulink
url="http://glide.xxedgexx.com/3DfxRPMS_vb_glibc.html">http://glide.xxedgexx.com/3DfxRPMS_vb_glibc.html</ulink>.
</para>

<para>
Voodoo Banshee og Voodoo3 er både et 2D og 3D-kort, så
når du installerer denne driver, bliver din 2D-driver i X også
opdateret. Når du har hentet den driver, som du skal bruge, skal den
installeres. Det gøres således efter du har hentet Glide-RPM-pakken:
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>rpm -Uvh Glide*.rpm</USERINPUT>
</SCREEN>

<para>
Når det er gjort skal Mesa installeres. Mesa findes på <ulink
url="http://www.mesa3d.org/">http://www.mesa3d.org</ulink> og ligger
i to tar.gz-filer (MesaLib og MesaDemos), som begge skal
nedlæses. Når de to filer er hentet og udpakket, skal Mesa
oversættes. 
Læs dokumentationen inden du går i gang:
</para>


<SCREEN>
<PROMPT>[root@linus mesa]# </PROMPT> <USERINPUT>make linux-glide</USERINPUT>
</SCREEN>


<para>
Du skal nu finde ud af, hvor i dit system de færdigt oversatte filer
skal kopieres hen. Derefter skal du gøre som følger: 
</para>

<SCREEN>
<PROMPT>[root@linus mesa]# </PROMPT> <USERINPUT>cd include/</USERINPUT>
<PROMPT>[root@linus include]# </PROMPT> <USERINPUT>cp -r GL/ /usr/include/</USERINPUT>
<PROMPT>[root@linus include]# </PROMPT> <USERINPUT>cd ../lib</USERINPUT>
<PROMPT>[root@linus lib]# </PROMPT> <USERINPUT>cp -d * /usr/lib/</USERINPUT>
<PROMPT>[root@linus lib]# </PROMPT> <USERINPUT>ldconfig</USERINPUT>
</SCREEN>

<para>
Nu skulle dit 3Dfx kort virke uden problemer. Hvis du ønsker at teste
dit 3Dfx kort, skal du skrive:
</para>

<SCREEN>
<PROMPT>[root@linus lib]# </PROMPT> <USERINPUT>/usr/local/glide/bin/test3Dfx</USERINPUT>
</SCREEN>

<para>
Nu skulle der gerne komme et roterende 3Dfx-logo.
</para>

<para>
<emphasis>Bemærk!</emphasis> Da din nuværende installation
kommunikerer direkte med 3Dfx-kortet, bliver du nødt til at køre dine
3Dfx-applikationer som "root". Da dette kan være irriterende og
samtidig udgøre en sikkerhedsrisiko, findes der en måde, hvorpå
man kan undgå dette problem. Det gøres med et såkaldt <emphasis>3Dfx
kernel module</emphasis>. Når først dette kernemodul er installeret,
vil de programmer (og spil), som skal bruge 3Dfx-kortet, kommunikere
via <filename>/dev/3Dfx</filename>. Denne løsning har ydermere den
fordel, at du kan bestemme, hvem der skal have adgang til kortet, men
det har samtidig den ulempe, at hastigheden på 3Dfx-kortet bliver
nedsat en smule.
</para>
<para>

</para>
<para>
Det omtalte modul er at finde på 
<ulink url="http://www.xs4all.nl/~carlo17/3dfx/">http://www.xs4all.nl/~carlo17/3dfx/</ulink>.
For at installere det skal du nedlæse tar.gz-filen, og skrive følgende:
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>mkdir dev3dfx</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>cd dev3dfx/</USERINPUT>
<PROMPT>[root@linus dev3dfx]# </PROMPT> <USERINPUT>tar zxvf ../Dev3Df*.tar.gz</USERINPUT>
<PROMPT>[root@linus dev3dfx]# </PROMPT> <USERINPUT>make</USERINPUT>
<PROMPT>[root@linus dev3dfx]# </PROMPT> <USERINPUT>cp 3dfx.o /lib/modules/`uname -r`/misc
</USERINPUT>
<PROMPT>[root@linus dev3dfx]# </PROMPT> <USERINPUT>mknod /dev/3dfx c 107 0</USERINPUT>
<PROMPT>[root@linus dev3dfx]# </PROMPT> <USERINPUT>insmod 3dfx</USERINPUT>
</SCREEN>

<para>
Derefter skal du redigere din <filename>/etc/conf.modules</filename>
således, at kommandoen <command>insmod 3dfx</command> bliver kørt,
hver gang du starter/genstarter din computer.
</para>

<para>
Ved hjælp af programmet GlideControl, som er at finde på 
<ulink url="http://rpmfind.net/linux/RPM/contrib/libc6/i386////GlideControl-0.3-1.i386.html">http://rpmfind.net/linux/RPM/contrib/libc6/i386////GlideControl-0.3-1.i386.html</ulink>,
kan man indstille sit Voodoo1- eller Voodoo2-kort under Linux.
</para>

<para>
Skulle der være problemer, kan det være en god idé at kigge forbi
<ulink url=" http://www.3dfxgamers.com/">http://www.3dfxgamers.com/</ulink>.
</para>
</sect3>

<sect3 id="nVidia">
<title>nVidia Riva chipsæt</title>
<para>
nVidia (bruges i TNT-kort) er et af de eneste firmaer, som officielt
selv er ved at udvikle Linux-drivere til deres grafik-chipsæt.
</para>
<para>
Deres drivere er at finde på <ulink
url="http://www.nvidia.com/Products.nsf/htmlmedia/software_drivers.html">http://www.nvidia.com/Products.nsf/htmlmedia/software_drivers.html</ulink>.
Yderligere information om installation af disse drivere er også at
finde på denne side. Man skal dog lige være opmærksom på at disse
drivere er på udviklingsstadiet, så de er ikke nær så hurtige og
fejlfrie som dem, du muligvis kender fra Windows.
</para>
</sect3>

<sect3 id="matroxg200">
<title>Matrox G200</title>
<para>
Matroxs G200 chipsættet har for 3D-delens vedkommende i en del tid
været understøttet i X. For nylig frigav Matrox specifikationer til
3D-delen, hvilket har medført, at der er kommet nogle midlertidige
drivere.
</para>

<para>
Installationen indeholder en modificeret udgave af Mesa samt et
"glx"-modul, som gør det muligt for X at arbejde med Mesa (OpenGL)
kommandoer. G200-driverne er under kraftig udvikling og er
ligesom nVidias drivere ikke særlig hurtige eller stabile. Så sørg for at
læse dokumentationen, før du går i gang.
</para>

<para>
Se også <ulink url="http://sunsite.dk/ftp/pub/os/linux/nl3dp/web">http://sunsite.dk/ftp/pub/os/linux/nl3dp/web</ulink>.
</para>

</sect3>
</sect2>

</sect1>









<SECT1 ID="friheden-Opstart">
<TITLE>Opstart af Linux</TITLE>
<indexterm><primary>Boot af Linux</primary></indexterm>
<indexterm><primary>Opstart af Linux</primary></indexterm>
<indexterm><primary>Microsoft Windows</primary><secondary>98</secondary></indexterm>
<indexterm><primary>Windows</primary><secondary>98</secondary></indexterm>

<PARA>
Som tidligere skrevet kan Linux fint eksistere sammen med Windows
95/98 eller Windows NT. Hvad angår Windows 95/98, skal du se på LILO
eller Loadlin som opstartsindlæser (bootloader), men med hensyn til
Windows NT kommer der i det følgende en vejledning i at anvende Linux sammen
med Windows NT's "OS Loader". 
</para>

<para>
Et alternativ til dette er at benytte "bootpart" programmet - så kan
du have LILO liggende på din Linux-partition i stedet for at lægge 
den i master boot record (MBR) - se
<ulink url="http://www.winimage.com">http://www.winimage.com</ulink> og
<ulink url="http://www.winimage.com/bootpart.htm">http://www.winimage.com/bootpart.htm</ulink>.
</para>

<sect2 id="grub">
 <title>GRUB</title>

 <indexterm>
  <primary>Opstart af Linux</primary>
  <secondary>GRUB</secondary>
 </indexterm>

 <indexterm>
  <primary>Start af Linux</primary>
  <secondary>GRUB</secondary>
 </indexterm>

 <indexterm>
  <primary>GRUB</primary>
  <secondary>startprogram</secondary>
 </indexterm>

<para>
GRUB er et nyere alternativ til LILO-opstartsprogrammet (se <xref
linkend="lilo">), dvs. et program som kan håndtere opstarten af et
eller flere styresystemer på maskinen (eng: boot loader).  GRUB er en
del af bl.a. Red Hat 7.2. Se f.eks. <ulink url="http://www.redhat.com/docs/manuals/linux/RHL-7.2-Manual/ref-guide/ch-grub.html">http://www.redhat.com/docs/manuals/linux/RHL-7.2-Manual/ref-guide/ch-grub.html</ulink>.
</para>

<para>
Fordelene med GRUB i forhold til LILO er at man ikke behøver at køre
nogen kommando for at installere en ny kerne (Med LILO skal man køre
<command>/sbin/lilo</command> - nogle vil med rette mene at dette ikke
er en fordel når man tænker på fejlmulighederne :) Man får også
muligheden for at gøre opstart-menuen lidt mere appetitvækkende, ved
at kunne lægge et baggrundbillede ind bag menuen (den virker mere
grafisk orienteret). Endelig understøtter GRUB LBA fuld ud - dvs. der
er problemer med at opstartspartitionen skal ligge før cylinder 1024 (som 
LILO har haft problemer med).
</para>

<para>
I <xref linkend="grub-conf-ex"> er vist et eksempel på den filen
<filename>/boot/grub/grub.conf</filename> som styrer
opstartsprogrammet.  Først er der en linie
<literal>default=0</literal>, der viser at det første menupunkt
(nummer nul) er det som man får per default. Næste del er
<literal>timeout=10</literal>, som betyder at default-menupunket vil
blive startet efter 10 sekunder. Parameteren
<literal>splashimage</literal> angiver stien til at billede som lægges
bag ved menuen. Det skal være et billede i VGA-størrelse dvs. 640x480
og man har kun 14 farver at gøre godt med. Filen skal gemmes i
XPM-format (f.eks. lavet med GIMP eller ImageMagick) 
og derefter skal man køre 
<command>gzip</command> på filen
idet den ellers vil fylde <emphasis>meget</emphasis> mere. Stien til
filen er interessant. <literal>(hd0,0)</literal> betyder den første
harddisk og første partition - dvs. <literal>/dev/hda1</literal> hvor
<filename>/boot/</filename> skal ligge. Dernæst er stien relativ til
kataloget <filename>/boot/</filename> - dvs. stien her er fysisk
<filename>/boot/grub/splash2.xpm.gz</filename> i eksemplet.  Dernæst
er der i <filename>/boot/grub/grub.conf</filename> en eller flere
sektioner, der startes med <literal>title</literal>. Hver af dem
bliver til et menu-punkt som man kan vælge mellem. I eksemplet er der
tre menupunkter, som vil fremkomme med titlerne "Dell" hhv. "Red Hat
Linux (2.4.7-10)" og "Windows". 
Bemærk at man igen her angiver den lidt specielle
notation for hvilken Linux-kerne der skal hentes ved at skrive
harddisk og partition som <literal>root
(hd&lt;DREV&gt;,&lt;PARTITION&gt;)</literal>.
</para>

<para> 
Under det første
menupunkt "Dell" hentes kernen fra
<filename>/boot/bzImage.417</filename> og filsystemets rod
(dvs. <filename>/</filename>) bliver sat til
<filename>/dev/hda2</filename>. <literal>ro</literal> betyder at
read-only fra start (sådan er det bare).
</para>

<para> 
Man kan også se at det andet menupunkt "Red Hat Linux (2.4.7-10)"
har en initiel RAM-disk <filename>/boot/initrd-2.4.7-10.img</filename>.
I eksemplet er den originale Red Hat 7.2 kerne lagt
under menupunktet "Red Hat Linux (2.4.7-10)", mens "Dell" er en nyere 
Linux-kerne uden initiel RAM-disk.
</para>

<para>
Det tre menupunkt "Windows" anvendes til at starte en Windows 95 eller
NT op fra <filename>/dev/hda2</filename> (det er den anden partition
på første disk - dvs. <literal>(hd0,1)</literal>.
</para>

<example id="grub-conf-ex">
<title>Eksempel på en grub.conf</title>
<screen>
default=0
timeout=10
splashimage=(hd0,0)/grub/splash2.xpm.gz
title Dell
     root (hd0,0)
     kernel /bzImage.417 ro root=/dev/hda2
title Red Hat Linux (2.4.7-10)
     root (hd0,0)
     kernel /vmlinuz-2.4.7-10 ro root=/dev/hda2
     initrd /initrd-2.4.7-10.img
title Windows 
     root        (hd0,1)
     makeactive
     chainloader +1
</screen>
</example>

<para>
Det eneste man skal gøre hvis man vil ændre i opstarts-opsætningen er
at rette i <filename>/boot/grub/grub.conf</filename> og ved næste
genstart af maskinen anvendes den nye opsætning. I bogens eksempler
kan man finde <filename>splash2.xpm.gz</filename> som er et
opstarts-billede med SSLUG-logo, der passer til GRUB.
</para>

<para>
Det skal lige nævnes at muligheden for at lægge et billede ind
kræver et patch til GRUB der kan hentes fra <ulink url="http://people.redhat.com/~katzj/grub/patches/">http://people.redhat.com/~katzj/grub/patches/</ulink>.
</para>

<para>
<emphasis>Tip:</emphasis> Se <ulink url="http://linuxtoday.com/news_story.php3?ltsn=2002-03-08-014-20-PS-MS-RH">http://linuxtoday.com/news_story.php3?ltsn=2002-03-08-014-20-PS-MS-RH</ulink> for information om GRUB, Linux og Windows XP.
</para>

</sect2>

<sect2 id="lilo">
<title>LILO</title>
<indexterm><primary>Opstart af Linux</primary><secondary>LILO</secondary></indexterm>
<indexterm><primary>LILO</primary><secondary>LILO</secondary></indexterm>
<para>
Mange vil allerede under installationen af Red Hat have installeret
LILO som opstarter (eng. Boot Manager). Senere kan det være, at du vil
have mulighed for at opstarte med en ny kerne eller lignende. Du skal
så ændre i opsætningsfilen <FILENAME>/etc/lilo.conf</FILENAME>, hvor
der står en del for hvert af de styresystemer, der kan opstartes. Når
du har rettet, skal du køre <command>/sbin/lilo</command> som "root",
hvorefter rettelserne har effekt.
</para>

<para>
Et eksempel på <FILENAME>/etc/lilo.conf</FILENAME> kan være
</para>

<SCREEN>
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
lba32
timeout=50
image=/boot/bzImage
        label=linux
        root=/dev/hda3
        read-only
        restricted  
        password=HEMLIPASSWORD
        append="max_loop=128 quiet"
image=/boot/vmlinuz-2.0.35-2
        label=linux2
        root=/dev/hda3
        read-only
        restricted  
        password=HEMLIPASSWORD
other=/dev/hda1
        label=dos
        table=/dev/hda
</SCREEN>

<para>
I eksemplet opstartes på første IDE-disk
(<filename>hda</filename>).  En opstartsfil indlæses og lægges i
opstartssektoren, og der opstartes efter 5 sekunder på den første af
de tre muligheder. Der er her to muligheder for at opstarte Linux med
to forskellige kerner (linierne med image). Begge starter op med root-partition
på <FILENAME>/dev/hda3</FILENAME>. Feltet "label" (mærkat)
er det, du ser på skærmen som opstarts-valgmulighed. Den sidste
mulighed i eksemplet er, at DOS startes på den første partition
(hda1) på første IDE-disk. <filename>lba32</filename> er tilføjet for
at kunne understøtte meget store harddiske.
</PARA>

<para>
I eksemplet er der benyttet kommandoerne <command>restricted</command>
og <command>password</command>. De linier gør at man ikke kan starte
op i enkeltbruger-tilstand (eng. single user mode) uden at give
password "HEMLIPASSWORD". Husk at <command>/etc/lilo.conf</command>
ikke bør kunne læses af andre end root, dvs. kør én gang for alle
</para>

<screen>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> chmod 600 /etc/lilo.conf</userinput>
</screen>

<para>
I eksemplet ses også kommandoen <command>append=</command> som får
LILO til at give kernen nogle ekstra direktiver til opstart.
Læs mere om direktiverne i <xref linkend="kernelparm">.
</para>

<PARA>
LILO kan en hel del, men kan være et lige så besværligt værktøj, som
det kan være suverænt. Du bør måske læse den mini-HOWTO om LILO, som
kan findes under "Linux Documentation Project" på <ulink
url="http://sunsite.dk/ldp">http://sunsite.dk/ldp</ulink>.
Specielt kan det være at de to alternativer "restricted" eller "password" 
(adgangskode) er værd at forstå.
</PARA>


<sect3 id="slette-lilo">
<title>Slette LILO</title>
<para>
<indexterm><primary>Slette LILO</primary></indexterm>
<indexterm><primary>LILO</primary><secondary>Slette</secondary></indexterm>
<emphasis>Tip:</emphasis> LILO kan fjernes i DOS ved at køre
<userinput>fdisk /mbr</userinput> i en DOS-vindue under DOS/Windows.
</para>

<para>
<emphasis>Tip:</emphasis> LILO kan i Linux fjernes ved at køre
<command>/sbin/lilo -u /dev/hda</command>, hvis din boot-harddisk er
<filename>/dev/hda</filename>.
</para>
</sect3>

<sect3 id="lilo-rescue">
<title>LILO gik galt!</title>
<indexterm><primary>LILO</primary><secondary>problemer</secondary></indexterm>
<para>
Hvis uheldet er ude og du har Linux installeret og der er problemer
med LILO, så maskinen ikke booter, så kan du bruge din
installations-cd-rom til at reparere systemet med.
</para>

<para>
Du skal starte op på din Linux-cd-rom og vælge
<command>rescue</command>-muligheden. Du får ikke kontakt med din
harddisk derved, men får Linux startet op med programmer til at klare
problemerne. 
</para>

<para>
Hvis vi antager at Linux er installeret med <filename>/</filename>
(roden) på <filename>/dev/hda1</filename>, så kan du skrive følgende
for at montere harddisk-roden på <filename>/mnt</filename>. 
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>mount /dev/hda1 /mnt</USERINPUT>
</SCREEN>

<para> 
Nu kan du med <command>cd /mnt/etc</command> komme ned til
<filename>/etc</filename> på harddisken. Husk at dit Linux-system er
fra din cd-rom og din cd-rom er tilgængelig via
<filename>/mnt</filename>. Du kan nu rette i
<filename>lilo.conf</filename> eller rettere
<filename>/mnt/etc/lilo.conf</filename>, f.eks. med
<command>vi</command> eller <command>pico</command>. Derefter kan du
køre <command>lilo -r /mnt</command>, der læser
<filename>lilo.conf</filename>-filen fra
<filename>/mnt/etc/lilo.conf</filename>, og installerer LILO, som om
du havde <filename>/mnt</filename> som dit rod-filsystem.
</para>

<para>
Husk at det kan være et problem at boote fra en harddisk, som har
flere end 1024 cylindre - hvis de filer som LILO skal bruge for at
boote ligger over cylinder 1024, 
er det ikke altid LILO eller din BIOS kan finde
ud af det, og derfor vil LILO i så fald komme med en advarsel. Det kan
være årsagen til, at den ikke vil installeres automatisk. Heldigvis
er dette kun et problem med ældre distributioner, 
idet LILO fra version 0.21.4.2
og fremover kan understøtte op til 2 Tb diske, hvilket vel stadig
dækker de fleste personers behov :-)
Husk dog at den nye LILO kun vil virke med BIOS'er der understøtter
de udvidede LBA-funktioner til store diske, så ældre BIOS'er og
nyere BIOS'er der ikke helt følger standarden kan stadig give problemer.
</para>
</sect3>
</sect2>

<sect2 id="loadlin">
<title>Loadlin</title>
<indexterm><primary>Opstart af Linux</primary><secondary>Loadlin</secondary></indexterm>
<PARA>
En anden mulighed er at starte op i Windows 95 og dér lave en opstarter
via <FILENAME>CONFIG.SYS</FILENAME> og
<FILENAME>AUTOEXEC.BAT</FILENAME>-filerne. Først hentes DOS-programmet
LOADLIN fra f.eks. <ulink url="http://freshmeat.net">http://freshmeat.net</ulink>.

</PARA>

<PARA>
Vi har installeret <command>loadlin</command> i
<FILENAME>c:\linux\loadlin</FILENAME> (loadlin kan hentes i
zip-format og pakkes ud som vanligt med 
<command>pkunzip</command> eller <command>WinZip</command>).  Vor
Linux-kerne har vi kopieret til 
<filename>c:\linux</filename> med navnet <filename>vmlinuz</filename>,
og i nedenstående <filename>autoexec.bat</filename> har vi vores
root-partition på <filename>/dev/hda3</filename> (tredje partition på
hoveddisken). Du skal rette i linien
<filename>c:\linux\loadlin\loadlin c:\linux\vmlinuz root=/dev/hda3
ro</filename> svarende til din opsætning.
</PARA>

<PARA>
I det følgende skal du erstatte indholdet for Windows 95 (Win95) med
det, som du selv har. Linux har reelt kun noget i
<FILENAME>AUTOEXEC.BAT</FILENAME>
</PARA>

<PARA>
<EMPHASIS>CONFIG.SYS</EMPHASIS>
</PARA>

<SCREEN>
[MENU]
MENUITEM=Win95
MENUITEM=Linux
MENUDEFAULT=Linux,5

[Win95]
DEVICE=C:\UCD\UCDIDE.SYS /D:UCD0001
DEVICE=C:\WINDOWS\SETVER.EXE
DEVICE=C:\WINDOWS\HIMEM.SYS
DOS=HIGH
device=C:\WINDOWS\COMMAND\display.sys con=(ega,,1)
Country=045,850,C:\WINDOWS\COMMAND\country.sys

[Linux]

</SCREEN>

<PARA>
<EMPHASIS>AUTOEXEC.BAT</EMPHASIS>
</PARA>

<SCREEN>
GOTO %CONFIG%

:Win95
rem - By Windows Setup - C:\WINDOWS\COMMAND\MSCDEX /D:UCD0001
@ECHO OFF
PROMPT $p$g
SET PATH=C:\WINDOWS;C:\WINDOWS\COMMAND;C:\DOS;
SET TEMP=C:\DOS
mode con codepage prepare=((850) C:\WINDOWS\COMMAND\ega.cpi)
mode con codepage select=850
keyb dk,,C:\WINDOWS\COMMAND\keyboard.sys
GOTO END

:Linux
c:\linux\loadlin\loadlin c:\linux\vmlinuz root=/dev/hda3 ro
GOTO END

:END
</SCREEN>
</sect2><!-- loadlin -->

<sect2 id="kernelparm">
<title>Kerneparametre</title>
<indexterm><primary>Opstart af Linux</primary><secondary>kerneparametre</secondary></indexterm>
<indexterm><primary>Boot af Linux</primary><secondary>kerneparametre</secondary></indexterm>
<indexterm><primary>Kerneparametre</primary><secondary>LILO</secondary></indexterm>
<indexterm><primary>LILO</primary><secondary>append</secondary></indexterm>

<para>
Når din computer bootes med LILO, holdes der typisk en pause. Pausen kan
enten bruges til at vælge en anden kerne at boote med, men kan også bruges
til at indtaste ekstra parametre til Linux.
En ofte brugt kommando er at boote Linux op i "single user mode", hvilket gør
at man kan udfører systemarbejde uden alt for mange programmer kørende,
eller hvis du har glemt password til <command>root</command>.
Kommandoen er:
</para>

<SCREEN>
<PROMPT>boot:</PROMPT> <USERINPUT>linux single</USERINPUT>
</SCREEN>

<para>
Flere parametre angives med et mellemrum imellem:
</para>

<SCREEN>
<PROMPT>boot:</PROMPT> <USERINPUT>linux single debug</USERINPUT>
</SCREEN>

<para>
Disse parametre kan også indsættes permanent i <filename>/etc/lilo.conf</filename>
så de altid er med og man ikke skal taste dem ind hver gang computeren booter.
Fra eksemplet om LILO i <xref linkend="lilo"> er der tilføjet to parametre
med linien <command>append="max_loop=128 quiet"</command>:
</para>

<screen>
...
image=/boot/bzImage
        label=linux
        root=/dev/hda3
        read-only
        restricted  
        password=HEMLIPASSWORD
        <userinput>append="max_loop=128 quiet"</userinput>
...
</screen>

<para>
Der er mange parametre og de fleste af dem har til formål at give
en bestemt type hardware, f.eks. en harddisk, nogle ekstra parametre
om I/O eller interrupt. Her er en liste af nogle af de mere generelle
parametre som kan skrives enten på boot-prompten eller i lilo.conf i
<command>append</command>-linien.
</para>

<itemizedlist>
 <listitem>
  <para><command>console=ttyS0,9600n</command> - få output til skærmen ud på den
  serielle port. Kommandoen kan bruges til at sende data til et modem eller en
  seriel skærmterminal. Alternativt til en printer med kommandoen
  <command>console=lp0</command>.
  Læs mere i <filename>/usr/src/linux/Documentation/serial-console.txt</filename>.
  Denne kommando vil typisk være noget man skriver i <filename>/etc/lilo.conf</filename>.
  </para>
 </listitem>
 <listitem>
  <para><command>debug</command> - modsat <command>quiet</command>
  skriver denne parameter om muligt endnu mere information ud under boot.
  Denne kommando vil typisk blive tastet ind under boot.
  </para>
 </listitem>
 <listitem>
  <para><command>init=3</command> - bestemmer i hvilken mode Linux booter.
  <command>init=3</command> svarer til at Linux booter op i tekstmode,
  og <command>init=5</command> er boot i grafisk mode. Init-level bestemmes
  normalt i <filename>/etc/inittab</filename>, men hvis man f.eks. skifter skærmkort
  og dette ikke virker med den gamle grafik-opsætning bruges denne kommando.
  <command>init=1</command> starter Linux i single user mode.
  Denne kommando vil typisk blive tastet ind under boot.
  </para>
 </listitem>
 <listitem>
  <para><command>max_loop=128</command> - øger antallet af loop-back
  devices i Linux. Værdien kan være helt op til 255. Default-værdien er 8.
  Loop-back bruges f.eks. til at mounte iso-filer:
  <command>mount -o loop redhat.iso /mnt</command> .
  Denne kommando vil typisk være noget man skriver i <filename>/etc/lilo.conf</filename>.
  </para>
 </listitem>
 <listitem>
  <para><command>panic=5</command> - antal sekunder der skal gå efter en kernel panic
  før systemet rebooter.
  Denne kommando vil typisk være noget man skriver i <filename>/etc/lilo.conf</filename>.
  </para>
 </listitem>
 <listitem>
  <para><command>quiet</command> - undertrykker de fleste informationslinier
  Linux skriver ud under boot. Fejl udskrives stadig, men ligegyldig
  information udskrives ikke. De beskeder der normalt ses, kan efter boot 
  stadig læses med <command>dmesg</command>.
  Denne kommando vil typisk være noget man med glæde skriver i <filename>/etc/lilo.conf</filename>.
  </para>
 </listitem>
 <listitem>
  <para><command>ro</command> - filsystemer bliver mounted read-only
  under boot. Herefter kan man foretage systemarbejde på et "sygt" system.
  Denne kommando vil typisk blive tastet ind under boot.
  </para>
 </listitem>
 <listitem>
  <para><command>single</command> - starter Linux i single user-mode
  hvilket er det samme som <command>init=1</command>.
  Denne kommando vil nok mest blive tastet ind, men kan også skrives
  i <filename>/etc/lilo.conf</filename>.
  </para>
 </listitem>
</itemizedlist>

<para>
Den fulde liste af kerneparametre kan findes på din harddisk:
<filename>/usr/src/linux/Documentation/kernel-parameters.txt</filename>
</para>

</sect2><!-- kernelparm -->

</sect1>
</CHAPTER>


