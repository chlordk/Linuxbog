<CHAPTER ID="sysadm">
<TITLE>Systemadministration af et enkeltbrugersystem</TITLE>

<indexterm><primary>Systemadministration</primary></indexterm>
<indexterm><primary>root</primary></indexterm>

<PARA>
Systemadministration er alle de opgaver, som handler om
at vedligeholde hardware og software på en computer.
</PARA>

<PARA>
I UNIX-verdenen består systemadministration ofte i at rette i en
masse forskellige konfigurationsfiler. Konfigurationsfilerne er rene
tekstfiler, og det vigtigste værktøj til systemadministration er
en tekst-editor så som <command>vi</command>. Red Hat har lavet om på
dette: der findes nu administrationssoftware, som er grafisk. Under
overfladen bruges dog stadig rene tekstfiler. Vi vil i dette kapitel
primært benytte os af Red Hat's grafiske værktøjer.
</PARA>

<PARA>
Systemadministration foretages af systemadministratoren, dvs. af
brugeren <FILENAME>root</FILENAME>, som også kaldes for
superbrugeren (eng. "super user"). Du kan enten logge ind som
<FILENAME>root</FILENAME> eller skifte til denne med
programmet <command>su</command> (ordet hemmelig vises ikke på skærmen).
</PARA>


<indexterm><primary>su</primary></indexterm>
<indexterm><primary>root</primary></indexterm>
<SCREEN>
<PROMPT>[daisy@linus daisy]$ </PROMPT><USERINPUT>su - root</USERINPUT>
Passwd: <USERINPUT>hemmelig</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT>
</SCREEN>

<PARA>
Ved at skrive "<userinput>su - root</userinput>" i stedet for blot
"<userinput>su root</userinput>" sikrer vi os, at alt er glemt om
brugeren (<FILENAME>daisy</FILENAME>), som skiftede til
systemadministrator ("<userinput>su</userinput>" og "<userinput>su
root</userinput>" er i øvrigt det samme). Typisk har en bruger en del
opsætning, f.eks. omkring e-post, og denne opsætning bør du ikke
"kende" til som <filename>root</filename>. Bemærk også, at prompten
ændrede sig, da du blev <filename>root</filename>. Dollar-tegnet
blev til et hash-tegn. Da root har lov til alt på maskinen, bør du
være meget omhyggelig med, om du er root eller almindelig
bruger. Måske tror du, at det er smart at være root og kunne alt 
- det er forkert! Som root kan du komme til at skrive <userinput>rm -rf
/</userinput>, og så er hele dit Linux-system væk! For
ikke at risikere at lave unødige fejl, bør du lave en brugerkonto til dig
selv, også selv om du har root-adgangskoden. Skift kun til superbruger, hvis
det er absolut nødvendigt, og skift tilbage til din almindelige brugerkonto
hurtigst muligt.
</PARA>

<PARA>
Der eksisterer to varianter af UNIX: System V (udtales "system fem")
og BSD (Berkeley Software Distribution). For en almindelig bruger er der
ikke den store forskel; den ligger hovedsagelig i, hvor de
forskellige konfigurationsfiler er placeret i filsystemet, og hvordan
opstartssekvensen (boot) foregår. Red Hat (og de fleste
Linux-distributioner) har valgt side og hører til
System V familien, men låner lidt fra BSD.
</PARA>

<SECT1 ID="Mount">
<TITLE>Få adgang til andre diskdrev, cdrom og diskettedrev</TITLE>
<indexterm><primary>mount</primary></indexterm>
<para>
Linux er lidt anderledet bygget op end Windows med hensyn til at læse og
skrive fra de eksterne enheder (devices), såsom cdrom og diskettedrev. Af
sikkerhedshensyn kan du ikke få adgang til noget, uden at root har
hjulpet dig. I Linux vil man <emphasis>montere</emphasis> (eng. Mount) et drev 
for så derefter at kunne læse og skrive fra det. Dit cd-drev vil det
selvfølgelig kun være muligt at læse fra.
</para>

<sect2 id="mount-CDROM">
<TITLE>Cdrom</TITLE>
<indexterm><primary>Cdrom</primary></indexterm>
<para>
Først en gang Linux-gymnastik, som kun skal gøres en gang på din
maskine. Skift til root ved at skrive <command>su -
root</command>. Kontrollér, at dit cdrom-drev er fundet korrekt, og tillad
alle at læse dit cdrom-drev:
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>ls -al /dev/cdrom</USERINPUT>
lrwxrwxrwx   1 root  root  3 Sep  4 14:31 /dev/cdrom -> hdd
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>chmod a+r /dev/hdd</USERINPUT>
</SCREEN>

<para>
I eksemplet er <filename>/dev/cdrom</filename> en lænke til
<filename>/dev/hdd</filename>, dvs. at cd-rom-drevet sidder på den
sekundære IDE-bus som slave (typisk situation). Se også <xref
linkend="redhatpartitioner">. Du skal ændre chmod-kommandoen alt
efter, hvor dit cd-rom-drev sidder.
</para>

<para>
Redigér filen <filename>/etc/fstab</filename> med
<command>vi /etc/fstab</command> eller lignende. Du har sikkert
en linje, der starter med <filename>/dev/cdrom</filename>. Den skal du
ændre til
</para>

<SCREEN>
/dev/cdrom    /mnt/cdrom   iso9660  noauto,ro,user,exec   0 0
</SCREEN>

<para>
Hvis du <EMPHASIS>ikke<EMPHASIS> finder en linje, som ligner ovenstående, 
kan det være fordi supermount er installeret, så du automatisk får 
adgang til dit cdrom- og floppy-drev, hvilket Mandrake bl.a. 
benytter. I så fald skal du ikke ændre noget i 
<filename>/etc/fstab</filename> og hop videre til næste afsnit.
</para>

<para>
Første kolonne viser den enhed (<filename>/dev/cdrom</filename>),
som du vil kunne tage fat i.  Næste kolonne viser det
sted i filtræet, hvor den skal kunne ses. I eksemplet har vi valgt
<filename>/mnt/cdrom</filename>.
</para>

<para>
Tredje kolonne beskriver filformatet, her er det iso9960 til en cdrom.  
Fjerde kolonne indeholder
nøgleord, der beskriver egenskaber ved cdrom-drevet. 'noauto' betyder,
at cdrom-drevet ikke automatisk monteres, når maskinen startes op. 'ro'
betyder read-only. 'user' gør det muligt at montere cdrom'er som
almindelig bruger. 'exec' gør det muligt at køre Linux-programmer fra
cdrom. Betydningen af de to nuller kan du finde frem til ved at udføre
kommandoen <command>man mount</command>.
</para>

<para>
Nu er du klar til at teste det. Stop som root ved at trykke Ctrl-D i
den terminal, du arbejder i. Læg f.eks. din Red Hat-cdrom i dit 
cdrom-drev, og skriv
</para>

<SCREEN>
<PROMPT>[daisy@linus daisy]$ </PROMPT> <USERINPUT>mount /mnt/cdrom</USERINPUT>
</SCREEN>

<para>Nu bør du kunne skrive <userinput>df /mnt/cdrom</userinput> for at se, hvor
meget data der ligger på skiven. Du kan nu kopiere og læse fra din cdrom.
Når du er færdig med at læse din cdrom, kan du ikke bare tage den ud. Du skal
først skrive
</para>

<SCREEN>
<PROMPT>[daisy@linus daisy]$ </PROMPT> <USERINPUT>umount /mnt/cdrom</USERINPUT>
</SCREEN>

<para>
Du skal også vide, at du sagtens kan bruge
f.eks. <filename>/cdrom</filename> som stedet, du monterer din cdrom. Du
skal bare først lave biblioteket med <userinput>mkdir /cdrom</userinput>
og gentage ovenstående med den nye sti. Endelig findes der systemer til
Linux (Automount, Supermount og AMD), hvor du mere eller mindre direkte 
kan lægge
din cdrom i drevet og få adgang til data uden at skulle bruge
specielle kommandoer, men det skal sættes op særskilt.
</para>
</sect2>

<sect2 id="mount-DOSdisk">
<TITLE>Læse DOS/Windows diskdrev</TITLE>
<indexterm><primary>DOS</primary><secondary>læsning af diskdrev</secondary></indexterm>
<indexterm><primary>Windows</primary><secondary>læsning af diskdrev</secondary></indexterm>
<indexterm><primary>/etc/fstab</primary></indexterm>
<para>
Tilsvarende, som med cdrom-drevet, kan du automatisk føje din
DOS/Windows diskdrev til Linux-filtræet, som f.eks. <filename>/dosc/</filename>
og/eller <filename>/dosd/</filename>. 
</para> 

<para>
Redigér filen <filename>/etc/fstab</filename> med <userinput>pico -w
/etc/fstab</userinput> eller lignende. Under installationen har du
måske sat dine DOS/Windows diskdrev ind, så de kan ses fra Linux, men her
er alligevel et eksempel på <filename>/etc/fstab</filename>.
</para>

<SCREEN>
/dev/hda1    /dosc   msdos  defaults   0 0
/dev/hda3    /dosd   vfat   defaults   0 0
</SCREEN>

<para>
Den første linje tager <filename>/dev/hda1</filename>, dvs. første
partition på den første IDE hardddisk, som antages her at være en
MS-DOS formatteret partition, og lægger den ind som
<filename>/dosc</filename>.  Tilsvarende med
<filename>/dev/hda2</filename>, dvs. anden partition på den første IDE
harddisk, som her antages at være en vfat formatteret partition,
dvs. en Windows-partition, hvor der anvendes lange filnavne. 

Når du genstarter computeren vil du automatisk have adgang til dine
DOS/Windows partitioner. Vil du prøve om det virker med det samme
behøver du ikke at genstarte computeren, du kan bare skrive
<command>mount -a</command> i et terminal vindue. Det er unødventigt
at genstarte Linux for at gennemføre en triviel ændring, som man
typisk skal i Windows.
</para>
</sect2>


<sect2 id="mount-floppy">
<TITLE>Diskettedrev</TITLE>
<indexterm><primary>Floppy diske</primary></indexterm>
<para>
For at kunne læse dine DOS disketter skal du gentage ovenstående
med få ændringer (<filename>msdos</filename> i stedet for
<filename>iso9660</filename> og <filename>rw</filename> i stedet for
<filename>ro</filename>). Der er dog en langt nemmere måde: installér
RPM pakken <filename>mtools</filename> fra din Red Hat cdrom (dette er
nøjere beskrevet under RPM i næste afsnit).
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>rpm -i mtools*.rpm</USERINPUT>
</SCREEN>

<para>
Giv læse- og skriveadgang til <filename>/dev/fd0</filename>
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>chmod a+rwx /dev/fd0</USERINPUT>
</SCREEN>

<para>
Med <userinput>man mtools</userinput> kan du se, at du reelt har fået de
gamle MS-DOS kommandoer, som bare har fået et m foran. Du kan bruge
<command>mdir</command>, <command>mcopy</command>,
<command>mcd</command> osv. Du kan endda bruge <filename>a:</filename>
som i MSDOS. For at kopiere hele disketten til det bibliotek, du står i,
skal du skrive
</para>

<SCREEN>
<PROMPT>[daisy@linus daisy]$ </PROMPT> <USERINPUT>mcopy a:* .</USERINPUT>
</SCREEN>

<para>
Med mtools har du også mulighed for at bruge lange filnavne, der
passer med Windows 95, og du skal ikke tænke på
<command>mount</command> og <command>umount</command>. Rigtig nyttige
programmer.
</para>
</sect2>

<sect2 id="autofs">
<title>Automatisk montering af ydre enheder</title>
<indexterm><primary>automount</primary></indexterm>
<indexterm><primary>autofs</primary></indexterm>
<indexterm><primary>Mount af cdrom og floppy - automatisk</primary></indexterm>

<para>
I Red Hat og SuSE er der mulighed for at du automatisk monteret
eksterne enheder, såsom cdrom og diskettedrev automatisk. Det er nemt
- du skal blot installere autofs-pakken. I Mandrake benyttes supermount, 
som er endnu smartere.
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>rpm -ivh autofs-*.rpm</USERINPUT>
</SCREEN>

<para>
Sørg først for, at autofs startes op i den "runlevel", du normalt
arbejder i (oftest 3, hvilket i øvrigt står i
<filename>/etc/inittab</filename>). Dette gøres ved at starte
<command>control-panel</command> og vælge ikonet med trafiklys på -
eller direkte starte <command>tksysv</command> op. Du føjer blot
autofs til runlevel 3.
</para>

<para>
Derefter skal du se i <filename>/etc/auto.master</filename>, der viser,
at <filename>/misc</filename> nu er under kontrol af automontøren.
Går du ned i <filename>/misc</filename>, bliver der monteret enheder
automatisk. Der er et tidsudløb på 60 sekunder i standardopsætningen -
dvs. 60 sekunder, efter du har besøgt f.eks. din cdrom, vil maskinen
automatisk køre <command>umount</command> for dig.  Filen
<filename>/etc/auto.misc</filename> er så der, hvor du skriver hvilke
af dine eksterne enheder der automatisk skal monteres.  Filen kan
f.eks. se ud som følger, for at din cdrom og diskettedrev automatisk
monteres i  <filename>/misc/cdrom</filename> hhv.
<filename>/misc/floppy</filename>
</para>

<screen>
cdrom           -fstype=iso9660,ro      :/dev/cdrom
floppy          -fstype=auto            :/dev/fd0
</screen>

<para>
Der er mange muligheder her, og er du doven, kan du endda lave en lænke
fra roden, så <filename>/cdrom</filename> peger på
<filename>/misc/cdrom</filename>, og du kan så anvende
<filename>/cdrom</filename> til at læse filer fra din
cdrom. Tilsvarende kan det gøres for <filename>/floppy</filename>. Har
du problemer med rettigheder, læs lige de forrige afsnit.
</para>

<para>
<emphasis>Tip:</emphasis> SuSE 6.4 har via
<filename>/etc/auto.net</filename> lavet mulighed for at man kan gå
direkte ind på netværkets andre filservere (hvor dette er
tilladt). Via <filename>/net/dykker.kongeh.dk/home/dykker</filename>
får man adgang til kataloget <filename>/home/dykker</filename> på
maskinen dykker.kongeh.dk, hvis dette er exporteret korrekt.
</para>

</sect2>

</SECT1>

<sect1 id="pakker">

<title>Pakker af data</title>

<indexterm><primary>zip</primary></indexterm>
<indexterm><primary>unzip</primary></indexterm>
<indexterm><primary>compress</primary></indexterm>
<indexterm><primary>uncompress</primary></indexterm>

<para>Linux har glimrende muligheder for at pakke programmer og
datafiler sammen svarende til zip-formatet kendt fra Windows-verdenen. 
Faktisk kan du med <command>unzip</command> udpakke
zip-filer. Du skal blot installere unzip-pakken først - se <xref
linkend="RPM">. Tilsvarende kan du have brug for at kunne udpakke en
selvudpakkende zip-fil (som kommer som en exe-fil fra Windows). Til
dette kan du bruge <command>unzipsfx</command>.
</para>

<para>
Du kan teoretisk set stadig komme ud fra program-pakker i Z-format. De
skal udpakkes med <command>uncompress</command> (og de laves med
<command>compress</command>). På grund af bedre pakke-effektivitet
anvendes combinationen af <command>tar</command> og
<command>gzip</command> eller <command>bzip2</command>. Dette er
nærmere omtalt i <xref linkend="tar">. Et andet alternativ som
efterhånden er en stærk standard for udbredelse af Linux programmer i
binær form er RPM, som er omtalt i <xref linkend="RPM">.
</para>

<para>
Det kan nævnes, at <command>tar</command> historisk er et program, man
bruger til at lime datafiler sammen så de kan ligges ud på bånd -
deraf navnet tar som står for Tape ARchive.
</para>

<sect2 id="tar">
<title>Pakning af data med tar og gzip/bzip2</title>

<para>
I Linux/UNIX verdenen anvendes oftest tar-formatet til at samle mange
filer i én pakke-fil. Denne er ikke komprimeret, men alene en samling
af filerne i én pakke-fil. Har du filerne
<filename>oversigt.txt</filename>, <filename>tekstA.txt</filename> op
til <filename>tekstD.txt</filename>, som du vil pakke sammen i filen
<filename>tekster.tar</filename>, så gøres dette ved
</para>

<SCREEN>
<PROMPT>[daisy@linus daisy]$ </PROMPT><USERINPUT>tar cvf tekster.tar oversigt.txt tekst[A-D].txt</USERINPUT>
oversigt.txt
tekstA.txt
tekstB.txt
tekstC.txt
tekstD.txt
<PROMPT>[daisy@linus daisy]$ </PROMPT><USERINPUT>ls -l oversigt.txt tekst[A-Z].txt tekster.tar</USERINPUT>
-rw-r--r-- 1 daisy daisy  400   mar  3 17:41 oversigt.txt
-rw-r--r-- 1 daisy daisy  1024  mar  3 17:41 tekstA.txt
-rw-r--r-- 1 daisy daisy  1024  mar  3 17:41 tekstB.txt
-rw-r--r-- 1 daisy daisy  1024  mar  3 17:41 tekstC.txt
-rw-r--r-- 1 daisy daisy  1024  mar  3 17:41 tekstD.txt
-rw-r--r-- 1 daisy daisy  10240 mar  3 17:41 tekster.tar
</SCREEN>

<para>
Du kan således give alle de fil-navne, der skal pakkes som det sidste
argument, og giver du et katalognavn i listen vil dette katalog - med
alle underkataloger - også blive pakket med. Som det ses af eksemplet
vil programmet <command>tar</command> vise filnavne på de filer, der
pakkes. Ønsker du ikke at se dette, skal du blot udelade option
<filename>v</filename>, dvs. brug <command>tar cf TARFILNAVN.tar
LISTE_AF_FILER</command> i stedet.
</para>

<para>
Hvis de filer du ville gemme er almindelige tekst-filer vil du i
<filename>tekster.tar</filename> direkte kunne læse dig til de enkelte
filer, som skulle lægges i pakken. Derfor vil tar-filen fylde lidt
mere end summen af de filer, der skulle gemmes. For små filer vil der
være en del ekstra fyld.
</para>

<para>
Ofte ønsker man nu at komprimere tar-filen, så den fylder
mindre. Oftest vinder man en faktor 2, men både langt mere eller noget
mindre er set i praksis. Der er flere muligheder for at komprimere,
hvor <command>gzip</command> er langt det mest udbredte.
</para>

<SCREEN>
<PROMPT>[daisy@linus daisy]$ </PROMPT><USERINPUT>gzip tekster.tar</USERINPUT>
tekster.tar:               93.3% -- replaced with tekster.tar.gz     
<PROMPT>[daisy@linus daisy]$ </PROMPT><USERINPUT>ls -l tekster.tar.gz</USERINPUT>
-rw-r--r-- 1 daisy daisy  706 mar  3 17:41 tekster.tar.gz
</SCREEN>


<para>
Programmet <command>gzip</command> fortæller at filen
<filename>tekster.tar.gz</filename> er komprimeret med 93.3% og vi ser
at filen nu kun fylder 706 bytes. Ofte vil man se at gzippede
tar-filer ikke hedder <filename>.tar.gz</filename> men den kortere
form <filename>.tgz</filename>, og de to fil-endelser betyder det
samme. 
</para>

<para>
Bemærk at originalfilen <filename>tekster.tar</filename> nu er
væk. Kun den pakkede fil er tilbage efter <command>gzip</command>.
</para>


<para>
Ofte laver man ikke tar-filen, man springer direkte til
<filename>.tgz</filename> formatet ved at danne pakke filen med 
<command>z</command> (for zip) tilføjet optionerne
</para>

<SCREEN>
<PROMPT>[daisy@linus daisy]$ </PROMPT><USERINPUT>tar cvzf tekster.tgz oversigt.txt tekst[A-D].txt</USERINPUT>
oversigt.txt
tekstA.txt
tekstB.txt
tekstC.txt
tekstD.txt
93.3%
<PROMPT>[daisy@linus daisy]$ </PROMPT><USERINPUT>ls -l tekster.tgz</USERINPUT>
-rw-r--r-- 1 daisy daisy  706 mar  3 17:41 tekster.tgz
</SCREEN>

<para>
Vi skal nu se på hvordan du udpakker dine filer igen fra pakke-filen.
Først ser vi hvad der er inde i pakken (t-option) , og når vi er sikre
på hvad der vil ske bliver filerne udpakket (x-option). Antag er vi
har placeret pakke-filen i et katalog, hvor der ikke er andre filer
end pakke-filen.
</para>
<SCREEN>
<PROMPT>[daisy@linus daisy]$ </PROMPT><USERINPUT>tar tvzf tekster.tgz </USERINPUT>
-rw-r--r-- 1 daisy daisy  400   mar  3 17:41 oversigt.txt
-rw-r--r-- 1 daisy daisy  1024  mar  3 17:41 tekstA.txt
-rw-r--r-- 1 daisy daisy  1024  mar  3 17:41 tekstB.txt
-rw-r--r-- 1 daisy daisy  1024  mar  3 17:41 tekstC.txt
-rw-r--r-- 1 daisy daisy  1024  mar  3 17:41 tekstD.txt
<PROMPT>[daisy@linus daisy]$ </PROMPT><USERINPUT>tar xvzf tekster.tgz</USERINPUT>
oversigt.txt
tekstA.txt
tekstB.txt
tekstC.txt
tekstD.txt
</SCREEN>

<para>
Igen kan v-option udelades, hvis du ikke vil have helt så meget
information præsenteret på skærmen. Det skal nævnes, at
<command>tar</command> har en stor mænge options, som kan læres lidt
efter lidt. Brug <command>man tar</command> til at komme videre. En
option du måske allerede nu kan lære at <command>-C DIR</command> som
bruges til at pakke pakke-filen ud svarende til at du står i kataloget 
<filename>DIR</filename> og pakker ud.
</para>


<para>
Du kan også komme ud for at folk bruger <command>bzip2</command> til
at komprimere data med istedet for <command>gzip</command>. En fil der
ender på <filename>.bz2</filename> kan du udpakke med <command>bunzip
FILNAVN.bz2</command>. Er det en tar-fil som er pakket med
<command>bzip2</command>, kan du med en nyere version af
<command>tar</command> udpakke direkte med <command>tar xvIf
FILNAVN.tar.bz2</command>, mens men med ældre version af
<command>tar</command> må tage den i to omgange: <command>bunzip2
FILNAVN.tar.bz2</command> og derefter <command>tar xvf FILNAVN.tar</command>.
</para>


<sect3 id="tar-flytning">
<title>Flytning af data ved brug af tar</title>
<indexterm><primary>mke2fs</primary></indexterm>
<indexterm><primary>Formattere disk</primary></indexterm>
<para>
<emphasis>Tip:</emphasis> Lad os lige tage et avanceret eksempel. Det
kan jo ske, at du løber tør for plads på din harddisk og køber en
ekstra disk. Du beslutter nu at du vil flytte
<filename>/home</filename> over på den nye disk
(<filename>/dev/hdb1</filename>) og vil køre videre med Linux-systemet
på den gamle disk. Lad os antage at du har partitioneret
<filename>/dev/hdb</filename> med <command>fdisk /dev/hdb</command> og
kørt <command>/sbin/mke2fs /dev/hdb1</command> for at formattere
disken.
</para>

<SCREEN>
<PROMPT>[root@linus /root]# mkdir /mnt/nydisk</PROMPT>
<PROMPT>[root@linus /root]# mount /dev/hdb1 /mnt/nydisk</PROMPT>
<PROMPT>[root@linus /root]# cd /home</PROMPT>
<PROMPT>[root@linus /root]# tar cvf - . | (cd /mnt/nydisk; tar xpf -)
</PROMPT>
</SCREEN>

<para>
De to første linier er blot forberedelse, så vi har den nye disk til
rådighed på <filename>/mnt/nydisk</filename>. Dernæst stiller vi os
der hvor backup skal startes fra (gør at dette er "."). I den sidste
kommando laver vi en backup til "-" dvs. til stdout, som pipes til en
modtage-tar-kommando, der startes under
<filename>/mnt/nydisk</filename>. Denne gang tilføjes p-option for at
filerne får samme rettigheder som originalerne.
</para>

<para>
Først når du <emphasis>har</emphasis> checket at alle dine filer er
genskabt under <filename>/mnt/nydisk</filename> kan du slette dine
filer og skabe kontakt med den nye disk med
<filename>/home</filename>-filerne. Rediger
<filename>/etc/fstab</filename> så den nye disk er med
</para>

<SCREEN>
/dev/hdb1  /home   ext2    defaults        1 1
</SCREEN>

<para>
bruger du en anden partition end <filename>/dev/hdb1</filename> til
den nye disk, så skal du naturligvis erstatte dette i
<filename>/etc/fstab</filename>
</para>

<SCREEN>
<PROMPT>[root@linus /root]# mv /home /oldhome</PROMPT>
<PROMPT>[root@linus /root]# umount /mnt/nydisk</PROMPT>
<PROMPT>[root@linus /root]# mount /home</PROMPT>
</SCREEN>

<para>
Hvis du kan se at alt fungerer, kan du slette den gamle
<filename>/home</filename> som nu endte på
<filename>/oldhome</filename>. Brug <command>rm -rf /oldhome</command>,
når du er helt sikker.
</para>

<para>
Det der kan gå galt her er at man har links, som ikke peger det
rigtige sted efter flytningen. Med <filename>/home</filename> er dette
normalt ikke tilfældet, men er det <filename>/usr</filename> du
flytter, så skal du være meget forsigtig og altid lave disse
operationer i single-user-mode (dvs. brug <command>init 1</command>).
</para>
</sect3>
</sect2>


<sect2 id="RPM">
<title>Installation af RPM program pakker</title>
<indexterm><primary>RPM</primary></indexterm>
<para>
Gennem mange år har UNIX systemadministratoren skullet hente nye
programmer hjem med kildetekst og derefter oversætte og installere.
Det gik oftest nemt, men kunne fra tid til anden være meget svært. 
Hvad værre var, man kunne typisk ikke afinstallere programmer uden at
have 100 pct. styr på installationsfasen og styr på at andre programmer ikke
anvendte samme biblioteker. Alt i alt ganske problematisk og uden reel
mulighed for at kunne opgradere systemet løbende.
</para>

<para>
Firmaet Red Hat og andre er i de senere år gået over til at
oversætte programmer en gang for alle og så distribuere
programpakker, der indeholder binær kode, biblioteker, manualsider og
andet. Fordelen ved disse programpakker er, at systemet kan holde
eksakt styr på, hvad der er installeret.  Alle pakker undersøges for
afhængigheder, og du kan afinstallere pakker igen, hvis andre pakker
ikke påvirkes af det. Red Hats format for programpakker kaldes RPM,
som er en forkortelse for "Red Hat Package Management", hvilket vil sige
Red Hat's pakkehåndtering.
</para>

<table>
<title>Miniguide i at anvende rpm-programmet.</title>
<tgroup cols=2 align="char">
<thead>
<row>
<entry>Kommando
</entry>

<entry>
Forklaring
</entry>

</row>
</thead>

<tbody>

<row>
<entry> <userinput>rpm -i pakke_version.rpm</userinput> </entry>
<entry> Installér pakken</entry>
</row>

<row>
<entry> <userinput>rpm -ivh pakke_version.rpm</userinput> </entry>
<entry>  Installér pakken med status vist. Tilføj option --nodeps hvis
pakken skal installere uden at tjekke for manglende støtte pakker.</entry>
</row>

<row>
<entry> <userinput>rpm -qip pakke_version.rpm</userinput></entry>
<entry> Viser information om den pakke, som kan installeres.</entry>
</row>

<row>
<entry> <userinput>rpm -e pakke</userinput> </entry>
<entry> Afinstallér den installerede pakke.</entry>
</row>

<row>
<entry> <userinput>rpm -q PAKKE</userinput> </entry>
<entry> Viser version af den installerede pakke.</entry>
</row>

<row>
<entry> <userinput>rpm -qi PAKKE</userinput> </entry>
<entry> Viser information om den installerede pakke.</entry>
</row>

<row>
<entry> <userinput>rpm -qf filnavn</userinput> </entry>
<entry> Viser hvilken RPM-pakke filnavnet kom fra.</entry>
</row>

<row>
<entry> <userinput>rpm -ql PAKKE</userinput> </entry>
<entry> Viser hvilke filer der blev installeret med RPM-pakken.</entry>
</row>

<row>
<entry> <userinput>rpm -qlp PAKKE.rpm</userinput> </entry>
<entry> Viser hvilke filer der er med i RPM-pakken.</entry>
</row>

<row>
<entry> <userinput>rpm -qa</userinput> </entry>
<entry> Viser alle installerede RPM-pakker.</entry>
</row>


<row>
<entry> <userinput>rpm -ql PAKKE</userinput> </entry>
<entry> Viser alle filnavne indeholdt i pakken.</entry>
</row>

<row>
<entry> <userinput>rpm -Va</userinput> </entry>
<entry> Tjek alle RPM-installerede filer for ændringer siden
installation af pakkerne.
</entry>
</row>
</tbody>
</tgroup>
</table>


<para>
Lad os illustrere styrken i RPM programmet: Du sidder på en maskine
som systemadministrator og opdaterer alle Linux
maskinerne i dit netværk med en kommando - og endda med krypteret
transmission, så ingen kan lytte med. Det er simpelthen
administratorens drøm af et system. Nemt, sikkert og stabilt. Hvis
alle maskiner, der skal opgraderes, er nævnt i filen
<filename>/etc/serverlist</filename>, vil nedenstående magiske linje
(ja, det er avanceret - men sejt, ikke sandt) opgradere vim-pakken, som
hentes fra ftp-serveren <filename>SERVER</filename>. Alle
maskiner bliver lige opgraderet i et hug!

<SCREEN>
<PROMPT>[root@linux /root]# </PROMPT><USERINPUT>cat /etc/serverlist | \
    xargs -l1 -i= -r ssh = rpm -U ftp://SERVER/vim-4.6-4.i386.rpm</USERINPUT>
</SCREEN>

</para>


<para>
<indexterm><primary>rpmfind</primary></indexterm>
<indexterm><primary>Mangler filer</primary></indexterm>

<emphasis>Tip:</emphasis> Under installationen eller upgraderingen af
en RPM-pakke sker det at den klager over at man mangler nogle filer,
dette skyldes at RPM-pakken som man er ved at installere afhænger af
andre RPM pakker for at fungere, RPM pakker som man enten mangler
eller hvor man har en for gammel version. Et godt trick er at gå ind
på <ulink url="http://www.rpmfind.net/linux/RPM/">http://www.rpmfind.net/linux/RPM/</ulink>. Her
kan man søge efter RPM-pakker, men også efter filnavne og derved
oftest finde hvilke RPM-pakker du mangler.
</para>

<para>
Er du mere interesseret i at kunne bruge RPM-programmet bedre så kan
vi anbefale at læse 
<ulink url="http://www.sslug.dk/rpm/">http://www.sslug.dk/rpm/</ulink>. 
</para>
</sect2>

<sect2 id="chkconfig">
<title>chkconfig</title>

<indexterm><primary>chkconfig</primary></indexterm>

<para>
<command>chkconfig</command> er et nyttigt lille værktøj til ændringer i
services i et runlevel. Værktøjet følger med Red Hat og Mandrake.
</para>

<para>
Antag, at du har en service <command>foo</command>, som du ønsker at 
tilføje til runlevel 3. Du har installeret (måske gennem 
<command>rpm</command>) et script i kataloget 
<filename>/etc/rc.d/init.d</filename>, som følger de gængse retningslinjer
for service-scripts (dvs. at en service startes op vha. <command>foo start</command>
og lukkes ned vha. <command>foo stop</command>). Nedenfor ser du hvordan
den nye service tilføjes.
</para>

<screen>
<prompt>[root@linus root]#</prompt> <userinput>chkconfig --level 3 foo on</userinput>
</screen>

<para>
Bliver du træt af servicen <command>foo</command> kan du naturligvis fjerne den.
Du udskifter blot <emphasis>on</emphasis> med <emphasis>off</emphasis>. Du
kan også bruge <command>chkconfig</command> til at tjekke hvilke runlevels en
service bliver startet op under. Nedenfor checker vi <command>named</command>.
</para>

<para>
<screen>
<prompt>[root@linus root]#</prompt> <userinput>chkconfig --list named</userinput>
named 0:off 1:off 2:off 3:off 4:off 5:off 6:off
</screen>
</para>
</sect2>

<sect2 id="dpkg">
<title>Installation af DEB program pakker</title>
<indexterm><primary>dpkg</primary></indexterm>
<indexterm><primary>DEB-pakker</primary></indexterm>

<para>
Skal du installere programmer på Debian eller Corel Linux, skal du
være root. Med Corel Linux er det meningen at man skal anvende
"Applications"-&gt;"System"-&gt;"update". Der anvendes et program der hedder
<command>get_it</command>.  Her kan man sætte cdrom, ftp eller http
adresser hvor updates hentes fra. Som standard er Corel's ftp-update
adresse medtaget.  Man kan jo prøve at tilføje <ulink
url="ftp://ftp.dk.debian.dk/debian">ftp://ftp.dk.debian.dk/debian</ulink>
for at få adgang til alle debian pakkerne.
</para>

<para>
Du kan dog også være interesseret i at kunne styre installation selv
fra kommando-linien.  Nyttige kommandoer er

<itemizedlist mark="bullet" spacing="compact">
<listitem>
  <para><command>dpkg -i PAKKE.deb</command> - installerer pakken.
 </para> 
</listitem>
<listitem>
  <para><command>dpkg -r PAKKE</command> - fjerner pakken igen.
 </para> 
</listitem>
<listitem>
  <para><command>dpkg -s PAKKE</command> - viser status for pakken.
 </para> 
</listitem>
<listitem>
  <para><command>dpkg -L PAKKE</command> - viser hvilke filer, der er i pakken.
 </para> 
</listitem>
<listitem>
  <para><command>dpkg -S FILNAVN</command> - viser hvilke pakker, 
                 som FILNAVN stammer fra.
 </para> 
</listitem>
<listitem>
  <para><command>dpkg --help</command> - viser hjælp.
 </para> 
</listitem>
</itemizedlist>
</para>

<para>
For at konfigurere pakker til dit system skal du køre kommandoen
<command>dpkg --pending --configure</command>. Det gør, at man får sat
de enkelte programmer op til maskinen efter, at pakkerne er blevet
installeret.
</para>

</sect2>


</sect1>

<SECT1 ID="GrafiskAdmin">
<TITLE>De grafiske værktøjer</TITLE>
<PARA>
Som allerede nævnt i indledningen til dette kapitel findes
der til Red Hat grafiske værktøjer til
systemadministratoren. Vi vil her koncentrere os om
<command>control-panel</command> og <command>linuxconf</command>.
</PARA>

<sect2 ID="control-panel">
<title>control-panel</title>
<para>
Som root kan du foretage systemarbejde via <command>control-panel</command>.
</para>

<SECT3 ID="control-panel-opstart">
<TITLE>control-panel startes op</TITLE>
<PARA>
At starte <command>control-panel</command> op er let. Du taster
ganske simpelt programmets navn på kommandolinjen. På figuren
nedenfor er hovedmenuen vist. Programmet er i
virkeligheden en række forskellige programmer.
</para>

<SCREEN>
<PROMPT>[root@linus /root]</PROMPT> <USERINPUT>control-panel</USERINPUT>
</SCREEN>

<FIGURE ID="control-panel-1" FLOAT="1">
<TITLE>Hovedmenuen i <FILENAME>control-panel</FILENAME</TITLE>
<GRAPHIC FILEREF="control-panel-1.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>
</SECT3>

<SECT3 ID="control-panel-bruger">
<TITLE>Opret en ny bruger</TITLE>
<indexterm><primary>Opret ny bruger</primary></indexterm>
<PARA>
En af systemadministratorens vigtigste opgaver er at
administrere brugere, dvs. oprette nye brugere og nedlægge
gamle. I tidligere af Red Hat (version 5.0 og 5.1) havde
<command>control-panel</command> et godt værktøj til netop denne
opgave. Bruger du Red Hat 6.1 findes dette værktøj ikke, men du kan
bruge <command>linuxconf</command> til at administrere brugere.
<!-- - se xref linkend="linuxconf"-->
</para>

<para>
Som sagt, bruger du tidligere udgaver af Red Hat, finder du dette
værktøj som den første knap i hovedmenuen (et smilende ansigt). Ved at
trykke på den får du et nyt vindue, som er vist nedenfor. 
</para>

<FIGURE ID="control-panel-2" FLOAT="1">
<TITLE>Brugeradministration</TITLE>
<GRAPHIC FILEREF="control-panel-2.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<PARA>Du kan oprette en ny bruger ved at trykke på "Add" (Tilføj)
knappen. Lad os oprette en ny bruger, som ønsker brugernavnet
pingo og i virkeligheden hedder Frederik. Figuren nedenfor viser
denne situation. En række af felterne har systemadministratoren
selv udfyldt, men <FILENAME>control-panel</FILENAME> er kommet med en
række forslag, f.eks. vil bruger-ID (brugernr.) blive
foreslået. Når du er færdig med at indtaste alle
oplysningerne, trykker du på "Done" knappen.
</PARA>

<FIGURE ID="control-panel-3" FLOAT="1">
<TITLE>En ny bruger ved navn pingo</TITLE>
<GRAPHIC FILEREF="control-panel-3.&magic;"  SCALE ="50"></GRAPHIC>
</FIGURE>

<PARA>
Nu har vi set lidt på de grafiske værktøjer du har til hjælpe. Lad os
nu også se på de tilsvarende tekst-baserede værktøjer. Som root kan
du på et vilkårligt tidspunkt skifte en brugers adgangskode ved at
skrive <userinput>passwd BRUGERNAVN</userinput>. Du kan 
også nemt oprette en bruger ved at skrive <userinput>adduser
BRUGERNAVN</userinput>. Derefter skal du bruge <userinput>passwd
BRUGERNAVN</userinput> for at sætte password.
</PARA>

</SECT3>

<SECT3 ID="stil-uret">
<TITLE>Stil uret</TITLE>
<PARA>
<command>control-panel</command> kan også bruges til at
stille din computers ur. Du finder denne funktion som den anden i
<command>control-panel</command>. Du kan ændre både klokken og
datoen. For at ændre noget trykker du først på det, du vil
ændre, f.eks. måneden. Derefter bruger du de to pile, og når
du er færdig, trykker du først på "Set System Clock" og
derefter på "Exit Time Machine".
</PARA>

<FIGURE ID="control-panel-4" FLOAT="1">
<TITLE>Stil computerens ur</TITLE>
<GRAPHIC FILEREF="control-panel-4.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<para>
Det kan også være praktisk er kunne en system kommando her. Skal du
sætte BIOS uret til 28. marts år 2000 kl. 23:44, så kan du gøre følgende:
</para>

<SCREEN>
<PROMPT>[root@linus /root]</PROMPT> <USERINPUT>/sbin/hwclock --set --date="03/28/2000 23:44:00"</USERINPUT>
<PROMPT>[root@linus /root]</PROMPT> <USERINPUT>/sbin/hwclock --hctosys</USERINPUT>
</SCREEN>

<para>
Note - der skal to minus-tegn til kommandoerne
(f.eks. <command>hctosys</command>) - ikke en. I PS og PDF-udgaven af
denne bogen ser der ud som om der kun er et minus.
</para>

</SECT3>

<SECT3 ID="runlevel-editor">
<TITLE>Runlevel editoren</TITLE>
<PARA>
Vi har tidligere i dette kapitel diskuteret runlevel, og hvordan
de bruges og konfigureres. <command>control-panel</command> giver os
et enkelt værktøj, nemlig runlevel editoren. Du finder den som
den anden knap fra oven i hovedmenuen. Figuren nedenfor viser, hvordan
runlevel editoren ser ud.
</PARA>

<FIGURE ID="control-panel-5" FLOAT="1">
<TITLE>Runlevel editoren</TITLE>
<GRAPHIC FILEREF="control-panel-5.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<PARA>Som du ser, kan du konfigurere runlevel 2 til 5. Foroven står
de tjenester, som skal startes, når din maskine
går ind i det givne runlevel, mens der forneden er anført de
tjenester, som skal lukkes, når din maskine forlader et
runlevel. Til venstre finder du de mulige tjenester, som kan startes
op i hvert runlevel. Hvis du vil føje en tjeneste til et
runlevel, begynder du med at trykke på den ønskede tjeneste til
venstre. Derefter trykker du på "Add" (tilføj). Der kommer nu et lille
vindue frem, og i det kan du vælge, hvilket runlevel den ønskede
tjeneste skal startes op eller lukkes ned i.
</PARA>

<FIGURE ID="control-panel-6" FLOAT="1">
<TITLE>Tilføj en ny tjeneste</TITLE>
<GRAPHIC FILEREF="control-panel-6.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>
</SECT3>
</SECT2>

</SECT1>


<SECT1 ID="lydkort">
<TITLE>Et lydkort</TITLE>
<indexterm><primary>Lydkort</primary></indexterm>
<PARA>Mange mennesker har lydkort i deres computer, og Linux
understøtter naturligvis en række af de lydkort, som du kan
købe til en personlig computer. For at lette opsætningen af
lydkort følger der med Red Hat et simpelt men godt program til
dette formål: <command>sndconfig</command>. I dette afsnit vil du
se, hvor let det er. Lydkortet, vi bruger som eksempel, er et
Plug-n-play SoundBlaster 32 fra Creative Labs.</PARA>

<PARA>Du starter programmet ved at taste
<command>sndconfig</command> på kommandolinjen (som root). Programmet er
designet til at køre i tekst-tilstand, og du kan selv vælge, om du
vil benytte dig af en <command>xterm</command> eller bruge
konsollen. Første skærmbillede ser ud som vist nedenfor.
</PARA>

<FIGURE ID="sndconfig-start" FLOAT="1">
<TITLE>Første skærmbillede i
<command>sndconfig</command></TITLE>
<GRAPHIC FILEREF="sndconfig-start.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<PARA>Du fortsætter ved at trykke på ENTER. Det næste
skærmbillede, som du ser nedenfor, fortæller, hvilket lydkort
<command>sndconfig</command> har fundet, i dette tilfælde et
SoundBlaster 32 - som forventet. Du bør naturligvis tjekke, om
programmet finder det rigtige.
</PARA>

<FIGURE ID="sndconfig-2" FLOAT="1">
<TITLE>Hvilket lydkort finder <command>sndconfig</command></TITLE>
<GRAPHIC FILEREF="sndconfig-2.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<PARA>Det tredje skærmbillede tillader, at du vælger et
lydkort. Hvis nu <command>sndconfig</command> ikke har været i
stand til at finde dit lydkort, kan du nu vælge det rette. Vi
vælger naturligvis vores SoundBlaster 32 lydkort. Du kan bevæge
markøren vha. piletasterne, og du flytter markøren ned til OK og CANCEL
ved at trykke på TAB-tasten.
</PARA>

<FIGURE ID="sndconfig-3" FLOAT="1">
<TITLE>Der vælges et lydkort</TITLE>
<GRAPHIC FILEREF="sndconfig-3.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<PARA>
Det er nu tid til at vælge indstillinger for lydkortet. Her er det
typisk lettest, hvis du kender dem på forhånd, så du ikke behøver at
gætte dig frem. Det er reelt de samme oplysninger, som du i Microsoft
Windows 95 finder under "egenskaber for enheder".
</PARA>

<FIGURE ID="sndconfig-4" FLOAT="1">
<TITLE>Indstillinger for lydkortet vælges</TITLE>
<GRAPHIC FILEREF="sndconfig-4.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<PARA>Når du har valgt de rigtige indstillinger, vil
<command>sndconfig</command> afspille en kort lydsekvens for
dig. Når du hører denne, betyder det, at lydkortet er korrekt
konfigureret.
</PARA>

<FIGURE ID="sndconfig-5" FLOAT="1">
<TITLE>En lydsekvens afspilles</TITLE>
<GRAPHIC FILEREF="sndconfig-5.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<para>Gik det helt galt med dit lydkort, kan det være, at du ikke
har den rette Linux-kerne og modulerne til dette. Du kan
læse videre i de følgende afsnit om, hvordan kernen oversættes.
</para>
</SECT1>


<sect1 id="grafik-3D">
<title>Linux og 3D-kort</title>
<indexterm><primary>3D grafik kort</primary></indexterm>
<para>
Som så mange andre styresystemer understøtter Linux 3d-kort. I Linux
bliver 3d grafikken produceret efter et system, der hedder
OpenGL. OpenGL er netop frigivet i Open Source form fra SGI. Indtil
dette skete var Mesa en meget anvendt emulering.
</para>
<para>
OpenGL er et grafisk standard bibliotek, som bruges af programmer til
at kommunikere med 3d-grafikkortet. OpenGL blev udviklet af SGI
(tidligere Silicon Graphics), til brug i deres meget kraftige grafiske
arbejdsstationer. OpenGL blev introduceret i 1992 og er med tiden
blevet et af de mest brugte 2d og 3d grafiske API'er (application
programming interface). I dag bliver OpenGL varetaget af en uafhængig
sammenslutning af firmaer inden for 3d-branchen.
</para>
<para>
Hvis man ønsker at skrive en driver til et 3d grafikkort, som gør brug
af OpenGL teknologien, kræver det, at man skal betale for en licens og
for en bekræftelse på, at driveren er kompatibel med OpenGL.
</para>
<para>
Linux brugere har alligevel mulighed for at bruge OpenGL
bibliotekerne ved hjælp af det før omtalte Mesa.
</para>
<para>
Mesa er et 3d grafisk bibliotek, som indeholder et API, der minder
uhyre meget om det, man finder i OpenGL.
</para>
<para>
Mesa er en såkaldt "Open Source" klon af OpenGL, som er gratis at
nedlæse og benytte. For at bruge 3d-grafikkort i Linux bliver man
først nødt til at installere den Mesa driver, som passer til &eacute;ns
grafikkort. Mesa understøtter (på nuværende tidspunkt) følgende
grafiske chip:
</para>

<itemizedlist>
<listitem><para>
3dfx Voodoo1, Voodoo2, Voodoo Rush, Voodoo Banshee, Voodoo3
</para></listitem>
<listitem><para>
nVidia (bruges i TNT kort)
</para></listitem>
<listitem><para>
Amiga Warp3D
</para></listitem>
<listitem><para>
(Matrox G200, driverne til dette kort indeholder en modificeret Mesa)
</para></listitem>
</itemizedlist>

<para>
Når dette er gjort, vil programmer, som skal bruge 3d-kortet, køre
vha. Mesa biblioteket.  Læs mere om Mesa på <ulink
url="http://www.mesa3d.org/">http://www.mesa3d.org</ulink> og om
OpenGL på <ulink
url="http://www.OpenGL.org/">http://www.OpenGL.org</ulink>
</para>

<para>
Som du kan se er det langt fra alle 3d-grafikkort, som understøttes i
Linux. Dette skyldes, at kun få grafikkort-fabrikanter offentliggør
alle specifikationerne til deres kort. Dette gør at man ikke kan udnytte 
alle kortets funktionen, og kortets ydelse vil derfor være under 
Windows-standarden. Desuden er mange af driverforfatterne alm. personer 
ofte uden den helt store tekniske indsigt, hvilket selvfølgelig også
påvirker driverudviklingen.
</para>

<para>
De bedst understøttede 3d-kort er nok 3Dfx kortene. Der kommer
heldigvis hele tiden nye drivere, først og fremmest til de store
fabrikanters 3d-kort.
</para>

<sect2 id="grafik-3dinstallation">
<title>Installation af 3d-grafikkort under Linux</title>

<sect3 id="grafik-3dfxinstallation">
<title>3Dfx</title>
<para>
3Dfx var blandt de første 3d-kort, som blev tilgængeligt for Linux
brugere. Dette skyldes, at 3Dfx kortene kører med et system, som hedder
Glide, der har været ret nemt at få overført til Linux.  Der findes to
forskellige typer af Glide drivere til Linux:
</para>

<para>
Der findes en, som understøtter Voodoo1, Voodoo2 og
Voodoo Rush, der findes på  <ulink
url="http://glide.xxedgexx.com/3DfxRPMS.html">http://glide.xxedgexx.com/3DfxRPMS.html</ulink>)
</para>

<para>
Og en der understøtter Voodoo Banshee og Voodoo3 kan findes
på  <ulink
url="http://glide.xxedgexx.com/3DfxRPMS_vb_glibc.html">http://glide.xxedgexx.com/3DfxRPMS_vb_glibc.html</ulink>)
</para>

<para>
Voodoo Banshee og Voodoo3 er både et 2d og 3d kort, så
når du installerer denne driver, bliver din 2d-driver i X også
opdateret. Når du har hentet den driver, som du skal bruge, skal den
installeres. Dette gøres således efter du har hentet Glide RPM pakken.
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>rpm -Uvh Glide*.rpm</USERINPUT>
</SCREEN>

<para>
Når dette er gjort skal Mesa installeres. Mesa findes på <ulink
url="http://www.mesa3d.org/">http://www.mesa3d.org</ulink> og ligger
i to tar.gz filer (MesaLib og MesaDemos), som begge skal
nedlæses. Når de to filer er hentet og udpakket, skal Mesa
oversættes. 
Læs dokumentationen inden du går i gang:
</para>


<SCREEN>
<PROMPT>[root@linus mesa]# </PROMPT> <USERINPUT>make linux-glide</USERINPUT>
</SCREEN>


<para>
Du skal nu finde ud af, hvor i dit system de færdigt oversatte filer
skal kopieres hen, derefter skal du gøre som følger: 
</para>

<SCREEN>
<PROMPT>[root@linus mesa]# </PROMPT> <USERINPUT>cd include/</USERINPUT>
<PROMPT>[root@linus include]# </PROMPT> <USERINPUT>cp -r GL/ /usr/include/</USERINPUT>
<PROMPT>[root@linus include]# </PROMPT> <USERINPUT>cd ../lib</USERINPUT>
<PROMPT>[root@linus lib]# </PROMPT> <USERINPUT>cp -d * /usr/lib/</USERINPUT>
<PROMPT>[root@linus lib]# </PROMPT> <USERINPUT>ldconfig</USERINPUT>
</SCREEN>

<para>
Nu skulle dit 3Dfx kort virke uden problemer. Hvis du ønsker at teste
dit 3Dfx kort, skal du skrive:
</para>

<SCREEN>
<PROMPT>[root@linus lib]# </PROMPT> <USERINPUT>/usr/local/glide/bin/test3Dfx</USERINPUT>
</SCREEN>

<para>
Nu skulle der gerne komme et roterende 3Dfx-logo.
</para>

<para>
<emphasis>Bemærk!</emphasis> Da din nuværende installation
kommunikerer direkte med 3Dfx-kortet, bliver du nødt til at køre dine
3Dfx applikationer som "root". Da dette kan være irriterende og
samtidigt kan udgøre en sikkerhedsrisiko, findes der en måde, hvorpå
man kan undgå dette problem. Dette gøres med et såkaldt <emphasis>3Dfx
kernel module</emphasis>. Når først dette kernemodul er installeret,
vil de programmer (og spil), som skal bruge 3DFx-kortet, kommunikere
via <filename>/dev/3Dfx</filename>. Denne løsning har ydermere den
fordel, at du kan bestemme, hvem der skal have adgang til kortet, men
det har samtidig den ulempe, at hastigheden på 3Dfx-kortet bliver
nedsat en smule.
</para>
<para>

</para>
<para>
Det omtalte modul er at finde på 
<ulink url="http://www.xs4all.nl/~carlo17/3dfx/">http://www.xs4all.nl/~carlo17/3dfx/</ulink>.
For at installere det skal du nedlæse tar.gz-filen, og skrive følgende:
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>mkdir dev3dfx</USERINPUT>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>cd dev3dfx/</USERINPUT>
<PROMPT>[root@linus dev3dfx]# </PROMPT> <USERINPUT>tar zxvf ../Dev3Df*.tar.gz</USERINPUT>
<PROMPT>[root@linus dev3dfx]# </PROMPT> <USERINPUT>make</USERINPUT>
<PROMPT>[root@linus dev3dfx]# </PROMPT> <USERINPUT>cp 3dfx.o /lib/modules/`uname -r`/misc
</USERINPUT>
<PROMPT>[root@linus dev3dfx]# </PROMPT> <USERINPUT>mknod /dev/3dfx c 107 0</USERINPUT>
<PROMPT>[root@linus dev3dfx]# </PROMPT> <USERINPUT>insmod 3dfx</USERINPUT>
</SCREEN>

<para>
Derefter skal du redigere din <filename>/etc/conf.modules</filename>
således, at kommandoen <command>insmod 3dfx</command> bliver kørt,
hver gang du starter/genstarter din computer.
</para>

<para>
Ved hjælp af programmet GlideControl, som er at finde på 
<ulink url="http://www.ling.ed.ac.uk/~oliphant/gc/">http://www.ling.ed.ac.uk/~oliphant/gc/</ulink>,
kan man indstille sit Voodoo1- eller Voodoo2-kort under Linux.
</para>

<para>
Skulle der være problemer, kan det være en god idé at kigge forbi
<emphasis>the 3Dfx Linux newsgroup</emphasis>, som er at finde på
<ulink
url="news://news.3dfx.com/3dfx.glide.linux">news://news.3dfx.com/3dfx.glide.linux</ulink>.
Skriv et venligt spørgsmål til denne nyhedsgruppe, vent en dags tid eller
noget i den stil, og dit svar skulle være kommet. En anden - efter
sigende - rigtig god hjemmeside til at komme igang er 
<ulink url=" http://www.3dfxgamers.com/">http://www.3dfxgamers.com/</ulink>.
</para>
</sect3>

<sect3 id="nVidia">
<title>nVidia Riva chipsæt</title>
<para>
nVidia (bruges i TNT kort) er et af de eneste firmaer, som officielt
selv er ved at udvikle Linux-drivere til deres grafik-chipsæt.
</para>
<para>
Deres drivere er at finde på <ulink
url="http://www.nvidia.com/Products.nsf/htmlmedia/software_drivers.html">http://www.nvidia.com/Products.nsf/htmlmedia/software_drivers.html</ulink>.
Yderligere information om installation af disse drivere er også at
finde på denne side. Man skal dog lige være opmærksom på at disse
drivere er på udviklingsstadiet, så de er ikke nær så hurtige og
fejlfrie som dem, du muligvis kender fra Windows.
</para>
</sect3>

<sect3 id="matroxg200">
<title>Matrox G200</title>
<para>
Matroxs G200 chipsættet har for 3d-delens vedkommende i en del tid
været understøttet i X. For nylig frigav Matrox specifikationer til
3d-delen, hvilket har medført, at der er kommet nogle midlertidige
drivere. De kan hentes på <ulink
url="http://www.on.openprojects.net/glx/">http://www.on.openprojects.net/glx/</ulink>. Læs
filen med ofte stille spørgsmål (OSS. - eng. FAQ), som ligger på
siden, for at finde ud af, hvordan du installerer driverne.
</para>

<para>
Installationen indeholder en modificeret udgave af Mesa samt et "glx"
modul, som gør det muligt for X at arbejde med Mesa (OpenGL)
kommandoer. Ifølge rygter skulle Mesa blive en del af X, fra og med
XFree86 version 4.0. G200 driverne er under kraftig udvikling og er
ligesom nVidas drivere ikke særligt hurtige eller stabile. Så sørg for at
læse dokumentationen,før du går i gang.
</para>
</sect3>
</sect2>

</sect1>




<sect1 id="printere">
<title>Printere</title>
<indexterm><primary>Printer</primary></indexterm>
<indexterm><primary>Udskrivning</primary></indexterm>
<para>
Skal du tilføje en printer, du kan skrive ud på, og du anvender Red
Hat, skal du lige som "root" sætte printeren op med
<command>printtool</command>. Det første billede, du møder, viser,
hvor mange printere, der allerede er sat op. I dette tilfælde kun én.
</para>

<FIGURE ID="printtool1" FLOAT="1">
<TITLE>Opsætning af ny printer med printtool i Red Hat</TITLE>
<GRAPHIC FILEREF="printtool1.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<para>
Vælger du nu "Add" (tilføj), skal du vælge, hvor printeren
findes. Netværksprintere og printere på egen maskine er
understøttet. Vi vælger en lokal printer til dette eksempel. Vælger du
en netværksprinter, skal du have information fra din
netværksadministrator om printertype og adresse.
</para>

<FIGURE ID="printtool2" FLOAT="1">
<TITLE>Valg af printer type i Red Hat</TITLE>
<GRAPHIC FILEREF="printtool2.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<para>
Linux vil for lokale printere automatisk detektere, hvilken enhed
der ser ud til at have en printer tilkoblet.
</para>

<FIGURE ID="printtool3" FLOAT="1">
<TITLE>Detektion af printer-device i Red Hat</TITLE>
<GRAPHIC FILEREF="printtool3.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<para>
Nu mangler vi bare at angive typen af printer, tryk derfor på "Select"
(vælg) ud for "Input Filter" (inddata-filter).
</para>

<FIGURE ID="printtool4" FLOAT="1">
<TITLE>Opsætning af ny printer med printtool i Red Hat</TITLE>
<GRAPHIC FILEREF="printtool4.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<para>
Nu vælger du typen af printer. Winprintere kan du godt glemme, men
mange gode printere er understøttet, og har du en PostScript printer,
er det slet intet problem. Husk at vælge grafik-opløsning og
papirstørrelse. Klik-feltet "Fix stair-stepping text" bør du vælge -
det er for at klare den forskellige fortolkning af linjeskift i UNIX
kontra DOS-verdenen.
</para>

<FIGURE ID="printtool5" FLOAT="1">
<TITLE>Opsætning af ny printer med printtool i Red Hat</TITLE>
<GRAPHIC FILEREF="printtool5.&magic;"  SCALE="50"></GRAPHIC>
</FIGURE>

<para>
Efter at have trykket på "Ok", er du tilbage i hovedmenuen for
printeropsætning og kan vælge at udskrive testsider. Håber det
virker.
</para>

<para>
Nu bør f.eks. din Netscape kunne udskrive og tilsvarende din gv (til PostScript
filer). Du kan udskrive tekstfiler med <command>lpr FILNAVN</command>,
og du bør nok læse man-siderne for lpr, lprm, lpq og lpc.
</para>

<para>
Til at udskrive tekstfiler, f.eks. C-kode, kan du med fordel
installere a2ps, som laver meget pæne udskrifter, der viser kode
syntaks. Du finder a2ps på <ulink
url="http://www.inf.enst.fr/~demaille/a2ps">http://www.inf.enst.fr/~demaille/a2ps</ulink>
</para>

<sect2 id="udskrivning-fra-andre-maskiner">
<title>Udskrivning fra andre maskiner</title>
<indexterm><primary>Printer</primary><secondary>fra andre Linux maskiner</secondary></indexterm>
<indexterm><primary>Udskrivning</primary><secondary>fra andre Linux maskiner</secondary></indexterm>
<para>
Skal du skrive dokumenter ud fra en anden Linux maskine til din
printer, du har sat på din Linux maskine, så bliver du nødt til at
rette filen <filename>/etc/hosts.lpd</filename>, så den indeholder de
maskiner, der kan skrive ud på printeren. Du kan også bruge jokertegn
(eng. wildcards), f.eks. "*.kongeh.dk" for at tillade alle maskiner i
domænet kongeh.dk.
</para>
</sect2>
</sect1>





<SECT1 ID="Opstart">
<TITLE>Opstart af Linux</TITLE>
<indexterm><primary>Boot af Linux</primary></indexterm>
<indexterm><primary>Opstart af Linux</primary></indexterm>
<indexterm><primary>Microsoft Windows</primary><secondary>98</secondary></indexterm>
<indexterm><primary>Windows</primary><secondary>98</secondary></indexterm>

<PARA>
Som tidligere skrevet kan Linux fint eksistere sammen med Windows
95/98 eller Windows NT. Hvad angår Windows 95/98, skal du se på LILO
eller Loadlin som opstartsindlæser (bootloader), men med hensyn til
Windows NT kommer der i det følgende en vejledning i at anvende Linux
sammen med Windows NT's "OS Loader". 
</para>

<para>
Et alternativ til dette er at benytte "bootpart" programmet - så kan
man have LILO liggende i din Linux partition i stedet for i master
boot record (MBR) - se
<ulink url="http://www.winimage.com">http://www.winimage.com</ulink> og
<ulink url="http://www.winimage.com/bootpart.htm">http://www.winimage.com/bootpart.htm</ulink>.
</para>


<sect2 id="lilo">
<title>LILO</title>
<indexterm><primary>Opstart af Linux</primary><secondary>LILO</secondary></indexterm>
<indexterm><primary>LILO</primary><secondary>LILO</secondary></indexterm>
<para>
Mange vil allerede under installationen af Red Hat have installeret
LILO som opstarter (eng. Boot Manager). Senere kan det være, at du vil
have mulighed for at opstarte med en ny kerne eller lignende. Du skal
så ændre i opsætningsfilen <FILENAME>/etc/lilo.conf</FILENAME>, hvor
der står en del for hvert af de styresystemer, der kan opstartes. Når
du har rettet, skal du køre <command>/sbin/lilo</command> som "root",
hvorefter rettelserne har effekt.
</para>

<para>
Et eksempel på <FILENAME>/etc/lilo.conf</FILENAME> kan være
</para>

<SCREEN>
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
image=/boot/bzImage
        label=linux
        root=/dev/hda3
        read-only
        restricted  
        password=HEMLIPASSWORD
image=/boot/vmlinuz-2.0.35-2
        label=linux2
        root=/dev/hda3
        read-only
        restricted  
        password=HEMLIPASSWORD
other=/dev/hda1
        label=dos
        table=/dev/hda
</SCREEN>

<para>
I eksemplet opstartes på første IDE harddisk
(<filename>hda</filename>).  En opstartsfil indlæses lægges i
opstartssektoren, og der opstartes efter 5 sekunder på den første af
de tre muligheder. Der er her to muligheder for at opstarte Linux med
to forskellige kerner (linjerne med image). Begge starter op med root
partition på <FILENAME>/dev/hda3</FILENAME>. Feltet "label" (Mærkat)
er det, du ser på skærmen som opstarts-valgmulighed. Den sidste
mulighed i eksemplet er, at DOS opstartes på den første partition
(hda1) på første IDE disk.
</PARA>

<para>
<indexterm><primary>Slette LILO</primary></indexterm>
<indexterm><primary>LILO</primary><secondary>Slette</secondary></indexterm>
<emphasis>Tip:</emphasis> LILO kan fjernes ved at køre
<userinput>fdisk /mbr</userinput> i en DOS vindue under DOS/Windows.
</para>

<para>
I eksemplet er der benyttet kommandoen <command>restricted</command>
og <command>password</command>. De linier gør at man ikke kan starte
op i enkelt bruger-tilstand (eng. single user mode) uden at give
password "HEMLIPASSWORD". Husk at <command>/etc/lilo.conf</command>
ikke bør kunne læses af andre end root, dvs. kør en gang for alle
</para>

<screen>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> chmod 600 /etc/lilo.conf</userinput>
</screen>


<PARA>
Lilo kan en hel del, men kan være et lige så besværligt værktøj, som
det kan være suverænt. Du bør måske læse den mini-HOWTO om LILO, som
kan findes under "Linux Documentation Project" på <ulink
url="http://sunsite.auc.dk/ldp">http://sunsite.auc.dk/ldp</ulink>.
Specielt kan det være at de to alternativer "restricted" eller "password" 
(adgangskode) er værd at forstå.
</PARA>

<sect3 id="lilo-rescue">
<title>LILO gik galt!</title>
<indexterm><primary>LILO</primary><secondary>problemer</secondary></indexterm>
<para>
Hvis uheldet er ude og du har Linux installeret og der er problemer
med LILO, så maskinen ikke booter, så kan du bruge din
installations-cdrom til at reparere systemet med.
</para>

<para>
Du skal starte op på din Linux cdrom og vælge
<command>rescue</command>-muligheden. Du får ikke kontakt med din
harddisk derved, men får Linux startet op med programmer til at klare
problemerne. 
</para>

<para>
Hvis vi antager at Linux er installeret med <filename>/</filename>
(roden) på <filename>/dev/hda1</filename>, så kan du skrive følgende
for at montere hardisk roden på <filename>/mnt</filename>. 
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT> <USERINPUT>mount /dev/hda1 /mnt</USERINPUT>
</SCREEN>

<para> 
Nu kan du med <command>cd /mnt/etc</command> komme ned til
<filename>/etc</filename> på harddisken. Husk at dit Linux system er
fra din cdrom og din cdrom er tilgængelig via
<filename>/mnt</filename>. Du kan nu rette i
<filename>lilo.conf</filename> eller rettere
<filename>/mnt/etc/lilo.conf</filename>, f.eks. med
<command>vi</command> eller <command>pico</command>. Derefter kan du
køre <command>lilo -r /mnt</command>, der læser
<filename>lilo.conf</filename>-filen fra
<filename>/mnt/etc/lilo.conf</filename>, og installerer LILO, som om
du havde <filename>/mnt</filename> som dit rod-filsystem.
</para>

<para>
Husk at det kan være et problem at boote fra en harddisk, som har
flere end 1024 cylindre - hvis de filer som LILO skal bruge for at
boote ligger over cylinder 1024, er det ikke altid din BIOS kan finde
ud af det, og derfor vil LILO i så fald komme med en advarsel. Det kan
være årsagen til, at den ikke vil installeres automatisk. Heldigvis
vil dette problem snart være historie, idet LILO fra version 0.21.4.2
og fremover kan understøtte op til 2 TB diske, hvilket vel stadig
dækker de fleste personers behov :-)
</para>
</sect3>
</sect2>

<sect2 id="loadlin">
<title>Loadlin</title>
<indexterm><primary>Opstart af Linux</primary><secondary>Loadlin</secondary></indexterm>
<PARA>
En anden mulighed er at starte op i Windows 95 og der lave en opstarter
via <FILENAME>CONFIG.SYS</FILENAME> og
<FILENAME>AUTOEXEC.BAT</FILENAME> filerne. Først hentes DOS programmet
LOADLIN fra
<ulink url="ftp://sunsite.auc.dk/pub/os/linux/sunsite/system/boot/dualboot/lodlin16.tgz">ftp://sunsite.auc.dk/pub/os/linux/sunsite/system/boot/dualboot/lodlin16.tgz</ulink>
</PARA>

<PARA>
Vi har installeret <command>loadlin</command> i
<FILENAME>c:\linux\loadlin</FILENAME> (loadlin kan downloades i
zip-format og pakkes ud som vanligt med 
<command>pkunzip</command> eller <command>WinZip</command>).  Vor
Linux-kerne har vi kopieret til 
<filename>c:\linux</filename> med navnet <filename>vmlinuz</filename>,
og i nedenstående <filename>autoexec.bat</filename> har vi vores
root-partition på <filename>/dev/hda3</filename> (tredje partition på
hoveddisken). Du skal rette i linjen
<filename>c:\linux\loadlin\loadlin c:\linux\vmlinuz root=/dev/hda3
ro</filename> svarende til din konfiguration.
</PARA>

<PARA>
I det følgende skal du erstatte indholdet for Windows 95 (Win95) med
det, som du selv har. Linux har reelt kun noget i
<FILENAME>AUTOEXEC.BAT</FILENAME>
</PARA>

<PARA>
<EMPHASIS>CONFIG.SYS</EMPHASIS>
</PARA>

<SCREEN>
[MENU]
MENUITEM=Win95
MENUITEM=Linux
MENUDEFAULT=Linux,5

[Win95]
DEVICE=C:\UCD\UCDIDE.SYS /D:UCD0001
DEVICE=C:\WINDOWS\SETVER.EXE
DEVICE=C:\WINDOWS\HIMEM.SYS
DOS=HIGH
device=C:\WINDOWS\COMMAND\display.sys con=(ega,,1)
Country=045,850,C:\WINDOWS\COMMAND\country.sys

[Linux]

</SCREEN>

<PARA>
<EMPHASIS>AUTOEXEC.BAT</EMPHASIS>
</PARA>

<SCREEN>
GOTO %CONFIG%

:Win95
rem - By Windows Setup - C:\WINDOWS\COMMAND\MSCDEX /D:UCD0001
@ECHO OFF
PROMPT $p$g
SET PATH=C:\WINDOWS;C:\WINDOWS\COMMAND;C:\DOS;
SET TEMP=C:\DOS
mode con codepage prepare=((850) C:\WINDOWS\COMMAND\ega.cpi)
mode con codepage select=850
keyb dk,,C:\WINDOWS\COMMAND\keyboard.sys
GOTO END

:Linux
c:\linux\loadlin\loadlin c:\linux\vmlinuz root=/dev/hda3 ro
GOTO END

:END
</SCREEN>
</SECT2>
</sect1>
</CHAPTER>


