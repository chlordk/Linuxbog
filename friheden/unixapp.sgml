<!-- $Id$ -->
<appendix id="UNIXapp">
<title>Lad mig lære lidt flere UNIX/Linux kommandoer</title>

<para>
I dette appendix vil vi gennemgå en række UNIX/Linux
kommandoer. Gennemgangen er overfladisk, men du kan finde flere
oplysninger i programmernes man-sider. Desuden er 
<ulink url="http://www.sslug.dk/artikler/begyndertips.html">http://www.sslug.dk/artikler/begyndertips.html</ulink>
et godt sted at få mere information.
</para>

<sect1 id="UNIXapp-redirect">
<title>Mere om omdirigering</title>
<para>
Linux (som UNIX) arbejder med følgende input/output terminologi:
</para>

<para>
<itemizedlist mark="bullet">
  <listitem><para>Standard input (<filename>stdin</filename>). Normalt
  tastaturet.</para></listitem>
  <listitem><para>Standard output
  (<filename>stdout</filename>). Normalt skærmen.</para></listitem>
  <listitem><para>Standard error (<filename>stderr</filename>). Normalt
    skærmen.</para></listitem>
</itemizedlist>
</para>

<para>
Vi har før været inde på, at <filename>stdout</filename> kan omdirigeres med <command>></command>.
<command>cat fil1 fil2 > fil3</command> vil samle indholdet af filerne
<filename>fil1</filename> og <filename>fil2</filename> i filen
<filename>fil3</filename>.
</para>

<para>
Da måden, du omdirigerer på, er afhængig af shell'en, er det en god ide at
undersøge dette nu. Prøv med:
</para>


<screen>
<prompt>[daisy@linux daisy]$ </prompt> <userinput>env | grep ^SHELL | cut -d/ -f3</userinput>
</screen>


<para>
Svaret skulle gerne være <command>bash</command>,
<command>csh</command> eller <command>tcsh</command>. Det kan være, at du
anvender en anden shell - der findes mange. Hvis det er tilfældet, kan du se i
man-pages for den aktuelle shell (<command>man SHELLNAVN</command>).
</para>

<para>
Hvis du selv starter en ny shell (enten fra kommandolinjen eller i et script),
er det ikke sikkert, at ovenstående metode virker. Prøv derfor at skrive
<command>ps</command>.  En liste over de kørende processer vil da
blive udskrevet til skærmen. Den nederste proces, der ender på "sh",
angiver din shell - normalt.
</para>

<para>
Fælles for Bourne-Again Shell (<command>bash</command>) og C-Shell er
følgende: Lad os antage, at filen <filename>fil3</filename> indeholder
information, vi ønsker at bevare. Vi vil tilføje (append) indholdet af
<filename>fil1</filename> og <filename>fil2</filename> til
<filename>fil3</filename>. Det gøres ved:
</para>

<screen>
<prompt>[daisy@linux daisy]$ </prompt> <userinput>cat fil1 fil2 >> fil3</userinput>
</screen>

<para>
Indholdet af en fil kan også anvendes som argument(er)
til en kommando, f.eks. vil følgende kommando sende indholdet af filen
<filename>megenRos</filename> til SSLUG's webmastere:
</para>

<screen>
<prompt>[daisy@linux daisy]$ </prompt> <userinput>sendmail www_admin@sslug.dk < megenRos</userinput>
</screen>

<para>
Linux skelner (som UNIX) mellem normale uddata
(<filename>stdout</filename>) og fejluddata (<filename>stderr</filename>).
Til tider kan det være rart kun at omdirigere det ene sæt meddelelser.
</para>

<para>
Specielt for <command>bash</command> gælder følgende: omdirigering af
<filename>stdout</filename> (1) og <filename>stderr</filename> (2) i
<command>bash</command> er forholdsvis simpel.
</para>

<para>
Hvis kun fejlmeddelelserne fra en kommando - her <command>ls</command> -
ønskes:
</para>

<screen>
<prompt>[daisy@linux daisy]$ </prompt>  <userinput>ls  1> /dev/null</userinput>
</screen>

<para>
Hvis kun <filename>stdout</filename> ønskes vist, og fejlmeddelelserne
skal sendes til en fil:
</para>

<screen>
<prompt>[daisy@linux daisy]$ </prompt> <userinput>ls 2> fejlfil </userinput>
</screen>

<para>
Og endelig, hvis du ønsker at akkumulere fejlmeddelelser i en fil, kan
<command>>></command> anvendes - f.eks.
</para>

<screen>
<prompt>[daisy@linux daisy]$ </prompt> <userinput>ls 2>> fejlfil</userinput>
</screen>

<para>
De to shells <command>csh</command> og <command>tcsh</command>
adskiller sig fra <command>bash</command> på følgende måder. Når du omdirigerer med
<command>></command> eller <command>>></command>, er det kun
<filename>stdout</filename>, der omdirigeres. Hvis
<filename>stderr</filename> skal med, skal du anvende
<command>&</command> efter
omdirigeringen. <filename>stderr</filename> kan ikke omdirigeres
alene, men med lidt krumspring lykkedes det alligevel:
</para>

<screen>
<prompt>[daisy@linux daisy]$ </prompt><userinput>ls -l /* | tee >& fil1 | diff fil1 - >fejlFil</userinput>
</screen>

<para>
Ovenstående kommando sender både <filename>stderr</filename> og
<filename>stdout</filename> til filen <filename>fil1</filename>.
</para>
</sect1>


<sect1 id="UNIXapp-smaating">
<title>En række nyttige værktøjer</title>

<sect2 id="UNIXapp-who">
<title>Hvem er logget ind?</title>
<indexterm><primary>who</primary></indexterm>
<para>
Hvis du ønsker at vide, hvilke brugere der er logget på samme computer
som dig, bruger du kommandoen <command>who</command>. Du vil så få en
liste med brugere, der har logget in, og fra hvilken (virtuel) terminal
de er koblet til. Denne kommando har ikke den store værdi, med mindre
du arbejder i et flerbruger-system. Arbejder du i et større netværk,
kan det være, at <command>rwho</command> virker. <command>rwho</command>
viser dig, hvem der er logget ind på hvilke computere i netværket.
</para>

<para>
Hvis du ikke er klar over, hvem du er logget ind som, skriver blot
<command>whoami</command>, svaret synes indlysende, men alligevel:
dit login dukker op og terminalens id ligeså.
</para>
</sect2>


<sect2 id="UNIXapp-find">
<title>Søg og du skal finde</title>
<indexterm><primary>find</primary></indexterm>

<para>
<command>find</command> bruges til at finde filer med. Syntaksen er:
<command>find</command> hvorfra hvad [handling]. Ikke alle Linux/UNIX
varianter kræver 3. argument. Lad os se nærmere på argumenterne.
</para>

<itemizedlist mark="bullet">
<listitem>
<para>
1. argument, hvorfra:
  <itemizedlist mark="bullet">
  <listitem><para>
    <filename>./</filename> angiver aktuelt katalog.
  </para></listitem>
  <listitem><para>
    <filename>~/</filename> angiver hjemmekatalog.
  </para></listitem>
  <listitem><para>
   <filename>/</filename> angiver roden.
  </para></listitem>
  <listitem><para>
    <filename>/usr</filename> angiver <filename>usr</filename> og alt
    under.
  </para></listitem>
</itemizedlist>
</para>
</listitem>
<listitem>
<para>
2. argument, hvad:
  <itemizedlist mark="bullet">
  <listitem><para>
    <screen>-name foo</screen> med navnet <filename>foo</filename>
  </para></listitem>
  <listitem><para>
    <screen> -type d</screen> som er et katalog.
  </para></listitem>
</itemizedlist>
</para>
</listitem>

<listitem>
<para>
3. argument, aktion:
  <itemizedlist mark="bullet">
  <listitem><para>
    <screen>-print</screen> udskriver, hvor filen er fundet
  </para></listitem>
  <listitem><para>
    <screen>-ls</screen> udfører <command>ls -l</command> på
    søgeresultatet
  </para></listitem>
  <listitem><para>
    <screen>-exec cmd {}\;</screen> udfører kommandoen
    <command>cmd</command> på søgeresultatet.
  </para></listitem>
  <listitem><para>
    <screen>-ok</screen> som <screen>exec</screen> men spørger først.
  </para></listitem>
  </itemizedlist>
</para>
</listitem>
</itemizedlist>

<para>
Som et sødt lille eksempel på hvor smart <command>find</command> er,
så kan vi tælle det totale antal af linier i en række tekstfiler, der
ligger spredt i nogle underbiblioteker.
</para>

<screen>
<prompt>[daisy@linux daisy]$ </prompt> <userinput>(find . -type f -exec cat {} \;) | wc -l</userinput>
</screen>

</sect2>


<sect2 id="UNIXapp-touch">
<title>Hvordan ændres datomærkningen?</title>

<indexterm><primary>touch</primary></indexterm>
<para>
Kommandoen <command>touch</command> anvendes til at oprette tomme
filer eller ændre tidspunktet for sidste modifikation.
</para>

<para>
Lad os antage, at filen <filename>minFil</filename> eksisterer, og
filen <filename>minIkkeEksisterendeFil</filename> ikke gør, da vil
<command>touch minFil</command> sætte tiden for sidste modifikation af
filen til det aktuelle klokkeslet. Kommandoen <command>touch
minIkkeEksisterendeFil</command> vil oprette en tom fil med
navnet <filename>minIkkeEksisterendeFil</filename>.
</para>

</sect2>

<sect2 id="UNIXapp-file">
<title>Hvilken filtype?</title>

<indexterm><primary>file</primary></indexterm>
<para>
Kommandoen <command>file</command> forsøger at gætte, hvilken filtype
der er givet som argument. Hvis <command>file</command> tror, at det er
en ascii-fil, vil <command>file</command> læse de 512 første tegn og
forsøge at gætte programmeringssproget.
</para>

<para>
<command>file</command> gætter desværre forkert fra tid til anden og
kan f.eks. ikke genkende filer, der indeholder programmer, som er
skrevet i Pascal og Lisp.
</para>
</sect2>

<sect2 id="UNIXapp-date">
<title>Tid og dato</title>
<indexterm><primary>date</primary></indexterm>

<para>
<command>date</command> udskriver den aktuelle dato og
klokkeslet.
</para>

<screen>
<prompt>[daisy@linux daisy]$ </prompt> <userinput>date</userinput>
 lør jan 16 17:50:55 CET 1999
</screen>

<indexterm><primary>cal</primary></indexterm>
<indexterm><primary>Kalender</primary><secondary>cal</secondary></indexterm>
<para>
<command>cal</command> er en hel lille kalender.
Uden argument udskrives kalenderen for den aktuelle måned.
Med et argument (tal) regnes argumentet for et årstal. Vær iøvrigt
opmærksom på, at <command>cal</command> er År2000 klar,
dvs. <command>cal 99</command> udskriver kalenderen for år 99, mens <command>cal
1999</command> skriver kalenderen for 1999.
</para>

<para>
Med 2 argumenter regnes det første som måned og det andet som
årstal. Det er værd at bemærke, at <command>cal</command> antager, at
skiftet fra Julianske kalender til Gregorianske kalender skete i september
1752, hvilket passer til engelske forhold (i katolske lande skete det i 1582
og i Danmark i 1700).
</para>
</sect2>

<sect2 id="UNIXapp-sort">
<title>Sortering</title>

<indexterm><primary>sort</primary></indexterm>
<para>
<command>sort</command> sorterer en fil linje for
linje. <command>sort</command> kan også flette flere filer samtidig
med, at indholdet sorteres. Omdirigering af <command>sort</command> til
en fil er mulig med optionen "-o". <command>sort fil1 fil2 >
fil1</command> vil give et pudsigt resultat: Da
<filename>stdout</filename> omdirigeres til <filename>fil1</filename>,
som eksisterer i forvejen, slettes <filename>fil1</filename>, og en ny,
tom <filename>fil1</filename> oprettes. Når <filename>fil1</filename>
og <filename>fil2</filename> flettes og sorteres, vil
<filename>fil1</filename> være tom. Derfor vil kun indholdet af
<filename>fil2</filename> komme med i <filename>fil1</filename> -
kryptisk - prøv selv! Husk blot, at <command>sort</command> er den
eneste (standard) kommando, hvor <filename>stdout</filename>
omdirigeres med en option "-o".
</para>

<para>
Men <command>sort</command> kan mere: En fil kan være inddelt i
poster, f.eks. filen <filename>navne</filename>.
</para>
<screen>
<prompt>[daisy@linux daisy]$ </prompt> <userinput>cat navne</userinput>
   poul nyrup 52
   holger beck-nielsen 90
   william gates 55
   torvald linus ??
</screen>

<para>
Lad os illustrere <command>sort</command> ved en række eksempler.
<command>sort +1 navne</command> vil sortere på efternavn (første felt
er felt 0). <command>sort +2-n navne</command> vil sortere numerisk
på hattestørrelse. <command>sort -r navne</command> vil sortere i
omvendt rækkefølge.
</para>
<screen>
<prompt>[daisy@linux daisy]$ </prompt> <userinput>sort +2 -n -r navne</userinput>
  torvald linus 91.2
  holger beck-nielsen 90
  william gates 55
  poul nyrup 52
</screen>
</sect2>

</sect1>
<sect1 id="UNIXapp-texttool">
<title>En række tekstværktøjer</title>

<para>
Linux har en række mindre værktøjer til at håndtere af tekstfiler. Vi
vil i dette afsnit se lidt nærmere på dem.
</para>

<para>
<command>diff</command> udskriver forskellen mellem to filer. Lad os
se på filerne <filename>fil1</filename> og <filename>fil2</filename>.
</para>

<screen>
<prompt>[daisy@linux daisy]$ </prompt> <userinput>cat fil1 </userinput>
  Per
  Poul
  Bent
<prompt>[daisy@linux daisy]$ </prompt> <userinput>cat fil2 </userinput>
  Per
  Bjarne
<prompt>[daisy@linux daisy]$ </prompt> <userinput>diff fil1 fil2 </userinput>
  2,3c2
  < Poul   (oversat: ud går Poul)
  < Bent   (oversat: ud går Bent)
  > Bjarne (oversat: ind kom Bjarne)
</screen>

<indexterm><primary>cat</primary></indexterm>
<indexterm><primary>uniq</primary></indexterm>
<para>
<command>uniq</command> fjerner ens linjer, der kommer efter hinanden,
hvilket illustreres nedenfor.
</para>

<screen>
<prompt>[daisy@linux daisy]$ </prompt>  <userinput>cat per3 </userinput>
  Per
  Per
  Per
<prompt>[daisy@linux daisy]$ </prompt> <userinput>uniq per3</userinput>
  Per
</screen>

<para>
<command>cmp</command> sammenligner filer og stopper læsningen af
filerne, når <command>cmp</command> finder en forskel.
</para>

<para>
<command>wc</command> står for Word Count, og som navnet antyder,
tæller den ord i en fil. <command>wc</command> har nogle options:
"-l", "-w" og "-c" for Lines, Words og Characters.
</para>

<para>
Vil du vide, hvor mange linjer en fil indeholder, skriver du <command>wc
-l fil</command>. <command>wc</command> er særlig god sammen med andre
kommandoer og <command>|</command> (pipe), f.eks. vil nedenstående
kommando tælle op, hvor mange filer, der er i kataloget
<filename>/usr/bin</filename>
</para>

<screen>
<prompt>[daisy@linux daisy]$ </prompt> <userinput>ls /usr/bin | wc -l</userinput>
  1208
</screen>

<para>
Eller hvis du vil vide, hvor mange kataloger der er i
<filename>/etc</filename>
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>ls -l /etc | grep ^d | wc -l</userinput>
  23
</screen>

<para>
Forklaringen er som følger: <command>ls -l</command> giver den lange
liste med egenskaberne for filerne med en fil pr. linje. Det
allerførste tegn på linjen angiver filtypen. <filename>d</filename>
betyder, at det er et "directory" - et katalog. <command>grep
^d</command> lader kun de linjer, der starter med
<filename>d</filename>, passere. <command>wc -l</command> tæller
antallet af linjer, den modtager.
</para>

<sect2 id="UNIXapp-tail">
<title>Hoved og hale</title>
<indexterm><primary>tail</primary></indexterm>
<indexterm><primary>head</primary></indexterm>
<para>
<command>tail</command> - uden options - udskriver de 10 sidste linjer
af en fil, "-5" vil udskrive de 5 sidste linjer, og "+8" vil udskrive
fra og med linje 8 i en fil. Lad os se på et eksempel.
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>cat sang</userinput>
    Jeg bærer med smil min byrde,
    jeg drager med sang mit læs;
    jeg er som den vilde hyrde,
    der genner sit kvæg på græs.
<prompt>[daisy@linus daisy]$ </prompt> <userinput>tail -2 sang</userinput>
    jeg er som den vilde hyrde,
    der genner sit kvæg på græs.
</screen>

<para>
<command>tail</command> har en meget nyttig "f"-option. Den
får <command>tail</command> til løbende at vise de sidste 10 linjer
af en fil, f.eks. vil du med <command>tail -f
/var/log/messages</command> kunne følge, hvad alle system-dæmoner
og lignende rapporterer.
</para>

<para>
<command>head</command> svarer til <command>tail</command>, men i
stedet for slutningen af en fil, er det begyndelsen.
<command>head</command> - uden optioner - udskriver de 10 første
linjer af en fil. Optioner kan gives som for <command>tail</command>.
</para>
</sect2>

<sect2 id="UNIXapp-cut">
<title>"cut" og "paste"</title>

<para>
<command>cut</command> tager det, du specificerer i options, ud af en
 linje, dvs. -cx-y: tager fra tegn nr. x til tegn nr. y på hver linje
 i den specificerede fil. Er der kun et tal, tages kun dette tegn ud.
 -fx-y er som for c, men her drejer det sig om felter, og -d'X'
 angiver felt-separatoren.
</para>

<para>
Vil du se, hvilke brugere der har adgang til systemet, så prøv:
<command>cat /etc/passwd | cut -d':' -f1</command>
</para>

<para>
<command>paste</command> samler filer lodret, hvor
<command>cat</command> samler (kan samle) filer vandret. Lad os se på
følgende eksempel. Du ønsker nu at samle to filer,
<filename>navne</filename> og <filename>iq</filename>, således at
linje 1 fra <filename>navne</filename> efterfølges af linje 1 fra
<filename>iq</filename> (uden at dette dog skulle være konkluderende,
for såvidt angår de tilfældige sammenstillinger af for- og efternavne
samt tal).
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>cat navne</userinput>
      poul nyrup 52
      holger beck-nielsen 90
      william gates 55
      torvald linus ??
<prompt>[daisy@linus daisy]$ </prompt> <userinput>cat iq</userinput>
      50
      230
      120
      ??
<prompt>[daisy@linus daisy]$ </prompt> <userinput>paste navne iq</userinput>
      poul nyrup 52 50
      holger beck-nielsen 90 230
      william gates 55 120
      torvald linus ?? ??
</screen>

</sect2>

<sect2 id="UNIXapp-tr">
<title>Søg og du skal erstatte</title>

<para>
<command>tr</command> erstatter det første argument med det andet.
<command>tr</command> er en lidt speciel sag. Den forventer, at få
input fra <filename>stdin</filename>. Derfor må du bruge følgende
fremgangsmåde, hvis du vil erstatte noget i <filename>fil1</filename>,
og skrive indholdet til <filename>fil2</filename>. Hvis du ønsker, at
alle små tegn skal erstattes med store, skulle følgende kunne lade sig
gøre.
</para>

<screen>
<prompt>[daisy@linus daisy]$ </prompt> <userinput>tr '[a-z,æ,ø,å]' '[A-Z,Æ,Ø,Å]' < fil1 > fil2</userinput>
</screen>

<para>
Det er ikke sikkert, at din distribution eller dit system vil godtage
de danske tegn, men vi har afprøvet det på Red Hat 6.0, hvor det virker.
</para>
</sect2>

</sect1>





<sect1 id="UNIXapp-andre">
<title>Andre UNIX-kommandoer</title>
<para>
<table>
<title>Oversigt over de mest anvendte andre UNIX-kommandoer.</title>
<tgroup cols=2 align="char">
<thead>
<row>
<entry>Kommando
</entry>

<entry>
Forklaring
</entry>

</row>
</thead>
<tbody>
<row><entry>find</entry> <entry> Find fil(er). Anvend f.eks. <command>find /usr -name "*.gif"</command>
      til at finde alle filer under biblioteket <filename>/usr</filename>, der ender
      på <filename>.gif</filename>. Prøv også <command>locate FILNAVN</command>.
</entry></row>
<row><entry>whoami</entry> <entry> Viser, hvilket login navn der arbejdes under.
</entry></row>
<row><entry>who</entry> <entry> Viser, hvem der er logget ind på maskinen.</entry></row>
<row><entry>passwd</entry> <entry> Skift password. </entry></row>
<row><entry>su</entry> <entry> Skift bruger identitet.</entry></row>
<row><entry>echo</entry> <entry> Kommandoen <command>echo "TEKST"</command>
      skriver teksten på skærmen.</entry></row>
<row><entry>chown</entry> <entry> ændrer ejerskabet af filer.</entry></row>
<row><entry>export</entry> <entry>
      Anvendes i <command>bash</command> shell'en (default i Linux) til at
      sætte systemvariable (ligesom <command>set</command> i
      DOS). Syntaksen er: <command>export VARIABEL=VÆRDI</command>.</entry></row>
<row><entry>date</entry> <entry> Viser dato og tid.</entry></row>
<row><entry>xhost</entry> <entry> Anvendes til at tillade/begrænse andre maskiner at
      koble til maskinens X server, dvs. om de må vise grafik
      på skærmen. Anvend <command>xhost +</command> til at tillade alle
      maskiner at vise grafik på maskinen. Anvend tilsvarende
      <command>xhost -maskinnavn</command> til at forhindre, at den
      pågældende maskine viser grafik.
</entry></row>
<row><entry>lpr</entry> <entry> Print ordre. Anvend <command>lpr -Pprinternavn filnavn</command>
      for at printe på printeren <command>printernavn</command>. De enkelte
      printere er defineret i filen <filename>/etc/printcap</filename>.
      De aktuelle printere kan være såvel lokale som netprintere.
</entry></row>
<row><entry>lpq</entry> <entry> Printerkø forespørgsel. Anvend <command>lpq -Plp</command> til
      at vise, hvor langt printeren <command>lp</command> er med at
      printe ud.
</entry></row>
<row><entry>lprm</entry> <entry> Anvendes til at fjerne printjobs, som ikke er skrevet endnu.
      Se muligheder med <command>man lprm</command>.
</entry></row>
<row><entry>tar</entry> <entry> Anvendes til at pakke flere programmer sammen til
      et. Anvend f.eks. <command>tar cvf tfil.tar fil1 fil2</command> for at
      pakke <filename>fil1</filename> og <filename>fil2</filename> sammen til filen <filename>tfil.tar</filename>.
      Tilsvarende kan filen pakkes ud med <command>tar xvf tfil.tar</command>.</entry></row>
<row><entry>compress</entry> <entry> Pakker filer ind/ud. Anvend
      <command>compress filnavn</command> til at pakke filen til <filename>
      filnavn.Z</filename>. Tilsvarende anvendes <command>uncompress</command> til at pakke ud.</entry></row>
<row><entry>gzip</entry> <entry> Andet og bedre pakke program, der
      anvender <filename>.gz</filename> som
      slutning af fil navn. Tilsvarende findes
      <command>gunzip</command> til at pakke ud.
      Normalt ses også filtypen <filename>.tgz</filename>,
      som er en <filename>tar</filename> fil, hvor der efterfølgende er anvendt
      <command>gzip</command>.
</entry></row>
<row><entry>diff</entry> <entry> Sammenligner to filer og rapporterer forskellene.
</entry></row>
<row><entry>free</entry> <entry> Viser, hvor meget hukommelse der er
      brugt, og der er til rådighed.
</entry></row>
<row><entry>df</entry> <entry> Viser, hvor meget diskplads der er
      brugt, og der er til rådighed
      på samtlige diske.
</entry></row>
<row><entry>du</entry> <entry> Viser status over, hvor meget diskplads
      der er brugt under det sted, hvor du står i filtræet.
</entry></row>
<row><entry>sort</entry> <entry> Sorterer en tekstfil.
</entry></row>

<row><entry>rsh</entry> <entry> <command>rsh henrik.kongehuset.dk
date</command> betyder, at du udfører kommandoen
<command>date</command> på maskinen
<command>henrik.kongehuset.dk</command>, dvs. en anden UNIX
maskine. Linux kan udføre kommandoer på andre maskiner og så vise
grafik (og tekst) på din egen maskine.  </entry></row>

</tbody>
</tgroup>
</table>
</para>
</sect1>
</appendix>

