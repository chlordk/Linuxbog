<!-- $Id$ -->
<chapter id="java-i18n">
<title>Internationale programmer</title>
<indexterm><primary>Internationalisering</primary></indexterm>
<indexterm><primary>Lokalisering</primary></indexterm>

<sect1 id="java-i18n-indledning">
<title>Indledning</title>

<para>
Java hjælper dig med at gøre dine programmer platformsuafhængige,
men hvad hvis de også skal være sproguafhængige? Når et program
skal anvendes af brugere med anden sproglig og kulturel baggrund
så opstår der behov for at programtekster, beløb og datoangivelser
afhænger af brugerens land, sprog og eventuelt andre faktorer.
</para>

<para>
En mulig måde at opnå sproguafhængighed på er at vedligeholde kildeteksten
til sit program i flere forskellige versioner, der hver især understøtter
et bestemt sprog. Man finder hurtigt ud af at denne løsningsmetode er
uholdbar i længden idet ændringer og opdateringer til programmet medfører
at samtlige versioner skal ændres. Ligeledes skal kildeteksten oversættes
hver eneste gang.
</para>

<para>
I stedet for at gøre livet træls for sig selv og benytte ovenstående
metode så kan man i stedet for vælge at benytte sig af de værktøjer, som JDK
stiller til rådighed. I den forbindelse er der to begreber, som du skal
være fortrolig med.
</para>

<itemizedlist mark="bullet">

<listitem><para>
<emphasis>Internationalisering</emphasis> er den proces, hvor du
laver et programdesign, som er sprogligt og kulturelt neutralt.
Al formatering og fortolkning af tal-, beløbs-, dato- og tidsangivelser
skal med andre ord være afhængigt af en række parametre, der på kørsels-
eller oversættelsestidspunktet bestemmer den konkrete sproglige og
kulturelle kontekst som programmet skal indgå i. Ligeledes skal
sproglige tekster og direkte stinavne til billeder adskilles fra
kildeteksten.
</para></listitem>

<listitem><para>
<emphasis>Lokalisering</emphasis> er den process, hvor du tilpasser
dit internationaliserede program så det imødekommer de sproglige og
kulturelle krav, der stilles af den givne målgruppe.
</para></listitem>

</itemizedlist>

<para>
Lyder det besværligt? Det er det ikke!
</para>

</sect1>

<sect1 id="java-i18n-locale">
<title>Lokalindstillinger</title>

<para>
I JDK anvendes objekter af typen <constant>java.util.Locale</constant>
til at angive brugerens sprog og geografiske region. Vi vil
kalde et konkret <constant>Locale</constant>-objekt for en
<emphasis>lokalindstilling</emphasis>. Klasser, der varierer deres
adfærd på baggrund af en lokalindstilling, vil vi kalde for
<emphasis>lokalafhængige</emphasis>.
</para>

<para>
Lokalindstillinger udfører intet i sig selv, men overgives til andre
lokalafhængige objekter, som udfører det egentlige arbejde, f.eks. at
formattere en beløbsstørrelse.
</para>

<sect2 id="java-i18n-locale-create">
<title>Oprettelse af en lokalindstilling</title>

<para>
En lokalindstilling kan konstrueres ved at angive sprog- og landekode, f.eks.
</para>

<programlisting>
Locale xLocale = new Locale("da", "DK");
</programlisting>

<para>
En lokalindstilling kan oprettes med et tredje, brugerdefineret argument.
Dette kan f.eks. signalere platform.
</para>

<programlisting>
Locale xLocale = new Locale("da", "DK", "UNIX");
Locale yLocale = new Locale("da", "DK", "WINDOWS");
</programlisting>

<para>
Det brugerdefineret argument har ingen speciel betydning i JDK.
Programmøren står selv for at bestemme betydningen af indholdet.
</para>

<para>
Det er også muligt at undlade landekoden ved at lade den være tom, men
sprogkoden er obligatorisk.
</para>

<programlisting>
Locale xLocale = new Locale("da", "");
</programlisting>

<para>
Som oftes er vi blot interesseret i at benytte en global lokalindstilling,
hvilket opnås ved at invokere en klassemetode på <constant>Locale</constant>:
</para>

<programlisting>
Locale currentLocale = Locale.getDefault();
</programlisting>

<para>
Dette objekt angiver den virtuelle maskines nuværende sprog- og
regionsindstillinger. Ved opstart af den virtuelle maskine
svarer denne lokalindstiling til brugerens indstillinger i
operativsystemet.
</para>

<para>
Det er muligt at ændre den globale lokalindstilling ved at kalde
klassemetoden <constant>Locale.setDefault(Locale aLocale)</constant>
men vær opmærksom på at <emphasis>alle</emphasis> programmer i den virtuelle
maskine vil blive berørt, da de lokalafhængige klasser anvender
den globale lokalindstilling i de situationer, hvor man ikke
explicit fortæller hvilken lokalindstilling, der skal anvendes.
</para>

<!--
<para>
Hvis dit program selv ønsker at styre valget af <constant>Locale</constant>-objekt,
f.eks. hvis det skal være flersproget, så gøres dette ved at invokere metoden
<constant>setLocale(aLocale)</constant>.
</para>
-->

</sect2>

<sect2 id="java-i18n-locale-available">
<title>Tilgængelige lokalindstillinger</title>

<para>
Man kan undersøge hvilke lokalindstillinger der er tilgængelige ved at læse
afsnittet om understøttede lokalindstillinger i JDK-dokumentationen.
</para>

<itemizedlist>
<listitem><para>
<ulink url="http://java.sun.com/j2se/1.3/docs/guide/intl/locale.doc.html">
http://java.sun.com/j2se/1.3/docs/guide/intl/locale.doc.html
</ulink>
</para></listitem>
</itemizedlist>

<para>
Det er også muligt at afgøre med
<constant>Locale.getAvailableLocales()</constant>.
</para>

<programlisting>
import java.util.Locale;

public class AvailableLocales
{
  public static void main(String[] args)
  {
    Locale[] l = Locale.getAvailableLocales();
    for (int i=0; i&lt;l.length; i++) System.out.print(l[i]+" ");
    System.out.println( );
  }
}
</programlisting>

<para>
Kørsel af ovenstående program giver en masse lokalindstillinger
</para>

<screen>
en en_US ar ar_AE ar_BH ar_DZ ar_EG ar_IQ ar_JO ar_KW ar_LB ar_LY ar_MA ar_OM
ar_QA ar_SA ar_SD ar_SY ar_TN ar_YE be be_BY bg bg_BG ca ca_ES ca_ES_EURO cs
cs_CZ da da_DK de de_AT de_AT_EURO de_CH de_DE de_DE_EURO de_LU de_LU_EURO el
el_GR en_AU en_CA en_GB en_IE en_IE_EURO en_NZ en_ZA es es_BO es_AR es_CL es_CO
es_CR es_DO es_EC es_ES es_ES_EURO es_GT es_HN es_MX es_NI et es_PA es_PE es_PR
es_PY es_SV es_UY es_VE et_EE fi fi_FI fi_FI_EURO fr fr_BE fr_BE_EURO fr_CA
fr_CH fr_FR fr_FR_EURO fr_LU fr_LU_EURO hr hr_HR hu hu_HU is is_IS it it_CH
it_IT it_IT_EURO iw iw_IL ja ja_JP ko ko_KR lt lt_LT lv lv_LV mk mk_MK nl nl_BE
nl_BE_EURO nl_NL nl_NL_EURO no no_NO no_NO_NY pl pl_PL pt pt_BR pt_PT pt_PT_EURO
ro ro_RO ru ru_RU sh sh_YU sk sk_SK sl sl_SI sq sq_AL sr sr_YU sv sv_SE th th_TH
tr tr_TR uk uk_UA zh zh_CN zh_HK zh_TW
</screen>

<para>
Som nævnt i sidste afsnit består en lokalindstilling af sprogkode, landekode og
valgfrit argument. Ud fra ovenstående ser vi at der f.eks. er lokalindstillinger for
</para>

<itemizedlist mark="bullet">
<listitem><para>
fr_BE: Fransk i Belgien
</para></listitem>
<listitem><para>
fr_BE_EURO: Fransk i Belgien med euro-valuta
</para></listitem>
<listitem><para>
fr_CA: Fransk i Canada
</para></listitem>
<listitem><para>
fr_FR: Fransk i Frankrig
</para></listitem>
<listitem><para>
fr_LU: Fransk i Louxembourg
</para></listitem>
</itemizedlist>

<para>
Sprog- og landekoderne er ISO-standarder, som kan findes på nettet.
</para>

<itemizedlist mark="bullet">
<listitem><para>Sprog, ISO-639
<ulink url="http://www.ics.uci.edu/pub/ietf/http/related/iso639.txt">
http://www.ics.uci.edu/pub/ietf/http/related/iso639.txt</ulink>
</para></listitem>
<listitem><para>Landekoder, ISO-3166
<ulink url="http://www.chemie.fu-berlin.de/diverse/doc/ISO_3166.html">
http://www.chemie.fu-berlin.de/diverse/doc/ISO_3166.html</ulink>
</para></listitem>
</itemizedlist>

<para>
Lad os nu se på hvordan lokalindstillinger kan anvendes.
</para>

</sect2>

</sect1>

<sect1 id="java-i18n-formatting-date">
<title>Formattering af datoer og klokkeslæt</title>

<para>
<constant>Date</constant>-objekter repræsenterer datoer og klokkeslæt.
Dette afsnit går i dybden med de lokalafhængige klasser
<constant>java.text.DateFormat</constant>,
<constant>java.text.DateFormatSymbols</constant> og
<constant>java.text.SimpleDateFormat</constant> som er velegnet
til at formattere <constant>Date</constant>-objekter.
</para>

<sect2 id="java-i18n-formatting-date-predefined">
<title>Prædefineret formater</title>

<para>
Klassen <constant>DateFormat</constant> indeholder en række statiske fabriksmetoder,
som returner specialiseret formatteringsobjekter. Seks af disse er
</para>

<screen>
getDateInstance(int style)
getDateInstance(int style, Locale aLocale)
getTimeInstance(int style)
getTimeInstance(int style, Locale aLocale)
getDateTimeInstance(int dateStyle, int timeStyle)
getDateTimeInstance(int dateStyle, int timeStyle, Locale aLocale)
</screen>

<para>
Metoderne tager imod en eller flere <constant>style</constant>-parametre, som
anvendes til at angive længden af formatteringsresultatet.
De mulige værdier er defineret som konstanter i <constant>DateFormat</constant>-klassen.
</para>

<itemizedlist>
<listitem><para>
<constant>SHORT</constant> forsøger at være numerisk og kort, f.eks. 12/11/01 og 2:31 AM
</para></listitem>
<listitem><para>
<constant>MEDIUM</constant> er længere, f.eks. Dec 11, 2001 og 2:31:35 AM
</para></listitem>
<listitem><para>
<constant>LONG</constant> er endnu længere, f.eks. December 11, 2001 og 2:31:35 AM CET
</para></listitem>
<listitem><para>
<constant>FULL</constant> er fuldstændig specificeret, f.eks. Tuesday, December 11, 2001 og 2:31:35 AM CET
</para></listitem>
<listitem><para>
<constant>DEFAULT</constant> svarer til <constant>DateFormat.MEDIUM</constant>.
</para></listitem>
</itemizedlist>

<para>
Det præcise resultat afhænger af lokalindstillingen. Det var med vilje at der
ikke blev brugt en dansk lokalindstilling i ovenstående eksempler, for i så
fald ville der ikke være nogen synlig forskel på brugen af LONG og FULL.
</para>

<para>
Her er et simpelt eksempel, der viser brugen af <constant>DateFormat</constant>
med den globale lokalindstilling.
</para>

<screen>
import java.text.*;
import java.util.*;

public class DateFormatExample
{
  public static void main(String arg[])
  {
    DateFormat klformat, datoformat, dkf;
    klformat   = DateFormat.getTimeInstance(DateFormat.MEDIUM);
    datoformat = DateFormat.getDateInstance(DateFormat.FULL);
    dkf = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT);

    Date tid = new Date();
    System.out.println( tid );
    System.out.println( "Kl   :"+ klformat.format(tid) );
    System.out.println( "Dato :"+ datoformat.format(tid) );
    System.out.println( "Tid  :"+ dkf.format(tid) );
  }
}
</screen>

<para>
Kørsel af ovenstående program med dansk lokalindstilling (da_DK) giver
</para>

<screen>
Mon Dec 03 13:28:06 GMT+01:00 2001
Kl:   13:28:06
Dato: 3. december 2001
Tid:  03-12-2001 13:28
</screen>

<para>
Hvis lokalindstillingen er amerikansk (en_US) så fås imidlertid
</para>

<screen>
Mon Dec 03 13:27:57 GMT+01:00 2001
Kl:   1:27:57 PM
Dato: Monday, December 3, 2001
Tid:  Dec 3, 2001 1:27 PM
</screen>

<para>
Læg i øvrigt mærke til at <constant>Date</constant>-objektets
<constant>toString()</constant>-metode ikke er lokaliseret. Den bør kun bruges til
testudskrifter og logning, og ikke i tekst som brugeren skal læse (med mindre du
bevidst ønsker at irritere ham/hende). 
</para>

</sect2>

<sect2 id="java-i18n-formatting-date-customizing">
<title>Egne formater</title>

<para>
Ønsker man som programmør fuld kontrol over hvordan datoen bliver formatteret
så må man selv specificere formatet med <constant>SimpleDateFormat</constant>.
</para>

<para>
Lad os starte ud med et eksempel.
</para>

<screen>
import java.text.*;
import java.util.*;

public class BenytSimpleDateFormat
{
  public static void main(String arg[])
  {
     DateFormat df = new SimpleDateFormat("EEEE 'den' d. MMMM 'år' yyyy.");

     Date tid = new Date();
     System.out.println( df.format(tid) );
  }
}
</screen>

<note><title>Kort sidebemærkning</title>
<para>
Den opmærksomme læser har måske opdaget at vi har begået en brøler i ovenstående
eksempel. Mønsteret indholder nemlig sprogspecifikke tekster! Senere i dette
kapitel ser vi på, hvordan brøleren kan løses ved at lægge de sprogspecifikke
tekster ud i ressourcefiler.
</para>
</note>

<para>
Kørsel af ovenstående program med dansk lokalindstilling giver 
</para>

<screen>
mandag den 10. december år 2001.
</screen>

<para>
En tilsvarende kørsel af programmet med amerikansk lokalindstilling giver 
</para>

<screen>
Monday den 10. December ?r 2001.
</screen>

<para>
Ud fra eksemplet ses at formatteringsresultatet afhænger af
to faktorer: lokalindstillingen samt mønsteret angivet til klassens konstruktør.
</para>

<para>
TODO...lav tabel over Date Format Pattern Syntax
</para>

</sect2>

<sect2 id="java-i18n-formatting-date-parsing">
<title>Fortolkning af brugerindtastninger</title>

<para>
TODO...om at parse datoer og klokkeslæt.
</para>

</sect2>

</sect1>

<sect1 id="java-i18n-currency-formatting">
<title>Formattering af tal og beløb</title>

<para>
TODO
</para>

</sect1>

<sect1 id="java-i18n-internationalization">
<title>Internationalisering</title>

<para>
TODO
</para>

<itemizedlist mark="bullet">
<listitem><para>Tekster</para></listitem>
<listitem><para>Hjælpefiler</para></listitem>
<listitem><para>Lyd</para></listitem>
<listitem><para>Farver</para></listitem>
<listitem><para>Billeder</para></listitem>
<listitem><para>Ikoner</para></listitem>
<listitem><para>Datoer</para></listitem>
<listitem><para>Tidspunkter</para></listitem>
<listitem><para>Tal</para></listitem>
<listitem><para>Valuta</para></listitem>
<listitem><para>Telefonnumre</para></listitem>
<listitem><para>Titelbetegnelser</para></listitem>
<listitem><para>Postnumre</para></listitem>
<listitem><para>Sidelayout </para></listitem>
</itemizedlist>

</sect1>

<sect1 id="java-i18n-property-resource-bundle">
<title>PropertyResourceBundle</title>

<para>
TODO
</para>

</sect1>

<sect1 id="java-i18n-list-resource-bundle">
<title>ListResourceBundle</title>

<para>
TODO
</para>

</sect1>

<sect1 id="java-i18n-parameterized-messages">
<title>Parametriserede beskeder</title>

<para>
TODO
</para>

</sect1>

<sect1 id="java-i18n-working-with-text">
<title>Tekster og tegn</title>

<para>
Java tilbyder klasser til at
</para>

<itemizedlist>
<listitem><para>
Analysere tegn
</para></listitem>
<listitem><para>
Sammenligne strenge
</para></listitem>
<listitem><para>
Finde text boundaries i sætninger
</para></listitem>
<listitem><para>
Konvertere non-unicode tekst
</para></listitem>
</itemizedlist>

<sect2 id="java-i18n-working-with-text-character">
<title>Analyse af tegn</title>

<screen>
Følgende kode duer ikke:
char ch;

if ((ch >= 'a' && ch &lt;= 'z') || (ch >= 'A' && ch &lt;= 'Z'))
	//ch is a letter

if (ch >= '0' && ch &lt;= '9') 
	//ch is a digit

if (ch == ' ' || ch == '\n' || ch == '\t') 
	//ch is a whitespace

Benyt altid metoderne på klassen Character:
isDigit
isLetter
isLetterOrDigit
isLowerCase / isUpperCase
isSpaceChar
isDefined
</screen>

</sect2>

<sect2 id="java-i18n-working-with-text-comparison">
<title>Sammenligning af strenge</title>

<screen>
Sikker sammenligning af strenge gøres vha. metoden compare() på klasssen Collator.

Sammenligning kan ikke gøres sikkert med String.compareTo(), idet den sammenligner binært på Unicode-niveau, hvilket ikke altid stemmer overens med et sprogs tegn-orden.

Således opnås en instans af Collator for en given Locale:
Collator myCol = Collator.getInstance(aLocale);

To strenge sammenlignes således:
myCol.compare(firstString, secondString);

compare() returnerer -1, 0 el. 1, afhængig af om firstString er hhv. mindre end, lig med el. større end secondString.
</screen>

</sect2>

<sect2 id="java-i18n-working-with-text-break">
<title>Analyse af grænser i tekst</title>

<screen>
Klassen BreakIterator gør det muligt at finde grænser (boundaries) i form af positionsnumre i en tekst for en given Locale på følgende niveauer:
tegn
ord
sætning
linie

Ved instantieringen af BreakIterator invokeres én af følgende klassemetoder til at konstruere instansen med den ønskede egenskab:
getCharacterInstance
getWordInstance
getSentenceInstance
getLineInstance
Eksempel:

BreakIterator bi = BreakIterator.getWordInstance(aLocale);
</screen>

</sect2>

</sect1>

</chapter>
