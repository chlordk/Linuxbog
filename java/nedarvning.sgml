<chapter id="java-arv">
  <title>Nedarvning</title>
<para>
Kapitlet forudsættes af resten af bogen.
</para>

<para>
Forudsætter <xref linkend="java-klasser" />, Definition af klasser.
</para>

<para>
I dette kapitel vil vi se på, hvordan man kan genbruge
programkode ved at tage en eksisterende klasse og udbygge den
med flere metoder og variabler (nedarvning).
</para>

<sect1 id="java-arv-udb">
  <title>At udbygge eksisterende klasser</title>

<para>
Hvad gør man, hvis man ønsker en klasse, der ligner
en eksisterende klasse, men alligevel ikke helt er den samme?
</para>

<para>
Svaret er: Man kan definere
underklasser, der <emphasis>arver</emphasis> (genbruger en del af koden) fra en
anden klasse og kun definerer den ekstra kode, der skal
til for at definere underklassen i forhold til stamklassen
(kaldet superklassen).
</para>

<para>
Arv er et meget vigtigt element i objektorienterede sprog. Med
nedarvning kan man have en hel samling af klasser, der ligner
hinanden på visse punkter, men som er forskellige på
andre punkter.
</para>

<sect2 id="java-arv-udb-fake-dice">
  <title>Eksempel: En falsk terning</title>

<para>
Hvis man vil snyde i terningspil, findes der et kendt trick: Bruge
sine egne terninger, hvor man har boret 1'er-sidens hul ud, kommet
bly i hullet og malet det pænt over, så det ikke kan ses.
Sådan en terning vil have meget lille sandsynlighed for at få
en 1-er og en ret stor sandsynlighed for at få en 6'er.
</para>

<para>
Herunder har vi lavet en nedarvning fra Terning til en ny klasse,
FalskTerning, ved at starte erklæringen med:
</para>

<screen>
public class FalskTerning extends Terning
</screen>


<para>
Vi har automatisk overtaget (arvet) alle metoder og variabler fra
Terning-klassen fordi vi skriver &quot;extends Terning&quot;. Dvs. at
et FalskTerning1-objekt også har en værdi-variabel og en
toString()-metode.
</para>

<para>
Vi ændrer nu klassens opførsel ved at definere en
anden udgave af kast()-metoden:
</para>

<screen>
<emphasis>// En Terning-klasse for falske terninger.</emphasis>

public class FalskTerning1 <emphasis>extends Terning</emphasis>
{
  <emphasis>// tilsidesæt kast med en &quot;bedre&quot; udgave</emphasis>
<emphasis>  public void kast()</emphasis>
  {
    <emphasis>// udskriv så vi kan se at metoden bliver kaldt</emphasis>
    System.out.print(&quot;[kast() på FalskTerning1] &quot;);

    værdi = (int) (6*Math.random() + 1);

<emphasis>    // er det 1 eller 2? Så lav det om til 6!</emphasis>
    if ( værdi &lt;= 2 ) værdi = 6;
  }
}
</screen>


<para>
I klassediagrammet er underklassen vist med en hul pil fra
FalskTerning1 til Terning.
</para>

<para>
Dette kaldes også en <emphasis>er-en</emphasis>-relation; FalskTerning1 <emphasis>er
en</emphasis> Terning, da den jo har alle de egenskaber en terning har.
</para>

<para>
Kort sagt:
</para>

<blockquote><para>En klasse kan arve variabler og
metoder fra en anden klasse</para></blockquote>
<blockquote><para>Klassen, der nedarves fra, kaldes
superklassen</para></blockquote>
<blockquote><para>Klassen, der arver fra superklassen,
kaldes underklassen</para></blockquote>
<blockquote><para>Underklassen kan tilsidesætte
(omdefinere) metoder arvet fra superklassen ved at definere dem
igen</para></blockquote>

<para>
Andre steder i litteraturen er der brugt talrige betegnelser for
superklasse og underklasse. Her er et udpluk:
</para>

<figure id="java-arv-super-sub-fig">
<title>Java</title>

<graphic fileref="Nordfalk715402.&magic;" scale="60"></graphic>
</figure>

<para>
<emphasis>Superklasse</emphasis> kaldes også: Baseklasse, basisklasse,
forældreklasse, stamklasse.
</para>

<para>
<emphasis>Underklasse</emphasis> kaldes også: Afledt klasse, nedarvet
klasse, barn, subklasse.
</para>

<para>
I vores eksempel er superklassen Terning og underklassen
FalskTerning1.
</para>

<para>
I det følgende program kastes med to terninger, en rigtig
og en falsk:
</para>

<screen>
public class Snydespil1
{
  public static void main(String[] args)
  {
    Terning t1 = new Terning();
    FalskTerning1 <emphasis>t2 = new FalskTerning1()</emphasis>;

    System.out.println(&quot;t1: &quot;+t1); <emphasis>// kunne også kalde t1.toString()</emphasis>
    System.out.println(&quot;t2: &quot;+t2);

    for (int i=0; i&lt;5; i++)
    {
      t1.kast();
<emphasis>      t2.kast();</emphasis>
      System.out.println(&quot;t1=&quot; + t1 + &quot;  t2=&quot; + t2);
      if (t1.værdi == <emphasis>t2.værdi</emphasis>) System.out.println(&quot;To ens!&quot;);
    }
  }
}
</screen>

<para>Resultatet bliver:</para>

<screen>
[kast() på FalskTerning1] t1: 1
t2: 3
[kast() på FalskTerning1] t1=1  t2=5
[kast() på FalskTerning1] t1=1  t2=3
[kast() på FalskTerning1] t1=4  t2=3
[kast() på FalskTerning1] t1=6  t2=6
To ens!
[kast() på FalskTerning1] t1=2  t2=6
</screen>


<para>
Vi kan altså bruge FalskTerning1-objekter på præcis
samme måde som Terning-objekter.
</para>
</sect2>    <!--   Eksempel: En falsk terning -->

<sect2 id="java-arv-udb-extra">
  <title>At udbygge med flere metoder og variabler</title>

<para>
Lad os nu se på et eksempel, hvor vi definerer nogle
variabler og metoder i nedarvingen.
</para>

<figure id="java-arv-fake-dice-fig">
<title>Java</title>

<graphic fileref="Nordfalk715403.&magic;" scale="60"></graphic>
</figure>

<screen>
public class FalskTerning2 <emphasis>extends Terning</emphasis>
{
<emphasis>  public int snydeværdi;</emphasis>

<emphasis>  public void sætSnydeværdi(int nySnydeværdi)</emphasis>
  {
    snydeværdi = nySnydeværdi;
  }

<emphasis>  public void kast()</emphasis>
  {
    System.out.print(&quot;[kast() på FalskTerning2] &quot;);

    værdi = (int) (6*Math.random() + 1);

    <emphasis>// 1 eller 2? Så lav det om til snydeværdi!</emphasis>
    if ( værdi &lt;= 2 ) værdi = snydeværdi;
  }
}
</screen>


<para>
FalskTerning2 har fået en ekstra variabel, snydeværdi,
og en ekstra metode, sætSnydeværdi(),
der sætter snydeværdi til noget andet.
</para>

<screen>
public class Snydespil2
{
  public static void main(String[] args)
  {
    FalskTerning2 t1 = new FalskTerning2();
    t1.sætSnydeværdi(4);

    for (int i=0; i&lt;5; i++)
    {
      t1.kast();
      System.out.println(&quot;t1=&quot; + t1);
    }
  }
}
</screen>

<para>Resultatet bliver:</para>

<screen>
[kast() på FalskTerning2] [kast() på FalskTerning2] t1=4
[kast() på FalskTerning2] t1=4
[kast() på FalskTerning2] t1=6
[kast() på FalskTerning2] t1=6
[kast() på FalskTerning2] t1=4
</screen>
</sect2>    <!--   At udbygge med flere metoder og variabler -->

<sect2 id="java-arv-udb-super">
  <title>Nøgleordet super</title>

<para>
Nogen gange ønsker man i en nedarvet klasse at få
adgang til superklassens metoder, selvom de måske er blevet
tilsidesat med en ny definition i nedarvingen. F.eks. kunne det være
rart, hvis vi kunne genbruge den oprindelige kast()-metode i
FalskTerning.
</para>

<para>
Med <emphasis>super</emphasis> refererer man til de metoder, der er kendt for
superklassen. Dermed kan vi skrive en smartere udgave af
FalskTerning:
</para>

<screen>
public class FalskTerning3 <emphasis>extends Terning</emphasis>
{
  <emphasis>// tilsidesæt kast med en &quot;bedre&quot; udgave</emphasis>
  public void kast ()
  {
    <emphasis>super.kast()</emphasis>; <emphasis>// kald den oprindelige kast-metode</emphasis>

    <emphasis>// blev det 1 eller 2? Så lav det om til en 6'er!</emphasis>
    if ( værdi &lt;= 2 ) værdi = 6;
  }
}
</screen>


<para>
super.kast() kalder kast()-metoden i superklassen. Derefter tager
vi højde for, at det er en falsk terning.
</para>
</sect2>    <!--   Nøgleordet super -->
</sect1>    <!--   At udbygge eksisterende klasser -->

<sect1 id="java-arv-poly">
  <title>Polymorfe variabler</title>

<figure id="java-arv-fake-game-fig">
<title>Snydespil2MedPolymorfiefter
  punkt A</title>

<graphic fileref="Nordfalk715404.&magic;" scale="60"></graphic>
</figure>

<para>
Se på følgende eksempel:
</para>

<screen>
public class Snydespil2medPolymorfi
{
  public static void main(String[] args)
  {
    FalskTerning2 ft = new FalskTerning2();
    ft.sætSnydeværdi(4);

    Terning t;
<emphasis>    t = ft;</emphasis>
                                       <emphasis>// punkt A</emphasis>
    for (int i=0; i&lt;3; i++)
    {
      t.kast();
      System.out.println(&quot;t=&quot; + t);
    }
  }
}
</screen>

<para>Resultatet bliver:</para>

<screen>
[kast() på FalskTerning2] [kast() på FalskTerning2] t=4
[kast() på FalskTerning2] t=6
[kast() på FalskTerning2] t=6
</screen>


<para>
Hov: Terning-variablen t refererer nu pludselig til et
FalskTerning2-objekt ?!
</para>

<screen>
    t = ft;
</screen>


<para>
Der er altså ikke overensstemmelse mellem typen på
venstre side (Terning) og typen på højre side
(FalskTerning2) .
</para>

<para>
Jamen, hvad så med typesikkerheden ?
</para>

<sect2 id="java-arv-poly-disp">
  <title>Dispensation fra traditionel typesikkerhed</title>

<para>
Typesikkerhed gør, at man ikke f.eks. kan tildele et
Point-objekt til en Terning-variabel uden at få en sprogfejl
under oversættelsen.
</para>

<para>
Hvis man kunne det, ville programmerne kunne indeholde mange fejl,
der var svære at finde. Hvis man f.eks. et eller andet sted i
et kæmpeprogram havde sat en Terning-variabel til at
referere til et Point-objekt, og det var tilladt, hvad skulle der så
ske, når man så (måske langt senere i en anden del
af programmet) forsøgte at kalde dette objekts kast()-metode?
Et Point-objekt har jo ingen kast()-metode. Det kunne blive meget
svært at finde ud af, hvor den forkerte tildeling fandt sted.
Sagt med andre ord: Normalt skal vi være lykkelige for, at Java
har denne regel om typesikkerhed.
</para>

<para>
Der er imidlertid en meget fornuftig dispensation fra denne regel:
</para>

<blockquote><para>En variabel kan referere til objekter
af en underklasse af variablens type</para></blockquote>

<para>
t-variablen har ikke ændret type (det kan variabler ikke),
men den peger nu på et objekt af typen FalskTerning2. Men dette
objekt har jo alle metoder og data, som et Terning-objekt har, så
vi kan ikke få kaldt ikke-eksisterende metoder, hvis vi bare
&quot;lader som om&quot;, den peger på et Terning-objekt. At
FalskTerning2-objektet også har en objektvariabel, snydeværdi,
og en ekstra metode, kan vi være ligeglade med. Variablen
bruger den bare ikke.
</para>

<para>
Dispensationen giver altså mening, fordi en nedarving
(f.eks. et FalskTerning2-objekt) set udefra kan lade, som om det også
er af superklassens type (et Terning-objekt). Udefra har det jo
<emphasis>mindst</emphasis> de samme objektvariabler og metoder, da det har arvet
dem.
</para>

<para>
Selvom t1 refererer til et FalskTerning2-objekt, kan man kun bruge
t-variablen til at kalde metoder eller anvende variabler i objektet,
som stammer fra Terning-klassen:
</para>

<screen>
  t.snydeværdi=4;    <emphasis>// sprogfejl: snydeværdi er ikke defineret i Terning</emphasis>
  t.sætSnydeværdi(4);<emphasis>// sprogfejl: sætSnydeværdi() er ikke defineret i Terning</emphasis>
</screen>
</sect2>    <!--   Dispensation fra traditionel typesikkerhed -->

<sect2 id="java-arv-poly-poly">
  <title>Polymorfi</title>

<para>
En anden meget væsentlig detalje omkring denne dispensation
er, at det er <emphasis>objektets</emphasis> type, ikke variablens, der bestemmer,
hvilken metodekrop der bliver udført, når vi kalder
en metode:
</para>

<screen>
  t.kast();  <emphasis>// kalder FalskTerning2's kast, </emphasis>
<emphasis>            // fordi t peger på et FalskTerning2-objekt.</emphasis>
</screen>


<para>
Herover kalder vi altså den kast()-metode, der findes i
FalskTerning2-klassen. Den kigger således ikke på
variablen t's type (så ville den jo udføre Ternings
kast() ).
</para>

<blockquote><para>Variablens type bestemmer, hvilke
metoder man kan kalde på objektet, og hvilke objektvariabler
man kan læse og ændre</para></blockquote>
<blockquote><para>Objektets type bestemmer, hvilken
metode-definition der bliver udført</para></blockquote>

<para>
Af samme grund kaldes det at definere en metode, som allerede
findes, fordi den er arvet, for <emphasis>tilsidesættelse</emphasis>
(eng.: override)
af metoden. Man <emphasis>tilsidesætter</emphasis>
metodens opførsel med en anden opførsel.
</para>

<blockquote><para>For at tilsidesætte en metode
skal man i underklassen lave en eksakt kopi af metode-hovedet fra
superklassen</para></blockquote>
</sect2>    <!--   Polymorfi -->

<sect2 id="java-arv-poly-eks">
  <title>Et eksempel på
polymorfi: Brug af Raflebaeger</title>
<screen>
public class SnydeMedBaeger
{
  public static void main(String[] args)
  {
    Raflebaeger bæger = new Raflebaeger(0);

    <emphasis>FalskTerning2 ft</emphasis> = new FalskTerning2();
    ft.sætSnydeværdi(6);

    <emphasis>bæger.tilføj(ft)</emphasis>;   <emphasis>// tilføj() tager et objekt af typen Terning,</emphasis>
<emphasis>                        // og dermed også af typen FalskTerning2.</emphasis>

    <emphasis>Terning t</emphasis> = new Terning();
    <emphasis>bæger.tilføj(t)</emphasis>;

    ft = new FalskTerning2();
    ft.snydeværdi=6;
    <emphasis>t=ft</emphasis>;               <emphasis>// t bruges som mellemvariabel for sjov.</emphasis>
    <emphasis>bæger.tilføj(t)</emphasis>;

    for (int i=1; i&lt;10; i++)
    {
      bæger.ryst();
    }
  }
}
</screen>


<para>
I SnydeMedBaeger kaldes
Raflebaeger's ryst()-metode. Hvis du nu kigger i definitionen af
dennes ryst()-metode (se afsnit <xref linkend="java-klasser-rela" />), kan du se, at den kalder
kast()-metoden på de enkelte objekter i
&quot;terninger&quot;-vektoren:
</para>

<screen>
  public void ryst()
  {
    int i;
    for (i=0;i&lt;terninger.size();i++) 
    {
      Terning t;
      t=(Terning) terninger.elementAt(i);
      t.kast();
    }
  }
</screen>


<para>
Da to af objekterne, vi har lagt
ind i bægeret, er af typen FalskTerning2, vil Raflebaeger's
ryst()-metode, når den kommer til et objekt af denne type,
kalde FalskTerning2's kast() helt automatisk. Resultatet er altså
at vi får større sandsynlighed for at få seksere.
</para>

<para>
Faktisk har vi ændret den
måde, et Raflebaeger-objekt opfører sig på helt
uden at ændre i Raflebaeger-klassen! Raflebaeger ved ikke noget
om FalskTerning2, men kan alligevel bruge den.
</para>

<para>
En programmør kan altså
lave en Raflebaeger-klasse, som kan alt muligt smart: Kaste
terninger, se hvor mange ens der er, tælle summen af
øjnene, se om der er en stigende følge (eng.:
straight) osv. Når en anden programmør vil lave en ny
slags terning (f.eks. en snydeterning), behøver han ikke
sætte sig ind i, hvordan Raflebaeger-klassen virker og lave
tilpasninger af den, for at den kan bruges sammen med hans egen nye
slags terning.
</para>
</sect2>    <!--   Et eksempel på
polymorfi: Brug af Raflebaeger -->

<sect2 id="java-arv-poly-polymorf">
  <title>Hvilken vej er en variabel polymorf ?</title>

<para>
Når følgende er muligt:
</para>

<screen>
    Terning t;
    FalskTerning2 ft;

    ft = new FalskTerning2();
    t = ft;
</screen>


<para>
Hvad så med det omvendte? Kan man tildele en
FalskTerning2-variabel en reference til et objekt af typen Terning?
</para>

<figure id="java-arv-fake-dice2-fig">
<title>Efter punkt A(programmet vil ikke oversætte)</title>

<graphic fileref="Nordfalk715405.&magic;" scale="60"></graphic>
</figure>

<para>
Svaret er: Nej!
</para>

<para>
Det er jo typen af ft (FalskTerning2), der bestemmer, hvilke
metoder og variabler vi kan bruge med ft. Dvs. vi ville kunne skrive:
</para>

<screen>
    t = new Terning();
    ft = t;                <emphasis>// sprogfejl</emphasis>
                           <emphasis>// punkt A</emphasis>
    ft.snydeværdi = 2;
</screen>


<para>
Hvis den sidste sætning kunne udføres, ville det være
uheldigt: Terning-objektet som ft refererer til, har jo ingen
snydeværdi.
</para>

<para>
Det er altså et brud på typesikkerhedsreglen, og Java
tillader det derfor ikke.
</para>

<para>
Bemærk, at her, som i andre sammenhænge, kigger Java
kun på en linje af gangen. F.eks. giver nedenstående
stadig en sprogfejl, selvom det i princippet kunne lade sig gøre:
</para>

<screen>
    t = new FalskTerning2();
    ft = t;                 <emphasis>// sprogfejl</emphasis>
    ft.snydeværdi = 2;
</screen>


<para>
Her refererer ft i sidste linje til et rigtigt
FalskTerning2-objekt, og den sidste linje ville derfor give
mening, men programmet kan ikke oversættes, fordi
typesikkerhedsreglen med dispensation ikke er opfyldt i linje 2.
</para>
</sect2>    <!--   Hvilken vej er en variabel polymorf ? -->

<sect2 id="java-arv-poly-ref">
  <title>Reference-typekonvertering</title>

<para>
Dispensationen i typesikkerhedsreglen svarer til den implicitte
værditypekonvertering: Ved konvertering fra int til double
behøver programmøren ikke angive eksplicit, at denne
værdi skal <emphasis>forsøges</emphasis>
konverteret. Når en typekonvertering med garanti giver det
ønskede, laver Java den implicit.
</para>

<para>
I foregående eksempel så
vi noget, der burde gå godt, men hvor Javas typeregel
forhindrer oversættelse. Her kan vi bruge explicit
reference-typekonvertering:
</para>

<figure id="java-arv-poly-fig">
<title>Efter punkt A</title>

<graphic fileref="Nordfalk715406.&magic;" scale="60"></graphic>
</figure>

<screen>
  Terning t;
  FalskTerning2 ft;

  t = new FalskTerning2();
  ft = (FalskTerning2) t; <emphasis>// OK, men muligvis</emphasis>
                          <emphasis>// køretidsfejl</emphasis>

                          <emphasis>// punkt A</emphasis>
  ft.snydeværdi = 2;
</screen>


<para>
Det ligner en almindelig eksplicit værditypekonvertering
(eng.:&nbsp;cast), og Javas betegnelse for det er også det
samme.
</para>

<para>
Når vi læser objekter i en vektor, er det faktisk det,
der sker.
</para>

<para>
I&nbsp;Raflebaeger's ryst()-metode skrev vi:
</para>

<screen>
  Terning t;
  t = (Terning) terninger.elementAt(i);
  t.kast();
</screen>


<para>
I en vektor kan gemmes alle typer objekter. For at kunne lægge
noget fra en vektor ned i en Terning-variabel er det derfor
nødvendigt at lave en reference-typekonvertering til Terning.
Dette går fint, så længe man har stoppet Terning-
eller FalskTerning2-objekter i vektoren, men man kan jo putte hvad
som helst i en vektor...
</para>

<para>
Hvis reference-typekonverteringen går galt (det opdages
først under programudførelsen), kommer der en
køretidsfejl (undtagelsen ClassCastException opstår), og
programmet stopper.
</para>

<para>
Der er dog nogle tilfælde, hvor Java, selv når man har
lavet en reference-typekonvertering, kan opdage en uheldig
konvertering. Hvis de to klasser, der forsøges at konverteres
imellem, ikke arver fra hinanden, får man en sprogfejl på
oversættertidspunktet.
</para>

<screen>
  Terning t;
  t = new Terning();
  Point p;
  p= (Point) t;         <emphasis>// Sprogfejl: Point og Terning er urelaterede</emphasis>
</screen>
</sect2>
</sect1>

<sect1 id="java-arv-poly-ref-matador">
<title>Eksempel: Et matador-spil</title>

<para>
Med arv kan man skabe et hierarki af klasser, der ligner hinanden
(fordi de har alle fællestrækkene fra superklassen)
og samtidig kan opføre sig forskelligt (polymorfi).
</para>

<para>
Her er vist klassediagrammet fra et matadorspil. Det er en skitse,
et rigtigt matadorspil ville indeholde flere detaljer.
</para>

<figure id="java-arv-poly-ref-fig">
<title>Java</title>

<graphic fileref="Nordfalk715408.&magic;" scale="60"></graphic>
</figure>

<para>
&Oslash;verst har vi klassen Felt, som indeholder fællestrækkene
for alle matadorspillets felter. F.eks. skal alle felter kunne
håndtere, at spilleren lander på eller passerer feltet.
Vi forestiller os, at metoderne landet() og passeret() bliver
kaldt af en anden del af programmet, når en spillers brik
henholdsvis lander på eller passerer feltet. I Felt-klassen er
metoderne defineret til ikke at gøre noget. Alle felter
har også et navn, f.eks &quot;Hvidovrevej&quot;.
</para>

<screen>
<emphasis>// Superklassen for alle matadorspillets felter</emphasis>

<emphasis>public class Felt</emphasis>
{
<emphasis>  String navn;</emphasis>

  <emphasis>public void passeret(Spiller sp)</emphasis> <emphasis>// kaldes når en spiller passerer dette felt</emphasis>
  {
    System.out.println(sp.navn+&quot; passerer &quot;+navn);
  }

  <emphasis>public void landet(Spiller sp) </emphasis>  <emphasis>// kaldes når en spiller lander på dette felt</emphasis>
  {
  }
}
</screen>


<para>Læg mærke til, at der er forskel mellem sp.navn
(spillerens navn) og navn (Felt-objektets navn).
</para>

<para>
Under Felt har vi klasserne Helle, Start, Rederi og Gade, der
indeholder data og programkode, der er specifik for de
forskellige slags felter i matadorspillet. De arver alle fra Felt og
er derfor tegnet med en <emphasis>er-en</emphasis>-relation
til Felt.
</para>

<para>
Klassen Helle er simpel; den skal lægge 15000 kr. til
spillerens kassebeholdning, hvis spilleren lander på
feltet. Dette gøres ved at tilsidesætte den nedarvede
passeret()-metode med en, der overfører penge til spilleren.
</para>

<screen>
<emphasis>// Helle. Hvis man lander her får man en gevinst.</emphasis>

<emphasis>public class Helle extends Felt</emphasis>
{
<emphasis>  double gevinst;</emphasis>

  public Helle (int gevinst)
  {
    navn=&quot;Helle&quot;;                   <emphasis>// navn er arvet fra Felt</emphasis>
    this.gevinst=gevinst;
  }

  <emphasis>public void landet(Spiller sp)</emphasis>    <emphasis>// tilsidesæt metode i Felt</emphasis>
  {
    System.out.println(sp.navn+&quot; lander på helle, og får overført &quot;+gevinst);
    sp.transaktion(gevinst);        <emphasis>// opdater spillers konto</emphasis>
    System.out.println(sp.navn+&quot;s konto lyder nu på &quot;+sp.konto);
  }
}
</screen>


<para>I konstruktøren sætter vi feltets navn. Gevinsten ved at
lande her er en parameter til konstruktøren. Metodekaldet
sp.transaktion(gevinst) beder spiller-objektet om at føje
gevinsten til kontoen.
</para>

<para>
Klassen Start skal overføre 5000 kr. til spilleren, der
passerer eller lander på feltet. Dette gøres ved at
tilsidesætte både landet() og passeret().
</para>

<screen>
<emphasis>// Startfeltet</emphasis>

<emphasis>public class Start extends Felt</emphasis>
{
<emphasis>  double gevinst;</emphasis>

  public Start(double gevinst)
  {
    navn=&quot;Start&quot;;
    this.gevinst=gevinst;
  }

<emphasis>  public void passeret(Spiller sp)</emphasis>                 <emphasis>// tilsidesæt metode i Felt</emphasis>
  {
    System.out.println(sp.navn+&quot; passerer start og modtager &quot;+gevinst);
    sp.transaktion(gevinst);                       // kredit/debit af konto
    System.out.println(sp.navn+&quot;s konto lyder nu på &quot;+sp.konto);
  }

<emphasis>  public void landet(Spiller sp)</emphasis>                   <emphasis>// tilsidesæt metode i Felt</emphasis>
  {
    System.out.println(sp.navn+&quot; lander på start og modtager &quot;+gevinst);
    sp.transaktion(gevinst);
    System.out.println(sp.navn+&quot;s konto lyder nu på &quot;+sp.konto);
  }
}
</screen>


<para>
Nu kommer vi til felter, der kan ejes af en spiller, nemlig
rederier og gader. De har en ejer-variabel, der refererer til en
Spiller (og er derfor tegnet med en <emphasis>har-en</emphasis>-relation
til klassen Spiller), en pris og en leje for at lande på
grunden.
</para>

<screen>
<emphasis>// Rederier</emphasis>

<emphasis>public class Rederi extends Felt</emphasis>
{
<emphasis>  Spiller ejer;</emphasis>
<emphasis>  double pris;</emphasis>
<emphasis>  double grundleje;</emphasis>

  public Rederi(String navn, double pris, double leje)
  {
    this.navn = navn;
    this.pris = pris;
    this.grundleje = leje;
  }

<emphasis>  public void landet(Spiller sp)</emphasis>
  {
    System.out.println(sp.navn+&quot; er landet på &quot;+navn);
    <emphasis>if (sp==ejer)</emphasis>
    {                                       <emphasis>// spiller ejer selv grunden</emphasis>
      System.out.println(&quot;Dette er &quot;+sp.navn+&quot;s egen grund&quot;);
    }
    <emphasis>else if (ejer==null)</emphasis>
    {                                       <emphasis>// ingen ejer grunden, så køb den</emphasis>
      if (sp.konto &gt; pris)
      {
        System.out.println(sp.navn+&quot; køber &quot;+navn+&quot; for &quot;+pris);
        <emphasis>ejer=sp</emphasis>;
        sp.transaktion( -pris );
      }
      else System.out.println(sp.navn+&quot; har ikke penge nok til at købe &quot;+navn);
    }
    <emphasis>else</emphasis>
    {                                       <emphasis>// feltet ejes af anden spiller</emphasis>
      System.out.println(&quot;Husleje: &quot;+grundleje);
      <emphasis>sp.betal(ejer, grundleje)</emphasis>;            <emphasis>// spiller betaler til ejeren</emphasis>
    }
  }
}
</screen>


<para>Når en spiller lander på et rederi, skal der overføres
penge fra spilleren til ejeren af grunden. Dette gøres
ved at tilsidesætte den nedarvede landet()-metode med en, der
overfører beløbet mellem parterne. Først tjekkes
om spilleren er den samme som ejeren (sp==ejer). Hvis dette ikke er
tilfældet, tjekkes om der ingen ejer er (ejer==null), og hvis
der ikke er, kan spilleren købe grunden (ejer sættes lig
spilleren). Ellers beordres spilleren til at betale et beløb
til ejeren: sp.betal(ejer, grundleje).
</para>

<para>
Klassen Gade repræsenterer en byggegrund, og objekter af
type Gade har derfor, ud over ejer, pris og grundleje, en variabel,
der husker, hvor mange huse der er bygget på dem.
</para>

<para>
Når en spiller lander på grunden, skal der ske
nogenlunde det samme som for et Rederi bortset fra, at hvis det er
ejeren der lander på grunden, kan han bygge et hus.
</para>

<screen>
<emphasis>// En gade der kan bebygges</emphasis>

<emphasis>public class Gade extends Felt</emphasis>
{
<emphasis>  Spiller ejer;</emphasis>
<emphasis>  double pris;</emphasis>
<emphasis>  double grundleje;</emphasis>
<emphasis>  int antalHuse;</emphasis>
<emphasis>  double huspris;</emphasis>

  public Gade(String navn, double pris, double leje, double huspris)
  {
    this.navn=navn;
    this.pris=pris;
    this.grundleje=leje;
    this.huspris=huspris;
    antalHuse = 0;
  }

<emphasis>  public void landet(Spiller sp)</emphasis>
  {
    System.out.println(sp.navn+&quot; er landet på &quot;+navn);

    if (sp==ejer)
    {                                        <emphasis>// eget felt</emphasis>
      System.out.println(&quot;Dette er &quot;+sp.navn+&quot;s egen grund&quot;);
      <emphasis>if (antalHuse&lt;5 &amp;&amp; sp.konto&gt;huspris)</emphasis>
      {                                     <emphasis>// byg et hus</emphasis>
        System.out.println(ejer.navn+&quot; bygger et hus på &quot;+navn+&quot; for &quot;+huspris);
<emphasis>        ejer.transaktion( -huspris );</emphasis>
<emphasis>        antalHuse = antalHuse + 1;</emphasis>
      }
    }
    else if (ejer==null)
    {                                        <emphasis>// ingen ejer grunden, så køb den</emphasis>
      if (sp.konto &gt; pris)
      {
        System.out.println(sp.navn+&quot; køber &quot;+navn+&quot; for &quot;+pris);
        ejer=sp;
        sp.transaktion( -pris );
      }
      else System.out.println(sp.navn+&quot; har ikke penge nok til at købe &quot;+navn);
    }
    else
    {                                        <emphasis>// felt ejes af anden spiller</emphasis>
      double <emphasis>leje = grundleje + antalHuse * huspris;</emphasis>
      System.out.println(&quot;Husleje: &quot;+leje);
<emphasis>      sp.betal(ejer, leje);                 </emphasis><emphasis>// spiller betaler til ejeren</emphasis>
    }
  }
}
</screen>


<para>
Et spil kunne opbygges ved at lægge forskellige felter ind i
en vektor for at få et bræt:
</para>

<screen>
<emphasis>// Matadorspil for to spillere</emphasis>
import java.util.*;

public class SpilMatador
{
  public static void main(String[] args)
  {
    Spiller sp1=new Spiller(&quot;Søren&quot;,50000);   <emphasis>// opret spiller 1</emphasis>
    Spiller sp2=new Spiller(&quot;Gitte&quot;,50000);   <emphasis>// opret spiller 2</emphasis>

    Vector felter=new Vector();               <emphasis>// indeholder alle felter</emphasis>
    felter.addElement(<emphasis>new Start(5000)</emphasis>);
    felter.addElement(<emphasis>new Gade(&quot;Gade 1&quot;,10000, 400,1000)</emphasis>);
    felter.addElement(<emphasis>new Gade(&quot;Gade 2&quot;,10000, 400,1000)</emphasis>);
    felter.addElement(<emphasis>new Gade(&quot;Gade 3&quot;,12000, 500,1200)</emphasis>);
    felter.addElement(<emphasis>new Rederi(&quot;Maersk&quot;,17000,4200)</emphasis>);
    felter.addElement(<emphasis>new Gade(&quot;Gade 5&quot;,15000, 700,1500)</emphasis>);
    felter.addElement(<emphasis>new Helle(15000)</emphasis>);
    felter.addElement(<emphasis>new Gade(&quot;Gade 7&quot;,20000,1100,2000)</emphasis>);
    felter.addElement(<emphasis>new Gade(&quot;Gade 8&quot;,20000,1100,2000)</emphasis>);
    felter.addElement(<emphasis>new Gade(&quot;Gade 9&quot;,30000,1500,2200)</emphasis>);

<emphasis>    // løb igennem 20 runder</emphasis>
    for (int runde = 0; runde&lt;20; runde=runde+1)
    {
<emphasis>      sp1.tur(felter);</emphasis>
<emphasis>      sp2.tur(felter);</emphasis>
    }
  }
}
</screen>


<para>
Man kan så lave en simpel tur()-metode, der rykker en
spiller rundt på felterne ved at hente objekterne i vektoren,
reference-typekonvertere dem til Felt og kalde objekternes
passeret()-metode og landet()-metoden på det sidste objekt.
</para>

<para>
Denne tur()-metode placerer vi i klassen Spiller sammen med
oplysningerne om spilleren.
</para>

<screen>
<emphasis>// Definition af en spiller</emphasis>

import java.util.*;

public class Spiller
{
<emphasis>  String navn;</emphasis>
<emphasis>  double konto;</emphasis>
<emphasis>  int feltnr;</emphasis>

  public Spiller(String navn, double konto)
  {
    this.navn=navn;
    this.konto=konto;
    feltnr = 0;
  }

<emphasis>  public void transaktion(double kr)</emphasis>
  {
    konto = konto + kr;
  }

<emphasis>  public void betal(Spiller modtager, double kr)</emphasis>
  {
    System.out.println(navn+&quot; betaler &quot;+modtager.navn+&quot;: &quot;+kr+&quot; kr.&quot;);
    modtager.transaktion(kr);
    transaktion(-kr);
  }

<emphasis>  public void tur(Vector felter)</emphasis>
  {
    int slag=(int)(Math.random()*6)+1;                <emphasis>// terningkast</emphasis>
    System.out.println(&quot;***** &quot;+navn+&quot; på felt &quot;+feltnr+&quot; slår &quot;+slag+&quot; *****&quot;);

<emphasis>    // nu rykkes der</emphasis>
<emphasis>    for (int i=1;i&lt;=slag;i=i+1)</emphasis>
    {
<emphasis>      // gå til næste felt: tæl op, hvis vi når over antal felter så tæl fra 0</emphasis>
      <emphasis>feltnr = (feltnr + 1)</emphasis> % felter.size();
      Felt felt;
      <emphasis>felt = (Felt) felter.elementAt(feltnr)</emphasis>;
      <emphasis>if (i&lt;slag) felt.passeret(this)</emphasis>;  <emphasis>// kald passer() på felter vi passerer</emphasis>
      <emphasis>else felt.landet(this)</emphasis>;           <emphasis>// kald land() på sidste felt</emphasis>
    }
    try {Thread.sleep(3000);} catch (Exception e) {}  <emphasis>// vent 3 sek.</emphasis>
  }
}
</screen>


<para>
Fidusen er, at denne tur()-metode kan skrives uafhængigt af,
hvilke felt-typer der findes: tur()-metoden kalder automatisk de
rigtige landet()- og passeret()-metoder, selvom den kun kender
Felt-klassen.
</para>

<para>
Bemærk i øvrigt, hvordan vi med <emphasis>this</emphasis> overfører
en reference til spilleren selv når vi kalder passeret() og
landet() på Felt-objekterne.
</para>

<para>
Linjen
</para>

<screen>
    try {Thread.sleep(3000);} catch (Exception e) {}
</screen>


<para>får programmet til at holde en pause i tre sekunder inden det
går videre (try og catch vil blive forklaret i kapitlet om
undtagelser).
</para>

<para>
Bemærk også hvordan vi sørger for, at variablen
feltnr forbliver at have en værdi mellem 0 og antallet af
felter med operatoren %, der giver resten af en division (se <xref linkend="java-basal-prg" />).
</para>

<para>
Her ses uddata af en kørsel af programmet:
</para>

<screen>
***** Søren på felt 0 slår 3 *****
Søren passerer Gade 1
Søren passerer Gade 2
Søren er landet på Gade 3
Søren køber Gade 3 for 12000.0
***** Gitte på felt 0 slår 5 *****
Gitte passerer Gade 1
Gitte passerer Gade 2
Gitte passerer Gade 3
Gitte passerer Maersk
Gitte er landet på Gade 5
Gitte køber Gade 5 for 15000.0
***** Søren på felt 3 slår 2 *****
Søren passerer Maersk
Søren er landet på Gade 5
Husleje: 700.0
Søren betaler Gitte: 700.0 kr.
***** Gitte på felt 5 slår 4 *****
Gitte passerer Helle
Gitte passerer Gade 7
Gitte passerer Gade 8
Gitte er landet på Gade 9
Gitte køber Gade 9 for 30000.0
***** Søren på felt 5 slår 1 *****
Søren er landet på helle, og får overført 15000.0
Sørens konto lyder nu på 52300.0
***** Gitte på felt 9 slår 5 *****
Gitte har passeret start og modtager 5000.0
Gittes konto lyder nu på 10700.0
Gitte passerer Gade 1
Gitte passerer Gade 2
Gitte passerer Gade 3
Gitte er landet på Maersk
Gitte har ikke penge nok til at købe Maersk
***** Søren på felt 6 slår 1 *****
Søren er landet på Gade 7
Søren køber Gade 7 for 20000.0
***** Gitte på felt 4 slår 1 *****
Gitte bygger et hus på Gade 5 for 1500.0
Gitte er landet på Gade 5
Dette er Gittes egen grund
***** Søren på felt 7 slår 1 *****
Søren er landet på Gade 8
Søren køber Gade 8 for 20000.0
***** Gitte på felt 5 slår 4 *****
Gitte passerer Helle
Gitte passerer Gade 7
Gitte passerer Gade 8
Gitte bygger et hus på Gade 9 for 2200.0
Gitte er landet på Gade 9
Dette er Gittes egen grund
***** Søren på felt 8 slår 2 *****
Søren passerer Gade 9
Søren er landet på start og modtager 5000.0
Sørens konto lyder nu på 17300.0
***** Gitte på felt 9 slår 1 *****
Gitte er landet på start og modtager 5000.0
Gittes konto lyder nu på 12000.0
***** Søren på felt 0 slår 3 *****
Søren passerer Gade 1
Søren passerer Gade 2
Søren bygger et hus på Gade 3 for 1200.0
Søren er landet på Gade 3
Dette er Sørens egen grund
***** Gitte på felt 0 slår 5 *****
Gitte passerer Gade 1
Gitte passerer Gade 2
Gitte passerer Gade 3
Gitte passerer Maersk
Gitte bygger et hus på Gade 5 for 1500.0
Gitte er landet på Gade 5
Dette er Gittes egen grund
***** Søren på felt 3 slår 5 *****
Søren passerer Maersk
Søren passerer Gade 5
Søren passerer Helle
Søren passerer Gade 7
Søren bygger et hus på Gade 8 for 2000.0
Søren er landet på Gade 8
Dette er Sørens egen grund
***** Gitte på felt 5 slår 1 *****
Gitte er landet på helle, og får overført 15000.0
Gittes konto lyder nu på 25500.0
***** Søren på felt 8 slår 3 *****
Søren passerer Gade 9
Søren har passeret start og modtager 5000.0
Sørens konto lyder nu på 19100.0
Søren er landet på Gade 1
Søren køber Gade 1 for 10000.0
</screen>


<para>
... (og så videre)
</para>

<sect2 id="java-arv-poly-poly2">
  <title>Polymorfi</title>

<para>
Polymorfi vil sige, at objekter af forskellig type bruges på
en ensartet måde uden hensyn til deres præcise type.
</para>

<para>
Matadorspillet udnytter polymorfi til at behandle alle
feltobjekter ens (ved at kalde landet() og passeret() fra
Spiller's tur()-metode), selvom de er af forskellig type.
</para>

<para>
Polymorfi er et kraftfuldt redskab til at lave meget fleksible
programmer, der senere kan udvides, uden at der skal ændres ret
meget i den eksisterende kode.
</para>

<para>
For eksempel kan vi til enhver tid udbygge matadorspillet med
flere felttyper uden at skrive programmet om. Den programkode, der
arbejder på felterne, Spiller-klassens tur()-metode, kender
faktisk slet ikke til andre klasser end Felt!
</para>

<para>
En forudsætning for at udnytte polymorfi-mekanismen er, at
objekterne &quot;sørger for sig selv&quot;, dvs. at data og
programkode er i de objekter, som de handler om.
</para>
</sect2>    <!--   Polymorfi -->
</sect1>    <!--   Polymorfe variabler -->

<sect1 id="java-arv-stamklasse">
<title>Stamklassen Object</title>

<para>
Klassen Object (i pakken java.lang) er 'alle klassers moder', dvs.
superklasse for alle andre klasser. Arver en klasse ikke fra noget
andet, vil den automatisk arve fra Object.
</para>

<blockquote><para>Alle klasser arver fra Object</para></blockquote>

<para>
Således arver f.eks. Terning fra Object. FalskTerning1 arver
indirekte fra Object gennem Terning. Alle standardklasserne arver
også fra Object, muligvis gennem andre klasser.
</para>

<figure id="java-arv-fake-dice3-fig">
<title>Java</title>

<graphic fileref="Nordfalk715410.&magic;" scale="60"></graphic>
</figure>

<para>
Det er derfor, at bl.a. toString()-metoden findes på
alle objekter; den er defineret i Object og arves til alle klasser i
Java. Her ses, hvad der sker, hvis man udskriver et (f.eks. Boks-)
objekt der ikke har sin egen toString():
</para>

<screen>
...
  Boks b = new Boks();
  System.out.println(&quot;b = &quot;+b);   <emphasis>// b.toString() kaldes implicit</emphasis>
...
</screen>

<para>Resultatet bliver:</para>


<screen>
  b = Boks@4852d1b0
</screen>


<para>
Den bruger toString() fra Object, og man kan altså se, at
implementationen af toString() i Object returnerer klassens navn, et
'@' og et tal,
f.eks. Boks@4852d1b0.
</para>

<para>
En anden metode i Object er equals(). Den har vi brugt til at
undersøge, om strenge er ens, men den findes altså på
ethvert objekt og kan f.eks. også bruges til at undersøge
om to vektorer indeholder de samme elementer.
</para>

<sect2 id="java-arv-stamklasse-ref">
  <title>Referencer til objekter</title>

<para>
Når alle objekter arver fra Object, kan man i en variabel af
denne type gemme en reference til ethvert slags objekt, jf. reglerne
om typekonvertering:
</para>

<screen>
  Object o;
  o=new Point();
  o=&quot;hej&quot;;
  o=new FalskTerning2();
</screen>


<para>
Omvendt kan man ikke rigtig bruge variablen til noget, før
man har lavet en eksplicit referencetypekonvertering:
</para>

<screen>
  Terning t;
  t=(Terning) o;
  t.kast();
</screen>


<para>
Her var jeg heldig, at o faktisk refererede til en (underklasse)
af Terning. Jeg får først at vide, om min
typekonvertering er gået godt på kørselstidspunktet.
</para>

<para>
Tilsvarende kan man bruge Object som parameter / returtype og få
et fleksibelt, men ikke særlig sikkert program. Klassen Vector
benytter sig af dette: Vektorer arbejder med lister af typen Object,
det er derfor, man kan gemme alle slags objekter i dem.
</para>

<screen>
  vector v = new Vector();
  Point p = new Point();
  v.addElement(p);
</screen>


<para>
Metoden addElement() tager et objekt af typen Object (dvs. et
hvilket som helst objekt) som parameter.
</para>

<para>
Nedenfor er vist det samme, men her bruges en mellemvariabel, der
illustrerer, at der sker en implicit reference-typekonvertering (p
skal jo konverteres fra en Point-reference til en Object-reference):
</para>

<screen>
  vector v = new Vector();
  Point p = new Point();
  Object o;                  <emphasis>// overflødig mellemvariabel</emphasis>
  o = p;                     <emphasis>// implicit reference-typekonvertering</emphasis>
  v.addElement(o);
</screen>


<para>
Når man kalder elementAt() for at få fat i objektet
igen, er det nødvendigt med en eksplicit
reference-typekonvertering, fordi konverteringen sker den anden vej,
fra superklasse til underklasse:
</para>

<screen>
  p = (Point) v.elementAt(0);
</screen>


<para>
Igen vises det samme blot med mellemvariabel, så man kan se,
hvilken typekonvertering der finder sted:
</para>

<screen>
  o = v.elementAt(0);        <emphasis>// ingen konvertering</emphasis>
  p= (point) o;              <emphasis>// eksplicit reference-typekonvertering</emphasis>
</screen>

</sect2>
</sect1>

<sect1 id="java-arv-stamklasse-subklasser">
<title>Konstruktører i underklasser</title>

<para>
Vi minder om, at:
</para>

<itemizedlist mark="bullet">
  <listitem>

<para>Konstruktører definerer, hvordan objekter oprettes, og
  med hvilke parametre de må oprettes. Der kan kun oprettes
  objekter på en måde, der passer med en konstruktør.
</para>

</listitem>

  <listitem>

<para>
Hvis en klasse ikke har defineret nogen konstruktører,
  så defineres automatisk en standardkonstruktør (uden
  parametre og med tom metodekrop). F.eks. har Boks automatisk
  fået en tom konstruktør, så den kunne oprettes
  med new Boks().
</para>

</listitem>
</itemizedlist>

<para>
En underklasse skal selv definere, hvordan dets objekter skal
kunne oprettes, så den skal selv definere sine konstruktører.
Underklassen kan også have færre eller flere
konstruktører end superklassen.
</para>

<para>
Når man definerer en konstruktør på en
underklasse, skal man kun initialisere den nye del af objektet.
</para>

<para>
Har man f.eks. tilføjet nye variabler, skal konstruktøren
initialisere dem. Den arvede del af objektet initialiseres ved, at
man fra underklassens konstruktør kalder en konstruktør
fra superklassen. Dette gøres med sætningen:
&quot;super(...);&quot; med eventuelle parametre. Man bruger altså
her <emphasis>super</emphasis> som en metode. Det skal gøres som den <emphasis>første</emphasis>
sætning i konstruktøren. Hvis man ikke selv kalder
super() som det første, sker der det, at super bliver kaldt
automatisk <emphasis>uden</emphasis>
parametre.
</para>

<figure id="java-arv-boks-fig">
<title>Boks3medDensitet
  tillader oprettelse på to måder</title>

<graphic fileref="Nordfalk715411.&magic;" scale="60"></graphic>
</figure>

<para>
Herunder definerer vi Boks3medDensitet, der arver fra Boks3. Den
nye egenskab er massefylden og metoden vægt(). Den skal kunne
oprettes med: new Boks3medDensitet(), som opretter boksen med
nogle standardværdier eller med: new
Boks3medDensitet(lgd,b,h,d), hvor d er densiteten (massefylden).
</para>

<screen>
public class Boks3medDensitet extends Boks3
{
  private double densitet;

  public Boks3medDensitet()
  {
<emphasis>    // <emphasis>super();</emphasis> overflødig, den kaldes implicit</emphasis>
    densitet = 10.0;
  }

  public Boks3medDensitet(double lgd, double b,  
          double h, double densitet)
  {
<emphasis>    // kald superklassens konstruktør</emphasis>
<emphasis>    super(lgd,b,h);</emphasis>
    this.densitet = densitet;
  }

  public double vægt()
  {
    return volumen() * densitet;    <emphasis>// superklassen udregner volumen for os</emphasis>
  }
}
</screen>

<blockquote><para>Konstruktører skal defineres på
ny i en underklasse</para></blockquote>
<blockquote><para>En konstruktør i en underklasse
kalder først en af superklassens konstruktører</para></blockquote>
<blockquote><para>Superklassens konstruktør kan
kaldes med: super(<emphasis>parametre</emphasis>)</para></blockquote>
<blockquote><para>Hvis programmøren ikke kalder
en af superklassens konstruktører, indsætter Java
automatisk et kald af superklassens konstruktør uden
parametre</para></blockquote>

<para>
Disse regler kombineret med reglerne for standardkonstruktøren
har nogle pudsige konsekvenser. Lad os se på et eksempel
med al overflødig kode skåret væk:
</para>

<screen>
public class A
{
  public A(int i)
  {
  }
}
</screen>

<para>og</para>

<screen>
public class B extends A
{

}
</screen>


<para>
Dette vil ikke oversætte, fordi B af Java vil blive lavet om
til:
</para>

<screen>
public class B extends A
{
  public B() <emphasis>// indsættes automatisk af Java</emphasis>
  {
    super();
  }
}
</screen>


<para>Standardkonstruktøren i B vil altså prøve at
kalde konstruktøren i A uden parametre, men den findes jo
ikke, fordi A har en anden konstruktør. Oversætteren
kommer med fejlmeddelelsen &quot;<emphasis>constructor A() not found</emphasis>&quot;.
</para>

<para>
Der er derimod ingen problemer med:
</para>

<screen>
public class A
{
}
</screen>

<para>og</para>

<screen>
public class B extends A
{
}
</screen>


<para>
Java laver det om til:
</para>

<screen>
public class A
{
  public A() <emphasis>// indsættes automatisk af Java</emphasis>
  {
  }
}
</screen>

<para>og</para>

<screen>
public class B extends A
{
  public B() <emphasis>// indsættes automatisk af Java</emphasis>
  {
    super();
  }
}
</screen>

</sect1>    <!--   Referencer til objekter -->

<sect1 id="java-arv-stamklasse-matador">
  <title>Matadorspillet version 2</title>

<para>
Dette eksempel viser, hvordan man kan spare programkode (og dermed
programmeringstid) med nedarvning. Samtidig viser det brugen af
konstruktører i underklasser.
</para>

<para>
Se igen på programkoden til Rederi og Gade. Der er meget
programkode, som er ens for de to klasser. Faktisk implementerer de
kode, der er fælles for alle grunde, der kan ejes af en
spiller, og derfor vil det være hensigtsmæssigt, at
følgende kode var i en Grund-klasse:
</para>

<itemizedlist mark="bullet">
  <listitem>

<para>Definition og initialisering af variablerne pris, grundleje,
  ejer.
</para>

</listitem>

  <listitem>

<para>
Håndtering af, at en spiller lander på grunden
  (bl.a. betaling af leje).
</para>

</listitem>

  <listitem>

<para>
Håndtering af, at en spiller lander på en grund,
  der ikke ejes af nogen (køb af grunden).
</para>

</listitem>
</itemizedlist>

<para>
Det har vi gjort herunder. Vi har været forudseende og
flyttet beregningen af lejen ud fra landet() og ind i en separat
metode beregnLeje(), fordi netop denne er meget forskellig for Rederi
og Gade.
</para>

<screen>
<emphasis>// Mellemklasse mellem 'Felt' og underliggende klasser som Gade og Rederi</emphasis>

public class Grund2 extends Felt
{
<emphasis>  Spiller ejer;</emphasis>
<emphasis>  double pris;</emphasis>
<emphasis>  double grundleje;</emphasis>

<emphasis>  public Grund2(String navn, double pris, double leje)</emphasis>
  {
    this.navn=navn;
    this.pris=pris;
    this.grundleje=leje;
  }

<emphasis>  public double beregnLeje()</emphasis>
  {
    return grundleje;
  }

<emphasis>  public void landet(Spiller sp)</emphasis>
  {
    System.out.println(sp.navn+&quot; er landet på &quot;+navn);
    if (sp==ejer)
    {                                       <emphasis>// spiller ejer feltet</emphasis>
      System.out.println(&quot;Dette er &quot;+sp.navn+&quot;s egen grund&quot;);
    }
    else if (ejer==null)
    {                                       <emphasis>// ingen ejer grunden, så køb den</emphasis>
      if (sp.konto &gt; pris)
      {
        System.out.println(sp.navn+&quot; køber &quot;+navn+&quot; for &quot;+pris);
        ejer=sp;
        sp.transaktion( -pris );
      }
      else System.out.println(sp.navn+&quot; har ikke penge nok til at købe &quot;+navn);
    }
    else
    {                                       <emphasis>// felt ejes af anden spiller</emphasis>
      double leje = <emphasis>beregnLeje()</emphasis>;
      System.out.println(&quot;Husleje: &quot;+leje);
      sp.betal(ejer, leje);                 <emphasis>// spiller betaler til ejeren</emphasis>
    }
  }
}
</screen>


<para>
Nu er Rederi ret nem. Den skal nemlig (i denne simple udgave)
opføre sig præcis som Grund. Vi skal blot definere
konstruktøren, som skal kalde den tilsvarende konstruktør
i Grund:
</para>

<screen>
<emphasis>// Rederier</emphasis>

public class Rederi2 extends Grund2 
{
<emphasis>  public Rederi2(String navn, double pris, double leje)</emphasis>
  {
<emphasis>    super(navn, pris, leje);</emphasis>    <emphasis>// kald superklassens konstruktør</emphasis>
  }
}
</screen>


<para>
Nu kommer vi til Gade. Her er beregnLeje() tilsidesat til også
at tage højde for antallet af huse. Med <emphasis>super</emphasis> kan vi
faktisk spare en hel del arbejde. Gaderne kan genbruge meget af
landet()-metoden, men der er dog en ekstra mulighed for at bygge hus.
Derfor kalder vi superklassens landet()-metode, hvis spilleren, der
er landet på gaden, ikke er ejeren. Hvis det <emphasis>er</emphasis> ejeren,
prøver vi at bygge et hus (udskilt i metoden bygHus()).
</para>

<screen>
<emphasis>// En gade der kan bebygges</emphasis>

public class Gade2 extends Grund2
{
  int antalHuse;                                      <emphasis>// antal huse og pris</emphasis>
  double huspris;

<emphasis>  public Gade2(String navn, double pris, double leje, double huspris)</emphasis>
  {
<emphasis>    super(navn, pris, leje);</emphasis>
    this.huspris=huspris;
    antalHuse = 0;
  }

<emphasis>  public double beregnLeje()</emphasis>                          <emphasis>// tilsidesæt Grund2's</emphasis>
  {
    return grundleje + antalHuse * huspris;
  }

  public void landet(Spiller sp)
  {
    if (sp==ejer)
    {                                                 <emphasis>// eget felt; byg hus</emphasis>
      System.out.println(sp.navn+&quot; er landet på &quot;+navn);
      System.out.println(&quot;Dette er &quot;+sp.navn+&quot;s egen grund&quot;);
      if (antalHuse&lt;5 &amp;&amp; sp.konto&gt;huspris) <emphasis>bygHus()</emphasis>;  <emphasis>// byg hus hvis vi kan</emphasis>
    }
    else <emphasis>super.landet(sp)</emphasis>;                            <emphasis>// brug gamle landet()</emphasis>
  }

<emphasis>  public void bygHus()</emphasis>
  {
    System.out.println(ejer.navn+&quot; bygger et hus på &quot;+navn+&quot; for &quot;+huspris);
    ejer.transaktion( -huspris );
    antalHuse = antalHuse + 1;
  }
}
</screen>


<para>
Læg mærke til, at vi har sparet næsten halvdelen
af koden væk i de to nye klasser.
</para>

<para>
Herunder ses klassediagrammet for de nye klasser. Da Grund2 <emphasis>har
en</emphasis> spiller (ejeren), er der en pil fra Grund2 til Spiller, en
<emphasis>har-en</emphasis>-relation. Resten af pilene symboliserer
<emphasis>er-en</emphasis>-relationer, f.eks. Gade2 <emphasis>er en</emphasis> Grund2, Grund2 <emphasis>er
et</emphasis> Felt.
</para>

<figure id="java-arv-grund-fig">
<title>Java</title>

<graphic fileref="Nordfalk715413.&magic;" scale="60"></graphic>
</figure>
</sect1>    <!--   Stamklassen Object -->

<sect1 id="java-arv-opg">
  <title>Opgaver</title>
<orderedlist>
  <listitem>

<para>Lav en LudoTerning, der arver fra Terning. Tilsidesæt
  toString() med en, der giver &quot;*&quot; på en 3er og
  &quot;globus&quot; på en 4er. Afprøv klassen.
</para>

</listitem>

  <listitem>

<para>
Tilføj en Bryggeri-klasse til matadorspillet (version
  1) og prøv om det virker.På bryggerier afhænger
  lejen af, hvor stort et slag spilleren slog, da han landede på
  feltet, men start med at lade lejen være tilfældig.
  Du kan evt. kopiere Gade.java i stedet for at skrive koden forfra.
  Husk at indsætte et bryggeri i felter-vektoren i main().
</para>

</listitem>

  <listitem>

<para>
Ret SpilMatador til at bruge Rederi2 og Gade2 i stedet for
  Rederi og Gade. Kør programmet, og følg med i,
  hvad der sker i Gade2's konstruktør og landet()-metode.
</para>

</listitem>

  <listitem>

<para>
Føj en Bryggeri-klasse til matadorspillet version 2.
  Husk at kalde super() i konstruktøren (hvorfor er det
  nødvendigt?). Du kan evt. kopiere Gade2.java i stedet for at
  skrive koden forfra. Hvor meget kode kan du spare?
</para>

</listitem>

  <listitem>

<para>
Ret på Spiller, så slag er en objektvariabel i
  stedet for en lokal variabel. Nu kan man udefra aflæse, hvad
  spilleren slog sidst. Brug værdien af slag i landet()-metoden
  i Bryggeri til at lade lejen afhænge af, hvad spilleren slog.
</para>

</listitem>
</orderedlist>

</sect1>    <!--   Opgaver -->
</chapter>    <!--   Nedarvning -->

