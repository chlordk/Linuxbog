<!-- $Id$ --> 
<chapter id="java-basal-prg"> 
  <title>Basal programmering</title> 
 
<para> 
Kapitlet forudsættes i resten af bogen. 
</para> 
 
<sect1 id="java-basal-prg-foerste"> 
  <title>Det første javaprogram</title> 
 
<para> 
Lad os se på et simpelt javaprogram, der skriver "Hej verden" og et 
citat af Storm P. ud til skærmen. 
</para> 
 
<screen> 
// Et simpelt program, der skriver "Hej verden"  
// og et citat af Storm P. ud til skærmen 
public class HejVerden 
{ 
  public static void main (String[] args) 
  { 
    System.out.println("Hej Verden!"); 
    System.out.println("Hvornår smager en Tuborg bedst?"); 
    System.out.println("Hvergang!"); 
  } 
} 
</screen> 
 
<para> 
Inden vi oversætter og kører programmet 
</para> 
 
<sect2 id="java-basal-prg-foerste-kommentar"> 
  <title>Kommentarer</title> 
 
<para> 
Kommentarer er dokumentation beregnet på at gøre programmets 
kildetekst lettere at forstå. De påvirker ikke programudførelsen, da 
oversætteren ignorerer dem.</para> 
 
<para> 
De første 3 linjer, der starter med //, er kommentarer: 
</para> 
 
<screen> 
// Et simpelt program, der skriver "Hej verden" 
// og et citat af Storm P. ud til skærmen 
</screen> 
 
<para> 
Kommentarer bør skrives, så de giver forståelse for, hvordan 
programmet virker - uden at være flertydige eller forklare indlysende 
ting. 
</para> 
 
<para> 
// markerer, at resten af linjen er en kommentar. Den kan også 
bruges efter en kommando, til at forklare hvad der sker, f.eks. 
</para> 
 
<screen> 
System.out.println("Hej verden!");  // Udskriv en hilsen 
</screen> 
 
<para> 
Java har også en anden form, som kan være nyttig til 
kommentarer over flere linjer: Man kan starte en kommentar med /* og 
afslutte den med */. Al tekst mellem /* og */ bliver så 
opfattet som kommentarer. Vi kunne altså også skrive 
</para> 
 
<screen> 
/* 
Et simpelt program, der skriver "Hej verden"  
og et citat af Storm P. ud til skærmen 
*/ 
</screen> 
 
<para> 
og 
</para> 
 
<screen> 
System.out.println("Hej verden!");  /* Udskriv en hilsen */ 
</screen> 
 
<para> 
Der findes også en tredje form kaldet for 
<emphasis>Javadoc-kommentarer</emphasis>, som starter med /** og 
slutter med */. Javadoc-kommentarer gennemgåes i <xref 
linkend="java-dev-env-doc-javadoc">. 
</para> 
 
</sect2>    <!--   Kommentarer --> 
 
<sect2 id="java-basal-prg-foerste-klassedef"> 
  <title>Klassedefinitionen</title> 
 
<para> 
Resten af teksten kaldes en klassedefinition og beskriver selve 
programmet (HejVerden). 
</para> 
 
<para> 
Den består af en fast struktur: 
</para> 
 
<screen> 
public class HejVerden 
{ 
  public static void main (String[] arg) 
  { 
    ... 
  } 
} 
</screen> 
 
 
<para> 
og noget programkode - kommandoer, der skal udføres, nærmest som en 
bageopskrift: 
</para> 
 
<screen> 
System.out.println(&quot;Hej verden!&quot;); 
</screen> 
 
<sect3 id="java-basal-prg-foerste-klassedef-struktur"> 
  <title>Strukturdelen</title> 
 
<para> 
Strukturdelen vil ikke blive ændret i de næste to kapitler, og det er 
ikke så vigtigt, at du forstår, hvad der foregår i første omgang. 
</para> 
 
<para> 
Al javakode er indkapslet i en klasse mellem { og } (blokstart og 
blokslut-parenteser). Beskrivelsen af en klasse er altid indkapslet i 
en blok bestående af: 
</para> 
 
<screen> 
public class HejVerden 
{ 
  ... 
} 
</screen> 
 
 
<para> 
Inde i klassen står der en main-metode med nogle kommandoer 
i. Indholdet af metoden er altid indkapslet i en blok med { og }: 
</para> 
 
<screen> 
public static void main (String[] arg) { ...  } 
</screen> 
 
<para> 
Programudførelsen starter i metoden: public static void main 
(String[] arg) 
</para> 
 
</sect3>    <!--   Strukturdelen --> 
 
<sect3 id="java-basal-prg-foerste-klassedef-kode"> 
  <title>Programkode</title> 
 
<para> 
I main-metoden giver man instruktioner til computeren: 
</para> 
 
<screen> 
    System.out.println("Hej verden!"); 
    System.out.println("Hvornår smager en Tuborg bedst?"); 
    System.out.println("Hvergang!"); 
</screen> 
 
 
<para> 
Instruktionerne udføres altid en efter en, ovenfra og ned. 
Hver instruktion afsluttes med et semikolon. 
</para> 
 
<para> 
Disse 3 instruktioner skriver 3 strenge ("Hej verden!", 
...) ud til skærmen. En streng er en tekst, som computeren kan 
arbejde med. Strenge er altid indkapslet i "". 
</para> 
 
<para> 
Hver instruktion består af et kald til metoden 
System.out.println, som betyder, at der skal udskrives noget til 
skærmen, og en streng som parameter. 
</para> 
 
<para> 
En parameter er en oplysning (data), som man overfører til 
metoden. 
 
I dette tilfælde hvilken tekst der skal skrives ud til 
skærmen. 
</para> 
 
<para> 
Vores main-metode kalder altså andre metoder. 
</para> 
</sect3>    <!--   Programkode --> 
</sect2>    <!--   Klassedefinitionen --> 
 
<sect2 id="java-basal-prg-foerste-oversaettelse"> 
  <title>Oversættelse og kørsel af programmet</title> 
 
<para> 
Når man skal udvikle et program, skriver man først en 
kildetekst (eng.: source code), der beskriver, hvad det er, man vil 
have programmet til at gøre. Programmet, vi lige har set, er 
et eksempel på en kildetekstfil. 
</para> 
 
<para> 
Instruktionerne (kildeteksten), som centralenheden i computeren arbejder med, er i en 
binær kode (ene ettaller og nuller) Nævnte binære kode kaldes maskinkode eller bytecode). 
En sådan kode er umulig at læse for almindelige mennesker. Kildeteksten skal derfor 
oversættes (eng.: compile; mange siger også kompilere på dansk) til binær kode, som så 
kan udføres af computeren. 
</para> 
 
<para> 
I Java kalder man den binære kode for bytekode. Bytekode er 
platform-uafhængigt, dvs. at det kan køre på stort set alle 
hardware-platforme og alle styresystemer. De fleste andre sprogs 
binære kode er ikke indrettet til at være platformuafhængigt. 
</para> 
 
<para> 
For at oversætte programmet HejVerden skal det gemmes i en fil med 
navnet "HejVerden.java" - HejVerden er filnavnet, mens java er filtypen (efternavnet). 
Filnavnet skal være det samme som klassenavnet - her er det ikke nok at de samme tegn
optræder i filnavnet, sammensætningen af store og små bogstaver skal identisk med klassenavnet. 
Filtypen skal være java. Man kan godt havde flere klasser i samme fil, men kun én kan have offentlig
tilgang (public) filnavnet skal opkaldes efter denne - læs mere om dette senere.
</para> 

<para> 
Eksempel: Klassen hedder HejVerden, og filen hedder 
HejVerden.java. 
</para> 
 
<sect3 id="java-basal-prg-foerste-oversaettelse-jdk"> 
  <title>Oversættelse og kørsel uden et udviklingsværktøj</title> 
 
<para> 
Hvis man bruger det kommandolinje-orienterede JDK, skal man (fra 
samme katalog) skrive: 
</para> 
 
<programlisting> 
<prompt>[jonas@zeta basal-prg]$</prompt> <userinput>javac HejVerden.java</userinput> 
</programlisting> 
 
<para> 
Såfremt der ikke er nogen fejl i kildeteksten så vil oversætteren 
forholde sig tavs. Det eneste tegn på at der er sket noget er at filen 
<filename>HejVerden.class</filename> er dukket op i samme katalog. Nu 
kan det køres med kommandoen 
</para> 
 
<programlisting> 
<prompt>[jonas@zeta basal-prg]$</prompt> <userinput>java HejVerden</userinput> 
</programlisting> 
 
<para> 
Resultatet bliver: 
</para> 
 
<screen> 
Hej Verden! 
Hvornår smager en Tuborg bedst? 
Hvergang! 
</screen> 
 
<figure id="java-basal-prg-oversaettelse-koer-cyklus-fig"> 
<title>Oversættelse og udførelse af programmet HejVerden</title> 
<graphic fileref="Nordfalk415342.&magic;" scale="60"></graphic> 
</figure> 
 
</sect3>    <!--   Oversættelse og kørsel uden et udviklingsværktøj --> 
 
<sect3 id="java-basal-prg-foerste-oversaettelse-ide"> 
  <title>Oversættelse og kørsel med et udviklingsværktøj</title> 
 
<para> 
I de fleste udviklingsværktøjer skal du oprette et 
<emphasis>projekt</emphasis> (f.eks. i JBuilder: File/New 
Project). Føj derefter din java-fil til projektet. Husk at placere 
filen i det katalog, som projektet angiver (eller rette projektets 
egenskaber). 
</para> 
 
 
 
<para> 
Når man vil oversætte sit java-program, skal man vælge 
<emphasis>make</emphasis> (det er et engelsk ord). Når man har gjort 
det, kan man køre sit program med <emphasis>run</emphasis>. 
</para> 
</sect3>    <!--   Oversættelse og kørsel med et udviklingsværktøj --> 
</sect2>    <!--   Oversættelse og kørsel af programmet --> 
</sect1>    <!--   Det første javaprogram --> 
 
<sect1 id="java-basal-prg-variable"> 
  <title>Variable</title> 
 
<para> 
Du kan vælge at give et område i computeren et navn - sætte en etiket på området. Området kan  
bruges til opbevaring af data. Da alle data ikke fylder lige meget i lageret, er det nødvendigt  
at definere, hvilken type data du vil bruge lageret til samtidig med erklæringen eller navngivningen  
af området. 
</para> 
 
<para> 
Det er en god vane at give variablerne sigende navne. Navnene bør 
starte med et lille bogstav. 
</para> 
 
<para> 
I det følgende gennemgår vi to af Javas variabeltyper: int (heltal) og 
double (kommatal). 
</para> 
 
<sect2 id="java-basal-prg-variable-int"> 
  <title>Heltal</title> 
 
<para> 
En variabel af typen int (et heltal, eng.: integer) erklæres med 
</para> 
 
<screen> 
int tal; 
</screen> 
 
 
<figure id="java-basal-prg-variable-int-tildeling-fig"> 
<title>Efter 1. tildeling</title> 
 
<graphic fileref="Nordfalk415343.&magic;" scale="60"></graphic> 
</figure> 
 
 
<para> 
Nu er der reserveret plads i hukommelsen til et heltal.  Man får fat i 
pladsen ved at bruge variabelnavnet 'tal'. Efter at variablen er 
erklæret kan den tildeles en værdi (der kan lagres en værdi på dens plads i computerens RAM), dvs.  man kan skrive data ind i 
den: 
</para> 
 
<screen> 
tal = 22; 
</screen> 
 
 
<para> 
Nu er værdien af tal 22 (vist på figuren til højre). 
</para> 
 
<para> 
Vi kan bruge tal-variablen i stedet for at skrive 22, f.eks. til at 
skrive ud til skærmen: 
</para> 
 
 
<screen> 
System.out.println("Svaret på livet, universet og alt det der: " + tal); 
</screen> 
 
<para> 
Her slår computeren op i hukommelsen, læser indholdet af tal-variablen 
og skriver det ud til skærmen (+'et vil blive forklaret om lidt). 
</para> 
 
<para> 
Variabler kan, som navnet siger, ændre værdi. Det gør vi ved at 
tildele variablen en ny værdi (der kan gemmes en værdi på den plads 
i computerens lager, der er "markeret" med etiketten tal): 
</para> 
 
<figure id="java-basal-prg-variable-int-tildeling2-fig"> 
<title>Efter 2. tildeling</title> 
<graphic fileref="Nordfalk415344.&magic;" scale="60"></graphic> 
</figure> 
 
<screen> 
tal = 42; 
</screen> 
 
<para> 
Herefter er den gamle værdi fuldstændigt glemt og erstattet med den 
nye. Når programudførelsen når et punkt, hvor variablen læses, vil det 
være den nye værdi, 42, der gælder. 
</para> 
 
<blockquote><para>I en tildeling læses værdien 
på højre side og gemmes i variablen på venstre 
side</para></blockquote> 
 
<para> 
Herunder er eksemplet i sin helhed (den væsentlige del af koden er 
fremhævet): 
</para> 
 
<screen> 
// Eksempel på brug af en variabel 
// koden skal være i filen Variabler.java 
public class Variabler 
{ 
  public static void main (String[] args) 
  { 
<emphasis>    int tal;</emphasis> 
<emphasis>    tal = 22;</emphasis> 
<emphasis>    System.out.println("Svaret på livet, universet og alt det der: " + tal);</emphasis> 
 
<emphasis>    tal = 42;</emphasis> 
<emphasis>    System.out.println("Undskyld, svaret er: " + tal);</emphasis> 
  } 
} 
</screen> 
 
 
<screen> 
Svaret på livet, universet og alt det der: 22 
Undskyld, svaret er: 42 
</screen> 
</sect2>    <!--   Heltal --> 
 
<sect2 id="java-basal-prg-variable-sammensaet"> 
  <title>Sammensætte strenge med +</title> 
 
<para> 
Som det er vist i ovenstående eksempel, kan vi med tegnet 
<emphasis>+</emphasis> sætte strenge sammen med noget andet: 
</para> 
 
<screen> 
System.out.println(<emphasis>"Svaret på livet, universet og alt det 
der: " + tal</emphasis>); 
</screen> 
 
<para> 
Herunder sætter vi to strenge sammen: 
</para> 
 
<screen> 
// Sammensæt to strenge med + 
// koden skal være i filen HejVerden2.java 
public class HejVerden2 
{ 
  public static void main (String[] args) 
  { 
    System.out.println(<emphasis>"Hej " + "Verden!"</emphasis>); 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
Hej Verden! 
</screen> 
 
<para> 
Herunder skriver vi en streng og tallet 42 ud: 
</para> 
 
<screen> 
public class HejVerden3 
{ 
  public static void main (String[] args) 
  { 
    System.out.println("Svaret på livet, universet og alt det der:"<emphasis> + 42</emphasis>); 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
Svaret på livet, universet og alt det der: 42 
</screen> 
 
<para> 
Det, der egentlig sker, er, at det hele bliver sat sammen til 
én streng, og den sendes til System.out.println(). 
</para> 
 
<blockquote><para>En streng + noget andet sættes 
sammen til en samlet streng</para></blockquote> 
</sect2>    <!--   Sammensætte strenge med + --> 
 
<sect2 id="java-basal-prg-variable-udtryk"> 
  <title>Beregningsudtryk</title> 
 
<para> 
Man kan erklære flere variabler på samme linje: 
</para> 
 
<screen> 
int antalHunde, antalKatte, antalDyr; 
antalHunde = 5; 
antalKatte = 8; 
</screen> 
 
<para> 
Tildelinger kan indeholde regneudtryk på højre side af 
lighedstegnet. Udtrykket antalHunde + antalKatte udregnes, og 
resultatet lægges i variablen på venstre side (fordi variabelnavnet ene og alene er en  
etiket sat på en del af computerens lager, er det naturligvis ikke muligt   
at have beregningsudtryk på venstre side): 
</para> 
 
<screen> 
antalDyr = antalHunde + antalKatte; 
</screen> 
 
<para> 
Beregningsudtrykkene undersøges af Java ved at indsætte de værdier, der er gemt i   
variablerne. Her indsætter Java 5 + 8 og får 13, som lægges i 
antalDyr. 
</para> 
 
<screen> 
public class Dyreinternat 
{ 
  public static void main(String[] args)  
  { 
    int antalHunde, antalKatte, antalDyr; 
    antalHunde = 5; 
    antalKatte = 8;  
 
    //udregn summen 
    antalDyr = antalHunde + antalKatte; 
 
    // udskriv resultatet 
    System.out.println("Antal dyr: " + antalDyr); 
 
    antalHunde  = 10; 
 
    // antalDyr er uændret 
    System.out.println("Antal dyr nu: " + antalDyr); 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
Antal dyr: 13 
Antal dyr nu: 13 
</screen> 
 
<para> 
Beregningen sker én gang <emphasis>på det tidspunkt, hvor kommandoen 
udføres</emphasis> Derfor er antalDyr's værdi ikke påvirket at af vi 
sætter antalHunde til noget andet efter udregningen. 
</para> 
 
<para> 
Ligesom i almindelig matematik har * (multiplikation) og / 
(division) højere prioritet end + og -. 
</para> 
 
<blockquote><para>I Java skrives 9 divideret med 3 som 9/3 3 gange 3 
som 3*3</para></blockquote> 
 
<para> 
Man kan ikke som i almindelig matematisk notation undlade at skrive 
gangetegn. 
</para> 
 
<para> 
Resultatet af en heltalsudregning er også et heltal. Det skal man være 
opmærksom på ved division, hvor eventuelle decimaler efter kommaet 
smides væk.  Heltalsudregningen 13 / 5 giver altså 2, fordi 5 går op i 
13 to gange. 
</para> 
 
<blockquote><para>Et heltal divideret med et heltal 
giver et heltal   95 / 100 giver 0</para></blockquote> 
 
<para> 
Ønsker man at få et kommatal som resultat af 
divisionen skal et eller begge af tallene være kommatal. 
Eksempelvis giver 95.0 / 10 kommatallet 9.5. 
</para> 
</sect2>    <!--   Beregningsudtryk --> 
 
<sect2 id="java-basal-prg-variable-float"> 
  <title>Kommatal</title> 
 
<para> 
Der findes mange andre variabeltyper end heltalstypen int. Hvis 
man vil regne med kommatal, bruger man typen double. En variabel af 
typen double erklæres med: 
</para> 
 
<screen> 
double højde; 
</screen> 
 
<para> 
De følgende afsnit bruger noget matematik, mange lærer i 
gymnasiet. Hvis du ikke kender så meget til matematik, gør det ikke 
noget. Præcis, hvad der udregnes og formlerne bag det, er ikke så 
vigtigt i denne sammenhæng. Det vigtige er at forstå, hvordan man 
arbejder med tal i Java. 
</para> 
 
<para> 
Her er et eksempel på beregning af en cylinders rumfang: 
</para> 
 
<screen> 
// 
// Beregning af rumfang for en cylinder 
// 
public class Cylinderberegning 
{ 
  public static void main(String[] args)  
  { 
    <emphasis>double radius;</emphasis> 
    <emphasis>radius = 5.0;</emphasis> 
    <emphasis>double højde = 12.5;</emphasis> 
    //beregn rumfang 
    <emphasis>double volumen = radius * radius * højde * 3.14159;</emphasis> 
 
    System.out.println("Cylinderens højde: " + højde); 
    System.out.println("Cylinderens radius: " + radius); 
    System.out.println("Cylinderens volumen: " + volumen); 
  } 
} 
</screen> 
 
 
<screen> 
Cylinderens højde: 12.5 
Cylinderens radius: 5.0 
Cylinderens volumen: 981.7468749999999 
</screen> 
 
 
<para> 
Læg mærke til, at man godt kan erklære en variabel og tildele den 
værdi i samme linje: 
</para> 
 
<screen> 
double højde = 12.5; 
</screen> 
 
<para> 
er altså det samme som: 
</para> 
 
<screen> 
double højde; 
højde = 12.5; 
</screen> 
 
 
<para> 
Her er et eksempel på en skatteberegning, der viser nogle 
flere fif: 
</para> 
 
<screen> 
// 
// Skatteberegning (Inspireret af Hallenberg og Sestoft, IT-C, København) 
// 
public class Skatteberegning  
{ 
  public static void main(String[] args)  
  { 
    double indkomst = 300000; 
    double ambi, pension, bundskat; 
 
    ambi = indkomst * 0.08; 
    pension = indkomst * 0.01; 
    indkomst = <emphasis>indkomst - (ambi + pension)</emphasis>; 
    bundskat = <emphasis>(indkomst - 33400) * 0.07</emphasis>; 
 
    System.out.println("AMBI: " + ambi); 
    System.out.println("Særlig pensionsopsparing: " + pension); 
    System.out.println("Bundskat: " + bundskat); 
  } 
} 
</screen> 
 
 
<screen> 
AMBI: 24000.0 
Særlig pensionsopsparing: 3000.0 
Bundskat: 16772.0 
</screen> 
 
 
<para> 
Udregninger sker normalt fra venstre mod højre, men ligesom 
i den almindelige matematik kan man påvirke 
udregningsrækkefølgen ved at sætte parenteser: 
</para> 
 
<screen> 
    bundskat = (indkomst - 33400) * 0.07; 
</screen> 
</sect2>    <!--   Kommatal --> 
 
<sect2 id="java-basal-prg-variable-matematik"> 
  <title>Matematiske funktioner</title> 
 
<para> 
De matematiske funktioner som sinus, cosinus, kvadratrod osv.  kaldes 
i Java med Math.sin(x), Math.cos(x), Math.sqrt(x) osv., hvor x er en 
variabel, et fast tal eller et beregningsudtryk. 
</para> 
 
<para> 
Vi kan f.eks. lave en tabel over værdierne af kvadratrod-funktionen 
Math.sqrt() for x=0 til x=10 med programmet (senere, i sektionen om 
løkker, vil vi se en smartere måde). 
</para> 
 
<screen> 
public class Kvadratrod 
{ 
  public static void main(String[] args)  
  { 
    System.out.println("kvadratroden af 0 er " + <emphasis>Math.sqrt(0)</emphasis>); 
    System.out.println("kvadratroden af 1 er " + Math.sqrt(1)); 
    System.out.println("kvadratroden af 2 er " + Math.sqrt(2)); 
    System.out.println("kvadratroden af 3 er " + Math.sqrt(3)); 
    System.out.println("kvadratroden af 4 er " + Math.sqrt(4)); 
    System.out.println("kvadratroden af 5 er " + Math.sqrt(5)); 
    System.out.println("kvadratroden af 6 er " + Math.sqrt(6)); 
    System.out.println("kvadratroden af 7 er " + Math.sqrt(7)); 
    System.out.println("kvadratroden af 8 er " + Math.sqrt(8)); 
    System.out.println("kvadratroden af 9 er " + Math.sqrt(9)); 
    System.out.println("kvadratroden af 10 er " + Math.sqrt(10)); 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
kvadratroden af 0 er 0.0 
kvadratroden af 1 er 1.0 
kvadratroden af 2 er 1.4142135623730951 
kvadratroden af 3 er 1.7320508075688772 
kvadratroden af 4 er 2.0 
kvadratroden af 5 er 2.23606797749979 
kvadratroden af 6 er 2.449489742783178 
kvadratroden af 7 er 2.6457513110645907 
kvadratroden af 8 er 2.8284271247461903 
kvadratroden af 9 er 3.0 
kvadratroden af 10 er 3.1622776601683795 
</screen> 
 
 
<para> 
Her er et program, der udregner længden af den skrå side (hypotenusen) 
af en retvinklet trekant ud fra længden af dens to lige sider 
(kateder): kvadratroden af a&sup2;+b&sup2;, hvor a og b er længderne 
af de to sider: 
</para> 
 
<screen> 
public class Trekant 
{ 
  public static void main(String[] args)  
  { 
    double a, b, hypotenuse; 
    a = 3; 
    b = 4; 
    hypotenuse = <emphasis>Math.sqrt(a*a + b*b)</emphasis>; 
    System.out.println("En retvinklet trekant med sider "+a+" og "+b); 
    System.out.println("har hypotenuse "+hypotenuse); 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
En retvinklet trekant med sider 3.0 og 4.0 
har hypotenuse 5.0 
</screen> 
 
<para> 
Her er et tilsvarende program, der udregner hypotenusen ud fra længden 
af en af de andre sider og den modstående vinkel. Det gøres ud fra 
formlen a/sin(v), hvor a er længden af siden, og v er vinklen (i 
radianer): 
</para> 
 
<screen> 
public class Trekant2 
{ 
  public static void main(String[] args)  
  { 
    double a, v, hypotenuse; 
    a = 10; 
    v = 0.3; // svarer til ca. 34 grader. 
    hypotenuse = <emphasis>a/Math.sin(v)</emphasis>; 
    System.out.println("Hypotenusen har længden: "+hypotenuse); 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
Hypotenusen har længden: 33.838633618241225 
</screen> 
 
<para> 
Ud over de almindelige matematiske funktioner findes også 
Math.random(), der giver et tilfældigt tal mellem 0 og 0.999999... 
</para> 
</sect2>    <!--   Matematiske funktioner --> 
 
<sect2 id="java-basal-prg-variable-metodekald"> 
  <title>Kald af metoder</title> 
 
<para> 
Math.sqrt(), Math.sin() og de andre matematiske funktioner og 
andre kommandoer, f.eks. System.out.println(), kaldes under et 
<emphasis>metoder</emphasis>. 
</para> 
 
<para> 
En metode er en navngiven programstump (i nogle computersprog
taler man på dette sted om funktioner), der kan gøre et 
eller andet eller beregne en værdi. F.eks. <emphasis>gør</emphasis> 
System.out.println() det, at den skriver tekst på 
skærmen, og Math.sqrt() <emphasis>beregner</emphasis> en 
kvadratrod. Når en metode nævnes i teksten, skriver vi 
altid () bagefter, så man kan se, at det er en 
metode. 
</para> 
 
<para> 
Nedenstående linje indeholder et <emphasis>metodekald</emphasis>: 
</para> 
 
<screen> 
hypotenuse = a/Math.sin(v); 
</screen> 
 
<para> 
Math.sin er navnet på metoden, og man kalder det v, der står 
inde i (), for argumentet eller parameteren. 
</para> 
 
<para> 
Et metodekald er en nævnelse af en metodes navn efterfulgt 
af de rigtige parametre. Parametrene er omgivet af parenteser. 
</para> 
 
<para> 
Ved et kald uden parametre skal man stadig have parenteserne med. 
Math.random() skal kaldes uden parametre. Her er et eksempel på 
et metodekald af Math.random(): 
</para> 
 
<screen> 
double tilfældigtTal;  
tilfældigtTal = Math.random(); 
</screen> 
 
<blockquote><para>Ved et metodekald kan man indsætte som parameter 
ethvert udtryk, der giver et resultat af den rigtige 
type.</para></blockquote> 
 
<para> 
Alt, der giver et resultat af den rigtige type, er altså 
tilladt: Konstanter, variabler, regneudtryk og resultatet af et andet 
metodekald: 
</para> 
 
<screen> 
double v,x; 
x = Math.sin(0.1);             // konstant som parameter 
x = Math.sin(v);               // variabel som parameter 
x = Math.sin(Math.sqrt(0.3));  // værdi af andet metodekald som parameter 
</screen> 
 
<para> 
Vi vil i <xref linkend="java-klasser" /> se, hvad der sker, når computeren udfører et 
metodekald, samt lære, hvordan man kan lave sine egne metoder. 
</para> 
</sect2>    <!--   Kald af metoder --> 
 
<sect2 id="java-basal-prg-variable-logiske"> 
  <title>Logiske variable</title> 
 
<para> 
En boolsk variabel, også kaldet en logisk variabel, kan kun indeholde 
værdierne sand eller falsk. Den bruges oftest til at huske, om noget 
er sandt eller ej, men kan også bruges til at repræsentere noget, der 
kun har to tilstande, f.eks. om en lampe er tændt eller slukket. 
</para> 
 
<para> 
Variabeltypen hedder boolean, og den erklæres med f.eks.: 
</para> 
 
<screen> 
boolean detErForSent; 
</screen> 
 
 
<para> 
En boolesk variabel kan kun sættes til værdierne true 
eller false. F.eks.: 
</para> 
 
<screen> 
detErForSent = false; 
</screen> 
 
<para> 
På højre side af lighedstegnet kan stå et logisk udtryk, dvs. et 
udsagn, der enten er sandt eller falsk, f.eks.  "klokken er over 8" 
(her forestiller vi os, at vi har variablen klokken) 
</para> 
 
<screen> 
detErForSent = klokken &gt; 8; 
</screen> 
 
<para> 
Udtrykket klokken &gt; 8 undersøges af Java ved at indsætte 
værdien af variablen i regneudtrykket og derefter afgøre 
om udsagnet er sandt. Hvis f.eks. klokken=7, står der 7&gt;8, 
det er ikke sandt, og detErForSent får værdien false. 
Hvis klokken=10, står der 10&gt;8, det er sandt, og 
detErForSent får værdien true. 
</para> 
</sect2>    <!--   Logiske variabler --> 
 
<sect2 id="java-basal-prg-variable-opgaver"> 
  <title>Opgaver</title> 
 
<orderedlist> 
<listitem><para> 
Skriv et program, som ud fra længde og bredde på et 
rektangel udskriver rektanglets areal. 
</para></listitem> 
 
<listitem><para> 
Skriv et program, som for ligningen y=3*x*x+6*x+9 udskriver 
  værdierne af y for x=0, x=1 og x=10. 
</para></listitem> 
 
<listitem><para> 
Skriv et program, som omregner et beløb fra dollar til 
  euro (f.eks. kurs 95). 
</para></listitem> 
</orderedlist> 
 
</sect2>    <!--   Opgaver --> 
</sect1>    <!--   Variabler --> 
 
<sect1 id="java-basal-prg-betinget"> 
  <title>Betinget udførelse</title> 
 
<para> 
Indtil nu har vores programmer været fuldstændig 
forudsigelige. Vi har bedt computeren om at udføre den ene 
kommando efter den anden uanset udfaldet af de tidligere kommandoer. 
</para> 
 
<figure id="java-basal-prg-betinget-rutediagram1-fig"> 
<title>Logikken i en if-sætning</title> 
 
<graphic fileref="Nordfalk415345.&magic;" scale="60"></graphic> 
</figure> 
 
<para> 
I programmer kan man påvirke programudførelsen 
ved at indføre betingelser, der fortæller, at en del af 
programmet kun skal gennemløbes, hvis betingelsen er opfyldt. 
</para> 
 
<para> 
Det består af et udtryk, der enten er sandt eller falsk, og noget, der 
afhænger af dets sandhedsværdi (se <xref linkend="java-basal-prg-betinget-rutediagram1-fig">). 
</para> 
 
<para> 
Alle er bekendte med betingelser fra deres dagligdag, f.eks.: 
</para> 
 
<itemizedlist mark="bullet"> 
<listitem><para> 
hvis du er over 18, er du myndig. 
</para></listitem> 
<listitem><para> 
hvis din alkoholpromille er større end 0.5, så 
  lad bilen stå. 
</para></listitem> 
<listitem><para> 
hvis den koster mindre end 500 kr, så køb den! 
</para></listitem> 
</itemizedlist> 
 
<para> 
I Java er syntaksen 
</para> 
 
<screen> 
if (<emphasis>betingelse</emphasis>) <emphasis>kommando;</emphasis> 
</screen> 
 
<para> 
For eksempel: 
</para> 
 
<screen> 
if (alder &gt;= 18) System.out.println("Du er myndig"); 
if (alkoholpromille &gt; 0.5) System.out.println("Lad bilen stå"); 
if (pris &lt; 500) System.out.println("Jeg køber den!"); 
if (alder == 18) System.out.println("Du er præcis atten år."); 
if (alder != 18) System.out.println("Du er ikke atten."); 
</screen> 
 
<para> 
Udtrykkene i parenteserne er logiske udtryk (eller boolske udtryk). På 
dansk er sætningen "over 18" tvetydig: skal man være OVER 18, dvs. 19, 
for at være myndig? Java har derfor to forskellige 
sammenligningsoperatorer: a &gt;= b undersøger, om a er større end 
eller lig med b, mens a &gt; b undersøger om a er større end b. I 
appendiks <xref linkend="java-basal-prg-appendiks-aritmetik" /> findes en oversigt over 
sammenligningsoperatorerne. 
</para> 
 
<figure id="java-basal-prg-conf-rutediagram2-fig"> 
<title>Rutediagram for Alder</title> 
 
<graphic fileref="Nordfalk415346.&magic;" scale="60"></graphic> 
</figure> 
 
<para> 
Herunder et komplet eksempel på et program, der afgør, om man er 
myndig. Programkoden, udtrykt på dansk, kunne være: hvis alder er 
større end 18, så skriv "Du er myndig". I et javaprogram skriver man: 
</para> 
 
<screen> 
public class Alder 
{ 
  public static void main(String[] args)  
  { 
    int alder; 
    alder = 15; 
 
    <emphasis>if (alder &gt;= 18)</emphasis> 
    <emphasis>System.out.println("Du er myndig.");</emphasis> 
    System.out.println("Du er " + alder + " år."); 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
Du er 15 år. 
</screen> 
 
<para> 
Kommandoen System.out.println("Du er myndig"), bliver kun udført, hvis 
udtrykket (alder &gt; 18) er sandt. I dette tilfælde er alder = 15, og 
der bliver ikke skrevet noget ud.  Hvis vi ændrer i programmet, så 
alder = 18, er betingelsen (alder &gt;= 18) sand, og vi får: 
</para> 
 
<screen> 
Du er myndig. 
Du er 18 år. 
</screen> 
 
<para> 
Programudførelsen fortsætter under alle 
omstændigheder efter betingelsen, så uafhængigt af 
udfaldet vil linjen 
</para> 
 
<screen> 
System.out.println("Du er " + alder + " år."); 
</screen> 
 
<para> 
blive udført. 
</para> 
 
<para> 
Bemærk, oversætteren er ligeglad med indrykning, linjeskift etc. Det 
er teksten, der tæller. Vi kunne lige så godt have skrevet 
</para> 
 
<screen> 
if (alder &gt;= 18) System.out.println("Du er myndig."); 
</screen> 
 
<para> 
eller for den sags skyld 
</para> 
 
<screen> 
    if (alder &gt;= 18)  
System.out.println("Du er myndig."); 
</screen> 
 
<para> 
... men det sidste er en dårlig stil, for det gør det 
sværere at læse kildeteksten. Normalt indrykker man 2-4 
tegn, når en kommando er betinget. 
</para> 
 
<sect2 id="java-basal-prg-betinget-if-else"> 
  <title>if-else</title> 
 
<figure id="java-basal-prg-betinget-rutediagram3-fig"> 
<title>Logikken  i en if-else-sætning</title> 
 
<graphic fileref="Nordfalk415347.&magic;" scale="60"></graphic> 
</figure> 
 
<para> 
Hvis vi ønsker at gøre én ting, hvor betingelsen er sand, og en anden 
ting hvis betingelsen er falsk, kan vi føje en else-del til vores 
if-sætning. Denne del vil kun blive udført, hvis betingelsen er 
falsk. Syntaksen er: 
</para> 
 
<screen> 
if (<emphasis>betingelse</emphasis>) <emphasis>kommando1;</emphasis> 
<emphasis>else kommando2;</emphasis> 
</screen> 
 
<para> 
Eksempelvis: 
</para> 
 
<screen> 
public class Alder2 
{ 
  public static void main(String[] args)  
  { 
    int alder; 
    alder = 15; 
 
    <emphasis>if (alder &gt;= 18)</emphasis> 
      System.out.println("Du er myndig."); 
    <emphasis>else</emphasis> System.out.println("Du er ikke myndig."); 
 
    System.out.println("Du er " + alder + " år."); 
  } 
} 
</screen> 
 
 
<screen> 
Du er ikke myndig. 
Du er 15 år. 
</screen> 
 
 
<para> 
Ændrer vi så alder = 18, er betingelsen (alder &gt;= 18) sand, og vi 
får resultatet 
</para> 
 
<screen> 
Du er myndig. 
Du er 18 år. 
</screen> 
 
 
<para> 
Det er selvfølgelig lidt kedeligt at kunne se direkte i vores program 
uden at køre det, om en betingelse er opfyldt. I virkeligheden er 
betingelser kun nyttige, når forgreningen afhænger af nogle ydre 
omstændigheder, f.eks. af brugerens indtastning eller af værdien af en 
variabel fra en anden del af programmet. Hvis du bare vil prøve, kan 
du lave et ikke-forudsigeligt program med Math.random().  
</para> 
</sect2>    <!--   if-else --> 
 
<sect2 id="java-basal-prg-betinget-opgaver"> 
  <title>Opgaver</title> 
 
<orderedlist> 
<listitem><para> 
Lav et veksleprogram fra dollar til euro. Det skal påregne en 
kommission på 2 %, dog mindst 0,5 euro. Afprøv programmet med 
forskellige beløb. 
</para></listitem> 
<listitem><para> 
Skriv et program, der beregner porto for et brev. Inddata er brevets 
vægt (i gram). Uddata er prisen for at sende det som A-post i Danmark. 
</para></listitem> 
</orderedlist> 
 
</sect2>    <!--   Opgaver --> 
</sect1>    <!--   Betinget udførelse --> 
 
<sect1 id="java-basal-prg-blok"> 
  <title>Blokke</title> 
 
<para> 
En blok er en samling af kommandoer. Den starter med en 
blokstart-parentes { og slutter med en blokslut-parentes}. 
</para> 
 
<blockquote><para>En blok grupperer flere kommandoer, så 
de udføres samlet som &eacute;n kommando</para></blockquote> 
 
<para> 
Blokke bruges blandt andet, hvis man vil have mere end 
førstkommende linje udført i en betingelse. Herunder 
udføres to kommandoer, hvis betingelsen er opfyldt, og to 
andre, hvis betingelsen ikke er opfyldt: 
</para> 
 
<screen> 
public class Alder3 
{ 
  public static void main(String[] args)  
  { 
    int alder; 
    alder = 15; 
 
    if (alder &gt;= 18)  
    <emphasis>{</emphasis> // blokstart 
      System.out.println("Du er " + alder + " år."); 
      System.out.println("Du er myndig."); 
    <emphasis>}</emphasis> // blokslut  
    else  
    <emphasis>{</emphasis> // blokstart 
      System.out.println("Du er kun " + alder + " år."); 
      System.out.println("Du er ikke myndig."); 
    <emphasis>}</emphasis> // blokslut 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
Du er kun 15 år. 
Du er ikke myndig. 
</screen> 
 
<sect2 id="java-basal-prg-blok-indrykning"> 
  <title>Indrykning</title> 
 
<para> 
Læg mærke til, hvordan programkoden i blokkene i ovenstående eksempel 
er rykket lidt ind. Det gør det lettere for programmøren at overskue 
koden, så han/hun kan se, hvilken {-parentes der hører sammen med 
hvilken }-parentes. 
</para> 
 
<blockquote><para>Det er god skik at bruge indrykning i 
en blok</para></blockquote> 
<blockquote><para>Indrykning gør programmet meget 
nemmere at overskue</para></blockquote> 
 
<para> 
Her er det samme program uden indrykning. Programmet er sværere at 
overskue nu (man kunne måske komme til at tro, at de nederste to 
linjer bliver udført uafhængig af if-sætningen): 
</para> 
 
<screen> 
public class Alder3UheldigIndrykning{ 
public static void main(String[] args)  
{int alder; 
alder = 15; 
if (alder &gt;= 18) 
{ 
System.out.println("Du er " + alder + " år."); 
System.out.println("Du er myndig"); 
} else { 
System.out.println("Du er kun " + alder + " år."); 
System.out.println("Du er ikke myndig"); 
}}} 
</screen> 
 
<para> 
De fleste udviklingsværktøjer har funktioner til at rykke flere 
linjers kode ind og ud (i JBuilder gøres det ved at markere en tekst, 
og trykke Tab for at rykke ind og skift-Tab for at rykke ud). 
</para> 
</sect2>    <!--   Indrykning --> 
</sect1>    <!--   Blokke --> 
 
<sect1 id="java-basal-prg-loekke"> 
  <title>Løkker</title> 
 
<para> 
En løkke er en gentaget udførelse af en kommando, igen og igen. Hvor 
mange gange løkken udføres afhænger af et logisk udtryk. 
</para> 
 
<sect2 id="java-basal-prg-loekke-while"> 
  <title>while-løkken</title> 
 
<figure id="java-basal-prg-loekke-while-fig"> 
<title>Logikken 
  i en while-løkke</title> 
 
<graphic fileref="Nordfalk415348.&magic;" scale="60"></graphic> 
</figure> 
 
<para> 
while-løkken har formen: 
</para> 
 
<screen> 
    while (<emphasis>betingelse</emphasis>) <emphasis>kommando;</emphasis> 
</screen> 
 
<para> 
Kommandoen udføres igen og igen mens 
betingelsen er opfyldt. Dvs. før kommandoen udføres, 
undersøges betingelsen, og det kontrolleres, at den er opfyldt 
(se <xref linkend="java-basal-prg-loekke-while-fig">). 
</para> 
 
<para> 
Oftest grupperer man flere kommandoer i en blok. 
</para> 
 
<screen> 
public class Alder4 
{ 
  public static void main(String[] args)  
  { 
    int alder; 
    alder = 15; 
 
    <emphasis>while (alder &lt; 18)</emphasis> 
    <emphasis>{</emphasis> 
      System.out.println("Du er "+alder+" år. Vent til du bliver ældre."); 
      alder = alder + 1; 
      System.out.println("Tillykke med fødselsdagen!"); 
    <emphasis>}</emphasis> 
 
    System.out.println("Nu er du "+alder+" år og myndig."); 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
Du er 15 år. Vent til du bliver ældre. 
Tillykke med fødselsdagen! 
Du er 16 år. Vent til du bliver ældre. 
Tillykke med fødselsdagen! 
Du er 17 år. Vent til du bliver ældre. 
Tillykke med fødselsdagen! 
Nu er du 18 år og myndig. 
</screen> 
 
 
<figure id="java-basal-prg-loekke-while-alder4-fig"> 
<title>Rutediagram for noget af Alder4</title> 
 
<graphic fileref="Nordfalk415349.&magic;" scale="60"></graphic> 
</figure> 
<para> 
Før løkken starter, har alder en startværdi på 15. Under hvert 
gennemløb tælles variablen 1 op. På et tidspunkt, når alder er talt 
op til 18, er betingelsen ikke mere opfyldt, og programudførelsen 
fortsætter efter løkken. 
</para> 
 
<para> 
Med en løkke kan vi lave Kvadratrod-programmet nemmere. I 
stedet for at skrive den samme kommando igen og igen kan vi lave 
en løkke (sammenlign med Kvadratrod <xref linkend="java-basal-prg-variable-matematik">). 
</para> 
 
<screen> 
public class Kvadratrod2 
{ 
  public static void main(String[] args)  
  { 
    int n; 
    n = 0; 
 
    while (n &lt;= 10) 
    { 
      System.out.println("kvadratroden af "+n+" er " + <emphasis>Math.sqrt(n)</emphasis>); 
      n = n + 1; 
    } 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
kvadratroden af 0 er 0.0 
kvadratroden af 1 er 1.0 
kvadratroden af 2 er 1.4142135623730951 
kvadratroden af 3 er 1.7320508075688772 
kvadratroden af 4 er 2.0 
kvadratroden af 5 er 2.23606797749979 
kvadratroden af 6 er 2.449489742783178 
kvadratroden af 7 er 2.6457513110645907 
kvadratroden af 8 er 2.8284271247461903 
kvadratroden af 9 er 3.0 
kvadratroden af 10 er 3.1622776601683795 
</screen> 
 
 
<para> 
En tællevariabel er en variabel, der tælles op i en løkke, indtil den 
når en bestemt øvre grænse.  I eksemplerne ovenfor bruges alder og n 
som tællevariabler. 
</para> 
 
<para> 
Herunder udskriver vi 7-tabellen ved hjælp af tællevariablen n: 
</para> 
 
<figure id="java-basal-prg-loekke-while-syvtabel-fig"> 
<title>Rutediagram for Syvtabel</title> 
 
<graphic fileref="Nordfalk415350.&magic;" scale="60"></graphic> 
</figure> 
 
<screen> 
public class Syvtabel 
{ 
  public static void main(String[] args)  
  { 
    int n; 
    n = 1; 
 
    while (n &lt;= 10) 
    { 
      System.out.println(n+" : "+ 7*n); 
      n = n + 1; 
    } 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
1 : 7 
2 : 14 
3 : 21 
4 : 28 
5 : 35 
6 : 42 
7 : 49 
8 : 56 
9 : 63 
10 : 70 
</screen> 
 
<para> 
Tællevariabel-formen er den mest almindelige for løkker, men man kan 
sagtens komme ud for andre former for løkker. Der kan f.eks. godt 
indgå et regneudtryk i betingelsen. 
</para> 
</sect2>    <!--   while-løkken --> 
 
<sect2 id="java-basal-prg-loekke-for"> 
  <title>for-løkken</title> 
 
<para> 
For-løkken er specielt velegnet til løkker med en tællevariabel. Den 
har formen 
</para> 
 
<screen> 
for (<emphasis>initialisering</emphasis>; 
<emphasis>betingelse</emphasis>; <emphasis>opdatering</emphasis>) 
<emphasis>kommando;</emphasis> 
</screen> 
 
<figure id="java-basal-prg-loekke-for-fig"> 
<title>Strukturen i en for-løkke</title> 
<graphic fileref="Nordfalk415351.&magic;" scale="60"></graphic> 
</figure> 
 
<itemizedlist mark="bullet"> 
<listitem><para> 
<emphasis>initialisering</emphasis> er en (evt.: erklæring og) 
tildeling af en tællevariabel, f.eks. <literal>alder = 15</literal> 
</para></listitem> 
<listitem><para> 
<emphasis>betingelse</emphasis> er et logisk udtryk, der angiver 
  betingelsen for, at løkken skal fortsætte med at 
  blive udført,  f.eks. <literal>alder 
  &lt; 18</literal> 
</para></listitem> 
<listitem><para> 
<emphasis>opdatering</emphasis> er ændringen i tællevariablen, 
    f.eks. <literal>alder = alder + 1</literal> 
</para></listitem> 
</itemizedlist> 
 
<para> 
Det kan indenad læses som &quot;for <emphasis>startværdi</emphasis>, 
så længe <emphasis>betingelse</emphasis> udfør: 
<emphasis>kommando</emphasis> og 
<emphasis>opdatering</emphasis>&quot;, f.eks. &quot;for 
<emphasis>alder = 15</emphasis>, så længe <emphasis>alder &lt; 
18</emphasis> udfør: <emphasis>Skriv &quot;du er..&quot;</emphasis> og 
<emphasis>tæl alder 1 op&quot;</emphasis>. 
</para> 
 
<para> 
En for-løkke og en while-løkke supplerer hinanden.  De har præcis 
samme funktion, men for-løkken er mere kompakt og bekvem, når man 
ønsker at lave en almindelig løkke, der udføres et bestemt antal 
gange. Dette program gør det samme som Syvtabel-eksemplet, men med en 
for-løkke: 
</para> 
 
<figure id="java-basal-prg-loekke-for-syvtabel2-fig"> 
<title>Rutediagram for Syvtabel2 (samme som for Syvtabel)</title> 
 
<graphic fileref="Nordfalk415352.&magic;" scale="60"></graphic> 
</figure> 
 
<screen> 
public class Syvtabel2 
{ 
  public static void main(String[] args)  
  { 
    int n; 
    <emphasis>for (n=1; n&lt;=10; n=n+1)</emphasis> 
      System.out.println(n+" : "+ 7*n); 
  } 
} 
</screen> 
 
 
<para> 
Programmører er dovne væsner og bruger ofte 
for-løkken til optælling, fordi der skal skrives 
mindre end i en while-løkke. 
</para> 
 
<para> 
Man ser også ofte, at de bruger operatoren ++ til at tælle 
en variabel op i en løkke: "alder++" svarer 
altså til "alder=alder+1", men med mindre 
skrivearbejde. Tilsvarende findes --, som tæller en variabel en 
ned, f.eks. alder--. 
</para> 
</sect2>    <!--   for-løkken --> 
 
<sect2 id="java-basal-prg-loekke-indlejrede"> 
  <title>Indlejrede løkker</title> 
 
<para> 
En betingelse eller en løkke kan stå ethvert sted i 
en metode, og altså også inden i en anden løkke 
eller en betingelse. 
</para> 
 
<para> 
Herunder har vi syvtabellen igen, men denne gang "brokker" 
programmet sig, når det når op på 6, og efter 8 
skriver den "ved ikke" i stedet for at regne resultatet ud. 
</para> 
 
<screen> 
public class Syvtabel3 
{ 
  public static void main(String[] args)  
  { 
    <emphasis>for (int n=1; n&lt;=10; n++)</emphasis>  // n++ gør det samme som n=n+1 
    { 
      <emphasis>if (n == 6)</emphasis> System.out.println("puha, nu bliver det svært."); 
 
      <emphasis>if (n &lt; 8)  </emphasis> System.out.println(n+" : "+ 7*n); 
      <emphasis>else</emphasis> System.out.println(n+" : (ved ikke)"); 
    } 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
1 : 7 
2 : 14 
3 : 21 
4 : 28 
5 : 35 
puha, nu bliver det svært. 
6 : 42 
7 : 49 
8 : (ved ikke) 
9 : (ved ikke) 
10 : (ved ikke) 
</screen> 
 
 
<para> 
Vi kan også lave løkker i løkker. Herunder 
udregner vi n*7 ved at lægge 7 sammen n gange. 
</para> 
 
<screen> 
public class Syvtabel4 
{ 
  public static void main(String[] args)  
  { 
    for (int n=1; n&lt;=10; n=n+1) 
    { 
      int sum = 0; 
      for (int j=0; j&lt;n; j++) sum = sum + 7; 
 
      System.out.println(n+" : "+ sum); 
    } 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
1 : 7 
2 : 14 
3 : 21 
4 : 28 
5 : 35 
6 : 42 
7 : 49 
8 : 56 
9 : 63 
10 : 70 
</screen> 
</sect2>    <!--   Indlejrede løkker --> 
 
<sect2 id="java-basal-prg-loekke-uendelig"> 
  <title>Uendelige løkker</title> 
 
<para> 
Hvis programmøren ikke er omhyggelig, kan han komme til at lave en 
løkke, hvor betingelsen vedbliver at være sand. Så bliver 
programudførelsen i løkken i al evighed (eller indtil brugeren 
afbryder programmet). 
</para> 
 
<para> 
Lad os f.eks. sige, at programmøren er kommet til at skrive '-' i 
stedet for '+' i opdateringen af n i while-løkken fra 
Syvtabel-programmet. Nu vil computeren tælle nedad: 
</para> 
 
<screen> 
public class SyvtabelFejl 
{ 
  public static void main(String[] args)  
  { 
    for (int n=1; n&lt;=10; <emphasis>n=n-1</emphasis>) 
      System.out.println(n+" : "+ 7*n); 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
1 : 7 
0 : 0 
-1 : -7 
-2 : -14 
-3 : -21 
-4 : -28 
</screen> 
 
<para> 
... og så videre i det uendelige. Løkken vil aldrig stoppe, fordi n 
vedbliver at være mindre end 10. 
</para> 
 
<para> 
En anden faldgrube er at komme til at sætte et semikolon efter en 
while-løkke: 
</para> 
 
<screen> 
    while (n &lt;= 10); 
</screen> 
 
<para> 
Oversætteren vil tro, at der ikke er nogen kommando, der skal udføres, 
og blot undersøge betingelsen igen og igen og igen og igen... Da n 
ikke ændrer sig, vil programmet aldrig stoppe. 
</para> 
 
<para> 
Det er programmørens ansvar at sikre, at betingelsen i en løkke på et 
tidspunkt ikke mere opfyldes, så programmet ikke går i uendelig løkke. 
</para> 
</sect2>    <!--   Uendelige løkker --> 
 
<sect2 id="java-basal-prg-loekke-opgaver"> 
  <title>Opgaver</title> 
<orderedlist> 
<listitem><para> 
Prøv at køre hvert eksempel, og forvis dig om, at du forstår det.Mange 
udviklingsværktøjer understøtter trinvis gennemgang til fejlfinding 
(eng.: debugging). Prøv trinvis gennemgang i dit værktøj, og hold øje 
med variablerne. (I JBuilder og JDeveloper gøres det med F8 "step 
over"). 
</para></listitem> 
<listitem><para> 
Omskriv Alder4-programmet til at bruge en for-løkke. 
</para></listitem> 
<listitem><para> 
Lav et program, der tæller nedad fra 10 til 1. 
</para></listitem> 
<listitem><para> 
Lav et program, der udregner værdien af 1+2+3+ ... +20. 
</para></listitem> 
<listitem><para> 
Ret programmet til at udregne værdierne af 1+2+3+ ...  +n, når n er 
10, 11, .. 30 (vink: brug en indlejret løkke). 
</para></listitem> 
<listitem><para> 
Lav et program, der udskriver 1-tabellen, 2-tabellen, .. op 
til 10-tabellen. 
</para></listitem> 
<listitem><para> 
Skriv et program, som for ligningen y=3*x*x+6*x+9 udskriver værdierne 
af y for x=0, x=1,x= 2, x=3 ... x=10. Ret det derefter til at skrive 
ud for x=0,x=10,x=20,x=30...x=100. 
</para></listitem> 
</orderedlist> 
</sect2>    <!--   Opgaver --> 
</sect1>    <!--   Løkker --> 
 
<sect1 id="java-basal-prg-typekonv"> 
  <title>Værditypekonvertering</title> 
 
<para> 
Java er det, man kalder et stærkt typet sprog. Det betyder, at alle 
variabler og værdier har en bestemt type gennem hele deres levetid, og 
at der er visse begrænsninger for, hvilke værdier man kan tildele en 
variabel. Når man først har vænnet sig til det, er det en stor hjælp, 
fordi oversætteren på denne måde ofte fanger fejl i 
programmerne. Desuden gør det, at computeren hurtigere kan udføre 
beregninger. 
</para> 
 
<para> 
I Java kan man f.eks. ikke lægge en double-værdi ind i en 
int-variabel: 
</para> 
 
<screen> 
int x; 
x=2.7;  // Fejl. 
</screen> 
 
<para> 
Forsøger man på dette, vil man få oversætter-fejlen: 
<emphasis>Possible loss of precision: double, required: 
int</emphasis>. 
</para> 
 
<para> 
&Aring;rsagen til, at vi i Java ikke kan gemme 2.7 i x, kan forstås på 
to måder: 
</para> 
 
<orderedlist> 
<listitem><para> 
x har kun plads i lageret til at gemme hele tal (fra -2 mia. 
til +2 mia). 
</para></listitem> 
<listitem><para> 
x er erklæret som en int, og skal derfor blive ved med at være en 
int. I de efterfølgende beregninger kan det have stor betydning, om x 
har en kommadel. Programmøren skal derfor kunne se på, hvordan x er 
erklæret, og derefter være helt sikker på, hvilke værdier x kan 
indeholde. 
</para></listitem> 
</orderedlist> 
 
<para> 
Begge måder at forstå årsagen på er 
rigtige og gyldige. 
</para> 
 
<para> 
For at kunne gemme 2.7 i x bliver man derfor nødt til at lave 2.7 om 
til en int-værdi. Det kaldes at typekonvertere værdien. Dette er ikke 
helt uden problemer. Der er åbenlyst et informationstab, da kommadelen 
af værdien må fjernes.  Derudover kunne double-værdien være 5 mia. i 
stedet for 2.7, og det er der ikke plads til i en int. Et tredje 
problem er, at man skal vælge, hvordan man vil udføre 
konverteringen. Skal man afrunde korrekt til 3, eller nedrunde til 2? 
Det første tager lidt mere tid end det sidste. 
</para> 
 
<para> 
Af disse årsager bliver man i nogle tilfælde nødt til eksplicit at 
fortælle oversætteren, at den skal foretage en værdi-typekonvertering. 
</para> 
 
<sect2 id="java-basal-prg-typekonv-explicit"> 
  <title>Eksplicit værdi-typekonvertering</title> 
 
<para> 
Man konverterer en værdi til en anden type ved at skrive det 
eksplicit (eng.: cast) med: 
</para> 
 
<screen> 
int x; 
x = (int) 2.7; 
</screen> 
 
<para> 
Inde i parentesen skriver man typen, som værdien lige til højre skal 
konverteres til. Denne form for typekonvertering runder altid ned til 
nærmeste hele tal. 
</para> 
</sect2>    <!--   Eksplicit værdi-typekonvertering --> 
 
<sect2 id="java-basal-prg-typekonv-implicit"> 
  <title>Implicit værdi-typekonvertering</title> 
 
<para> 
Implicit typekonvertering betyder, at oversætteren selv 
laver konverteringen, uden at programmøren behøver at 
skrive noget særligt om, at den skal gøre det. 
</para> 
 
<screen> 
double y; 
y=4;   // OK: Implicit værdi-typekonvertering. 
</screen> 
 
<para> 
Selvom 4 er en int-værdi, kan y godt indeholde den, da den 
svarer til double-værdien 4.0. Denne form for typekonvertering 
er således ikke nær så problematisk som i det 
tidligere eksempel. 
</para> 
 
<para> 
En tommelfingerregel i Java er, at når modtagertypen kan 
indeholde hele intervallet af mulige værdier for afsendertypen, 
kan den være implicit. I appendikset sidst i dette kapitel 
findes en tabel over typerne. 
</para> 
</sect2>    <!--   Implicit værdi-typekonvertering --> 
 
<sect2 id="java-basal-prg-typekonv-misconception"> 
  <title>Misforståelser af værdi-typekonvertering</title> 
 
<para> 
Bemærk, at det kun er <emphasis>værdien</emphasis>, der bliver 
konverteret. Variablen bliver ikke ændret. 
</para> 
 
<screen> 
int x; 
double y; 
y=2.7; 
<emphasis>x=(int)y</emphasis>;              // punkt A 
System.out.println(x); 
System.out.println(y); // y er upåvirket af typekonverteringen 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
2 
2.7 
</screen> 
 
<para> 
Man kunne måske fristes til at tro, at i punkt A konverteres variablen 
y til en variabel af typen int, men det ville så betyde, at den sidste 
linje i uddata skulle være 2. Men husk at: 
</para> 
 
<blockquote><para>En variabels type er altid som den er 
erklæret - den kan ikke ændre type</para></blockquote> 
 
<para> 
Det der sker i ovenstående er, at y's værdi (2.7) læses, en 
konverteret værdi (2) beregnes og denne værdi lægges ind i x. 
</para> 
 
<para> 
En anden misforståelse er at tro, at oversætteren kan se at noget er 
lovligt ud fra de øvrige programlinjer, f.eks.: 
</para> 
 
<screen> 
int x; 
double y; 
y=4.0; 
x=y;    // Fejl - her stopper oversætteren med "Possible loss of precision" 
</screen> 
 
 
<para> 
I ovenstående tilfælde kunne man tro, at man kan bruge implicit 
typekonvertering, fordi oversætteren kan se at y altid er 4.0, og at 
der derfor ikke går information tabt. Men så klog er oversætteren 
ikke. Når den skal afgøre, om den kan lave implicit typekonvertering, 
kigger den <emphasis>kun</emphasis> på typerne af variabler og 
værdier. Den skeler ikke til resten af programmet. 
</para> 
</sect2>    <!--   Misforståelser af værdi-typekonvertering --> 
</sect1>    <!--   Værditypekonvertering --> 
 
<sect1 id="java-basal-prg-fejl"> 
  <title>Fejl</title> 
 
<para> 
Som sagt udfører computeren programmet instruktion  
 som en kogebogsopskrift. Computeren forstår 
ikke programmet, men udfører blot det, programmøren 
(kogebogsforfatteren) har skrevet. 
</para> 
 
<sect2 id="java-basal-prg-fejl-logiske"> 
  <title>Indholdsmæssige (logiske) fejl</title> 
 
<para> 
Da maskinen ikke forstår programmet, kan den heller ikke 
rette op på fejlene i programmørens opskrift eller 
forstå, hvad programmøren "mener" med det, han 
skrev. Man kan altså sagtens komme til at lave et program, der 
gør noget andet end det, der var tilsigtet: 
</para> 
 
<screen> 
public class ProgramMedFejl 
{ 
  public static void main (String[] args) 
  { 
    System.out.println("Hej Verdne!"); 
    int sum = 2 - 2; 
    System.out.println("2 og 2 er "+sum); 
  } 
} 
</screen> 
 
<para> 
Resultatet bliver 
</para> 
 
<screen> 
Hej Verdne! 
2 og 2 er 0 
</screen> 
 
<para> 
Dette eksempel har en stavefejl og en forkert udregning. I  
<xref linkend="java-basal-prg-loekke-uendelig" /> 
om uendelige løkker så vi en anden fejl, der 
gjorde, at programmet aldrig stoppede. Et andet eksempel kunne være 
et skatteprogram, der glemmer at tage højde for bundfradraget. 
</para> 
</sect2>    <!--   Indholdsmæssige (logiske) fejl --> 
 
<sect2 id="java-basal-prg-fejl-sproglige"> 
  <title>Sproglige fejl</title> 
 
<para> 
Mens computeren ikke har mulighed for at finde indholdsmæssige fejl i 
programmerne, kan den godt finde sproglige og syntaksmæssige 
problemer, dvs. hvis kildeteksten gør brug af ukendte variable eller 
metoder eller ikke er gyldig i forhold til sprogets syntaks (den 
formelle definition af, hvordan man skriver javakode). 
</para> 
 
<para> 
Hvis der er sproglige fejl i kildeteksten, kan den ikke oversættes til 
bytekode, så man kan altså overhovedet ikke komme til at prøve sit 
program. De følgende instruktioner er alle forkerte, og vil blive 
fanget under oversættelsen af programmet. Ofte kan fejlmeddelelsen 
overraske lidt, men med lidt øvelse kan man lære at forstå den 
"firkantede", måde som computeren "tænker" på: 
</para> 
 
<screen> 
    System.out.println(&quot;Hej verden!); 
</screen> 
 
<para> 
Her mangler en slut-&quot; til at markere, hvor strengen stopper. 
Oversætteren skriver <emphasis>unclosed character 
literal</emphasis>. Den kan ikke regne ud, at strengen slutter lige 
før ')'. 
</para> 
 
<screen> 
System.out.pintln("Hej verden!"); 
</screen> 
 
<para> 
 
Kaldet til println er stavet forkert. Oversætteren skriver 
<emphasis>method pintln(java.lang.String) not found in class 
java.io.PrintStream</emphasis>. Den kan ikke finde ud af, at man mener 
p<emphasis>r</emphasis>intln (med r) i stedet for pintln. 
</para> 
 
<screen> 
system.out.println("Hej verden!"); 
</screen> 
 
<para> 
 
System er stavet forkert (med småt). Oversætteren skriver 
<emphasis>cannot access class system.out; neither class nor source found for 
system.out</emphasis>. Den skelner mellem store og små bogstaver og 
kan ikke se, at man mener System (med stort) i stedet for system. 
</para> 
 
<screen> 
System.out.println(Hej verden!); 
</screen> 
 

 
<para> 
 
Der mangler &quot; til at markere, hvor strengen starter og slutter. 
Oversætteren skriver <emphasis>')' expected</emphasis> og peger lige 
efter Hej. Den forstår ikke at "Hej verden!" er en tekststreng, når 
&quot;-tegnene mangler, og mener derfor, at 'Hej' og 'verden!' skal 
behandles adskilt. 
</para> 
 
<para> 
Når man skal finde en fejl, gælder det om at nærlæse fejlmeddelelsen 
og programkoden omkring stedet, hvor fejlen er, og at huske, at 
computeren følger faste regler, men ikke forstår hvad der 
foregår. F.eks. er den sidste fejlmeddelelse <emphasis>')' 
expected</emphasis> ikke særlig sigende, da fejlen formentlig er, at 
der mangler &quot;-tegn. 
</para> 
 
<para> 
Det kan være banaliteter, der er årsag til sprogfejl. 
Det giver ofte anledning til sprogfejl, at folk glemmer, at der er 
forskel på store og små bogstaver. 
</para> 
 
<blockquote><para>Java skelner altid mellem store og små 
bogstaver</para></blockquote> 
<blockquote><para>Det er god stil konsekvent at skrive 
klassenavne med stort og variabler og metoder med småt</para></blockquote> 
</sect2>    <!--   Sproglige fejl --> 
 
<sect2 id="java-basal-prg-fejl-koeretid"> 
  <title>Køretidsfejl</title> 
 
<para> 
Visse fejl opstår først ved udførelsen af 
programmet. Selvom alting er syntaktisk korrekt, opstår der 
alligevel en undtagelse fra den normale programudførelse. 
Herunder ses et program, der stopper på grund af division med 
0. 
</para> 
 
<screen> 
public class ProgramMedFejl2 
{ 
  public static void main (String[] args) 
  { 
    int a,b,c; 
 
    a = 5; 
    b = 6; 
 
    c = b/(a-5); 
    System.out.println("c = "+c); 
  } 
} 
</screen> 
 
<screen> 
Exception in thread "main" java.lang.ArithmeticException: / by zero 
        at ProgramMedFejl2.main(ProgramMedFejl2.java:10) 
</screen> 
 
<para> 
Køretidsfejl forårsager, at der opstår en 
undtagelse (eng.: exception), som, hvis den ikke håndteres, 
stopper programudførelsen (populært: programmet går 
ned). Dette vil blive behandlet grundigere i kapitlet om undtagelser. 
</para> 
</sect2>    <!--   Køretidsfejl --> 
</sect1>    <!--   Fejl --> 
 
<sect1 id="java-basal-prg-opgaver"> 
  <title>Opgaver</title> 
 
<sect2 id="java-basal-prg-opgaver-befordringsfradrag"> 
  <title>Befordringsfradrag</title> 
 
<para> 
Lav et program, som udregner befordringsfradraget (det der kan 
trækkes fra i skat ud fra, hvor langt der er mellem arbejde og 
hjem). 
</para> 
 
<orderedlist> 
<listitem><para> 
Udregn, og udskriv fradraget pr. dag fra 25 til 75 km på 
  hver sin linje. 
</para></listitem> 
<listitem><para> 
Udregn, og udskriv fradraget pr. dag fra 25 til 150 km på 
  hver sin linje. 
</para></listitem> 
<listitem><para> 
Udregn, og udskriv fradraget pr. dag fra 10 til 150 km på 
  hver sin linje. Kun hver 10. km udskrives (10km, 20km, 30km...). 
</para></listitem> 
</orderedlist> 
 
<para> 
Reglerne for fradraget for år 2000 var følgende: 
</para> 
 
<itemizedlist> 
<listitem><para> 
første 24 km  intet fradrag 
</para></listitem> 
<listitem><para> 
25  - 100 km  154 øre pr. km 
</para></listitem> 
<listitem><para> 
over 100 km  77 øre pr. km 
</para></listitem> 
</itemizedlist> 
 
</sect2>    <!--   Befordringsfradrag --> 
 
<sect2 id="java-basal-prg-opgaver-kurveprogram"> 
  <title>Kurveprogram</title> 
 
<orderedlist> 
<listitem><para> 
Skriv et program, der tegner grafen over kvadratrod-funktionen 
(Math.sqrt()).Vink: Når du vil skrive en "*" uden linjeskift kan du 
bruge System.out.print("*") (dvs. uden 'ln'). Når du vil skifte linje, 
kan du bruge System.out.println() uden parametre. 
</para></listitem> 
<listitem><para> 
Lav kurveprogrammet om, så det i stedet viser kurven over polynomiet 
0.2*x*x +0.5*x +2. Lav programmet, så det er nemt at se, hvor man skal 
rette for at ændre funktionen, intervalstart, intervalslut, skalering 
og forskydning af y-aksen.  Dvs. lav det til variabler, og brug 
kommentarer til at markere stederne i programmet. 
</para></listitem> 
<listitem><para> 
Lav om på kurvetegningsprogrammet, så kurven ikke er udfyldt, men kun 
en streg. 
</para></listitem> 
<listitem><para> 
Eventuelt: Udvid kurveprogrammet til at udregne det totale antal af 
stjerner, der skrives ud (udregn integralet af funktionen numerisk ved 
at summere arealet under grafen). Er det nemmest at gøre løbende, mens 
stjernerne tegnes, eller bagefter? Hvordan ville du gøre på den ene og 
på den anden måde? 
</para></listitem> 
</orderedlist> 
</sect2> 
 
</sect1>  <!-- opgaver --> 
 
<sect1 id="java-basal-prg-appendiks"> 
<title>Appendiks</title> 
 
<para> 
Dette afsnit sætter det, du har lært i kapitlet, i 
system og kan senere bruges som opslagsværk. Enkelte 
steder står der noget, som ikke er gennemgået endnu, men 
som er med for helhedens skyld. 
</para> 
 
<sect2 id="java-basal-prg-appendiks-navneregler"> 
  <title>Navngivningsregler</title> 
 
<para> 
Variabler og metoder bør have lille startbogstav. 
</para> 
 
<para> 
Eksempler: n, alder, tal, talDerSkalUndersøges, main(), 
println(), sqrt(). 
</para> 
 
<para> 
Klasser bør have stort startbogstav. 
</para> 
 
<para> 
Eksempler: HejVerden, Cylinderberegning, Syvtabel2 
</para> 
 
<para> 
Består navnet af flere ord, stryger man normalt 
mellemrummene og lader hvert af de efterfølgende ord 
starte med stort (nogen bruger også understreg _ som 
mellemrum). 
</para> 
 
<itemizedlist mark="bullet"> 
<listitem><para> 
Navnet kan bestå af A-&Aring;, a-å, 0-9, $ og _ 
</para></listitem> 
<listitem><para> 
Det må ikke starte med et tal. Det kan have en 
  vilkårlig længde. 
</para></listitem> 
<listitem><para> 
Lovlige navne: peter, Peter, $antal, var2, J2EE, 
  dette_er_en_test 
</para></listitem> 
<listitem><para> 
Ulovlige navne: 7eleven, dette-er-en-test, peter# 
</para></listitem> 
</itemizedlist> 
 
<para> 
Da visse styresystemer endnu ikke understøtter æ, ø og å i filnavne, 
bør man undgå disse i klassenavne. 
</para> 
</sect2>    <!--   Navngivningsregler --> 
 
<sect2 id="java-basal-prg-appendiks-simpletyper"> 
  <title>De simple typer</title> 
 
<para> 
Her er en oversigt over alle de simple variabeltyper i Java. 
</para> 
 
<table id="tal-1-java"> 
<title>Simple variabeltyper i Java</title> 
<tgroup cols="5" align="char"> 
<thead> 
<row> 
 <entry> 
   Type 
 </entry> 
 <entry> 
   Art 
 </entry> 
 <entry> 
   Antal bit 
 </entry> 
 <entry> 
   Mulige værdier 
 </entry> 
 <entry> 
   Standardværdi 
 </entry> 
</row> 
</thead> 
 
<tbody> 
<row> 
<entry> 
byte 
</entry> 
<entry> 
heltal 
</entry> 
<entry> 
8 
</entry> 
<entry> 
-128 til 127 
</entry> 
<entry> 
0 
</entry> 
</row> 
 
<row> 
<entry> 
short 
</entry> 
<entry> 
heltal 
</entry> 
<entry> 
16 
</entry> 
<entry> 
-32768 til 32767 
</entry> 
<entry> 
0 
</entry> 
</row> 
 
<row> 
<entry> 
int 
</entry> 
<entry> 
heltal 
</entry> 
<entry> 
32 
</entry> 
<entry> 
-2147483648 til 2147483647 
</entry> 
<entry> 
0 
</entry> 
</row> 
 
<row> 
<entry> 
long 
</entry> 
<entry> 
heltal 
</entry> 
<entry> 
64 
</entry> 
<entry> 
-9223372036854775808 til 9223372036854775807 
</entry> 
<entry> 
0 
</entry> 
</row> 
 
<row> 
<entry> 
float 
</entry> 
<entry> 
kommatal 
</entry> 
<entry> 
32 
</entry> 
<entry> 
&plusmn;1.40239846E-45 til &plusmn;3.40282347E+38 
</entry> 
<entry> 
0.0 
</entry> 
</row> 
 
<row> 
<entry> 
double 
</entry> 
<entry> 
kommatal 
</entry> 
<entry> 
64 
</entry> 
<entry> 
&plusmn;4.94065645841246544E-324 til 
&plusmn;1.79769313486231570E+308 
</entry> 
<entry> 
0.0 
</entry> 
</row> 
 
<row> 
<entry> 
char 
</entry> 
<entry> 
unicode 
</entry> 
<entry> 
16 
</entry> 
<entry> 
\u0000 til \uffff (0 til 65535) 
</entry> 
<entry> 
\u0000 
</entry> 
</row> 
 
<row> 
<entry> 
boolean 
</entry> 
<entry> 
logisk 
</entry> 
<entry> 
1 
</entry> 
<entry>true og false 
</entry><entry>false 
</entry></row> 
</tbody> 
 
</tgroup> 
</table> 
 
<para> 
De vigtigste er int, double og boolean. I enkelte tilfælde 
bliver long og char også brugt, mens byte, short og float meget 
sjældent bruges. 
</para> 
</sect2>    <!--   De simple typer --> 
 
<sect2 id="java-basal-prg-appendiks-typekonv"> 
  <title>Værditypekonvertering</title> 
 
<para> 
Konvertering til en anden type sker automatisk i de tilfælde, 
hvor der ikke mistes information (forstået på den 
måde, at intervallet af de mulige værdier udvides), dvs. 
</para> 
 
<itemizedlist mark="bullet"> 
  <listitem> 
 
<para> 
 
fra byte til short, int, long, float eller double 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
fra short til int, long, float eller double 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
fra int til long, float eller double 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
fra long til float eller double 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
fra float til double. 
</para> 
 
</listitem> 
</itemizedlist> 
 
<para> 
Den anden vej, dvs. hvor der muligvis mistes information, fordi 
intervallet af mulige værdier indsnævres, skal man 
skrive en eksplicit typekonvertering. 
</para> 
 
<para> 
Det gøres ved at skrive en parentes med typenavnet foran 
det, der skal konverteres: 
</para> 
 
<screen> 
int x; 
double y; 
y = 3.8; 
x = (int) y 
</screen> 
 
 
<para> 
 
Her skæres kommadelen af 3.8 væk og x får værdien 
3. 
</para> 
 
<para> 
Eksplicit typekonvertering sikrer at programmøren er 
bevidst om informationstabet (glemmes dette kommer oversætteren 
med fejlen: possible loss of precision: double, required: int). 
Det skal ske 
</para> 
 
<itemizedlist mark="bullet"> 
  <listitem> 
 
<para> 
 
fra double til float, long, int, short, char eller byte 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
fra float til long, int, short, char eller byte 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
fra long til int, short, char eller byte 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
fra int til short, char eller byte 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
fra short til char eller byte 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
fra byte til char 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
fra char til short eller byte. 
</para> 
 
</listitem> 
</itemizedlist> 
 
<para> 
Der kan ikke typekonverteres til eller fra boolean. 
</para> 
</sect2>    <!--   Værditypekonvertering --> 
 
<sect2 id="java-basal-prg-appendiks-aritmetik"> 
  <title>Aritmetiske operatorer</title> 
<table> 
<title>Java</title> 
<tgroup cols="0" align="char"> 
<thead> 
<row> 
<entry> 
Operator 
</entry> 
<entry> 
Brug 
</entry> 
<entry> 
Forklaring 
</entry> 
</row> 
</thead> 
 
<tbody> 
    <row> 
      <entry>+ 
</entry><entry>a + b 
</entry><entry>a lagt sammen med b 
</entry></row> 
<row> 
      <entry>- 
</entry><entry>a - b 
</entry><entry>b trukket fra a 
</entry></row> 
<row> 
      <entry>* 
</entry><entry>a * b 
</entry><entry>a gange b 
</entry></row> 
<row> 
      <entry>/ 
</entry><entry>a / b 
</entry><entry>a divideret med b 
</entry></row> 
<row> 
      <entry>% 
</entry><entry>a % b 
</entry><entry>rest fra heltalsdivision af a med b 
</entry></row> 
<row> 
<entry> 
- 
</entry> 
<entry> 
-a 
</entry> 
<entry> 
den negative værdi af a 
</entry> 
</row> 
<row> 
      <entry>++ 
</entry><entry>a++ 
</entry><entry>a = a+1; værdi før optælling 
</entry></row> 
<row> 
      <entry>++ 
</entry><entry>++a 
</entry><entry>a = a+1; værdi efter optælling 
</entry></row> 
<row> 
      <entry>-- 
</entry><entry>a-- 
</entry><entry>a = a-1; værdi før nedtælling 
</entry></row> 
<row> 
      <entry>-- 
</entry><entry>--a 
</entry><entry>a = a-1; værdi efter nedtælling 
</entry></row> 
</tbody> 
 
</tgroup> 
</table> 
 
<para> 
Operatorerne giver altid samme type som operanderne, der indgår. 
Det skal man være specielt opmærksom på for / 
(divisions) vedkommende, hvor resten mistes ved heltalsdivision. 
</para> 
 
<para> 
Operatoren ++ tæller en variabel op med &eacute;n : a++ 
svarer til a=a+1. Tilsvarende er a-- det samme som a=a-1. 
</para> 
</sect2>    <!--   Aritmetiske operatorer --> 
 
<sect2 id="java-basal-prg-appendiks-logik"> 
  <title>Regning med logiske udtryk</title> 
 
<para> 
u1 og u2 er to logiske udtryk eller logiske variabler 
</para> 
 
<table> 
<title>Java</title> 
<tgroup cols="0" align="char"> 
<thead> 
    <row> 
      <entry> 
Operator 
</entry> 
<entry> 
Brug 
</entry> 
<entry> 
Forklaring 
</entry> 
</row> 
</thead> 
 
<tbody> 
    <row> 
      <entry>&amp;&amp; 
</entry><entry>u1 &amp;&amp; u2 
</entry><entry>både u1 og u2 er sandt 
</entry></row> 
<row> 
      <entry>|| 
</entry><entry>u1 || u2 
</entry><entry>u1 eller u2 er sandt 
</entry></row> 
<row> 
      <entry>! 
</entry><entry>! u1 
</entry><entry>negation af u1 
</entry></row> 
</tbody> 
 
</tgroup> 
</table> 
 
<para> 
<emphasis>Operator &amp;&amp;</emphasis> udtrykker, at både 1. <emphasis>og</emphasis> 
2. udtryk skal være sandt: 
</para> 
 
<table> 
<title>Java</title> 
<tgroup cols="3" align="char"> 
<thead> 
    <row> 
 
<entry> 
1. udtryk 
</entry> 
<entry> 
2. udtryk 
</entry> 
<entry> 
1. udtryk &amp;&amp; 2. udtryk 
</entry> 
</row> 
</thead> 
 
<tbody> 
    <row> 
      <entry>FALSK 
</entry><entry>FALSK 
</entry><entry>FALSK 
</entry></row> 
<row> 
      <entry>FALSK 
</entry><entry>SAND 
</entry><entry>FALSK 
</entry></row> 
<row> 
      <entry>SAND 
</entry><entry>FALSK 
</entry><entry>FALSK 
</entry></row> 
<row> 
      <entry>SAND 
</entry><entry>SAND 
</entry><entry>SAND 
</entry></row> 
</tbody> 
 
</tgroup> 
</table> 
 
<para> 
F.eks. er udsagnet (a &gt; 5 &amp;&amp; a &lt; 10) sandt, hvis a 
er større end 5, og a er mindre end 10. 
</para> 
 
<para> 
<emphasis>Operator ||</emphasis> udtrykker, at 1. <emphasis>eller</emphasis> 2. udtryk skal 
være sandt. 
</para> 
 
<table> 
<title>Java</title> 
<tgroup cols="3" align="char"> 
<thead> 
    <row> 
 
<entry> 
1. udtryk 
</entry> 
<entry> 
2. udtryk 
</entry> 
<entry> 
1. udtryk || 2. udtryk 
</entry> 
</row> 
</thead> 
 
<tbody> 
    <row> 
      <entry>FALSK 
</entry><entry>FALSK 
</entry><entry>FALSK 
</entry></row> 
<row> 
      <entry>FALSK 
</entry><entry>SAND 
</entry><entry>SAND 
</entry></row> 
<row> 
      <entry>SAND 
</entry><entry>FALSK 
</entry><entry>SAND 
</entry></row> 
<row> 
      <entry>SAND 
</entry><entry>SAND 
</entry><entry>SAND 
</entry></row> 
</tbody> 
 
</tgroup> 
</table> 
 
<para> 
F.eks. er udsagnet (a &gt; 5 || a == 0) sandt, hvis a er større 
end 5, eller a er 0. 
</para> 
 
<para> 
<emphasis>Operator !</emphasis> Udtrykker, at udtrykket skal <emphasis>negeres</emphasis>, 
dvs. at (!u1) er sandt, hvis u1 er falsk, og falsk hvis u1 er sandt, 
f.eks. er udsagnet (!(a &gt; 5)) sandt, hvis der ikke gælder at 
a er større end 5 (det er det samme som (a &lt;= 5)). 
</para> 
 
<para> 
I visse andre programmeringssprog skrives AND for &amp;&amp;, OR 
for || og NOT for ! 
</para> 
</sect2>    <!--   Regning med logiske udtryk --> 
 
<sect2 id="java-basal-prg-appendiks-sammenligning"> 
  <title>Sammenligningsoperatorer</title> 
<table> 
<title>Java</title> 
<tgroup cols="3" align="char"> 
<thead> 
<row> 
<entry> 
Operator 
</entry>       
<entry> 
Brug 
</entry> 
<entry> 
Forklaring 
</entry> 
</row> 
</thead> 
 
<tbody> 
    <row> 
      <entry>&gt; 
</entry><entry>a &gt; b 
</entry><entry>a større end b 
</entry></row> 
<row> 
      <entry>&gt;= 
</entry><entry>a &gt;= b 
</entry><entry>a større end el. lig med b 
</entry></row> 
<row> 
      <entry>&lt; 
</entry><entry>a &lt; b 
</entry><entry>a mindre end b 
</entry></row> 
<row> 
      <entry>&lt;= 
</entry><entry>a &lt;= b 
</entry><entry>a mindre end el. lig med b 
</entry></row> 
<row> 
      <entry> == 
</entry><entry>a == b 
</entry><entry>a er lig med (identisk med) b 
</entry></row> 
<row> 
      <entry>!= 
</entry><entry>a != b 
</entry><entry>a forskellig fra b 
</entry></row> 
</tbody> 
 
</tgroup> 
</table> 
</sect2>    <!--   Sammenligningsoperatorer --> 
 
<sect2 id="java-basal-prg-appendiks-programmeringsraad"> 
  <title>Gode råd om programmering</title> 
<itemizedlist mark="bullet"> 
  <listitem> 
 
<para> 
 
Gennemtænk problemstillingen, inden du sætter dig 
  til computeren. 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
Formul&eacute;r problemet eller formålet med 
  programmet. 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
Overvej mulige løsningsstrategier. De fleste problemer 
  kan løses på mere end &eacute;n måde. 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
Lav en skitse til programmet i pseudokode (på papiret 
  med danske ord). Du kan også tegne flowdiagrammer (der 
  beskriver rækkefølgen tingene sker i). 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
Det er ikke altid, man kan tænke hele programmet 
  igennem på forhånd. Ved mere komplicerede programmer må 
  man skifte mellem kodning og refleksion over koden. 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
Når du sidder ved computeren, så skriv ganske få 
  linjer ad gangen, og afprøv. På den måde er det 
  ofte lettere at se problemet, hvis programmet ikke virker. 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
Gør flittigt brug af System.out.println(...) til at 
  kontrollere, om programmet gør som forventet. 
</para> 
 
</listitem> 
 
  <listitem> 
 
<para> 
Lær en standardiseret indrykning fra starten og følg 
  den stringent (Se afsnit <xref linkend="java-basal-prg-blok" />). 
</para> 
 
</listitem> 
</itemizedlist> 
 
</sect2>    <!--   Gode råd om programmering --> 
</sect1>    <!--   Appendiks --> 
 
</chapter>    <!--   Basal programmering --> 
 
