<chapter>
  <title>Basal programmering</title>
<sect1>
  <title>xxx</title>

<para>
Indhold:
</para>

<itemizedlist mark="bullet">
  <listitem>

<para>

Variabler, tildelinger og regneudtryk
</para>

</listitem>

  <listitem>

<para>
Forgreninger og løkker
</para>

</listitem>

  <listitem>

<para>
Kald af metoder
</para>

</listitem>
</itemizedlist>

<para>
Kapitlet forudsættes i resten af bogen.
</para>

<sect2>
  <title>Det første javaprogram</title>

<para>
Lad os se på et simpelt javaprogram, der skriver &quot;Hej
verden&quot; og et citat af Storm P. ud til skærmen. Neden
under den vandrette linie er vist, hvad der sker, hvis programmet
køres:
</para>

<screen>
// Et simpelt program, der skriver &quot;Hej verden&quot; 
// og et citat af Storm P. ud til skærmen
// filnavn: HejVerden.java
public class HejVerden
{
  public static void main (String[] arg)
  {
    System.out.println(&quot;Hej Verden!&quot;);
    System.out.println(&quot;Hvornår smager en Tuborg bedst?&quot;);
    System.out.println(&quot;Hvergang!&quot;);
  }
}
</screen>


<screen>
Hej Verden!
Hvornår smager en Tuborg bedst?
Hvergang!
</screen>


<para>
Alle javaprogrammer har den samme grundlæggende struktur,
som også kan ses af dette eksempel.
</para>

<sect3>
  <title>Kommentarer</title>

<para>
Kommentarer er dokumentation beregnet på at gøre
programmets kildetekst lettere at forstå. De påvirker
ikke programudførelsen. De første 3 linier, der starter
med //, er kommentarer:
</para>

<screen>
<emphasis>// Et simpelt program, der skriver &quot;Hej verden&quot; </emphasis>
<emphasis>// og et citat af Storm P. ud til skærmen</emphasis>
<emphasis>// filnavn: HejVerden.java</emphasis>
</screen>


<para>
I dette tilfælde er der beskrevet, hvad programmet gør,
og hvilket filnavn kildeteksten bør gemmes i.
</para>

<blockquote><para>Kommentarer bliver sprunget over og
har ingen indflydelse på programmet</para></blockquote>
<blockquote><para>Kommentarer bør skrives, så
de giver forståelse for, hvordan programmet virker&nbsp;-&nbsp;uden
at være tvetydige eller forklare indlysende ting</para></blockquote>

<para>
// markerer, at resten af linien er en kommentar. Den kan også
bruges efter en kommando, til at forklare hvad der sker, f.eks.
</para>

<screen>
    System.out.println(&quot;Hej verden!&quot;);  <emphasis>// Udskriv en hilsen</emphasis>
</screen>


<para>
Java har også en anden form, som kan være nyttig til
kommentarer over flere linier: Man kan starte en kommentar med /* og
afslutte den med */. Al tekst mellem /* og */ bliver så
opfattet som kommentarer. Vi kunne altså også skrive
</para>

<screen>
<emphasis><emphasis>/*</emphasis></emphasis>
<emphasis>Et simpelt program, der skriver &quot;Hej verden&quot; </emphasis>
<emphasis>og et citat af Storm P. ud til skærmen</emphasis>
<emphasis>filnavn: HejVerden.java</emphasis>
<emphasis><emphasis>*/</emphasis></emphasis>
</screen>


<para>

og
</para>

<screen>
    System.out.println(&quot;Hej verden!&quot;);  <emphasis><emphasis>/*</emphasis> Udskriv en hilsen <emphasis>*/</emphasis></emphasis>
</screen>


<para>
I denne bog skriver vi kommentarer i kursiv for at lette læsningen
af eksemplerne.
</para>
</sect3>    <!--   Kommentarer -->

<sect3>
  <title>Klassedefinitionen</title>

<para>
Resten af teksten kaldes en klassedefinition og beskriver selve
programmet (HejVerden).
</para>

<para>
Den består af en fast struktur:
</para>

<screen>
public class HejVerden
{
  public static void main (String[] arg)
  {
    ...
  }
}
</screen>


<para>
og noget programkode - kommandoer, der skal udføres,
nærmest som en bageopskrift:
</para>

<screen>
    System.out.println(&quot;Hej verden!&quot;);
</screen>

<sect4>
  <title>Strukturdelen</title>

<para>
Strukturdelen vil ikke blive ændret i de næste to
kapitler, og det er ikke så vigtigt, at du forstår, hvad
der foregår i første omgang.
</para>

<para>
Al javakode er indkapslet i en klasse mellem { og } (blokstart og
blokslut-parenteser). Beskrivelsen af en klasse er altid
indkapslet i en blok bestående af :
</para>

<screen>
public class HejVerden
{
  ...
}
</screen>


<para>
Inde i klassen står der en main-metode med nogle kommandoer
i.
</para>

<screen>
  public static void main (String[] arg)
  {
    ...
  }
</screen>


<para>
Indholdet af metoden er altid indkapslet i en blok med { og }:
</para>

<blockquote><para>Programudførelsen starter i
metoden:  public static void main
(String[] arg)</para></blockquote>
</sect4>    <!--   Strukturdelen -->

<sect4>
  <title>Programkode</title>

<para>
I main-metoden giver man instruktioner til computeren:
</para>

<screen>
    System.out.println(&quot;Hej verden!&quot;);
    System.out.println(&quot;Hvornår smager en Tuborg bedst?&quot;);
    System.out.println(&quot;Hvergang!&quot;);
</screen>


<para>
Instruktionerne udføres altid en efter en, ovenfra og ned.
Hver instruktion afsluttes med et semikolon.
</para>

<para>
Disse 3 instruktioner skriver 3 strenge (&quot;Hej verden!&quot;,
...) ud til skærmen. En streng er en tekst, som computeren kan
arbejde med. Strenge er altid indkapslet i &quot;&quot;.
</para>

<para>
Hver instruktion består af et kald til metoden
System.out.println, som betyder, at der skal udskrives noget til
skærmen, og en streng som parameter.
</para>

<para>
En parameter er en oplysning, som man overfører til
metoden. I dette tilfælde hvilken tekst der skal skrives ud til
skærmen.
</para>

<para>
Vores main-metode kalder altså andre metoder.
</para>
</sect4>    <!--   Programkode -->
</sect3>    <!--   Klassedefinitionen -->

<sect3>
  <title>Oversættelse og kørsel af programmet</title>

<para>
Når man skal udvikle et program, skriver man først en
kildetekst (eng.: source code), der beskriver, hvad det er, man vil
have programmet til at gøre. Programmet, vi lige har set, er
et eksempel på en kildetekstfil.
</para>

<para>
Instruktionerne, som centralenheden i computeren arbejder med, er
i en binær kode (kaldet maskinkode eller bytecode), der er
umulig at læse for almindelige mennesker.
</para>

<para>
Kildeteksten skal derfor oversættes (eng.: compile; mange
siger også kompilere på dansk) til binær kode, som
så kan udføres af computeren.
</para>

<para>
I Java kalder man den binære kode for bytekode. Bytekode er
platformuafhængigt, dvs. at det kan køre på stort
set alle hardware-platforme og alle styresystemer. De fleste andre
sprogs binære kode er ikke indrettet til at være
platformuafhængigt.
</para>

<para>
For at oversætte programmet HejVerden skal det gemmes i en
fil med navnet &quot;HejVerden.java&quot;.
</para>

<blockquote><para>En kildetekstfil skal hedde det samme
som klassen og skal have .java som filendelse</para></blockquote>

<para>
Eksempel: Klassen hedder HejVerden, og filen hedder
HejVerden.java.
</para>

<sect4>
  <title>Oversættelse og kørsel uden et udviklingsværktøj</title>

<para>
Hvis man bruger det kommandolinie-orienterede JDK, skal man (fra
samme katalog) skrive:
</para>

<screen>
  javac HejVerden.java
</screen>


<para>
Dette oversætter programmet til bytekode (filen
HejVerden.class skulle nu gerne ligge i samme katalog). Nu kan det
køres med kommandoen:
</para>

<screen>
  java HejVerden
</screen>


<para>
Resultatet bliver:
</para>

<screen>
Hej Verden!
Hvornår smager en Tuborg bedst?
Hvergang!
</screen>


<figure>
<title>Java</title>

<graphic fileref="Nordfalk415342.&magic;" scale="60"></graphic>
</figure>

<para>
<emphasis>Oversættelse
og udførelse af programmet HejVerden</emphasis>
</para>
</sect4>    <!--   Oversættelse og kørsel uden et udviklingsværktøj -->

<sect4>
  <title>Oversættelse og kørsel med et udviklingsværktøj</title>

<para>
I de fleste udviklingsværktøjer skal du oprette et
<emphasis>projekt</emphasis> (f.eks. i JBuilder:
File/New Project)<emphasis>. F</emphasis>øj derefter din
java-fil til projektet. Husk at placere filen i det katalog, som
projektet angiver (eller rette projektets egenskaber).
</para>

<para>
Når man vil oversætte
sit java-program, skal man vælge <emphasis>make</emphasis>
(det er et engelsk ord). Når man har gjort det, kan man køre
sit program med <emphasis>run</emphasis>.
</para>
</sect4>    <!--   Oversættelse og kørsel med et udviklingsværktøj -->
</sect3>    <!--   Oversættelse og kørsel af programmet -->
</sect2>    <!--   Det første javaprogram -->

<sect2>
  <title>Variabler</title>

<para>
Variabler bruges til at opbevare og ændre data. En variabel
kan opfattes som en navngiven papirlap, hvor der til enhver tid
kan stå netop &eacute;n ting.
</para>

<para>
Variabler skal altid erklæres, dvs. at man skal fortælle
computeren, at der skal oprettes en variabel, hvad slags data den
skal indeholde, og hvad den skal hedde.
</para>

<blockquote><para>En variabel er et navn på et
sted i computerens hukommelse, beregnet på at indeholde data af
en bestemt type</para></blockquote>
<blockquote><para>En variabel erklæres ved at
skrive <emphasis>variabeltype</emphasis> <emphasis>variabelnavn;</emphasis></para></blockquote>

<para>
Det er en god vane at give variablerne sigende navne. Navnene bør
starte med et lille bogstav.
</para>

<para>
I det følgende gennemgår vi to af Javas
variabeltyper: int (heltal) og double (kommatal).
</para>

<sect3>
  <title>Heltal</title>

<para>
En variabel af typen int (et heltal, eng.: integer) erklæres
med
</para>

<screen>
    int tal;
</screen>


<figure>
<title>Efter 1. tildeling</title>

<graphic fileref="Nordfalk415343.&magic;" scale="60"></graphic>
</figure>

<para>
Nu er der reserveret plads i hukommelsen til et heltal<xref linkend="sdfootnote1sym">.
Man får fat i pladsen ved at bruge variabelnavnet 'tal'. Efter
at variablen er erklæret kan den tildeles en værdi, dvs.
man kan skrive data ind i den:
</para>

<screen>
    tal = 22;
</screen>


<para>
Nu er værdien af tal 22 (vist på figuren til højre).
</para>

<para>
Vi kan bruge tal-variablen i stedet for at skrive 22, f.eks. til
at skrive ud til skærmen:
</para>

<screen>
    System.out.println(&quot;Svaret på livet, universet og alt det der: &quot; + tal);
</screen>


<para>
Her slår computeren op i hukommelsen, læser indholdet
af tal-variablen og skriver det ud til skærmen (+'et vil blive
forklaret i næste afsnit).
</para>

<para>
Variabler kan, som navnet siger, ændre værdi. Det gør
vi ved at tildele variablen en ny værdi:
</para>

<figure>
<title>Efter
  2. tildeling</title>

<graphic fileref="Nordfalk415344.&magic;" scale="60"></graphic>
</figure>

<screen>
    tal = 42;
</screen>


<para>
Herefter er den gamle værdi fuldstændigt glemt og
erstattet med den nye. Når programudførelsen når
et punkt, hvor variablen læses, vil det være den nye
værdi, 42, der gælder.
</para>

<blockquote><para>I en tildeling læses værdien
på højre side og gemmes i variablen på venstre
side</para></blockquote>

<para>
Herunder er eksemplet i sin helhed (den væsentlige del af
koden er fremhævet med fed):
</para>

<screen>
<emphasis>// Eksempel på brug af en variabel</emphasis>
<emphasis>// koden skal være i filen Variabler.java</emphasis>
public class Variabler
{
  public static void main (String[] args)
  {
<emphasis>    int tal;</emphasis>
<emphasis>    tal = 22;</emphasis>
<emphasis>    System.out.println(&quot;Svaret på livet, universet og alt det der: &quot; + tal);</emphasis>

<emphasis>    tal = 42;</emphasis>
<emphasis>    System.out.println(&quot;Undskyld, svaret er: &quot; + tal);</emphasis>
  }
}
</screen>


<screen>
Svaret på livet, universet og alt det der: 22
Undskyld, svaret er: 42
</screen>
</sect3>    <!--   Heltal -->

<sect3>
  <title>Sammensætte strenge med +</title>

<para>
Som det er vist i ovenstående eksempel, kan vi med tegnet <emphasis>+</emphasis>
sætte strenge sammen med noget andet:
</para>

<screen>
    System.out.println(<emphasis>&quot;Svaret på livet, universet og alt det der: &quot; + tal</emphasis>);
</screen>


<para>
Herunder sætter vi to strenge sammen:
</para>

<screen>
<emphasis>// Sammensæt to strenge med +</emphasis>
<emphasis>// koden skal være i filen HejVerden2.java</emphasis>
public class HejVerden2
{
  public static void main (String[] args)
  {
    System.out.println(<emphasis>&quot;Hej &quot; + &quot;Verden!&quot;</emphasis>);
  }
}
</screen>


<screen>
Hej Verden!
</screen>


<para>
Herunder skriver vi en streng og tallet 42 ud:
</para>

<screen>
public class HejVerden3
{
  public static void main (String[] args)
  {
    System.out.println(&quot;Svaret på livet, universet og alt det der:&quot;<emphasis> + 42</emphasis>);
  }
}
</screen>


<screen>
Svaret på livet, universet og alt det der: 42
</screen>


<para>
Det, der egentlig sker, er, at det hele bliver sat sammen til &eacute;n
streng, og den sendes til System.out.println().
</para>

<blockquote><para>En streng + noget andet sættes
sammen til en samlet streng</para></blockquote>
</sect3>    <!--   Sammensætte strenge med + -->

<sect3>
  <title>Beregningsudtryk</title>

<para>
Man kan erklære flere variabler på samme linie:
</para>

<screen>
    int antalHunde, antalKatte, antalDyr;
    antalHunde = 5;
    antalKatte = 8;
</screen>


<para>
Tildelinger kan indeholde regneudtryk på højre side
af lighedstegnet. Udtrykket antalHunde + antalKatte udregnes, og
resultatet lægges i variablen på venstre side (det er
ikke tilladt at have beregningsudtryk på venstre side):
</para>

<screen>
    antalDyr = antalHunde + antalKatte;
</screen>


<para>
Beregningsudtrykkene undersøges af Java ved at indsætte
værdien af variablerne. Her indsætter Java 5 + 8 og får
13, som lægges i antalDyr.
</para>

<screen>
public class Dyreinternat
{
  public static void main(String[] args) 
  {
    int antalHunde, antalKatte, antalDyr;
    antalHunde = 5;
    antalKatte = 8; 

    <emphasis>//udregn summen</emphasis>
    antalDyr = antalHunde + antalKatte;

    <emphasis>// udskriv resultatet</emphasis>
    System.out.println(&quot;Antal dyr: &quot; + antalDyr);

    antalHunde  = 10;

    <emphasis>// antalDyr er uændret</emphasis>
    System.out.println(&quot;Antal dyr nu: &quot; + antalDyr);
  }
}
</screen>


<screen>
Antal dyr: 13
Antal dyr nu: 13
</screen>


<para>
Beregningen sker &eacute;n gang
<emphasis>på det tidspunkt, hvor kommandoen udføres</emphasis><xref linkend="sdfootnote2sym">.
Derfor er antalDyr's værdi ikke påvirket at af vi sætter
antalHunde til noget andet efter udregningen.
</para>

<para>
Ligesom i almindelig matematik har * (multiplikation) og /
(division) højere prioritet end + og -.
</para>

<blockquote><para>I Java skrives   &#148;9 divideret
med 3&#148; som 9/3  &#148;3 gange 3&#148; som 3*3</para></blockquote>

<para>
Man kan ikke som i almindelig matematisk notation undlade at
skrive gangetegn.
</para>

<para>
Resultatet af en heltalsudregning er også et heltal. Det
skal man være opmærksom på ved division, hvor
eventuelle decimaler efter kommaet smides væk.
Heltalsudregningen 13 / 5 giver altså 2, fordi 5 går op i
13 to gange<xref linkend="sdfootnote3sym">.
</para>

<blockquote><para>Et heltal divideret med et heltal
giver et heltal   95 / 100 giver 0</para></blockquote>

<para>
&Oslash;nsker man at få et kommatal som resultat af
divisionen skal et eller begge af tallene være kommatal.
Eksempelvis giver 95.0 / 10 kommatallet 9.5.
</para>
</sect3>    <!--   Beregningsudtryk -->

<sect3>
  <title>Kommatal</title>

<para>
Der findes mange andre variabeltyper end heltalstypen int. Hvis
man vil regne med kommatal, bruger man typen double. En variabel af
typen double erklæres med:
</para>

<screen>
  double højde;
</screen>


<para>
De følgende afsnit bruger noget matematik, mange lærer
i gymnasiet. Hvis du ikke kender så meget til matematik, gør
det ikke noget. Præcis, hvad der udregnes og formlerne bag det,
er ikke så vigtigt i denne sammenhæng. Det vigtige er at
forstå, hvordan man arbejder med tal i Java.
</para>

<para>
Her er et eksempel på beregning af en cylinders rumfang:
</para>

<screen>
<emphasis>//</emphasis>
<emphasis>// Beregning af rumfang for en cylinder</emphasis>
<emphasis>//</emphasis>
public class Cylinderberegning
{
  public static void main(String[] args) 
  {
<emphasis>    double radius;</emphasis>
<emphasis>    radius = 5.0;</emphasis>

<emphasis>    double højde = 12.5;</emphasis>

    <emphasis>//beregn rumfang</emphasis>
<emphasis>    double volumen = radius * radius * højde * 3.14159;</emphasis>

    System.out.println(&quot;Cylinderens højde: &quot; + højde);
    System.out.println(&quot;Cylinderens radius: &quot; + radius);
    System.out.println(&quot;Cylinderens volumen: &quot; + volumen);
  }
}
</screen>


<screen>
Cylinderens højde: 12.5
Cylinderens radius: 5.0
Cylinderens volumen: 981.7468749999999
</screen>


<para>
Læg mærke til, at man godt kan erklære en
variabel og tildele den værdi i samme linie:
</para>

<screen>
  double højde = 12.5;
</screen>


<para>
er altså det samme som:
</para>

<screen>
  double højde;
  højde = 12.5;
</screen>


<para>
Her er et eksempel på en skatteberegning, der viser nogle
flere fif:
</para>

<screen>
<emphasis>//</emphasis>
<emphasis>// Skatteberegning (Inspireret af Hallenberg og Sestoft, IT-C, København)</emphasis>
<emphasis>//</emphasis>
public class Skatteberegning 
{
  public static void main(String[] args) 
  {
    double indkomst = 300000;
    double ambi, pension, bundskat;

    ambi = indkomst * 0.08;
    pension = indkomst * 0.01;
    indkomst = <emphasis>indkomst - (ambi + pension)</emphasis>;
    bundskat = <emphasis>(indkomst - 33400) * 0.07</emphasis>;

    System.out.println(&quot;AMBI: &quot; + ambi);
    System.out.println(&quot;Særlig pensionsopsparing: &quot; + pension);
    System.out.println(&quot;Bundskat: &quot; + bundskat);
  }
}
</screen>


<screen>
AMBI: 24000.0
Særlig pensionsopsparing: 3000.0
Bundskat: 16772.0
</screen>


<para>
Udregninger sker normalt fra venstre mod højre, men ligesom
i den almindelige matematik kan man påvirke
udregningsrækkefølgen ved at sætte parenteser:
</para>

<screen>
    bundskat = (indkomst - 33400) * 0.07;
</screen>
</sect3>    <!--   Kommatal -->

<sect3>
  <title>Matematiske funktioner</title>

<para>
De matematiske funktioner som sinus, cosinus, kvadratrod osv.
kaldes i Java med Math.sin(x), Math.cos(x), Math.sqrt(x) osv., hvor x
er en variabel, et fast tal eller et beregningsudtryk.
</para>

<para>
Vi kan f.eks. lave en tabel over værdierne af
kvadratrod-funktionen Math.sqrt()<xref linkend="sdfootnote4sym">
for x=0 til x=10 med programmet (senere, i afsnittet om løkker,
vil vi se en smartere måde).
</para>

<screen>
public class Kvadratrod
{
  public static void main(String[] args) 
  {
    System.out.println(&quot;kvadratroden af 0 er &quot; + <emphasis>Math.sqrt(0)</emphasis>);
    System.out.println(&quot;kvadratroden af 1 er &quot; + Math.sqrt(1));
    System.out.println(&quot;kvadratroden af 2 er &quot; + Math.sqrt(2));
    System.out.println(&quot;kvadratroden af 3 er &quot; + Math.sqrt(3));
    System.out.println(&quot;kvadratroden af 4 er &quot; + Math.sqrt(4));
    System.out.println(&quot;kvadratroden af 5 er &quot; + Math.sqrt(5));
    System.out.println(&quot;kvadratroden af 6 er &quot; + Math.sqrt(6));
    System.out.println(&quot;kvadratroden af 7 er &quot; + Math.sqrt(7));
    System.out.println(&quot;kvadratroden af 8 er &quot; + Math.sqrt(8));
    System.out.println(&quot;kvadratroden af 9 er &quot; + Math.sqrt(9));
    System.out.println(&quot;kvadratroden af 10 er &quot; + Math.sqrt(10));
  }
}
</screen>


<screen>
kvadratroden af 0 er 0.0
kvadratroden af 1 er 1.0
kvadratroden af 2 er 1.4142135623730951
kvadratroden af 3 er 1.7320508075688772
kvadratroden af 4 er 2.0
kvadratroden af 5 er 2.23606797749979
kvadratroden af 6 er 2.449489742783178
kvadratroden af 7 er 2.6457513110645907
kvadratroden af 8 er 2.8284271247461903
kvadratroden af 9 er 3.0
kvadratroden af 10 er 3.1622776601683795
</screen>


<para>
Her er et program, der udregner længden af den skrå
side (hypotenusen) af en retvinklet trekant ud fra længden af
dens to lige sider (kateder): kvadratroden af a&sup2;+b&sup2;, hvor a
og b er længderne af de to sider:
</para>

<screen>
public class Trekant
{
  public static void main(String[] args) 
  {
    double a, b, hypotenuse;
    a = 3;
    b = 4;
    hypotenuse = <emphasis>Math.sqrt(a*a + b*b)</emphasis>;
    System.out.println(&quot;En retvinklet trekant med sider &quot;+a+&quot; og &quot;+b);
    System.out.println(&quot;har hypotenuse &quot;+hypotenuse);
  }
}
</screen>


<screen>
En retvinklet trekant med sider 3.0 og 4.0
har hypotenuse 5.0
</screen>


<para>
Her er et tilsvarende program, der udregner hypotenusen ud fra
længden af en af de andre sider og den modstående
vinkel. Det gøres ud fra formlen a/sin(v), hvor a er længden
af siden, og v er vinklen (i radianer):
</para>

<screen>
public class Trekant2
{
  public static void main(String[] args) 
  {
    double a, v, hypotenuse;
    a = 10;
    v = 0.3;<emphasis> // svarer til ca. 34 grader.</emphasis>
    hypotenuse = <emphasis>a/Math.sin(v)</emphasis>;
    System.out.println(&quot;Hypotenusen har længden: &quot;+hypotenuse);
  }
}
</screen>


<screen>
Hypotenusen har længden: 33.838633618241225
</screen>


<para>
Ud over de almindelige matematiske funktioner findes også
Math.random(), der giver et tilfældigt tal mellem 0 og
0.999999...
</para>
</sect3>    <!--   Matematiske funktioner -->

<sect3>
  <title>Kald af metoder</title>

<para>
Math.sqrt(), Math.sin() og de andre matematiske funktioner og
andre kommandoer, f.eks. System.out.println(), kaldes under et
<emphasis>metoder</emphasis>.
</para>

<para>
En metode er en navngiven programstump, der kan gøre et
eller andet eller beregne en værdi. F.eks. <emphasis>gør</emphasis>
System.out.println() det, at den skriver tekst på
skærmen, og Math.sqrt() <emphasis>beregner </emphasis>en
kvadratrod. Når en metode nævnes i teksten, skriver vi
altid &#148;()&#148; bagefter, så man kan se, at det er en
metode.
</para>

<para>
Nedenstående linie indeholder et <emphasis>metodekald</emphasis>:
</para>

<screen>
    hypotenuse = a/Math.sin(v);
</screen>


<para>
Math.sin er navnet på metoden, og man kalder det v, der står
inde i &#148;()&#148;, for argumentet eller parameteren.
</para>

<para>
Et metodekald er en nævnelse af en metodes navn efterfulgt
af de rigtige parametre. Parametrene er omgivet af parenteser.
</para>

<para>
Ved et kald uden parametre skal man stadig have parenteserne med.
Math.random() skal kaldes uden parametre. Her er et eksempel på
et metodekald af Math.random():
</para>

<screen>
    double tilfældigtTal; 
    tilfældigtTal = Math.random();
</screen>

<blockquote><para>Ved et metodekald kan man som
parameter indsætte som parameter kan indsætte ethvert
udtryk, der giver et resultat af den rigtige type.</para></blockquote>

<para>
Alt, der giver et resultat af den rigtige type, er altså
tilladt: Konstanter, variabler, regneudtryk og resultatet af et andet
metodekald:
</para>

<screen>
    double v,x;
    x = Math.sin(0.1);             <emphasis>// konstant som parameter</emphasis>
    x = Math.sin(v);               <emphasis>// variabel som parameter</emphasis>
    x = Math.sin(Math.sqrt(0.3));  <emphasis>// værdi af andet metodekald som parameter</emphasis>
</screen>


<para>
Vi vil i kapitel 4 se, hvad der sker, når computeren udfører
et metodekald, samt lære, hvordan man kan lave sine egne
metoder.
</para>
</sect3>    <!--   Kald af metoder -->

<sect3>
  <title>Logiske variabler</title>

<para>
En boolsk<xref linkend="sdfootnote5sym">
variabel, også kaldet en logisk variabel, kan kun indeholde
værdierne sand eller falsk. Den bruges oftest til at
huske, om noget er sandt eller ej, men kan også bruges til at
repræsentere noget, der kun har to tilstande, f.eks. om en
lampe er tændt eller slukket.
</para>

<para>
Variabeltypen hedder boolean, og den erklæres med f.eks.:
</para>

<screen>
    boolean detErForSent;
</screen>


<para>
En boolesk variabel kan kun sættes til værdierne true
eller false. F.eks.:
</para>

<screen>
    detErForSent = false;
</screen>


<para>
På højre side af lighedstegnet kan stå et
logisk udtryk, dvs. et udsagn, der enten er sandt eller falsk, f.eks.
&quot;klokken er over 8&quot; (her forestiller vi os, at vi har
variablen klokken)
</para>

<screen>
    detErForSent = klokken &gt; 8;
</screen>


<para>
Udtrykket klokken &gt; 8 undersøges af Java ved at indsætte
værdien af variablen i regneudtrykket og derefter afgøre
om udsagnet er sandt. Hvis f.eks. klokken=7, står der 7&gt;8,
det er ikke sandt, og detErForSent får værdien false.
Hvis klokken=10, står der 10&gt;8, det er sandt, og
detErForSent får værdien true.
</para>
</sect3>    <!--   Logiske variabler -->

<sect3>
  <title>Opgaver</title>

<orderedlist>
  <listitem>

<para>

Skriv et program, som ud fra længde og bredde på
  et rektangel udskriver rektanglets areal.
</para>

</listitem>

  <listitem>

<para>
Skriv et program, som for ligningen y=3*x*x+6*x+9 udskriver
  værdierne af y for x=0, x=1 og x=10.
</para>

</listitem>

  <listitem>

<para>
Skriv et program, som omregner et beløb fra dollar til
  euro (f.eks. kurs 95).
</para>

</listitem>
</orderedlist>

</sect3>    <!--   Opgaver -->
</sect2>    <!--   Variabler -->

<sect2>
  <title>Betinget udførelse</title>

<para>
Indtil nu har vores programmer været fuldstændig
forudsigelige. Vi har bedt computeren om at udføre den ene
kommando efter den anden uanset udfaldet af de tidligere kommandoer.
</para>

<figure>
<title>Logikken i en if-sætning</title>

<graphic fileref="Nordfalk415345.&magic;" scale="60"></graphic>
</figure>

<para>
I programmer kan man påvirke programudførelsen
ved at indføre betingelser, der fortæller, at en del af
programmet kun skal gennemløbes, hvis betingelsen er opfyldt.
</para>

<para>
Det består af et udtryk, der enten er sandt eller falsk, og
noget, der afhænger af dets sandhedsværdi (se
rutediagrammet til højre).
</para>

<para>
Alle er bekendte med betingelser fra deres dagligdag, f.eks.:
</para>

<itemizedlist mark="bullet">
  <listitem>

<para>
hvis du er over 18, er du myndig.
</para>

</listitem>

  <listitem>
<para>
hvis din alkoholpromille er større end 0.5, så
  lad bilen stå.
</para>

</listitem>

  <listitem>

<para>
hvis den koster mindre end 500 kr, så køb den!
</para>

</listitem>
</itemizedlist>

<para>
I Java er syntaksen
</para>

<screen>
    if (<emphasis>betingelse</emphasis>) <emphasis>kommando;</emphasis>
</screen>


<para>
For eksempel:
</para>

<screen>
if (alder &gt;= 18) System.out.println(&quot;Du er myndig&quot;);
</screen>

<screen>
if (alkoholpromille &gt; 0.5) System.out.println(&quot;Lad bilen stå&quot;);
</screen>

<screen>
if (pris &lt; 500) System.out.println(&quot;Jeg køber den!&quot;);
</screen>

<screen>
if (alder == 18) System.out.println(&quot;Du er præcis atten år.&quot;);
</screen>

<screen>
if (alder != 18) System.out.println(&quot;Du er ikke atten.&quot;);
</screen>


<para>
Udtrykkene i parenteserne er logiske udtryk (eller boolske
udtryk). På dansk er sætningen &quot;over 18&quot;
tvetydig: skal man være OVER 18, dvs. 19, for at være
myndig? Java har derfor to forskellige sammenligningsoperatorer: a &gt;=
b undersøger, om a er større end eller lig med b, mens
a &gt; b undersøger om a er større end b. I appendiks
afsnit 2.11.6 findes en oversigt over sammenligningsoperatorerne.
</para>

<figure>
<title>Rutediagram
  for Alder</title>

<graphic fileref="Nordfalk415346.&magic;" scale="60"></graphic>
</figure>


<para>
Herunder et komplet eksempel på et program, der afgør,
om man er myndig. Programkoden, udtrykt på dansk, kunne være:
hvis alder er større end 18, så skriv &quot;Du er
myndig&quot;. I et javaprogram skriver man:
</para>

<screen>
public class Alder
{
  public static void main(String[] args) 
  {
    int alder;
    alder = 15;

<emphasis>    if (alder &gt;= 18)</emphasis>
<emphasis>      System.out.println(&quot;Du er myndig.&quot;);</emphasis>

    System.out.println(&quot;Du er &quot; + alder + &quot; år.&quot;);
  }
}
</screen>


<screen>
Du er 15 år.
</screen>


<para>
Kommandoen System.out.println(&quot;Du er myndig&quot;), bliver
kun udført, hvis udtrykket (alder &gt; 18) er sandt. I
dette tilfælde er alder = 15, og der bliver ikke skrevet noget
ud<xref linkend="sdfootnote6sym">.
Hvis vi ændrer i programmet, så alder = 18, er
betingelsen (alder &gt;= 18) sand, og vi får:
</para>

<screen>
Du er myndig.
Du er 18 år.
</screen>


<para>
Programudførelsen fortsætter under alle
omstændigheder efter betingelsen, så uafhængigt af
udfaldet vil linien
</para>

<screen>
    System.out.println(&quot;Du er &quot; + alder + &quot; år.&quot;);
</screen>


<para>
blive udført.
</para>

<para>
Bemærk, oversætteren er ligeglad med indrykning,
linieskift etc. Det er teksten, der tæller. Vi kunne lige så
godt have skrevet
</para>

<screen>
    if (alder &gt;= 18) System.out.println(&quot;Du er myndig.&quot;);
</screen>


<para>
eller for den sags skyld
</para>

<screen>
    if (alder &gt;= 18) 
System.out.println(&quot;Du er myndig.&quot;);
</screen>


<para>
... men det sidste er en dårlig stil, for det gør det
sværere at læse kildeteksten. Normalt indrykker man 2-4
tegn, når en kommando er betinget.
</para>

<sect3>
  <title>if-else</title>

<figure>
<title>Logikken  i en if-else-sætning</title>

<graphic fileref="Nordfalk415347.&magic;" scale="60"></graphic>
</figure>

<para>
Hvis vi ønsker at gøre &eacute;n ting, hvis
betingelsen er sand, og en anden ting hvis betingelsen er falsk, kan
vi føje en else-del til vores if-sætning. Denne del vil
kun blive udført, hvis betingelsen er falsk. Syntaksen
er:
</para>

<screen>
    if (<emphasis>betingelse</emphasis>) <emphasis>kommando1;</emphasis>
<emphasis>    else kommando2;</emphasis>
</screen>


<para>
Eksempelvis:
</para>

<screen>
public class Alder2
{
  public static void main(String[] args) 
  {
    int alder;
    alder = 15;

<emphasis>    if (alder &gt;= 18)</emphasis>
      System.out.println(&quot;Du er myndig.&quot;);
    <emphasis>else</emphasis> System.out.println(&quot;Du er ikke myndig.&quot;);

    System.out.println(&quot;Du er &quot; + alder + &quot; år.&quot;);
  }
}
</screen>


<screen>
Du er ikke myndig.
Du er 15 år.
</screen>


<para>
&AElig;ndrer vi så alder = 18, er betingelsen (alder &gt;=
18) sand, og vi får resultatet
</para>

<screen>
Du er myndig.
Du er 18 år.
</screen>


<para>
Det er selvfølgelig lidt kedeligt at kunne se direkte i
vores program uden at køre det, om en betingelse er opfyldt. I
virkeligheden er betingelser kun nyttige, når forgreningen
afhænger af nogle ydre omstændigheder, f.eks. af
brugerens indtastning eller af værdien af en variabel fra en
anden del af programmet. Hvis du bare vil prøve, kan du lave
et ikke-forudsigeligt program med Math.random(). I afsnittet
&quot;Avanceret&quot; i slutningen af kapitlet kan du læse om,
hvordan man indlæser fra tastaturet på en terminal.
</para>
</sect3>    <!--   if-else -->

<sect3>
  <title>Opgaver</title>

<orderedlist>
  <listitem>

<para>
Lav et veksleprogram fra dollar til euro. Det skal påregne
  en kommission på 2 %, dog mindst 0,5 euro. Afprøv
  programmet med forskellige beløb.
</para>

</listitem>

  <listitem>

<para>
Skriv et program, der beregner porto for et brev. Inddata er
  brevets vægt (i gram). Uddata er prisen for at sende det
  som A-post i Danmark.
</para>

</listitem>
</orderedlist>

</sect3>    <!--   Opgaver -->
</sect2>    <!--   Betinget udførelse -->

<sect2>
  <title>Blokke</title>

<para>
En blok er en samling af kommandoer. Den starter med en
blokstart-parentes { og slutter med en blokslut-parentes}.<xref linkend="sdfootnote7sym">
</para>

<blockquote><para>En blok grupperer flere kommandoer, så
de udføres samlet som &eacute;n kommando</para></blockquote>

<para>
Blokke bruges blandt andet, hvis man vil have mere end
førstkommende linie udført i en betingelse. Herunder
udføres to kommandoer, hvis betingelsen er opfyldt, og to
andre, hvis betingelsen ikke er opfyldt:
</para>

<screen>
public class Alder3
{
  public static void main(String[] args) 
  {
    int alder;
    alder = 15;

    if (alder &gt;= 18) 
    <emphasis>{</emphasis><emphasis> // blokstart</emphasis>
      System.out.println(&quot;Du er &quot; + alder + &quot; år.&quot;);
      System.out.println(&quot;Du er myndig.&quot;);
    <emphasis>}</emphasis><emphasis> // blokslut</emphasis> 
    else 
    <emphasis>{</emphasis><emphasis> // blokstart</emphasis>
      System.out.println(&quot;Du er kun &quot; + alder + &quot; år.&quot;);
      System.out.println(&quot;Du er ikke myndig.&quot;);
    <emphasis>}</emphasis><emphasis> // blokslut</emphasis>
  }
}
</screen>


<screen>
Du er kun 15 år.
Du er ikke myndig.
</screen>


<sect3>
  <title>Indrykning</title>

<para>
Læg mærke til, hvordan programkoden i blokkene i
ovenstående eksempel er rykket lidt ind. Det gør det
lettere for programmøren at overskue koden, så han/hun
kan se, hvilken {-parentes der hører sammen med hvilken
}-parentes<xref linkend="sdfootnote8sym">.
</para>

<blockquote><para>Det er god skik at bruge indrykning i
en blok</para></blockquote>
<blockquote><para>Indrykning gør programmet meget
nemmere at overskue</para></blockquote>

<para>
Her er det samme program uden indrykning. Programmet er sværere
at overskue nu (man kunne måske komme til at tro, at de
nederste to linier bliver udført uafhængig af
if-sætningen):
</para>

<screen>
public class Alder3UheldigIndrykning{
public static void main(String[] args) 
{int alder;
alder = 15;
if (alder &gt;= 18)
{
System.out.println(&quot;Du er &quot; + alder + &quot; år.&quot;);
System.out.println(&quot;Du er myndig&quot;);
} else {
System.out.println(&quot;Du er kun &quot; + alder + &quot; år.&quot;);
System.out.println(&quot;Du er ikke myndig&quot;);
}}}
</screen>


<para>
De fleste udviklingsværktøjer har funktioner til at
rykke flere liniers kode ind og ud (i JBuilder gøres det ved
at markere en tekst, og trykke Tab for at rykke ind og skift-Tab for
at rykke ud).
</para>
</sect3>    <!--   Indrykning -->
</sect2>    <!--   Blokke -->

<sect2>
  <title>Løkker</title>

<para>
En løkke er en gentaget udførelse af en kommando,
igen og igen. Hvor mange gange løkken udføres
afhænger af et logisk udtryk.
</para>

<sect3>
  <title>while-løkken</title>

<figure>
<title>Logikken
  i en while-løkke</title>

<graphic fileref="Nordfalk415348.&magic;" scale="60"></graphic>
</figure>

<para>
while-løkken har formen:
</para>

<screen>
    while (<emphasis>betingelse</emphasis>) <emphasis>kommando;</emphasis>
</screen>


<para>
Kommandoen udføres igen og igen så længe
betingelsen er opfyldt. Dvs. før kommandoen udføres,
undersøges betingelsen, og det kontrolleres, at den er opfyldt
(se rutediagrammet til højre).
</para>

<para>
Oftest grupperer man flere kommandoer i en blok.
</para>

<screen>
public class Alder4
{
  public static void main(String[] args) 
  {
    int alder;
    alder = 15;

    <emphasis>while (alder &lt; 18)</emphasis>
    <emphasis>{</emphasis>
      System.out.println(&quot;Du er &quot;+alder+&quot; år. Vent til du bliver ældre.&quot;);
      alder = alder + 1;
      System.out.println(&quot;Tillykke med fødselsdagen!&quot;);
    <emphasis>}</emphasis>

    System.out.println(&quot;Nu er du &quot;+alder+&quot; år og myndig.&quot;);
  }
}
</screen>


<screen>
Du er 15 år. Vent til du bliver ældre.
Tillykke med fødselsdagen!
Du er 16 år. Vent til du bliver ældre.
Tillykke med fødselsdagen!
Du er 17 år. Vent til du bliver ældre.
Tillykke med fødselsdagen!
Nu er du 18 år og myndig.
</screen>


<figure>
<title>Rutediagram
  for noget af Alder4</title>

<graphic fileref="Nordfalk415349.&magic;" scale="60"></graphic>
</figure>
<para>
Før løkken starter, har alder en startværdi
på 15. Under hvert gennemløb tælles variablen en
op. På et tidspunkt, når alder er talt op til 18, er
betingelsen ikke mere opfyldt, og programudførelsen
fortsætter efter løkken.
</para>

<para>
Med en løkke kan vi lave Kvadratrod-programmet nemmere. I
stedet for at skrive den samme kommando igen og igen kan vi lave
en løkke (sammenlign med Kvadratrod afsnit 2.2.5).
</para>

<screen>
public class Kvadratrod2
{
  public static void main(String[] args) 
  {
    int n;
    n = 0;

    while (n &lt;= 10)
    {
      System.out.println(&quot;kvadratroden af &quot;+n+&quot; er &quot; + <emphasis>Math.sqrt(n)</emphasis>);
      n = n + 1;
    }
  }
}
</screen>


<screen>
kvadratroden af 0 er 0.0
kvadratroden af 1 er 1.0
kvadratroden af 2 er 1.4142135623730951
kvadratroden af 3 er 1.7320508075688772
kvadratroden af 4 er 2.0
kvadratroden af 5 er 2.23606797749979
kvadratroden af 6 er 2.449489742783178
kvadratroden af 7 er 2.6457513110645907
kvadratroden af 8 er 2.8284271247461903
kvadratroden af 9 er 3.0
kvadratroden af 10 er 3.1622776601683795
</screen>


<para>
En tællevariabel er en variabel, der tælles op i en
løkke, indtil den når en bestemt øvre grænse.
I eksemplerne ovenfor bruges alder og n som tællevariabler.
</para>

<para>
Herunder udskriver vi 7-tabellen ved hjælp af
tællevariablen n:
</para>

<figure>
<title>Rutediagram
  for Syvtabel</title>

<graphic fileref="Nordfalk415350.&magic;" scale="60"></graphic>
</figure>

<screen>
public class Syvtabel
{
  public static void main(String[] args) 
  {
    int n;
    n = 1;

    while (n &lt;= 10)
    {
      System.out.println(n+&quot; : &quot;+ 7*n);
      n = n + 1;
    }
  }
}
</screen>


<screen>
1 : 7
2 : 14
3 : 21
4 : 28
5 : 35
6 : 42
7 : 49
8 : 56
9 : 63
10 : 70
</screen>


<para>
Tællevariabel-formen er den mest almindelige for løkker,
men man kan sagtens komme ud for andre former for løkker. Der
kan f.eks. godt indgå et regneudtryk i betingelsen.
</para>
</sect3>    <!--   while-løkken -->

<sect3>
  <title>for-løkken</title>

<para>
For-løkken er specielt velegnet til løkker med en
tællevariabel. Den har formen
</para>

<screen>
    for (<emphasis>initialisering</emphasis>; <emphasis>betingelse</emphasis>; <emphasis>opdatering</emphasis>) <emphasis>kommando;</emphasis>
</screen>


<figure>
<title>Strukturen
  i en for-løkke</title>
<graphic fileref="Nordfalk415351.&magic;" scale="60"></graphic>
</figure>

<itemizedlist mark="bullet">
  <listitem>

<para>

<emphasis>initialisering</emphasis> er en (evt.: erklæring og)
  tildeling af en tællevariabel, f.eks. <literal>alder = 15</literal>
</para>

</listitem>

  <listitem>

<para>
<emphasis>betingelse</emphasis> er et logisk udtryk, der angiver
  betingelsen for, at løkken skal fortsætte med at
  blive udført,  f.eks. <literal>alder
  &lt; 18</literal>
</para>

</listitem>

  <listitem>

<para>
<emphasis>opdatering</emphasis> er ændringen i tællevariablen,
    f.eks. <literal>alder = alder + 1</literal>
</para>

</listitem>
</itemizedlist>

<para>
Det kan indenad læses som &quot;for <emphasis>startværdi</emphasis>,
så længe <emphasis>betingelse</emphasis> udfør: <emphasis>kommando</emphasis>
og <emphasis>opdatering</emphasis>, f.eks. &quot;for <emphasis>alder = 15</emphasis>, så
længe <emphasis>alder &lt; 18</emphasis> udfør: <emphasis>Skriv &quot;du
er..&quot;</emphasis> og <emphasis>tæl alder 1 op&quot;</emphasis>.
</para>

<para>
En for-løkke og en while-løkke supplerer hinanden.
De har præcis samme funktion, men for-løkken er mere
kompakt og bekvem, når man ønsker at lave en almindelig
løkke, der udføres et bestemt antal gange. Dette
program gør det samme som Syvtabel-eksemplet, men med en
for-løkke:
</para>

<figure>
<title>Rutediagram
  for Syvtabel2 (samme som for Syvtabel)</title>

<graphic fileref="Nordfalk415352.&magic;" scale="60"></graphic>
</figure>


<screen>
public class Syvtabel2
{
  public static void main(String[] args) 
  {
    int n;
<emphasis>    for (n=1; n&lt;=10; n=n+1)</emphasis>
      System.out.println(n+&quot; : &quot;+ 7*n);
  }
}
</screen>


<para>
Programmører er dovne væsner og bruger ofte
for-løkken til optælling, fordi der skal skrives
mindre end i en while-løkke.
</para>

<para>
Man ser også ofte, at de bruger operatoren ++ til at tælle
en variabel op i en løkke: &quot;alder++&quot; svarer
altså til &quot;alder=alder+1&quot;, men med mindre
skrivearbejde. Tilsvarende findes --, som tæller en variabel en
ned, f.eks. alder--.
</para>
</sect3>    <!--   for-løkken -->

<sect3>
  <title>Indlejrede løkker</title>

<para>
En betingelse eller en løkke kan stå ethvert sted i
en metode, og altså også inden i en anden løkke
eller en betingelse.
</para>

<para>
Herunder har vi syvtabellen igen, men denne gang &quot;brokker&quot;
programmet sig, når det når op på 6, og efter 8
skriver den &quot;ved ikke&quot; i stedet for at regne resultatet ud.
</para>

<screen>
public class Syvtabel3
{
  public static void main(String[] args) 
  {
    <emphasis>for (int n=1; n&lt;=10; n++)</emphasis>  <emphasis>// n++ gør det samme som n=n+1</emphasis>
    {
      <emphasis>if (n == 6)</emphasis> System.out.println(&quot;puha, nu bliver det svært.&quot;);

      <emphasis>if (n &lt; 8)  </emphasis> System.out.println(n+&quot; : &quot;+ 7*n);
      <emphasis>else</emphasis> System.out.println(n+&quot; : (ved ikke)&quot;);
    }
  }
}
</screen>


<screen>
1 : 7
2 : 14
3 : 21
4 : 28
5 : 35
puha, nu bliver det svært.
6 : 42
7 : 49
8 : (ved ikke)
9 : (ved ikke)
10 : (ved ikke)
</screen>


<para>
Vi kan også lave løkker i løkker. Herunder
udregner vi n*7 ved at lægge 7 sammen n gange.
</para>

<screen>
public class Syvtabel4
{
  public static void main(String[] args) 
  {
    for (int n=1; n&lt;=10; n=n+1)
    {
      int sum = 0;
      for (int j=0; j&lt;n; j++) sum = sum + 7;

      System.out.println(n+&quot; : &quot;+ sum);
    }
  }
}
</screen>


<screen>
1 : 7
2 : 14
3 : 21
4 : 28
5 : 35
6 : 42
7 : 49
8 : 56
9 : 63
10 : 70
</screen>
</sect3>    <!--   Indlejrede løkker -->

<sect3>
  <title>Uendelige løkker</title>

<para>
Hvis programmøren ikke er omhyggelig, kan han komme til at
lave en løkke, hvor betingelsen vedbliver at være
sand. Så bliver programudførelsen i løkken i al
evighed (eller indtil brugeren afbryder programmet).
</para>

<para>
Lad os f.eks. sige, at programmøren er kommet til at skrive
'-' i stedet for '+' i opdateringen af n i while-løkken
fra Syvtabel-programmet. Nu vil computeren tælle nedad:
</para>

<screen>
public class SyvtabelFejl
{
  public static void main(String[] args) 
  {
    for (int n=1; n&lt;=10; <emphasis>n=n-1</emphasis>)
      System.out.println(n+&quot; : &quot;+ 7*n);
  }
}
</screen>


<screen>
1 : 7
0 : 0
-1 : -7
-2 : -14
-3 : -21
-4 : -28
</screen>


<para>

... og så videre i det uendelige. Løkken vil aldrig
stoppe, fordi n vedbliver at være mindre end<xref linkend="sdfootnote9sym">
10.
</para>

<para>
En anden faldgrube er at komme til at sætte et semikolon
efter en while-løkke:
</para>

<screen>
    while (n &lt;= 10);
</screen>


<para>
Oversætteren vil tro, at der ikke er nogen kommando, der
skal udføres, og blot undersøge betingelsen igen og
igen og igen og igen... Da n ikke ændrer sig, vil programmet
aldrig stoppe.
</para>

<para>
Det er programmørens ansvar at sikre, at betingelsen i en
løkke på et tidspunkt ikke mere opfyldes, så
programmet ikke går i uendelig løkke<xref linkend="sdfootnote10sym">.
</para>
</sect3>    <!--   Uendelige løkker -->

<sect3>
  <title>Opgaver</title>
<orderedlist>
  <listitem>

<para>

Prøv at køre hvert eksempel, og forvis dig om,
  at du forstår det.Mange udviklingsværktøjer
  understøtter trinvis gennemgang til fejlfinding (eng.:
  debugging). Prøv trinvis gennemgang i dit værktøj,
  og hold øje med variablerne. (I JBuilder og JDeveloper
  gøres det med F8 &quot;step over&quot;).
</para>

</listitem>

  <listitem>

<para>
Omskriv Alder4-programmet til at bruge en for-løkke.
</para>

</listitem>

  <listitem>

<para>
Lav et program, der tæller nedad fra 10 til 1.
</para>

</listitem>

  <listitem>

<para>
Lav et program, der udregner værdien af 1+2+3+ ... +20.
</para>

</listitem>

  <listitem>

<para>
Ret programmet til at udregne værdierne af 1+2+3+ ...
  +n, når n er 10, 11, .. 30 (vink: brug en indlejret
  løkke).
</para>

</listitem>

  <listitem>

<para>
Lav et program, der udskriver 1-tabellen, 2-tabellen, .. op
  til 10-tabellen.
</para>

</listitem>

  <listitem>

<para>
Skriv et program, som for ligningen y=3*x*x+6*x+9 udskriver
  værdierne af y for x=0, x=1,x= 2, x=3 ... x=10. Ret det
  derefter til at skrive ud for x=0,x=10,x=20,x=30...x=100.
</para>

</listitem>
</orderedlist>
</sect3>    <!--   Opgaver -->
</sect2>    <!--   Løkker -->

<sect2>
  <title>Værditypekonvertering</title>

<para>
Java er det, man kalder et stærkt typet sprog. Det betyder,
at alle variabler og værdier har en bestemt type gennem hele
deres levetid, og at der er visse begrænsninger for, hvilke
værdier man kan tildele en variabel. Når man først
har vænnet sig til det, er det en stor hjælp, fordi
oversætteren på denne måde ofte fanger fejl i
programmerne. Desuden gør det, at computeren hurtigere kan
udføre beregninger.
</para>

<para>
I Java kan man f.eks. ikke lægge en double-værdi ind i
en int-variabel:
</para>

<screen>
    int x;
    x=2.7;  <emphasis>// Fejl.</emphasis>
</screen>


<para>
Forsøger man på dette, vil man få
oversætter-fejlen: <emphasis>Possible loss of precision: double,
required: int</emphasis>.
</para>

<para>
&Aring;rsagen til, at vi i Java ikke kan gemme 2.7 i x, kan
forstås på to måder:
</para>

<orderedlist>
  <listitem>

<para>

x har kun plads i lageret til at gemme hele tal (fra -2 mia.
  til +2 mia).
</para>

</listitem>

  <listitem>

<para>
x er erklæret som en int, og skal derfor blive ved med
  at være en int. I de efterfølgende beregninger kan det
  have stor betydning, om x har en kommadel. Programmøren skal
  derfor kunne se på, hvordan x er erklæret, og derefter
  være helt sikker på, hvilke værdier x kan
  indeholde.
</para>

</listitem>
</orderedlist>

<para>
Begge måder at forstå årsagen på er
rigtige og gyldige.
</para>

<para>
For at kunne gemme 2.7 i x bliver man derfor nødt til at
lave 2.7 om til en int-værdi. Det kaldes at typekonvertere
værdien. Dette er ikke helt uden problemer. Der er åbenlyst
et informationstab, da kommadelen af værdien må fjernes.
Derudover kunne double-værdien være 5 mia. i stedet
for 2.7, og det er der ikke plads til i en int. Et tredje problem er,
at man skal vælge, hvordan man vil udføre
konverteringen. Skal man afrunde korrekt til 3, eller nedrunde til 2?
Det første tager lidt mere tid end det sidste.
</para>

<para>
Af disse årsager bliver man i nogle tilfælde nødt
til eksplicit at fortælle oversætteren, at den skal
foretage en værdi-typekonvertering.
</para>

<sect3>
  <title>Eksplicit værdi-typekonvertering</title>

<para>
Man konverterer en værdi til en anden type ved at skrive det
eksplicit (eng.: cast) med:
</para>

<screen>
    int x;
    x= (int) 2.7;
</screen>


<para>
Inde i parentesen skriver man typen, som værdien lige til
højre skal konverteres til. Denne form for typekonvertering
runder altid ned<xref linkend="sdfootnote11sym">
til nærmeste hele tal<xref linkend="sdfootnote12sym">.
</para>
</sect3>    <!--   Eksplicit værdi-typekonvertering -->

<sect3>
  <title>Implicit værdi-typekonvertering</title>

<para>
Implicit typekonvertering betyder, at oversætteren selv
laver konverteringen, uden at programmøren behøver at
skrive noget særligt om, at den skal gøre det.
</para>

<screen>
    double y;
    y=4;   <emphasis>// OK: Implicit værdi-typekonvertering.</emphasis>
</screen>


<para>
Selvom 4 er en int-værdi, kan y godt indeholde den, da den
svarer til double-værdien 4.0. Denne form for typekonvertering
er således ikke nær så problematisk som i det
tidligere eksempel.
</para>

<para>
En tommelfingerregel i Java er, at når modtagertypen kan
indeholde hele intervallet af mulige værdier for afsendertypen,
kan den være implicit. I appendikset sidst i dette kapitel
findes en tabel over typerne.
</para>
</sect3>    <!--   Implicit værdi-typekonvertering -->

<sect3>
  <title>Misforståelser af værdi-typekonvertering</title>

<para>
Bemærk, at det kun er <emphasis>værdien</emphasis>, der bliver
konverteret. Variablen bliver ikke ændret.
</para>

<screen>
    int x;
    double y;
    y=2.7;
    <emphasis>x=(int)y</emphasis>;              <emphasis>// punkt A</emphasis>
    System.out.println(x);
    System.out.println(y); <emphasis>// y er upåvirket af typekonverteringen</emphasis>
</screen>


<screen>
2
2.7
</screen>


<para>
Man kunne måske fristes til at tro, at i punkt A konverteres
variablen y til en variabel af typen int, men det ville så
betyde, at den sidste linie i uddata skulle være 2. Men husk
at:
</para>

<blockquote><para>En variabels type er altid som den er
erklæret - den kan ikke ændre type</para></blockquote>

<para>
Det der sker i ovenstående er, at y's værdi (2.7)
læses, en konverteret værdi (2) beregnes og denne værdi
lægges ind i x.
</para>

<para>
En anden misforståelse er at tro, at oversætteren kan
se at noget er lovligt ud fra de øvrige programlinier,
f.eks.:
</para>

<screen>
  int x;
  double y;
  y=4.0;
  x=y;    <emphasis>// Fejl - her stopper oversætteren med &quot;Possible loss of precision&quot;</emphasis>
</screen>


<para>
I ovenstående tilfælde kunne man tro, at man kan bruge
implicit typekonvertering, fordi oversætteren kan se at y altid
er 4.0, og at der derfor ikke går information tabt. Men så
klog er oversætteren ikke. Når den skal afgøre, om
den kan lave implicit typekonvertering, kigger den <emphasis>kun</emphasis> på
typerne af variabler og værdier. Den skeler ikke til resten af
programmet<xref linkend="sdfootnote13sym">.
</para>
</sect3>    <!--   Misforståelser af værdi-typekonvertering -->
</sect2>    <!--   Værditypekonvertering -->

<sect2>
  <title>Fejl</title>

<para>
Som sagt udfører computeren programmet instruktion for
instruktion som en kogebogsopskrift. Computeren forstår
ikke programmet, men udfører blot det, programmøren
(kogebogsforfatteren) har skrevet.
</para>

<sect3>
  <title>Indholdsmæssige (logiske) fejl</title>

<para>
Da maskinen ikke forstår programmet, kan den heller ikke
rette op på fejlene i programmørens opskrift eller
forstå, hvad programmøren &quot;mener&quot; med det, han
skrev. Man kan altså sagtens komme til at lave et program, der
gør noget andet end det, programmøren har tilsigtet:
</para>

<screen>
public class ProgramMedFejl
{
  public static void main (String[] args)
  {
    System.out.println(&quot;Hej Verdne!&quot;);
    int sum = 2 - 2;
    System.out.println(&quot;2 og 2 er &quot;+sum);
  }
}
</screen>


<screen>
Hej Verdne!
2 og 2 er 0
</screen>


<para>
Dette eksempel har en stavefejl og en forkert udregning. I afsnit
2.5.4 om uendelige løkker så vi en anden fejl, der
gjorde, at programmet aldrig stoppede. Et andet eksempel kunne være
et skatteprogram, der glemmer at tage højde for bundfradraget.
</para>
</sect3>    <!--   Indholdsmæssige (logiske) fejl -->

<sect3>
  <title>Sproglige fejl</title>

<para>
Mens computeren ikke har mulighed for at finde indholdsmæssige
fejl i programmerne, kan den godt finde sproglige og syntaksmæssige
problemer, dvs. hvis kildekoden gør brug af ukendte variabler
eller metoder eller ikke er gyldig i forhold til sprogets syntaks
(den formelle definition af, hvordan man skriver javakode).
</para>

<para>
Hvis der er sproglige fejl i kildekoden, kan den ikke oversættes
til bytekode, så man kan altså overhovedet ikke komme til
at prøve sit program. De følgende instruktioner er alle
forkerte, og vil blive fanget under oversættelsen af
programmet. Ofte kan fejlmeddelelsen overraske lidt, men med lidt
øvelse kan man lære at forstå den &quot;firkantede&quot;,
måde som computeren &quot;tænker&quot; på:
</para>

<screen>
    System.out.println(&quot;Hej verden!);
</screen>


<para>

Her mangler en slut-&quot; til at markere, hvor strengen stopper.
Oversætteren skriver <emphasis>unclosed character literal</emphasis>. Den kan
ikke regne ud, at strengen slutter lige før ')'.
</para>

<screen>
    System.out.pintln(&quot;Hej verden!&quot;);
</screen>


<para>

Kaldet til println er stavet forkert. Oversætteren skriver
<emphasis>method pintln(java.lang.String) not found in class
java.io.PrintStream</emphasis>. Den kan ikke finde ud af, at man mener
p<emphasis>r</emphasis>intln (med r) i stedet for pintln.
</para>

<screen>
    system.out.println(&quot;Hej verden!&quot;);
</screen>


<para>

System er stavet forkert (med småt). Oversætteren skriver
<emphasis>cannot access class system.out; neither class nor source found for
system.out</emphasis>. Den skelner mellem store og små bogstaver og
kan ikke se, at man mener System (med stort) i stedet for system.
</para>

<screen>
    System.out.println(Hej verden!);
</screen>


<para>

Der mangler &quot; til at markere, hvor strengen starter og slutter.
Oversætteren skriver <emphasis>')' expected</emphasis> og peger lige
efter Hej. Den forstår ikke at &quot;Hej verden!&quot; er en
tekststreng, når &quot;-tegnene mangler, og mener derfor, at
'Hej' og 'verden!' skal behandles adskilt.
</para>

<para>
Når man skal finde en fejl, gælder det om at nærlæse
fejlmeddelelsen og programkoden omkring stedet, hvor fejlen er, og at
huske, at computeren følger faste regler, men ikke forstår
hvad der foregår. F.eks. er den sidste fejlmeddelelse <emphasis>')'
expected</emphasis> ikke særlig sigende, da fejlen formentlig er, at
der mangler &quot;-tegn.
</para>

<para>
Det kan være banaliteter, der er årsag til sprogfejl.
Det giver ofte anledning til sprogfejl, at folk glemmer, at der er
forskel på store og små bogstaver.
</para>

<blockquote><para>Java skelner altid mellem store og små
bogstaver</para></blockquote>
<blockquote><para>Det er god stil konsekvent at skrive
klassenavne med stort og variabler og metoder med småt</para></blockquote>
</sect3>    <!--   Sproglige fejl -->

<sect3>
  <title>Køretidsfejl</title>

<para>
Visse fejl opstår først ved udførelsen af
programmet. Selvom alting er syntaktisk korrekt, opstår der
alligevel en undtagelse fra den normale programudførelse.
Herunder ses et program, der stopper på grund af division med
0.
</para>

<screen>
public class ProgramMedFejl2
{
  public static void main (String[] args)
  {
    int a,b,c;

    a = 5;
    b = 6;

    c = b/(a-5);
    System.out.println(&quot;c = &quot;+c);
  }
}
</screen>


<screen>
Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero
        at ProgramMedFejl2.main(ProgramMedFejl2.java:10)
</screen>


<para>
Køretidsfejl forårsager, at der opstår en
undtagelse (eng.: exception), som, hvis den ikke håndteres,
stopper programudførelsen (populært: programmet går
ned). Dette vil blive behandlet grundigere i kapitlet om undtagelser.
</para>
</sect3>    <!--   Køretidsfejl -->
</sect2>    <!--   Fejl -->

<sect2>
  <title>Opgaver</title>
<sect3>
  <title>Befordringsfradrag</title>

<para>
Lav et program, som udregner befordringsfradraget (det der kan
trækkes fra i skat ud fra, hvor langt der er mellem arbejde og
hjem).
</para>

<orderedlist>
  <listitem>

<para>

Udregn, og udskriv fradraget pr. dag fra 25 til 75 km på
  hver sin linie.
</para>

</listitem>

  <listitem>

<para>
Udregn, og udskriv fradraget pr. dag fra 25 til 150 km på
  hver sin linie.
</para>

</listitem>

  <listitem>

<para>
Udregn, og udskriv fradraget pr. dag fra 10 til 150 km på
  hver sin linie. Kun hver 10. km udskrives (10km, 20km, 30km...).
</para>

</listitem>
</orderedlist>

<para>
Reglerne for fradraget for år
2000 var følgende:
</para>

<para>
  første 24 km  intet fradrag
</para>

<para>
  25  - 100 km  154 øre pr. km
</para>

<para>
   over 100 km  77 øre pr. km
</para>
</sect3>    <!--   Befordringsfradrag -->

<sect3>
  <title>Kurveprogram</title>
<orderedlist>
  <listitem>

<para>

Skriv et program, der tegner grafen over
  kvadratrod-funktionen (Math.sqrt()).Vink: Når du vil
  skrive en &quot;*&quot; uden linieskift kan du bruge
  System.out.print(&quot;*&quot;) (dvs. uden 'ln'). Når du vil
  skifte linie, kan du bruge System.out.println() uden parametre.
</para>

</listitem>

  <listitem>

<para>
Lav kurveprogrammet om, så det i stedet viser kurven
  over polynomiet 0.2*x*x +0.5*x +2. Lav programmet, så det er
  nemt at se, hvor man skal rette for at ændre funktionen,
  intervalstart, intervalslut, skalering og forskydning af y-aksen.
  Dvs. lav det til variabler, og brug kommentarer til at markere
  stederne i programmet.
</para>

</listitem>

  <listitem>

<para>
Lav om på kurvetegningsprogrammet, så kurven ikke
  er udfyldt, men kun en streg.
</para>

</listitem>

  <listitem>

<para>
Eventuelt: Udvid kurveprogrammet til at udregne det totale
  antal af stjerner, der skrives ud (udregn integralet af
  funktionen numerisk ved at summere arealet under grafen). Er
  det nemmest at gøre løbende, mens stjernerne tegnes,
  eller bagefter? Hvordan ville du gøre på den ene og på
  den anden måde?
</para>

</listitem>
</orderedlist>
</sect3>

<sect3>
<title>Appendiks</title>

<para>
Dette afsnit sætter det, du har lært i kapitlet, i
system og kan senere bruges som opslagsværk. Enkelte
steder står der noget, som ikke er gennemgået endnu, men
som er med for helhedens skyld.
</para>
</sect3>    <!--   Kurveprogram -->

<sect3>
  <title>Navngivningsregler</title>

<para>
Variabler og metoder bør have lille startbogstav.
</para>

<para>
Eksempler: n, alder, tal, talDerSkalUndersøges, main(),
println(), sqrt().
</para>

<para>
Klasser bør have stort startbogstav.
</para>

<para>
Eksempler: HejVerden, Cylinderberegning, Syvtabel2
</para>

<para>
Består navnet af flere ord, stryger man normalt
mellemrummene og lader hvert af de efterfølgende ord
starte med stort (nogen bruger også understreg _ som
mellemrum).
</para>

<itemizedlist mark="bullet">
  <listitem>

<para>

Navnet kan bestå af A-&Aring;, a-å, 0-9, $ og _
</para>

</listitem>

  <listitem>

<para>
Det må ikke starte med et tal. Det kan have en
  vilkårlig længde.
</para>

</listitem>

  <listitem>

<para>
Lovlige navne: peter, Peter, $antal, var2, J2EE,
  dette_er_en_test
</para>

</listitem>

  <listitem>

<para>
Ulovlige navne: 7eleven, dette-er-en-test, peter#
</para>

</listitem>
</itemizedlist>

<para>
Da visse styresystemer endnu ikke understøtter æ, ø
og å i filnavne, bør man undgå disse i
klassenavne.
</para>
</sect3>    <!--   Navngivningsregler -->

<sect3>
  <title>De simple typer</title>

<para>
Her er en oversigt over alle de simple variabeltyper i Java.
</para>

<table>

<tgroup cols="0" align="char">
<thead>
    <tr valign=top>
      <th width=11%>

<para>
Type
</para>

</th>
      <th width=13%>

<para>
Art
</para>

</th>
      <th width=13%>

<para>
Antal bit
</para>

</th>
      <th width=44%>

<para>
Mulige værdier
</para>

</th>
      <th width=20%>

<para>
Standardværdi
</para>

</th></row>
</thead>

<tbody>
<row>
<td width=11% valign=top>

<para>
byte
</para>

</entry>
<td width=13% valign=top>

<para>
heltal
</para>

</entry>
<td width=13% valign=bottom sdval="8" sdnum="1030;">

<para>
8
</para>

</entry>
<td width=44% valign=top>

<para>
-128 til 127
</para>

</entry>
<td width=20% valign=bottom sdval="0" sdnum="1030;">

<para>
0
</para>

</entry>
</row>

<row>
<td width=11% valign=top>

<para>
short
</para>

</entry>
<td width=13% valign=top>

<para>
heltal
</para>

</entry>
<td width=13% valign=bottom sdval="16" sdnum="1030;">

<para>
16
</para>

</entry>
<td width=44% valign=top>

<para>
-32768 til 32767
</para>

</entry>
<td width=20% valign=bottom sdval="0" sdnum="1030;">

<para>
0
</para>

</entry>
</row>

<row>
<td width=11% valign=top>

<para>
int
</para>

</entry>
<td width=13% valign=top>

<para>
heltal
</para>

</entry>
<td width=13% valign=bottom sdval="32" sdnum="1030;">

<para>
32
</para>

</entry>
<td width=44% valign=top>

<para>
-2147483648 til 2147483647
</para>

</entry>
<td width=20% valign=bottom sdval="0" sdnum="1030;">

<para>
0
</para>

</entry>
</row>

<row>
<td width=11% valign=top>

<para>
long
</para>

</entry>
<td width=13% valign=top>

<para>
heltal
</para>

</entry>
<td width=13% valign=top sdval="64" sdnum="1030;">

<para>
64
</para>

</entry>
<td width=44% valign=top>

<para>
-9223372036854775808 til 9223372036854775807
</para>

</entry>
<td width=20% valign=bottom sdval="0" sdnum="1030;">

<para>
0
</para>

</entry>
</row>
<tr valign=top>
      <td width=11%>

<para>
float
</para>

</entry>
<td width=13%>

<para>
kommatal
</para>

</entry>
<td width=13% sdval="32" sdnum="1030;">

<para>
32
</para>

</entry>
<td width=44%>

<para>
&plusmn;1.40239846E-45 til &plusmn;3.40282347E+38
</para>

</entry>
<td width=20%>

<para>
0.0
</para>

</entry>
</row>
<tr valign=top>
      <td width=11%>

<para>
double
</para>

</entry>
<td width=13%>

<para>
kommatal
</para>

</entry>
<td width=13% sdval="64" sdnum="1030;">

<para>
64
</para>

</entry>
<td width=44%>

<para>
&plusmn;4.94065645841246544E-324 til
</para>

<para>
&plusmn;1.79769313486231570E+308
</para>

</entry>
<td width=20%>

<para>
0.0
</para>

</entry>
</row>

<row>
<td width=11% valign=top>

<para>
char
</para>

</entry>
<td width=13% valign=top>

<para>
unicode
</para>

</entry>
<td width=13% valign=bottom sdval="16" sdnum="1030;">

<para>
16
</para>

</entry>
<td width=44% valign=top>

<para>
\u0000 til \uffff (0 til 65535)
</para>

</entry>
<td width=20% valign=top>

<para>
\u0000
</para>

</entry>
</row>

<row>
<td width=11% valign=top>

<para>
boolean
</para>

</entry>
<td width=13% valign=top>

<para>
logisk
</para>

</entry>
<td width=13% valign=bottom sdval="1" sdnum="1030;">

<para>
1
</para>

</entry>
<td width=44% valign=top>

<para>
true og false
</para>

</entry>
<td width=20% valign=top>

<para>
false
</para>

</entry>
</row>
</tbody>

</tgroup>
</table>

<para>
De vigtigste er int, double og boolean. I enkelte tilfælde
bliver long og char også brugt, mens byte, short og float meget
sjældent bruges.
</para>
</sect3>    <!--   De simple typer -->

<sect3>
  <title>Værditypekonvertering</title>

<para>
Konvertering til en anden type sker automatisk i de tilfælde,
hvor der ikke mistes information (forstået på den
måde, at intervallet af de mulige værdier udvides), dvs.
</para>

<itemizedlist mark="bullet">
  <listitem>

<para>

fra byte til short, int, long, float eller double
</para>

</listitem>

  <listitem>

<para>
fra short til int, long, float eller double
</para>

</listitem>

  <listitem>

<para>
fra int til long, float eller double
</para>

</listitem>

  <listitem>

<para>
fra long til float eller double
</para>

</listitem>

  <listitem>

<para>
fra float til double.
</para>

</listitem>
</itemizedlist>

<para>
Den anden vej, dvs. hvor der muligvis mistes information, fordi
intervallet af mulige værdier indsnævres, skal man
skrive en eksplicit typekonvertering.
</para>

<para>
Det gøres ved at skrive en parentes med typenavnet foran
det, der skal konverteres:
</para>

<screen>
int x;
double y;
y = 3.8;
x = (int) y
</screen>


<para>

Her skæres kommadelen af 3.8 væk og x får værdien
3.
</para>

<para>
Eksplicit typekonvertering sikrer at programmøren er
bevidst om informationstabet (glemmes dette kommer oversætteren
med fejlen: possible loss of precision: double, required: int).
Det skal ske
</para>

<itemizedlist mark="bullet">
  <listitem>

<para>

fra double til float, long, int, short, char eller byte
</para>

</listitem>

  <listitem>

<para>
fra float til long, int, short, char eller byte
</para>

</listitem>

  <listitem>

<para>
fra long til int, short, char eller byte
</para>

</listitem>

  <listitem>

<para>
fra int til short, char eller byte
</para>

</listitem>

  <listitem>

<para>
fra short til char eller byte
</para>

</listitem>

  <listitem>

<para>
fra byte til char
</para>

</listitem>

  <listitem>

<para>
fra char til short eller byte.
</para>

</listitem>
</itemizedlist>

<para>
Der kan ikke typekonverteres til eller fra boolean.
</para>
</sect3>    <!--   Værditypekonvertering -->

<sect3>
  <title>Aritmetiske operatorer</title>
<table>
<tgroup cols="0" align="char">
<thead>
    <tr valign=top>
      <th width=28%>

<para>
Operator
</para>

</th>
      <th width=29%>

<para>
Brug
</para>

</th>
      <th width=43%>

<para>
Forklaring
</para>

</th></row>
</thead>

<tbody>
    <tr valign=top>
      <td width=28%>

<para>
+
</para>

</entry>
<td width=29%>

<para>
a + b
</para>

</entry>
<td width=43%>

<para>
a lagt sammen med b
</para>

</entry>
</row>
<tr valign=top>
      <td width=28%>

<para>
-
</para>

</entry>
<td width=29%>

<para>
a - b
</para>

</entry>
<td width=43%>

<para>
b trukket fra a
</para>

</entry>
</row>
<tr valign=top>
      <td width=28%>

<para>
*
</para>

</entry>
<td width=29%>

<para>
a * b
</para>

</entry>
<td width=43%>

<para>
a gange b
</para>

</entry>
</row>
<tr valign=top>
      <td width=28%>

<para>
/
</para>

</entry>
<td width=29%>

<para>
a / b
</para>

</entry>
<td width=43%>

<para>
a divideret med b
</para>

</entry>
</row>
<tr valign=top>
      <td width=28%>

<para>
%
</para>

</entry>
<td width=29%>

<para>
a % b
</para>

</entry>
<td width=43%>

<para>
rest fra heltalsdivision af a med b
</para>

</entry>
</row>
<tr valign=top>
      <td width=28%>

<para>
-
</para>

</entry>
<td width=29%>

<para>
-a
</para>

</entry>
<td width=43%>

<para>
den negative værdi af a
</para>

</entry>
</row>
<tr valign=top>
      <td width=28%>

<para>
++
</para>

</entry>
<td width=29%>

<para>
a++
</para>

</entry>
<td width=43%>

<para>
a = a+1; værdi før optælling
</para>

</entry>
</row>
<tr valign=top>
      <td width=28%>

<para>
++
</para>

</entry>
<td width=29%>

<para>
++a
</para>

</entry>
<td width=43%>

<para>
a = a+1; værdi efter optælling
</para>

</entry>
</row>
<tr valign=top>
      <td width=28%>

<para>
--
</para>

</entry>
<td width=29%>

<para>
a--
</para>

</entry>
<td width=43%>

<para>
a = a-1; værdi før nedtælling
</para>

</entry>
</row>
<tr valign=top>
      <td width=28%>

<para>
--
</para>

</entry>
<td width=29%>

<para>
--a
</para>

</entry>
<td width=43%>

<para>
a = a-1; værdi efter nedtælling
</para>

</entry>
</row>
</tbody>

</tgroup>
</table>

<para>
Operatorerne giver altid samme type som operanderne, der indgår.
Det skal man være specielt opmærksom på for /
(divisions) vedkommende, hvor resten mistes ved heltalsdivision.
</para>

<para>
Operatoren ++ tæller en variabel op med &eacute;n : a++
svarer til a=a+1. Tilsvarende er a-- det samme som a=a-1.
</para>
</sect3>    <!--   Aritmetiske operatorer -->

<sect3>
  <title>Regning med logiske udtryk</title>

<para>
u1 og u2 er to logiske udtryk eller logiske variabler
</para>

<table>
<tgroup cols="0" align="char">
<thead>
    <tr valign=top>
      <th width=33%>

<para>
Operator
</para>

</th>
      <th width=33%>

<para>
Brug
</para>

</th>
      <th width=33%>

<para>
Forklaring
</para>

</th></row>
</thead>

<tbody>
    <tr valign=top>
      <td width=33%>

<para>
&amp;&amp;
</para>

</entry>
<td width=33%>

<para>
u1 &amp;&amp; u2
</para>

</entry>
<td width=33%>

<para>
både u1 og u2 er sandt
</para>

</entry>
</row>
<tr valign=top>
      <td width=33%>

<para>
||
</para>

</entry>
<td width=33%>

<para>
u1 || u2
</para>

</entry>
<td width=33%>

<para>
u1 eller u2 er sandt
</para>

</entry>
</row>
<tr valign=top>
      <td width=33%>

<para>
!
</para>

</entry>
<td width=33%>

<para>
! u1
</para>

</entry>
<td width=33%>

<para>
negation af u1
</para>

</entry>
</row>
</tbody>

</tgroup>
</table>

<para>
<emphasis>Operator &amp;&amp;</emphasis> udtrykker, at både 1. <emphasis>og</emphasis>
2. udtryk skal være sandt:
</para>

<table>
<tgroup cols="0" align="char">
<thead>
    <tr valign=top>
      <th width=33%>

<para>
1. udtryk
</para>

</th>
      <th width=33%>

<para>
2. udtryk
</para>

</th>
      <th width=33%>

<para>
1. udtryk &amp;&amp; 2. udtryk
</para>

</th></row>
</thead>

<tbody>
    <tr valign=bottom>
      <td width=33% sdval="0" sdnum="1030;0;boolean">

<para>
FALSK
</para>

</entry>
<td width=33% sdval="0" sdnum="1030;0;boolean">

<para>
FALSK
</para>

</entry>
<td width=33% sdval="0" sdnum="1030;0;boolean">

<para>
FALSK
</para>

</entry>
</row>
<tr valign=bottom>
      <td width=33% sdval="0" sdnum="1030;0;boolean">

<para>
FALSK
</para>

</entry>
<td width=33% sdval="1" sdnum="1030;0;boolean">

<para>
SAND
</para>

</entry>
<td width=33% sdval="0" sdnum="1030;0;boolean">

<para>
FALSK
</para>

</entry>
</row>
<tr valign=bottom>
      <td width=33% sdval="1" sdnum="1030;0;boolean">

<para>
SAND
</para>

</entry>
<td width=33% sdval="0" sdnum="1030;0;boolean">

<para>
FALSK
</para>

</entry>
<td width=33% sdval="0" sdnum="1030;0;boolean">

<para>
FALSK
</para>

</entry>
</row>
<tr valign=bottom>
      <td width=33% sdval="1" sdnum="1030;0;boolean">

<para>
SAND
</para>

</entry>
<td width=33% sdval="1" sdnum="1030;0;boolean">

<para>
SAND
</para>

</entry>
<td width=33% sdval="1" sdnum="1030;0;boolean">

<para>
SAND
</para>

</entry>
</row>
</tbody>

</tgroup>
</table>

<para>
F.eks. er udsagnet (a &gt; 5 &amp;&amp; a &lt; 10) sandt, hvis a
er større end 5, og a er mindre end 10.
</para>

<para>
<emphasis>Operator ||</emphasis> udtrykker, at 1. <emphasis>eller</emphasis> 2. udtryk skal
være sandt.
</para>

<table>
<tgroup cols="0" align="char">
<thead>
    <tr valign=top>
      <th width=33%>

<para>
1. udtryk
</para>

</th>
      <th width=33%>

<para>
2. udtryk
</para>

</th>
      <th width=33%>

<para>
1. udtryk || 2. udtryk
</para>

</th></row>
</thead>

<tbody>
    <tr valign=bottom>
      <td width=33% sdval="0" sdnum="1030;0;boolean">

<para>
FALSK
</para>

</entry>
<td width=33% sdval="0" sdnum="1030;0;boolean">

<para>
FALSK
</para>

</entry>
<td width=33% sdval="0" sdnum="1030;0;boolean">

<para>
FALSK
</para>

</entry>
</row>
<tr valign=bottom>
      <td width=33% sdval="0" sdnum="1030;0;boolean">

<para>
FALSK
</para>

</entry>
<td width=33% sdval="1" sdnum="1030;0;boolean">

<para>
SAND
</para>

</entry>
<td width=33% sdval="1" sdnum="1030;0;boolean">

<para>
SAND
</para>

</entry>
</row>
<tr valign=bottom>
      <td width=33% sdval="1" sdnum="1030;0;boolean">

<para>
SAND
</para>

</entry>
<td width=33% sdval="0" sdnum="1030;0;boolean">

<para>
FALSK
</para>

</entry>
<td width=33% sdval="1" sdnum="1030;0;boolean">

<para>
SAND
</para>

</entry>
</row>
<tr valign=bottom>
      <td width=33% sdval="1" sdnum="1030;0;boolean">

<para>
SAND
</para>

</entry>
<td width=33% sdval="1" sdnum="1030;0;boolean">

<para>
SAND
</para>

</entry>
<td width=33% sdval="1" sdnum="1030;0;boolean">

<para>
SAND
</para>

</entry>
</row>
</tbody>

</tgroup>
</table>

<para>
F.eks. er udsagnet (a &gt; 5 || a == 0) sandt, hvis a er større
end 5, eller a er 0.
</para>

<para>
<emphasis>Operator !</emphasis> Udtrykker, at udtrykket skal <emphasis>negeres</emphasis>,
dvs. at (!u1) er sandt, hvis u1 er falsk, og falsk hvis u1 er sandt,
f.eks. er udsagnet (!(a &gt; 5)) sandt, hvis der ikke gælder at
a er større end 5 (det er det samme som (a &lt;= 5)).
</para>

<para>
I visse andre programmeringssprog skrives AND for &amp;&amp;, OR
for || og NOT for !
</para>
</sect3>    <!--   Regning med logiske udtryk -->

<sect3>
  <title>Sammenligningsoperatorer</title>
<table>
<tgroup cols="0" align="char">
<thead>
    <tr valign=top>
      <th width=159>

<para>
Operator
</para>

</th>
      <th width=161>

<para>
Brug
</para>

</th>
      <th width=195>

<para>
Forklaring
</para>

</th></row>
</thead>

<tbody>
    <tr valign=top>
      <td width=159>

<para>
&gt;
</para>

</entry>
<td width=161>

<para>
a &gt; b
</para>

</entry>
<td width=195>

<para>
a større end b
</para>

</entry>
</row>
<tr valign=top>
      <td width=159>

<para>
&gt;=
</para>

</entry>
<td width=161>

<para>
a &gt;= b
</para>

</entry>
<td width=195>

<para>
a større end el. lig med b
</para>

</entry>
</row>
<tr valign=top>
      <td width=159>

<para>
&lt;
</para>

</entry>
<td width=161>

<para>
a &lt; b
</para>

</entry>
<td width=195>

<para>
a mindre end b
</para>

</entry>
</row>
<tr valign=top>
      <td width=159>

<para>
&lt;=
</para>

</entry>
<td width=161>

<para>
a &lt;= b
</para>

</entry>
<td width=195>

<para>
a mindre end el. lig med b
</para>

</entry>
</row>
<tr valign=top>
      <td width=159>

<para>
 ==
</para>

</entry>
<td width=161>

<para>
a == b
</para>

</entry>
<td width=195>

<para>
a er lig med (identisk med) b
</para>

</entry>
</row>
<tr valign=top>
      <td width=159>

<para>
!=
</para>

</entry>
<td width=161>

<para>
a != b
</para>

</entry>
<td width=195>

<para>
a forskellig fra b
</para>

</entry>
</row>
</tbody>

</tgroup>
</table>
</sect3>    <!--   Sammenligningsoperatorer -->

<sect3>
  <title>Gode råd om programmering</title>
<itemizedlist mark="bullet">
  <listitem>

<para>

Gennemtænk problemstillingen, inden du sætter dig
  til computeren.
</para>

</listitem>

  <listitem>

<para>
Formul&eacute;r problemet eller formålet med
  programmet.
</para>

</listitem>

  <listitem>

<para>
Overvej mulige løsningsstrategier. De fleste problemer
  kan løses på mere end &eacute;n måde.
</para>

</listitem>

  <listitem>

<para>
Lav en skitse til programmet i pseudokode (på papiret
  med danske ord). Du kan også tegne flowdiagrammer (der
  beskriver rækkefølgen tingene sker i).
</para>

</listitem>

  <listitem>

<para>
Det er ikke altid, man kan tænke hele programmet
  igennem på forhånd. Ved mere komplicerede programmer må
  man skifte mellem kodning og refleksion over koden.
</para>

</listitem>

  <listitem>

<para>
Når du sidder ved computeren, så skriv ganske få
  linier ad gangen, og afprøv. På den måde er det
  ofte lettere at se problemet, hvis programmet ikke virker.
</para>

</listitem>

  <listitem>

<para>
Gør flittigt brug af System.out.println(...) til at
  kontrollere, om programmet gør som forventet.
</para>

</listitem>

  <listitem>

<para>
Lær en standardiseret indrykning fra starten og følg
  den stringent (Se afsnit 2.4.1).
</para>

</listitem>
</itemizedlist>

<para>
<xref linkend="sdfootnote1anc">Nøjere
  bestemt til et tal mellem -2147483648 og 2147483647, da der kun er
  reserveret 4 byte, dvs. 32 bit.
</para>

<para>
<xref linkend="sdfootnote2anc">Der
  er altså ikke tale om en matematisk ligning, der altid skal
  gælde, men om en tildeling, hvor variablen på venstre
  side får tildelt værdien af udtrykket på
  højresiden.
</para>

<para>
<xref linkend="sdfootnote3anc">Man
  kan med operatoren % finde resten af divisionen. 13 % 5 giver altså
  3, fordi 13 - 5*2 = 3.
</para>

<para>
<xref linkend="sdfootnote4anc">sqrt
  er en forkortelse for square root.
</para>

<para>
<xref linkend="sdfootnote5anc">Opkaldt
  efter den britiske matematiker George Boole, 1815-64.
</para>

<para>
<xref linkend="sdfootnote6anc">Eksemplet
  ville naturligvis være sjovere hvis, brugeren af programmet
  kunne taste sin alder ind, i stedet for at skulle rette i
  programmet.
</para>

<para>
<xref linkend="sdfootnote7anc">De
  som kender Pascal, vil genkende { som BEGIN og } som END.
</para>

<para>
<xref linkend="sdfootnote8anc">30-50
  % af de problemer nybegyndere, har med at få deres programmer
  til at virke, skyldes dårlig indrykning, som gør koden
  uoverskuelig.
</para>

<para>
<xref linkend="sdfootnote9anc">På
  et tidspunkt når n til -2147483648. Variablens 32-bit
  kapacitet vil være opbrugt, og n vil faktisk skifte til
  2147483647 som er større end 10 hvorved løkken vil
  stoppe, men der er næppe nogen der gider vente så
  længe!
</para>

<para>
<xref linkend="sdfootnote10anc">hvilket
  er noget ganske andet end uendelig l<emphasis>y</emphasis>kke!
</para>

<para>
<xref linkend="sdfootnote11anc">Med
  metoden Math.round(x) kan man få den normale afrunding hvor
  3.5 rundes op til 4 og 3.4999 rundes ned til 3.
</para>

<para>
<xref linkend="sdfootnote12anc">Man
  skal være opmærksom på at hvis det konverteres fra
  et meget stort tal kan det være at den nye type ikke kan
  repræsentere tallet. F.eks. vil konvertering fra
  10000000000000.0 til int ikke give det forventede, da det
  største tal int kan rumme er 2147483647. Ved
  typekonverteringen fra int (32 bit) til float (16 bit) mistes noget
  præcision (de mindst betydende cifre).
</para>

<para>
<xref linkend="sdfootnote13anc">
  Den ser ikke engang, om en konstant værdi uproblematisk kan
  konverteres: int x; x=4.0; //Fejl
</para>
</sect3>    <!--   Gode råd om programmering -->
</sect2>    <!--   Opgaver -->
</sect1>
</chapter>    <!--   Basal programmering -->

