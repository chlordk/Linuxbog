<chapter>
  <title>Avancerede klasser</title>

<para>
Indhold:
</para>

<itemizedlist mark="bullet">
  <listitem>

<para>

Nøgleordene public, protected og private forklaret i
  dybden
</para>

</listitem>

  <listitem>

<para>
Nøgleordet final
</para>

</listitem>

  <listitem>

<para>
Nøgleordet abstract
</para>

</listitem>

  <listitem>

<para>
Nøgleordenes betydning når de anvendes på
  variabler, metoder og klasser
</para>

</listitem>
</itemizedlist>

<para>
Dette kapitels afsnit om final på variabler forudsættes
af kapitel 21, Indre klasser.
</para>

<para>
Forudsætter kapitel 5, Nedarvning og 6, Pakker og ønske
om at vide mere om emner som først bliver relevante når
man laver større programmer.
</para>

<sect2>
  <title>public, protected og private</title>

<para>
Det er vigtigt at styre adgangen til at kalde metoder og ændre
på variabler, i særdeleshed når programmerne bliver
store. Det kan lette overskueligheden meget hvis interne variabler,
metoder og klasser er skjult for programmøren.
</para>

<para>
Adgang styres med nøgleordene public, protected og private.
Adgangskontrol ud over
public/private bliver først interessant når der er mange
klasser og programmet spænder over flere pakker. Se
eventuelt kapitlet om pakker.
</para>

<sect3>
  <title>Variabler og metoder</title>

<para>
Variabler og metoder erklæret
<emphasis>public</emphasis> er altid tilgængelige, inden og uden for
klassen.
</para>

<para>
Variabler og metoder erklæret
<emphasis>protected</emphasis> er tilgængelige for alle klasser inden for
samme pakke. Klasser i andre pakker kan kun få adgang, hvis de
er nedarvinger.
</para>

<para>
Skriver man <emphasis>ingenting</emphasis>, er det kun klasser i samme pakke,
der har adgang til variablen eller metoden.
</para>

<para>
Hvis en variabel eller metode er erklæret <emphasis>private</emphasis>,
kan den kun benyttes inden for samme klasse (og kan derfor ikke
tilsidesættes med nedarvning). Det er det mest restriktive.
</para>

<para>
Adgangen kan sættes på skemaform:
</para>

<table>
<tgroup cols="0" align="char">
<thead>
    <tr valign=top>
      <th width=45% height=15>

<para>
Adgang
</para>

</th>
      <th width=13%>

<para>
public
</para>

</th>
      <th width=14%>

<para>
protected
</para>

</th>
      <th width=15%>

<para>
(ingenting)
</para>

</th>
      <th width=13%>

<para>
private
</para>

</th></row>
</thead>

<tbody>
    <tr valign=top>
      <td width=45% height=16>

<para>
i samme klasse
</para>

</entry>
<td width=13%>

<para>
ja
</para>

</entry>
<td width=14%>

<para>
ja
</para>

</entry>
<td width=15%>

<para>
ja
</para>

</entry>
<td width=13%>

<para>
ja
</para>

</entry>
</row>
<tr valign=top>
      <td width=45% height=16>

<para>
klasse i samme pakke
</para>

</entry>
<td width=13%>

<para>
ja
</para>

</entry>
<td width=14%>

<para>
ja
</para>

</entry>
<td width=15%>

<para>
ja
</para>

</entry>
<td width=13%>

<para>
nej
</para>

</entry>
</row>
<tr valign=top>
      <td width=45% height=16>

<para>
arving i en anden pakke
</para>

</entry>
<td width=13%>

<para>
ja
</para>

</entry>
<td width=14%>

<para>
ja
</para>

</entry>
<td width=15%>

<para>
nej
</para>

</entry>
<td width=13%>

<para>
nej
</para>

</entry>
</row>
<tr valign=top>
      <td width=45% height=15>

<para>
ej arving og i en anden pakke
</para>

</entry>
<td width=13%>

<para>
ja
</para>

</entry>
<td width=14%>

<para>
nej
</para>

</entry>
<td width=15%>

<para>
nej
</para>

</entry>
<td width=13%>

<para>
nej
</para>

</entry>
</row>
</tbody>

</tgroup>
</table>

<para>
Holder man sig inden for samme pakke, er der altså ingen
forskel mellem public, protected og ingenting.
</para>
</sect3>    <!--   Variabler og metoder -->

<sect3>
  <title>Klasser</title>

<para>
Klasser kan erklæres public eller ingenting (men ikke
protected eller private).
</para>

<para>
Klasser erklæres normalt public og er tilgængelige fra
alle pakker.
</para>

<screen>
<prompt><emphasis>public</emphasis> class X </prompt>
<prompt>{</prompt>
<emphasis>  // ...</emphasis>
<prompt>}</prompt>
</screen>


<para>
Undlader man public, er klassen kun tilgængelig inden for
samme pakke.
</para>

<screen>
<prompt>class X</prompt>
<prompt>{</prompt>
<emphasis>  // ...</emphasis>
<prompt>}</prompt>
</screen>


<para>
Man kan have flere klasser i en fil, men højst en, der er
public, og denne klasse skal hedde det samme som filnavnet.
</para>
</sect3>    <!--   Klasser -->
</sect2>    <!--   public, protected og private -->

<sect2>
  <title>Nøgleordet final</title>

<para>
Noget, der er erklæret <emphasis>final</emphasis>, kan ikke ændres.
Både variabler, metoder og klasser kan erklæres
final.
</para>

<sect3>
  <title>Variabler</title>

<para>
En variabel, der er erklæret <emphasis>final</emphasis>, kan ikke ændres,
når den først har fået en værdi.
</para>

<screen>
public class X 
{
  public <emphasis>final</emphasis> int a=10;

<emphasis>  //..</emphasis>
<emphasis>  // forbudt: a=11;</emphasis>
}
</screen>


<para>
Herover kan a's værdi ikke ændres i den efterfølgende
kode.
</para>

<para>
Det kan lette overskueligheden at vide, hvilke variabler, der er
konstante. Desuden udføres programmet lidt hurtigere.
</para>

<para>
final foran en objektvariabel angiver ikke synlighed, men kan
bruges sammen med public, protected og private.
</para>

<para>
final kan også bruges på lokale variabler (hvor
public, protected og private aldrig kan bruges):
</para>

<screen>
  public static void main(String args[])
  {
    <emphasis>final</emphasis> Vector v = new Vector();

<emphasis>    //v = new Vector();  // ulovligt! v kan ikke ændres.</emphasis>
</screen>


<para>
Bemærk: Når vi arbejder med objekter, er variablerne
jo referencer til objekterne. En variabel erklæret final
kan ikke ændres til at referere til et andet objekt, men
objektet kan godt få ændret sin indre tilstand, f.eks.
gennem et metodekald:
</para>

<screen>
    v.addElement(&quot;Hans&quot;);<emphasis>  // lovligt, v refererer stadig til samme objekt</emphasis>
</screen>
</sect3>    <!--   Variabler -->

<sect3>
  <title>Metoder</title>

<para>
En metode erklæret final kan ikke tilsidesættes i en
nedarving.
</para>

<screen>
public class X 
{
  public <emphasis>final</emphasis> void a()
  {
<emphasis>    // ..</emphasis>
  }
}
</screen>

<screen>
public class Y extends X 
{
  public void a()<emphasis> // ulovligt! a() er final</emphasis>
  {
<emphasis>    //..</emphasis>
  }
}
</screen>


<para>
Den virtuelle maskine kan optimere final metoder, så kald
til dem sker en smule hurtigere.
</para>
</sect3>    <!--   Metoder -->

<sect3>
  <title>Klasser</title>

<para>
En klasse erklæret final må man overhovedet ikke arve
fra (og alle dens metoder bliver final).
</para>

<screen>
public <emphasis>final</emphasis> class X 
{
<emphasis>  // ..</emphasis>
}
</screen>

<screen>
public class Y extends X<emphasis>  // ulovligt! X er final</emphasis>
{
}
</screen>
</sect3>    <!--   Klasser -->
</sect2>    <!--   Nøgleordet final -->

<sect2>
  <title>Nøgleordet abstract</title>

<para>
Noget der er erklæret <emphasis>abstract</emphasis> er ikke implementeret
og skal defineres i en nedarvning.
</para>

<para>
Det skrives i kursiv i UML-notationen.
</para>

<sect3>
  <title>Klasser</title>

<para>
En abstrakt klasse erklæres således
</para>

<screen>
public <emphasis>abstract</emphasis> class X 
{
  public void a()
  {
<emphasis>    //..</emphasis>
  }
}
</screen>


<para>
Det er ikke tilladt at oprette objekter fra en abstrakt klasse
</para>

<screen>
  public static void main(String args[])
  {
    X x = new X();<emphasis>   // ulovligt! X er abstrakt</emphasis>
</screen>


<para>
I stedet skal man arve fra klassen
</para>

<screen>
public class Y extends X 
{
}
</screen>


<para>
og lave objekter fra den nedarvede klasse:
</para>

<screen>
  public static void main(String args[])
  {
    X x;            <emphasis>// lovligt</emphasis>

    x = new Y();    <emphasis>// lovligt, Y er ikke abstrakt</emphasis>
</screen>


<para>
Basisklasserne for IO-systemet, InputStream og OutputStream,
abstrakte, fordi programmøren altid skal bruge en mere
konkret klasse, f.eks. FileInputStream (se afsnit 14.5.2).
</para>

<para>
Det er lovligt (og nyttigt i visse tilfælde) at have
variabler af en abstrakt klasse (det svarer til, at det er lovligt og
nyttigt at have variabler af en interface-type).
</para>
</sect3>    <!--   Klasser -->

<sect3>
  <title>Metoder</title>

<para>
En metode erklæret abstract har et metodehoved, men ingen
krop. Den kan kun erklæres i en abstrakt klasse
</para>

<screen>
public abstract class X 
{
  public <emphasis>abstract</emphasis> void a();
}
</screen>


<para>
Nedarvede klasser skal definere de abstrakte metoder (eller også
selv være abstrakte)
</para>

<screen>
public class Y extends X 
{
  public void a()
  {
<emphasis>    //..</emphasis>
  }
}
</screen>
</sect3>    <!--   Metoder -->
</sect2>    <!--   Nøgleordet abstract -->
</chapter>    <!--   Avancerede klasser -->

