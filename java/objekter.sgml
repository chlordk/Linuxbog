<chapter id="java-obj">
  <title>Objekter</title>

<para>
Indhold:
</para>

<itemizedlist mark="bullet">
  <listitem>

<para>

Objekter og klasser
</para>

</listitem>

  <listitem>

<para>
Oprettelse af objekter og konstruktører
</para>

</listitem>

  <listitem>

<para>
Brug af objekters variabler og metoder
</para>

</listitem>

  <listitem>

<para>
Punkter, rektangler, strenge, vektorer
</para>

</listitem>
</itemizedlist>

<para>
Kapitlet forudsættes i resten af bogen.
</para>

<para>
Forudsætter <xref linkend="java-basal-prg" />, Basal programmering.
</para>


<sect1 id="java-obj-klasser">
  <title>Objekter og klasser</title>

<para>
Hidtil har vi kun brugt de <emphasis>simple typer</emphasis> (som
int, boolean og double). Et javaprogram vil ofte udføre
mere komplekse opgaver og dermed have brug for <emphasis>objekter</emphasis>. Et
objekt repræsenterer en eller anden (ofte fysisk) ting og
indeholder sammensatte data om denne ting, f.eks. et hus-objekt (med
adresse, telefonnummer, antallet af døre og vinduer ...), en
bil, en person, en bankkonto, en selvangivelse, en ordre, et dokument
...
</para>

<para>
Objekter kan klassificeres i forskellige kategorier, kaldet
<emphasis>klasser</emphasis>. F.eks. kunne man sige, at alle hus-objekter tilhører
Hus-klassen. Hus-klassen er en beskrivelse af alle slags huse.
</para>

<para>
Næsten alt er repræsenteret som objekter i Java, og
der findes tusindvis af foruddefinerede klasser til ting, som
man ofte har brug for som programmør såsom:
tekststrenge, datoer, lister, filer og kataloger, vinduer,
knapper, menuer, netværksforbindelser, hjemmeside-adresser,
billeder, lyde ...
</para>

<para>
Et objekt indeholder data, der beskriver det, som objektet
repræsenterer. Et Fil-objekt har oplysninger om den fil, det
repræsenterer: Navn, placering, type, dato for oprettelse og
indhold. Et Person-objekt har måske variabler for fornavn,
efternavn, CPR-nummer.
</para>

<para>
Et objekt kan også indeholde navngivne programstumper, som
kan udføres ved at give objektet besked om det. Disse
programstumper kaldes metoder og kan opfattes som spørgsmål
eller kommandoer, som man bruger til at undersøge og
manipulere indholdet af objektet med.
</para>

<para>
Et Fil-objekt har måske metoden &quot;omdøb()&quot;,
der ændrer filens navn, et Person-objekt kan måske give
personens alder med metoden &quot;hvadErDinAlder()&quot;.
</para>

<blockquote><para>Et objekt kan indeholde metoder og
data (variabler)</para></blockquote>
<blockquote><para>En metode kan ændre på
objektets data, når den udføres</para></blockquote>

<para>
Ligesom med de simple typer afhænger det af objektets type,
dets klasse, hvad man kan gøre med det. Ordet &quot;klasse&quot;
skal forstås i betydningen &quot;kategori, gruppe&quot;. Alle
objekter kan klassificeres som værende af en bestemt type
(klasse), f.eks. Streng, Dato, Fil, Knap.
</para>

<blockquote><para>Et objekts type kaldes dets klasse</para></blockquote>
<blockquote><para>Klassen bestemmer, hvilke metoder og
data et objekt indeholder</para></blockquote>

<para>
Objekter af samme klasse forstår de samme beskeder
(kommandoer og spørgsmål) og indeholder samme slags
data. Objekter af klassen Person indeholder f.eks. begge et navn, men
navnene (data) i de to person-objekter kan være forskellige.
</para>

<figure id="java-obj-klasse2-fig">
<title>Java</title>

<graphic fileref="Nordfalk515358.&magic;" scale="60"></graphic>
</figure>

<para>
Vi tegner klasser som vist her:
</para>

<figure id="java-obj-klasse3-fig">
<title>Java</title>
<graphic fileref="Nordfalk515360.&magic;" scale="60"></graphic>
</figure>



<para>
&Oslash;verst er klassens navn, dernæst data og nederst
metoderne.
</para>

<para>
Dette er en del af UML-notationen (Unified Modelling Language), en
notation, der ofte bliver anvendt i forbindelse med objektorienteret
programmering.
</para>

<para>
I dette kapitel vil vi bruge objekter fra foruddefinerede klasser.
Vi har valgt at kigge nærmere på nogle klasser, der
er velegnede til at illustrere ideerne, nemlig Point, Rectangle,
String, Date, StringBuffer og Vector.
</para>

<para>
String og Vector er nok de mest brugte klasser overhovedet og
er næsten uundværlige i praktisk programmering.
</para>

</sect1>

<sect1 id="java-obj-klasser-punkter"> 
<title>Punkter (klassen Point)</title>

<para>
Det første objekt, vi vil arbejde med, er Javas
Point-objekt, der repræsenterer et <emphasis>punkt</emphasis>. I Java
indeholder et punkt to heltalsvariable, nemlig en x- og en
y-koordinat. Vi vil senere bruge Point-klassen, når vi kommer
til programmering af grafik.
</para>

<sect2 id="java-obj-klasser-def-opr">
  <title>Erklæring og oprettelse</title>

<para>
For at kunne arbejde med et objekt har man brug for en variabel,
der refererer til objektet. En variabel af typen Point (der refererer
til et punkt) erklæres ved at skrive
</para>

<screen>
<prompt>  Point p;</prompt>
</screen>

<figure id="java-obj-point-fig">
<title>Java <emphasis>p
  refererer til et punktobjekt.Objektet har x=0 og y=0</emphasis></title>
<graphic fileref="Nordfalk515361.&magic;" scale="60"></graphic>
</figure>

<para>
Ligesom med de simple typer skriver man typen (Point)
efterfulgt af variabelnavnet. Nu har vi defineret, at p er en
variabel til objekter af typen Point, og vi kan lave et nyt
Point-objekt, som vi sætter p til at pege på:
</para>

<screen>
<prompt>  p = new Point();</prompt>
</screen>


<para>
Vi skriver altså new og klassens navn (Point) efterfulgt af
parenteser med startværdier for objektet. Her giver vi ingen
startværdier, og parentesen er derfor tom.
</para>

<blockquote><para>Et objekt oprettes med new</para></blockquote>
<blockquote><para>Når et objekt oprettes, sørger
det for dets datas startværdi</para></blockquote>

<para>
I dette tilfælde vil punktet starte med at have
koordinaterne (0,0), og situationen er som vist på figuren til
højre: p peger hen på et objekt, der har en x- og
y-variabel, som begge er sat til 0.
</para>

<para>
Man kan sige, at hver gang vi anvender new-operatoren, bruger vi
klassen som en slags støbeform til at skabe et nyt objekt med.
</para>
</sect2>    <!--   Erklæring og oprettelse -->

<sect2 id="java-obj-klasser-var">
  <title>Objektvariable</title>

<para>
Vi kan undersøge objektet p's variabler. Her erklærer
vi en anden variabel, a,
</para>

<screen>
<prompt>    int a;</prompt>
</screen>


<para>
... og gemmer p's x-koordinat i variablen:
</para>

<screen>
<prompt>    a = p.x;</prompt>
</screen>


<para>
p's x-koordinat får man fat i ved at skrive p punktum x. Vi
kan derefter udskrive a:
</para>

<screen>
    System.out.println(&quot;a: &quot;+a);
</screen>


<para>
Man kan også udskrive koordinaterne direkte uden at bruge a
som mellemvariabel:
</para>

<screen>
    System.out.println(&quot;x-koordinat: &quot;+p.x);
    System.out.println(&quot;y-koordinat: &quot;+p.y);
</screen>


<figure id="java-obj-point2-fig">
<title>Efter tildeling af p.x og p.y</title>
<graphic fileref="Nordfalk515362.&magic;" scale="60"></graphic>
</figure>

<para>
Vi kan også ændre p's koordinater:
</para>

<screen>
    p.x = 110;
    p.y = 210;
</screen>


<para>
Variablerne x og y i Point-objektet kan behandles fuldstændig
som andre variabler af typen int, når vi bare husker at skrive
&quot;p.&quot; foran. F.eks. kan man tælle x-koordinaten op med
5:
</para>

<screen>
      p.x = p.x + 5;
</screen>


<para>
x og y kaldes objektvariabler, fordi de tilhører objektet
p.
</para>
</sect2>    <!--   Objektvariable -->

<sect2 id="java-obj-klasser-met">
  <title>Metodekald</title>

<para>
I stedet for at ændre objektet udefra, kan vi bede objektet selv
udføre ændringen. Metoden move() flytter punktet til et bestemt
koordinatsæt, dvs. den ændrer x- og y-koordinaten.  </para>

<figure id="java-obj-point3-fig">
<title>Efter kald af move(200,300)</title>

<graphic fileref="Nordfalk515363.&magic;" scale="60"></graphic>
</figure>


<screen>
    p.move(200,300);
</screen>


<para>
Man siger, at man foretager et metodekald på objektet som p
refererer til, og man skriver: p punktum metodenavn parenteser.
</para>

<para>
Efter metodekaldet til move() har x- og y-koordinaterne ændret
sig i det objekt, som p peger på.
</para>

<blockquote><para>Et objekt kan indeholde metoder</para></blockquote>
<blockquote><para>Et metodekald på et objekt kan
ændre objektets variabler</para></blockquote>

<para>
Her er Point-klassen illustreret i UML-notationen:
</para>

<figure id="java-obj-point-uml-fig">
<title>Java</title>

<graphic fileref="Nordfalk515364.&magic;" scale="60"></graphic>
</figure>


<para>
Herunder er nogle af de metoder, som punktobjekter forstår
(en oversigt over klassen kan findes i appendiks, 
<xref linkend="java-obj-appendix-point" />).
</para>

<para>
<emphasis>Nogle af Point-klassens
metoder</emphasis>
</para>

<para>
<emphasis>move</emphasis>(int x, int y)Sætter
punktets koordinater
</para>

<para>
<emphasis>translate</emphasis>(int x, int y)Rykker
punktets koordinater relativt i forhold til, hvor det er
</para>

<para>
Først står navnet på metoden med fed, f.eks.:
<emphasis>move</emphasis>.
</para>

<para>
Derefter står parametrene adskilt af komma, f.eks.: (int x,
int y).
</para>

<para>
For hver parameter er angivet en type og et navn.
</para>

<para>
Typen angiver, hvilke værdier man kan kalde metoden med, og
bruges til at kontrollere, at man har kaldt den med en værdi af
den rigtige type.
</para>

<para>
Navnet i beskrivelsen bruges kun til at minde om, hvordan metoden
bruger parameteren.
</para>

<para>
Bemærk at kaldet derfor ser anderledes ud end beskrivelsen:
</para>

<screen>
p.move(200,300);          <emphasis>// korrekt</emphasis>
p.move(int 200, int 300); <emphasis>// sprogfejl: parametertyper angivet ved kald.</emphasis>
p.move(x=200, y=300);     <emphasis>// sprogfejl: parameternavne angivet ved kald.</emphasis>
</screen>

<blockquote><para>I parenteserne i metodekaldet giver
man oplysninger til objektet om, hvordan man vil have metoden udført</para></blockquote>
<blockquote><para>Oplysningerne kaldes parametre (eller
argumenter)</para></blockquote>

<para>
I kaldet til move() ovenfor gav vi oplysningerne 200 og 300 som
parametre.
</para>
</sect2>    <!--   Metodekald -->

<sect2 id="java-obj-klasser-eks">
  <title>Eksempel</title>

<para>
Her er et eksempel på tingene, vi har vist ovenfor:
</para>

<screen>
import java.awt.*; <emphasis>// Point-klassen skal importeres fra pakken java.awt</emphasis>

public class Punkt
{
  public static void main(String[] args) 
  {
    Point p;
    p = new Point();

    int a;
    a = p.x;

    System.out.println(&quot;a: &quot;+a);

    System.out.println(&quot;x-koordinat: &quot;+p.x);
    System.out.println(&quot;y-koordinat: &quot;+p.y);

    p.x = 110;
    p.y = 210;

    System.out.println(&quot;x-koordinat: &quot;+p.x);
    System.out.println(&quot;y-koordinat: &quot;+p.y);

    p.move(200,300);

    System.out.println(&quot;x-koordinat: &quot;+p.x);
    System.out.println(&quot;y-koordinat: &quot;+p.y);

    p.x = p.x + 5;

    System.out.println(&quot;x-koordinat: &quot;+p.x);
    System.out.println(&quot;y-koordinat: &quot;+p.y);

    p.translate(-10,20);

    System.out.println(&quot;x-koordinat: &quot;+p.x);
    System.out.println(&quot;y-koordinat: &quot;+p.y);
  }
}
</screen>

<para>Resultatet bliver:</para>

<screen>
a: 0
x-koordinat: 0
y-koordinat: 0
x-koordinat: 110
y-koordinat: 210
x-koordinat: 200
y-koordinat: 300
x-koordinat: 205
y-koordinat: 300
x-koordinat: 195
y-koordinat: 320
</screen>
</sect2>  

<sect2 id="java-obj-klasser-imp">
  <title>Import af standardklasser</title>

<para>
&Oslash;verst i kildeteksten &quot;importerer&quot; vi alle
klasser i pakken java.awt:
</para>

<screen>
import java.awt.*;
</screen>


<para>
Dette fortæller oversætteren, hvor den skal lede efter
definitionen af klasserne, vi bruger i programmet. I dette tilfælde
er det for, at oversætteren skal kende til Point-klassen (der
findes i pakken java.awt).
</para>

<para>
En pakke er en samling klasser med beslægtede funktioner.
AWT står for &quot;Abstract Window Toolkit&quot;, og
java.awt indeholder forskellige nyttige klasser til at tegne grafik
på skærmen, herunder klasser til at repræsentere
punkter og rektangler.
</para>

<para>
Lige nu er det nok at vide, at de fleste klasser skal importeres,
før de kan bruges (hvis du er meget nysgerrig, kan du læse
den første del af kapitlet om pakker allerede nu).
</para>
</sect2>    <!--   Import af standardklasser -->
</sect1>    <!--   Objekter og klasser -->

<sect1 id="java-obj-rekt">
  <title>Rektangler (klassen Rectangle)</title>

<para>
Vi vil nu gå videre til nogle lidt mere indviklede objekter,
af klassen Rectangle. Den bruges sjældent i praksis (så
du behøver ikke lære dens metoder udenad), men den er
velegnet til at illustrere ideer omkring oprettelse af objekter
(konstruktører) og metodekald med returværdi.
</para>

<para>
Et rektangel-objekt består af en x- og y-koordinat og en
højde og bredde. Disse objektvariabler (data) hedder
x,y,width og height.
</para>

<para>
En variabel med navnet r af typen Rectangle erklæres med:
</para>

<screen>
    Rectangle r;
</screen>


<para>
Ligesom med Point skal vi have lavet et rektangel-objekt, som r
refererer til:
</para>

<figure id="java-obj-rekt-fig">
<title>Java</title>

<graphic fileref="Nordfalk515365.&magic;" scale="60"></graphic>
</figure>

<screen>
    r = new Rectangle();
</screen>


<para>
Dette skaber et Rectangle-objekt med x,y,width og height sat til
0.
</para>

<para>
Vi kan ændre dette til (1,1,10,10) med:
</para>

<screen>
    r.x=1;
    r.y=1;
    r.width=10;
    r.height=10;
</screen>


<para>
Det er besværligt hvis vi skal bruge fire linjers
programkode på at sætte et objekts værdier hver
gang vi opretter det.
</para>

<sect2 id="java-obj-rekt-konst">
  <title>Konstruktører</title>

<para>
Når man vil oprette et objekt med bestemte startværdier,
kan det gøres ved at benytte en <emphasis>konstruktør</emphasis>,
hvor startværdierne kan angives.
</para>

<para>
For eksempel kan et rektangel oprettes med:
</para>

<screen>
    r = new Rectangle(1,1,10,10);
</screen>


<para>
De fire parametre i parenteser fortæller, at det rektangel,
som skal skabes, som start skal have det øverste venstre
hjørne i (1,1) og en bredde og en højde på 10.
Det er i virkeligheden en slags metodekald, vi her foretager, så
det er ikke nogen tilfældighed, hvis det ligner.
</para>

<blockquote><para>Når man skaber et nyt objekt med
new, kaldes en konstruktør</para></blockquote>
<blockquote><para>Konstruktøren skaber et nyt
objekt og initialiserer objektets data</para></blockquote>
<blockquote><para>Nogle konstruktører tager
parametre, der beskriver, hvordan objektet skal oprettes</para></blockquote>

<para>
Herunder er beskrevet tre konstruktører for Rectangle -
dvs. tre måder rektangler kan oprettes på.
</para>

<para>
<emphasis>Nogle af
Rectangle-klassens konstruktører</emphasis>
</para>

<para>
Rectangle()opretter
et rektangel i (0,0), hvis bredde og højde er 0
</para>

<para>
Rectangle(int
bredde, int højde)opretter et rektangel i (0,0) med den
angivne bredde og højde
</para>

<para>
Rectangle(int
x, int y, int bredde, int højde)opretter et rektangel i
(x,y) med den angivne bredde og højde
</para>

<para>
Point-klassens konstruktører er beskrevet i appendikset
<xref linkend="java-obj-appendix-point" />. 
Vi kan f.eks. bruge den, der tager to parametre:
</para>

<screen>
    Point p;
    p= new Point(8,6);  <emphasis>// skaber et Point med koordinaterne (8,6)</emphasis>
</screen>
</sect2>    <!--   Konstruktører -->

<sect2 id="java-obj-rekt-met">
  <title>Metoder</title>

<para>
Vi vil nu lave et lille program, der tjekker, om punktet p ligger
inde i rektanglet r. Vi erklærer en variabel, inde, af
type boolean, som vi kan bruge til at gemme resultatet af vores
undersøgelse i.
</para>

<screen>
    boolean inde;
</screen>


<para>
Objekter af klassen Rectangle har en metode, contains(), som kan
fortælle, om et punkt ligger inde i rektanglet:
</para>

<screen>
    inde = r.contains(p);
</screen>


<para>
Det, der sker, er, at vi kalder metoden contains() - svarende til
spørgsmålet <emphasis>&quot;indeholder du p?&quot;</emphasis> - på
rektanglet r. Vi giver p med som parameter, således at
rektanglets metode ved, at det lige præcis er punktet p, som
skal undersøges. Metoden bliver udført og foretager
nogle beregninger, som vi ikke kan se, og til sidst kommer den ud med
et svar. Dette svar returneres til os og bliver gemt i variablen
'inde'. Modsat tilfældet med Point-objekters move()- og
translate()-metoder er rektanglers indhold uændret af kald af
contains().
</para>

<blockquote><para>Ikke alle metoder på et objekt
ændrer på det</para></blockquote>
<blockquote><para>Nogle metoder giver et svar tilbage
(returnerer et resultat)</para></blockquote>

<para>
Prøv at sammenligne det med kaldet til Math.sqrt(), som vi
så i forrige kapitel:
</para>

<screen>
    hypotenuse = Math.sqrt(x*x + y*y);
</screen>


<para>
Det er samme mekanisme: Vi spørger Math.sqrt() om, hvad
kvadratroden af x*x+y*y er, og svaret, som metoden giver tilbage,
gemmer vi i variablen hypotenuse.
</para>
</sect2>    <!--   Metoder -->

<sect2 id="java-obj-rekt-retur">
  <title>Metoders returtype</title>

<para>
Ligesom parametre skal være af den rette type, gælder
det for resultatet af et metode-kald at:
</para>

<blockquote><para>En metode giver et resultat af en
bestemt type, når den bliver udført</para></blockquote>
<blockquote><para>Dette kaldes metodens returtype</para></blockquote>

<para>
Math.sin() har returtypen double, mens contains() på et
rektangel-objekt har returtypen boolean. Det er derfor, vores
variabel 'inde' også skulle have typen boolean.
</para>

<para>
Hvis punktet var inde i rektanglet, så vil vi skrive det på
skærmen:
</para>

<screen>
    if (inde==true)
    {
        System.out.println(&quot;p r inde i r&quot;);
    }
</screen>


<para>
Herunder ses nogle af Rectangle-klassens metoder. Foran
metode-navnene står returtyperne. I kursiv står
spørgsmålene, som de svarer til. En mere komplet
oversigt over klassen kan findes  i appendiks i 
<xref linkend="java-obj-appendix-rectangle" />. 
</para>

<para>
<emphasis>Nogle af
Rectangle-klassens metoder.</emphasis>
</para>

<para>
boolean
<emphasis>contains </emphasis>(Point p)  <emphasis>&quot;indeholder du
p?&quot;</emphasis>returnerer true hvis <emphasis>p</emphasis>
er inden for rektanglet, ellers false.
</para>

<para>

Point <emphasis>getLocation</emphasis>()  <emphasis>&quot;hvad er din placering?&quot;</emphasis>
</para>

<para>
  returnerer
et Point-objekt, der har samme koordinater som rektanglets øverste
venstre hjørne.
</para>

<para>
String
<emphasis>toString</emphasis>()  <emphasis>&quot;hvordan
vil du beskrive dig selv?&quot;</emphasis>giver en beskrivelse af
rektanglet med (x,y)-koordinater og mål som en
streng.
</para>

<para>
Her er Rectangle illustreret i UML-notation.
</para>

<figure id="java-obj-rekt-uml-fig">
<title>Java</title>

<graphic fileref="Nordfalk515367.&magic;" scale="60"></graphic>
</figure>

<para>
Returtyperne skrives her efter metodenavnet. Ofte vil vi af hensyn
til overskueligheden undlade returtyperne (ligesom vi nogle gange
undlader parametertyperne).
</para>

<para>
Herunder ses et samlet eksempel med to punkter. Det andet punkt,
p2, undersøger vi direkte i en if-sætning uden at
bruge en mellemvariabel.
</para>

<screen>
import java.awt.*;

public class Rektangler
{
  public static void main (String[] args)
  {
<prompt>    Point p, p2;</prompt>
<prompt>    Rectangle r;</prompt>

<prompt>    p = new Point();</prompt>
<prompt>    p2 = new Point(6,8);</prompt>

    r = <emphasis>new Rectangle(1,1,10,10)</emphasis>;

    boolean inde;
    inde = <emphasis>r.contains(p)</emphasis>;

    if (inde==true)
    {
        System.out.println(&quot;p er inde i r&quot;);
    }

    if (<emphasis>r.contains(p2)</emphasis>)
    {
        System.out.println(&quot;p2 er inde i r&quot;);
    }
  }
}
</screen>


<screen>
p2 er inde i r
</screen>
</sect2>    <!--   Metoders returtype -->

<sect2 id="java-obj-rekt-param">
  <title>Metoders parametre</title>

<para>
Her er et eksempel, der beregner afstanden (distancen) mellem
punktet p og rektanglet r's øverste venstre hjørne. Det
foregår ved, at vi spørger r: getLocation() - &quot;<emphasis>hvad
er din position?</emphasis>&quot;. Svaret bruger vi som parameter til
et spørgsmål til p: distance(svaret fra r) - &quot;<emphasis>Hvad
er din afstand til (svaret fra r)?</emphasis>&quot;
</para>

<screen>
    double afstand;
    afstand = p.distance(r.getLocation());
</screen>

<blockquote><para>Ved et metodekald beregnes først
alle parametrene, og derefter udføres metoden</para></blockquote>

<para>
Dvs. først beregnes parameteren, getLocation() kaldes altså
på r. Den returnerer et punkt som er r's (x,y), og derefter
kaldes distance() på p med dette Point-objekt som parameter.
</para>

<para>
Man kunne også bruge en mellemvariabel, og skrive:
</para>

<screen>
    Point rpunkt;
    rpunkt = r.getLocation();      <emphasis>// rpunkt er r's øverste venstre hjørne</emphasis>
    afstand = p.distance(rpunkt);
</screen>


<para>
Det er i starten lettere at læse kode med mellemvariable,
men når eksemplerne bliver mere indviklede bliver antallet af
mellemvariabler for stort. Man skal øve sig i selv at
forestille sig, at der er nogle mellemregninger med mellemvariabler.
</para>

</sect2>
</sect1>

<sect1 id="java-obj-rekt-strenge">
<title>Tekststrenge (klassen String)</title>

<figure id="java-obj-rekt-strenge-fig">
<title>s refererer ikke til noget</title>

<graphic fileref="Nordfalk515368.&magic;" scale="60"></graphic>
</figure>

<para>
Vi kommer nu til de mest brugte objekter, nemlig tekststrenge
(af typen String). En variabel, der refererer til strenge erklæres
ved at skrive
</para>

<screen>
String s;
</screen>


<para>
Nu har vi defineret, at s er en variabel, der kan referere til
objekter af typen String, men den refererer endnu ikke til nogen
konkret streng. Lad os tildele s en værdi:
</para>

<figure id="java-obj-strenge2-fig">
<title>s refererer nu til en streng</title>

<graphic fileref="Nordfalk515369.&magic;" scale="60"></graphic>
</figure>

<screen>
s = &quot;Ude godt&quot;;
</screen>


<para>
Nu er situationen som vist på figuren til højre. Vi
kan bruge s i vores program, f.eks. til at skrive ud på
skærmen:
</para>

<screen>
System.out.println(&quot;Strengen s indeholder: &quot;+s);
</screen>


<para>
Nu kan vi spørge streng-objektet om forskellige ting. For
eksempel kan vi kalde metoden length(), der svarer til spørgsmålet
&quot;hvor lang er du?&quot;. Strengen vil svare med tallet 8:
</para>

<screen>
...
int strengensLængde;
strengensLængde = s.length();
System.out.println(&quot;s er &quot;+strengensLængde+&quot; tegn lang&quot;);
...
</screen>


<screen>
s er 8 tegn lang
</screen>


<para>
Vi kunne også springe mellemvariablen over og skrive:
</para>

<screen>
System.out.println(&quot;s er &quot;+s.length()+&quot; tegn lang&quot;);
</screen>


<para>
Metoden toUpperCase() svarer til spørgsmålet &quot;hvordan
ser du ud med store bogstaver?&quot;:
</para>

<screen>
System.out.println(&quot;s med store bogstaver: &quot;+s.toUpperCase());
</screen>


<screen>
s med store bogstaver: UDE GODT
</screen>


<para>
Herunder ses nogle af metoderne, man kan kalde på strenge. I
kursiv til højre står spørgsmålene,
som de svarer til.
</para>

<para>
<emphasis>Nogle af String-klassens
metoder. En mere fuldstændig oversigt kan findes i 
<xref linkend="java-obj-appendix-string" />.
</emphasis>
</para>

<para>
char <emphasis>charAt</emphasis> (int indeks)  <emphasis>&quot;hvilket
tegn er der på plads nummer x?&quot;</emphasis>Returnerer tegnet
på det angivne <emphasis>indeks</emphasis>. Indeks tæller fra 0.
</para>

<para>
String <emphasis>replace</emphasis> (char gammeltTegn,
char nytTegn)  <emphasis>&quot;hvad hvis tegn x erstattes med y?&quot;</emphasis>Returnerer
en ny streng, som er identisk med denne streng, bortset fra at alle
forekomster af <emphasis>gammeltTegn</emphasis> er erstattet med <emphasis>nytTegn</emphasis>.
</para>

<para>
String <emphasis>substring</emphasis> (int
startindeks)  <emphasis>&quot;hvad er delstrengen fra x?&quot;</emphasis>Returnerer
en ny streng, som er en del af denne streng. Delstrengen starter ved
<emphasis>startindeks</emphasis> og går til slutningen.
</para>

<para>
String <emphasis>substring</emphasis> (int startindeks,
int slutindeks)  <emphasis>&quot;hvad er delstrengen fra x til y?&quot;</emphasis>Returnerer
en ny streng, som er en del af denne streng. Delstrengen starter ved
<emphasis>startindeks</emphasis> og slutter ved <emphasis>slutindeks</emphasis> (til og med
<emphasis>slutindeks</emphasis>-1).
</para>

<para>
String <emphasis>toLowerCase</emphasis> ()  <emphasis>&quot;hvordan
ser du ud med små bogstaver?&quot;</emphasis>Returnerer en ny
streng, som er identisk med denne streng, bortset fra at alle store
bogstaver er erstattet med små.
</para>

<para>
String <emphasis>toUpperCase</emphasis> ()  <emphasis>&quot;hvordan
ser du ud med store bogstaver?&quot;</emphasis>Returnerer en ny streng,
som er identisk med denne streng, bortset fra at alle små
bogstaver er erstattet med store.
</para>

<para>
boolean <emphasis>equals</emphasis> (String str)  <emphasis>&quot;er
det samme indhold?&quot;</emphasis>Returnerer sand, hvis denne streng
indeholder den samme tegnsekvens som <emphasis>str</emphasis>, ellers falsk.
</para>

<para>
int <emphasis>length</emphasis> ()    <emphasis>&quot;hvad er din
længde?&quot;</emphasis>Returnerer længden af (antal tegn i)
strengen.
</para>

<para>
int <emphasis>indexOf</emphasis> (String str)  <emphasis>&quot;hvor
er delstrengen x?&quot;</emphasis>Returnerer indekset på den
første forekomst af <emphasis>str</emphasis> som delstreng. Hvis <emphasis>str</emphasis>
ikke er en delstreng, returneres -1.
</para>

<para>
Herunder ses et eksempel, hvor nogle af metoderne er afprøvet:
</para>

<screen>
<emphasis>// Strengeleg.java</emphasis>
<emphasis>// Viser brugen af String-klassen og dens metoder.</emphasis>
public class Strengeleg
{
  public static void main(String[] args)
  {
    String s;
    s = &quot;Ude godt&quot;;
    System.out.println(&quot;Strengen s indeholder: &quot;+s);
    System.out.println(&quot;s er &quot;+<emphasis>s.length()</emphasis>+&quot; tegn lang&quot;);
    System.out.println(&quot;s med store bogstaver: &quot;+<emphasis>s.toUpperCase()</emphasis>);
    System.out.println(&quot;Tegnet på plads nummer 2 er: &quot;+<emphasis>s.charAt(2)</emphasis>);
    System.out.println(&quot;Det første g er på plads nummer: &quot;+<emphasis>s.indexOf(&quot;g&quot;)</emphasis>);
  }
}
</screen>


<screen>
Strengen s indeholder: Ude godt
s er 8 tegn lang s med store bogstaver: UDE GODT
Tegnet på plads nummer 2 er: e
Det første g er på plads nummer: 4
</screen>

<sect2 id="java-obj-rekt-strenge-imut">
  <title>Strenge er uforanderlige</title>

<para>
De fleste objekter tillader, at deres data ændres, enten ved
at man direkte har adgang til deres variabler eller gennem kald af
metoder. String-objekter er derimod indrettet sådan, at når
de først er oprettet, så kan de ikke ændres (det
giver Java mulighed for at spare hukommelse ved at slå
streng-objekter med fælles indhold sammen til &eacute;n
streng). I stedet for at ændre indholdet af strengen returnerer
String-objekters metoder altid en anden streng, som er resultatet af
ændringen.
</para>

<para>
Når vi skal ændre i et Point-objekt, f.eks. så
dets x og y er (1,1), skriver vi:
</para>

<screen>
  p.move(1,1);              <emphasis>// p forandres</emphasis>
</screen>


<para>
Kalder man derimod en metode på et String-objekt, bliver den
ikke ændret:
</para>

<screen>
  s.replace('d','f');      <emphasis>// s forandres ikke</emphasis>
</screen>


<para>
replace()-metoden giver en ny streng tilbage til os, hvor alle
'd'-tegn er erstattet med 'f', men den bliver smidt væk med det
samme, da vi ikke bruger returværdien. I stedet kunne vi
skrive:
</para>

<screen>
  String s2;
  s2 = s.replace('d','f');  <emphasis>// s forandres ikke, men s2 husker resultatet</emphasis>
</screen>


<para>
Nu bliver resultat-strengen gemt vha. s2 (s er som sagt
uforandret).
</para>

<para>
Her ses samlet et eksempel på strenges uforanderlighed:
</para>

<screen>
<emphasis>// Strengeleg2.java</emphasis>
public class Strengeleg2
{
  public static void main (String[] args)
  {
    String s1;
    String s2;
    String s3;
    String s4;

    s1 = &quot;Ude godt, men hjemme bedst.&quot;;
    <emphasis>s2 = s1.toUpperCase()</emphasis>;          <emphasis>// kald toUpperCase() på s1</emphasis>
    <emphasis>s3 = s2.replace('E', 'X')</emphasis>;        <emphasis>// kald replace() på s2</emphasis>
    <emphasis>s4 = s3.substring(4, 16)</emphasis>;        <emphasis>// kald substring() på s3</emphasis>

    System.out.println (&quot;s1: &quot; + s1);  <emphasis>// s1 er uændret af toUpperCase()-kald</emphasis>
    System.out.println (&quot;s2: &quot; + s2);  <emphasis>// s2 er uændret af replace()-kaldet</emphasis>
    System.out.println (&quot;s3: &quot; + s3);  <emphasis>// s3 er uændret af s3.substring(4, 20)</emphasis>
    System.out.println (&quot;s4: &quot; + s4);  <emphasis>// s4 er resultatet af substring()-kaldet</emphasis>
 }
}
</screen>


<screen>
s1: Ude godt, men hjemme bedst.
s2: UDE GODT, MEN HJEMME BEDST.
s3: UDX GODT, MXN HJXMMX BXDST.
s4: GODT, MXN HJ
</screen>


<para>
Variablerne s1, s2, s3 og s4 får tildelt en reference til
hvert sit strengobjekt, og derefter ændrer deres indhold sig
ikke, uanset hvilke metoder der kaldes på objekterne.
</para>

<para>
Bemærk, at selvom streng-objekterne i sig selv er
uforanderlige, kan streng-variablerne godt ændres:
</para>

<screen>
  s = s.replace('d','f');  <emphasis>// sæt s til at referere resultatet af replace()</emphasis>
</screen>


<para>
Forskellen mellem en metode, der ændrer på det objekt,
den bliver kaldt på og en metode, der returnerer en værdi,
kan være svær at forstå i starten, men det kommer i
takt med, at du programmerer selv.
</para>
</sect2>    <!--   Strenge er uforanderlige -->

<sect2 id="java-obj-rekt-ej-new">
  <title>Man behøver ikke bruge new til String-objekter</title>

<para>
De andre klasser, vi har set indtil nu, har vi brugt til at skabe
nye objekter med. Når vi skulle lave et nyt Point-objekt,
kaldte vi dens konstruktør vha. new, f.eks.:
</para>

<screen>
<prompt>  Point p;</prompt>
<prompt>  p = new Point(0,0);</prompt>
</screen>


<para>
Lige netop med strenge behøves det ikke. Her skriver man
typisk:
</para>

<screen>
<prompt>  String s;</prompt>
<prompt>  s = &quot;Ude godt&quot;;</prompt>
</screen>


<para>
Man <emphasis>kan</emphasis> godt skrive:
</para>

<screen>
  s = new String(&quot;Ude godt&quot;);
</screen>


<para>
I det sidste tilfælde skabes et nyt String-objekt, som også
indeholder teksten &quot;Ude godt&quot;, så der i lageret er <emphasis>to</emphasis>
strenge med samme indhold, hvilket er unødvendigt.
Netop fordi strenge ikke kan ændres, når de først
er skabt, har man aldrig brug for kopier. Hvorfor skulle man lave en
kopi, der altid vil være helt den samme som originalen?
</para>
</sect2>    <!--   Man behøver ikke bruge new til String-objekter -->

<sect2 id="java-obj-rekt-overload">
<title>Navnesammenfald for metoder</title>

<para>
I tabellen over Strings metoder er der en, der er nævnt to
gange; substring(). Den findes i to varianter: <emphasis>substring</emphasis>(int
startindeks) og <emphasis>substring</emphasis>(int startindeks, int slutindeks).
</para>

<para>
Hvilken variant der kaldes i Strengeleg2.java ved tildelingen af
s4 kan man se ud fra, hvilke parameterlister der passer sammen.
I dette tilfælde den metode med to parametre.
</para>

<para>
Så længe der er forskel på antallet af
parametre, er det simpelt nok, ellers må man kigge på
typerne af parametrene.
</para>
</sect2>    <!--   Navnesammenfald for metoder -->

<sect2 id="java-obj-rekt-concat">
  <title>At sætte strenge sammen med +</title>

<para>
Operatoren + bruges ikke kun til at lægge tal sammen. Hvis
enten højre- eller venstre-siden er en streng, bliver +
opfattet som: &quot;<emphasis>konverter begge sider til strenge, og sæt
dem i forlængelse af hinanden til en samlet streng</emphasis>&quot;.
</para>

<para>
Hvis man f.eks. skriver:
</para>

<screen>
  Point p;
  p=new Point(1,1);
  System.out.println(<emphasis>&quot;Svaret er: &quot;+p</emphasis>);
</screen>


<screen>
Svaret er: java.awt.Point[x=1,y=1]
</screen>


<para>
Sker der i computeren nogenlunde følgende:
</para>

<screen>
  String s1;
  String s2;
  String s3;
  <emphasis>s1 = &quot;Svaret er: &quot;</emphasis>;
  <emphasis>s2 = p.toString()</emphasis>;  <emphasis>// toString() er en metode alle objekter har</emphasis>
  <emphasis>s3 = s1 + s2</emphasis>;
  System.out.println(<emphasis>s3</emphasis>);
</screen>


<para>
toString() laver en streng-repræsentation af et objekt. Alle
objekter har en toString()-metode, og oversætteren sætter
kode ind, der kalder toString(), hvis den møder et + mellem en
streng og en anden slags objekt.
</para>

<para>
Alle de simple typer kan også laves om til strenge med +:
</para>

<screen>
  int i;
  i = 42;
  System.out.println(&quot;Svaret er: &quot;+i);
</screen>


<para>
Java kigger ikke på indholdet af strengene, så &quot;2&quot;
(som streng) + 3 (som tal) giver &quot;23&quot; (som streng). Man kan
altså bruge operatoren + til et lille trick: For at få
noget repræsenteret som en streng kan man sammensætte
det med en tom streng:
</para>

<screen>
  String s;
  int i;
  i=42;
  s=&quot;&quot;+i; <emphasis>// nu refererer s til strengen &quot;42&quot;</emphasis>
</screen>


<para>
Man kan derimod ikke skrive:
</para>

<screen>
  s=i; <emphasis>// sprogfejl: konverterer ikke automatisk fra int til String. </emphasis>
</screen>


<para>
...eller...
</para>

<screen>
  i=s+1; <emphasis>// sprogfejl: konverterer ikke automatisk fra String til int.</emphasis>
</screen>


<para>
... selvom s er &quot;42&quot;.
</para>
</sect2>    <!--   At sætte strenge sammen med + -->

<sect2 id="java-obj-rekt-samlign">
  <title>Sammenligning</title>

<para>
Umiddelbart kunne man fristes til at sammenligne to strenge med ==
ligesom med de simple typer. Det går ofte (men ikke altid)
godt:
</para>

<screen>
    s1 = &quot;Hej verden&quot;;
    s2 = s1;
    <emphasis>if (s1 == s2) </emphasis>System.out.println(&quot;s1 og s2 er ens.&quot;);<emphasis> // <emphasis>forkert</emphasis>!</emphasis>
    else System.out.println(&quot;s1 og s2 er IKKE ens.&quot;);
</screen>


<screen>
s1 og s2 er ens.
</screen>


<para>
Imidlertid sammenligner == <emphasis>referencerne til</emphasis> (adresserne på)
objekterne, ikke <emphasis>indholdet af </emphasis>dem. Sammenligningen s1==s2 går
godt fordi s1 og s2 refererer til samme objekt.
</para>

<para>
Derfor vil det gå galt hvis s1 og s2 refererer til to
objekter forskellige steder i hukommelsen, selvom de har
samme indhold:
</para>

<screen>
    s1 = &quot;Hej verden&quot;;
    s2 = &quot;Hej &quot;+&quot;verden&quot;;
    <emphasis>if (s1 == s2) </emphasis>System.out.println(&quot;s1 og s2 er ens.&quot;);<emphasis> // <emphasis>forkert</emphasis>!</emphasis>
    else System.out.println(&quot;s1 og s2 er IKKE ens.&quot;);
</screen>


<screen>
s1 og s2 er IKKE ens.
</screen>


<para>
I stedet bør man kalde equals()-metoden, dvs. spørge
et af objekterne &quot;<emphasis>har du samme indhold som dette
objekt?</emphasis>&quot; og give det andet objekt som parameter:
</para>

<screen>
    <emphasis>if (s1.equals(s2))</emphasis> System.out.println(&quot;s1 og s2 er ens.&quot;); <emphasis>// korrekt</emphasis>
    else System.out.println(&quot;s1 og s2 er IKKE ens.&quot;);
</screen>


<screen>
s1 og s2 er ens.
</screen>


<para>
Dette gælder i virkeligheden ikke kun strenge. Alle objekter
har en equals()-metode, som kan bruges til at afgøre, om to
objekter er ens, og den bør man bruge i stedet for ==.
</para>

<blockquote><para>Sammenligning af adresser på
objekter sker med ==</para></blockquote>
<blockquote><para>Sammenligning af objekters indhold
sker med equals()-metoden</para></blockquote>
</sect2>    <!--   Sammenligning -->

<sect2 id="java-obj-rekt-opg">
  <title>Opgaver</title>
<orderedlist>
  <listitem>

<para>

Skriv et program, der finder positionen af det første
  mellemrum i en streng (Vink: Brug metoden indexOf(&quot; &quot;)).
</para>

</listitem>

  <listitem>

<para>
Skriv et program, der fjerner det første ord i en
  sætning (indtil første mellemrum).
</para>

</listitem>

  <listitem>

<para>
Skriv et program, der finder og fjerner alle forekomster af
  ordet &quot;måske&quot; fra en tekst.
</para>

</listitem>

  <listitem>

<para>
Skriv et program, der finder og fjerner alle forekomster af
  ordet &quot;måske&quot; fra en tekst, uanset om det er skrevet
  med store eller små bogstaver.
</para>

</listitem>

  <listitem>

<para>
Skriv et program, der tæller antallet af kommaer i en
  tekst.
</para>

</listitem>

  <listitem>

<para>
Skriv et program, der undersøger, om en tekst er et
  palindrom, dvs. med samme stavning forfra og bagfra (som f.eks.
  &quot;regninger&quot;, &quot;russerdressur&quot;, &quot;vær
  dog god ræv&quot;).(vink: træk de enkelte tegn ud af
  strengene med substring(n,n+1) eller med charAt(n), som er beskrevet
  i apendikset, og kræver at du også bruger variabler
  af typen char).
</para>

</listitem>

  <listitem>

<para>
Udvid programmet til at tage højde for store/små
  bogstaver, tegnsætning og mellemrum, sådan at de
  følgende palindromer også genkendes: &quot;Selmas
  lakserøde garagedøre skal samles&quot; og &quot;&Aring;ge
  lo, da baronesse Nora bad Ole gå&quot;.
</para>

</listitem>
</orderedlist>
</sect2>
</sect1>

<sect1 id="java-obj-rekt-vector">
<title>Lister (klassen Vector)</title>

<para>
En Vector er en liste af andre objekter, nummereret efter et
indeks.
</para>

<figure id="java-obj-vector-fig">
<title>Java</title>

<graphic fileref="Nordfalk515371.&magic;" scale="60"></graphic>
</figure>

<para>
Konstruktører og metoder er beskrevet i appendiks, 
<xref linkend="java-obj-appendix-vector" />.
</para>

<blockquote><para>En Vector er en liste af andre
objekter</para></blockquote>

<para>
Man opretter en vektor med f.eks.:
</para>

<screen>
  Vector v;
  v = new Vector();
</screen>


<para>
Derefter kan man tilføje et objekt i enden af listen med
<emphasis>addElement</emphasis>( objekt ), f.eks.:
</para>

<screen>
  v.addElement(&quot;æh&quot;);
</screen>


<para>

tilføjer strengen &quot;æh&quot; sidst i vektoren.
</para>

<para>
Man kan sætte ind midt i listen med v.<emphasis>insertElementAt</emphasis>(
objekt, int indeks ), f.eks.:
</para>

<screen>
  v.insertElementAt(&quot;øh&quot;,0);
</screen>


<para>

indsætter &quot;øh&quot; på plads nummer 0, sådan
at vektoren nu indeholder først &quot;øh&quot; og så
&quot;æh&quot;. Alle elementerne fra og med det indeks hvori
man indsætter, får altså rykket deres indeks et
frem.
</para>

<para>
Man henter elementerne ud igen med <emphasis>elementAt</emphasis> ( indeks ).
</para>

<para>
Med v.<emphasis>size</emphasis>() får man antallet af elementer i
vektoren, i dette tilfælde 2.
</para>

<para>
<emphasis>Nogle af Vector-klassens
metoder</emphasis>
</para>

<para>
<emphasis>Metoder</emphasis>
</para>

<para>
void <emphasis>addElement</emphasis>( objekt )Føjer
<emphasis>objekt</emphasis> til vektoren. <emphasis>objekt</emphasis>
kan være et vilkårligt objekt (men ikke en simpel type)
</para>

<para>
void <emphasis>insertElementAt</emphasis>( objekt, int
indeks )Indsætter <emphasis>objekt</emphasis>
i vektoren lige før plads nummer <emphasis>indeks</emphasis>
</para>

<para>
void <emphasis>removeElementAt</emphasis>( int indeks
)Sletter objektet på plads
nummer <emphasis>indeks</emphasis>
</para>

<para>
int <emphasis>size</emphasis>()Returnerer antallet af
elementer
</para>

<para>
Object <emphasis>elementAt</emphasis> (int
indeks)Returnerer en reference til objektet på plads nummer
<emphasis>indeks</emphasis>. Husk at lave en
typekonvertering af referencen til den rigtige klasse før
resultatet lægges i en variabel (se
Point-eksemplet nedenfor).
</para>

<para>
String <emphasis>toString</emphasis> ()Returnerer
vektorens indhold som en streng. Dette sker ved at konvertere hver af
elementerne til en streng.
</para>

<para>
<emphasis>Vector-klassen skal
importeres med <literal>import java.util.*;</literal>
før den kan bruges</emphasis>
</para>

<para>
Her er et lille eksempel:
</para>

<screen>
import java.util.*;

public class Vectortest
{
  public static void main(String args[])
  {
    Vector v;
 
<emphasis>    v = new Vector();</emphasis>
<emphasis> </emphasis>
<emphasis>    v.addElement(&quot;æh&quot;);</emphasis>
<emphasis>    v.addElement(&quot;bæh&quot;);</emphasis>
<emphasis>    v.addElement(&quot;buh&quot;);</emphasis>
<emphasis> </emphasis>
    System.out.println(&quot;v har elementerne &quot;<emphasis>+v.toString()</emphasis>);

<emphasis>    v.insertElementAt(&quot;og&quot;,2);</emphasis>
    System.out.println(&quot;Nu har v elementerne &quot;<emphasis>+v</emphasis>); <emphasis>//toString() kaldes implicit</emphasis>

<emphasis>    v.removeElementAt(0);</emphasis>
    System.out.println(&quot;Nu har v elementerne &quot;+v+&quot; og størrelsen &quot;+<emphasis>v.size()</emphasis>);

    System.out.println(&quot;På plads nummer 2 er: &quot;+<emphasis>v.elementAt(2)</emphasis>);
  }
}
</screen>


<screen>
v har elementerne [æh, bæh, buh]
Nu har v elementerne [æh, bæh, og, buh]
Nu har v elementerne [bæh, og, buh] og størrelsen 3
På plads nummer 2 er: buh
</screen>


<para>
Vi indsætter først tre (referencer til) strenge i
vektoren. I hukommelsen ser det sådan ud:
</para>

<figure id="java-obj-vector2-fig">
<title>Java</title>

<graphic fileref="Nordfalk515372.&magic;" scale="60"></graphic>
</figure>

<para>
Dernæst lægges &quot;og&quot; ind på plads
nummer 2, dvs. efter &quot;bæh&quot; og før &quot;buh&quot;.
Til sidst fjernes &quot;æh&quot; på plads nummer 0.
</para>

<para>
Vector-objekter kan blive vilkårligt lange. De sørger
selv for at reservere mere hukommelse, hvis det bliver
nødvendigt.
</para>

<sect2 id="java-obj-rekt-point">
  <title>Eksempel med Point</title>

<para>
I det næste eksempel lægges tre Point-objekter ind i
en vektor, og vektoren gennemløbes for at finde punktet med
den mindste afstand til (0,0) (origo).
</para>

<para>
Læg mærke til, hvordan man kan gennemløbe en
vektor:
</para>

<screen>
    for (int n=0;<emphasis>n&lt;pv.size()</emphasis>;n++)
    {
      Point p;
      <emphasis>p=(Point) pv.elementAt(n)</emphasis>; <emphasis>// punkt nr n hentes ud af vektoren</emphasis>
<emphasis>                                 // (typekonvertering nødvendig)</emphasis>
<emphasis>      //...</emphasis>
    }
</screen>


<para>
Da vektorer kan indeholde objekter af alle mulige typer, er man
nødt til at lave en typekonvertering af den
objekt-reference, som elementAt() returnerer.
</para>

<screen>
import java.awt.*;
import java.util.*;
 
public class MindsteAfstand
{
  public static void main(String args[])
  {
    Vector pv; <emphasis>// punkt-vektor</emphasis>
    Point origo, p1, p2, p3;
    double mindist=10000;

    pv=new Vector();
    origo=new Point(0,0);
    p1=new Point(0,65);
    p2=new Point(50,50);
    p3=new Point(120,10);
    
    pv.addElement(p1);
    pv.addElement(p2);
    pv.addElement(p3);
    
    for (int n=0;n&lt;pv.size();n++)
    {
      double dist;
      Point p;

      p=(Point) pv.elementAt(n); <emphasis>// punkt nr n hentes ud af vektoren</emphasis>
<emphasis>                                 // (typekonvertering nødvendig)</emphasis>

      dist = origo.distance(p);
      if (dist&lt;minDist)
      {
        mindist=dist;
      }
    }

    System.out.println(&quot;Den mindste afstand mellem punkterne &quot;
      +pv+&quot; og (0,0) er &quot;+minDist);
  }
}
</screen>


<screen>
Den mindste afstand mellem punkterne [java.awt.Point[x=0,y=65], java.awt.Point[x=50,y=50], java.awt.Point[x=120,y=10]] og (0,0) er 65.0
</screen>


<para>
Her er en lille stump programkode, der i stedet finder den mindste
afstand mellem to punkter, der ligger ved siden af hinanden i
vektoren:
</para>

<screen>
    for (int n=0;n&lt;<emphasis>pv.size()-1</emphasis>;n++)
    {
      double dist;
      Point p<emphasis>,q</emphasis>;

      p=(Point) pv.elementAt(n);
      <emphasis>q=(Point) pv.elementAt(n+1);</emphasis>

      dist = q.distance(p);
      if (dist&lt;minDist)
      {
        mindist=dist;
      }
    }
</screen>


<para>
Og herunder er vist, hvordan man kan finde den mindste afstand
mellem to vilkårlige punkter i vektoren:
</para>

<screen>
    for (int n=0;n&lt;pv.size();n++)
    {
      for (int <emphasis>k=n</emphasis>;<emphasis>k</emphasis>&lt;pv.size();<emphasis>k++</emphasis>)
      {
        double dist;
        Point p,q;
        p=(Point) pv.elementAt(<emphasis>n</emphasis>);
        q=(Point) pv.elementAt(<emphasis>k</emphasis>);

        dist = q.distance(p);
        if (dist&lt;minDist)
        {
          mindist=dist;
        }
      }
    }
</screen>
</sect2>    <!--   Eksempel med Point -->
</sect1>    <!--   Rektangler (klassen Rectangle) -->

<sect1 id="java-obj-eksempel">
  <title>Ekstra eksempler</title>

<para>
Tillykke! Du har nu lært, hvordan man opretter og arbejder
med objekter, og du er kommet igennem de vigtigste klasser af
objekter. De eksempler og klasser, der følger nu er ikke
fundamentalt forskellige fra det, du har set. Der bliver med andre
ord ikke introduceret nogen nye begreber, men klasserne kan være
nyttige, og eksemplerne kan måske hjælpe dig med at få
repeteret ideerne om brug af objekter, metodekald og konstruktører.
</para>

<sect2 id="java-obj-eksempel-vector">
  <title>Blanding af kort med Vector</title>

<para>
I det følgende bruges nogle af de metoder der er nævnt
i appendikset om Vector.
</para>

<para>
Dette program blander nogle spillekort (beskrevet som strenge) i
en vektor. Det gøres ved 100 gange at tage et kort fra en
tilfældig plads og flytte det til en anden tilfældig
plads:
</para>

<screen>
import java.util.*;
 
public class BlandKort
{
  public static void main(String args[])
  {
    Vector bunke;
<emphasis>    bunke = new Vector();</emphasis>

<emphasis>    // Opbyg bunken</emphasis>
    for (int n=2; n&lt;9; n++)
    {
      bunke.addElement(&quot;ruder&quot;+n);  <emphasis>// ruder</emphasis>
      bunke.addElement(&quot;klør&quot;+n);   <emphasis>// klør</emphasis>
      bunke.addElement(&quot;spar&quot;+n);   <emphasis>// spar</emphasis>
    }

    System.out.println(&quot;Før blanding: &quot;+bunke);
    int antalKort = bunke.size();

<emphasis>    // Bland bunken</emphasis>
    for (int n=0;n&lt;100;n++)
    {
      int nr;
      nr = (int) (Math.random() * antalKort);     <emphasis>// find en tilfældig plads</emphasis>

      String <emphasis>kort = (String) bunke.elementAt(nr)</emphasis>; <emphasis>// tag et kort ud</emphasis>

      <emphasis>bunke.removeElementAt(nr);</emphasis>

      nr = (int) (Math.random() * antalKort);
      bunke.<emphasis>insertElementAt(kort,nr)</emphasis>;             <emphasis>// sæt det ind et andet sted</emphasis>
    }
    
    System.out.println(&quot;Efter blanding: &quot;+bunke);
  }
}
</screen>


<screen>
Før blanding: [ruder2, klør2, spar2, ruder3, klør3, spar3, ruder4, klør4, spar4, ruder5, klør5, spar5, ruder6, klør6, spar6, ruder7, klør7,
spar7, ruder8, klør8, spar8]
Efter blanding: [spar3, klør3, ruder7, spar5, spar2, ruder5, ruder6, klør6, spar6, klør5, klør8, ruder2, ruder4, klør7, ruder3, spar8, spar4, ruder8, klør4, klør2, spar7]
</screen>


<para>
I et rigtigt program ville de enkelte kort nok være
repræsenteret med objekter fra en Kort-klasse med
objektvariablerne farve og værdi.
</para>
</sect2>    <!--   Blanding af kort med Vector -->

<sect2 id="java-obj-eksempel-date">
  <title>Datoer (klassen Date)</title>

<para>
Date-klassen repræsenterer et punkt i tiden (en dato og et
klokkeslæt).
</para>

<figure id="java-eksempel-date-fig">
<title>Java</title>

<graphic fileref="Nordfalk515374.&magic;" scale="60"></graphic>
</figure>

<para>
For at oprette et dato-objekt, der repræsenterer dags dato
og tid, skriver vi:
</para>

<screen>
  Date netopNu;
  netopNu = new Date();
</screen>


<para>
new-operatoren er som bekendt bindeleddet mellem en klasse (f.eks.
Date) og et objekt (en konkret dato, f.eks. 24/12 2000 kl. 18:37).
</para>

<para>
For at oprette en dato, der repræsenterer et andet
tidspunkt, kan vi bruge en af de andre konstruktører, der
tager årstal, måned (regnet fra 0), dag, time og minut.
Undertegnede er født den 1. januar 1971, så min
fødselsdag kunne oprettes med:
</para>

<screen>
  jacobsFødselsdag = new Date(71,0,1,12,00); <emphasis>// 1.januar 1971 kl. 12:00</emphasis>
</screen>


<para>
I appendikset er et udvalg af Date-klassens konstruktører
og metoder beskrevet.
</para>

<para>
Eksemplet nedenfor regner på min fødselsdato og
finder ud af, hvornår jeg var halvt så gammel som nu.
</para>

<screen>
<emphasis>// Datoer.java</emphasis>
<emphasis>// Viser brugen af Date-klassen og dens metoder.</emphasis>

import java.util.*; <emphasis>// Date-klassen er i pakken java.util</emphasis>

public class Datoer
{
  public static void main (String[] args)
  {
    Date netopNu;
    Date jacob;

    netopNu = new Date();
    jacob = new Date(71,0,1,12,00); <emphasis>// 1. januar 1971 kl. 12:00</emphasis>

    System.out.println(&quot;Dags dato: &quot;+netopNu.toString());
    System.out.println(&quot;Jacob blev født &quot;+jacob); <emphasis>// .toString() implicit</emphasis>

<emphasis>    // Lad os regne Jacobs alder ud (i millisekunder)</emphasis>
    long nuMs;
    long jacobMs;
    long alderMs;

    nuMs = netopNu.getTime();
    jacobMs = jacob.getTime();
    alderMs = nuMs - jacobMs;
 
<emphasis>    // Hvornår var han halvt så gammel?</emphasis>
    jacob.setTime(nuMs - alderMs/2);
    System.out.println(&quot;Jacob var halvt så gammel &quot;+jacob);
  }
}
</screen>


<screen>
Dags dato: Sun Jul 15 14:33:59 CEST 2001
Jacob blev født Fri Jan 01 12:00:00 CET 1971
Jacob var halvt så gammel Wed Apr 09 01:46:59 CEST 1986
</screen>


<para>
Kaldet jacob.setTime(...) ændrer objektet, så Jacobs
fødselsdag blev glemt.
</para>

<para>
Man kan gøre meget mere med datoer end vist her.
</para>

<para>
Med DateFormat-klassen kan man formatere og udskrive datoer langt
pænere end med toString() og på alle mulige sprog (bl.a.
på dansk). Klassen kan også gå den anden vej:
Analysere en tekststreng og finde frem til datoen, den repræsenterer.
</para>

<para>
GregorianCalendar-klassen repræsenterer vort kalendersystem
(det gregorianske / julianske) og har alle de
kalenderfunktioner, man kunne ønske sig. Med den kan man
arbejde med ugedage, måneder, år, tidszoner, sommertid
etc.
</para>

<para>
Disse klasser vil ikke blive behandlet her, da de benytter
begreber, som ikke er introduceret endnu (klassevariabler og
klassemetoder).
</para>
</sect2>    <!--   Datoer (klassen Date) -->

<sect2 id="java-obj-eksempel-opg">
<title>Opgaver</title>
<orderedlist>
  <listitem>

<para>

Ret Datoer-programmet sådan, at Jacobs fødselsdato
  ikke går tabt (opret et tredje objekt i stedet for at
  ændre i jacob-objektet).
</para>

</listitem>

  <listitem>

<para>
Skriv et program, der udskriver datoen for i morgen, om en
  uge og om et år.
</para>

</listitem>

  <listitem>

<para>
Skriv et program, der ud fra en persons fødselsdato
  udskriver alle fødselsdage, som personen har fejret indtil nu
  (lav f.eks. en while-løkke, hvor du tæller år
  frem fra fødselsdatoen, og brug before-metoden til at
  tjekke, om du er nået frem til nu).
</para>

</listitem>
</orderedlist>

</sect2>
</sect1>


<sect1 id="java-obj-apppendix">
<title>Appendiks</title>

<para>
Her finder du en oversigt over de vigtigste klasser og deres
vigtigste metoder. På siden
<ulink url="http://java.sun.com/products/jdk/1.2/docs/api/index.html">http://java.sun.com/products/jdk/1.2/docs/api/index.html</ulink>
findes en komplet oversigt.
</para>

<para>
Nogle af metoderne er markeret med:
</para>

<itemizedlist mark="bullet">
  <listitem>

<para>

JDK1.2: Denne metode er kun tilgængelig fra og med Java
  version 1.2.
</para>

</listitem>
</itemizedlist>

<itemizedlist mark="bullet">
  <listitem>

<para>

(frarådes): Denne metode er frarådet (eng.:
  deprecated), men findes endnu af hensyn til programmer skrevet til
  tidligere versioner af Java. Oversætteren advarer mod brugen
  med '... has been deprecated', men programmet kører i øvrigt
  fint.
</para>

</listitem>
</itemizedlist>

<sect2 id="java-obj-appendix-point">
<title>Point</title>

<para>
Point repræsenterer et punkt med en x- og y-koordinat.
</para>

<para>
<emphasis>java.awt.Point - punkter
med en x- og y-koordinat - skal importeres med import java.awt.*;</emphasis>
</para>

<para>
<emphasis>Variabler</emphasis>
</para>

<para>
int
x  x-koordinaten
</para>

<para>
int
y  y-koordinaten
</para>

<para>
<emphasis>Konstruktører</emphasis>
</para>

<para>
Point()
</para>

<para>
  Opretter et
punkt i (0,0).
</para>

<para>
Point(int x,
int y)Opretter et punkt i (x,y).
</para>

<para>
Point(Point
p)Opretter et punkt med samme (x,y)-koordinater som p.
</para>

<para>
<emphasis>Metoder</emphasis>
</para>

<para>
void <emphasis>move</emphasis>(int
x, int y)Sætter punktets koordinater.
</para>

<para>
void
<emphasis>translate</emphasis>(int x, int y)Rykker punktets koordinater
relativt i forhold til, hvor det er.
</para>

<para>
double <emphasis>distance</emphasis>(Point
etAndetPunkt)  JDK1.2 Giver afstanden fra punktet til
<emphasis>etAndetPunkt</emphasis>.
</para>

<para>
boolean <emphasis>equals</emphasis>(Object
obj)Undersøger, om punktet har samme koordinater som <emphasis>obj</emphasis>.
Returnerer true, hvis det er tilfældet, og false, hvis obj ikke
er et punkt, eller hvis det har andre koordinater.
</para>

<para>
String
<emphasis>toString</emphasis>()giver en strengrepræsentation af punktet
med (x,y)-koordinater, f.eks. java.awt.Point[x=0,y=0]
</para>
</sect2>    <!--   Point -->

<sect2 id="java-obj-appendix-rectangle">
  <title>Rectangle</title>

<para>
Rectangle repræsenterer et todimensionalt rektangel.
</para>

<para>
<emphasis>java.awt.Rectangle -
todimensionalt rektangel - skal importeres med import java.awt.*;</emphasis>
</para>

<para>
<emphasis>Variabler</emphasis>
</para>

<para>
int
x  x-koordinat på øverste venstre hjørne
</para>

<para>
int
y  y-koordinat på øverste venstre hjørne
</para>

<para>
int
width  bredden
</para>

<para>
int
height  højden
</para>

<para>
<emphasis>Konstruktører</emphasis>
</para>

<para>
Rectangle()opretter
et rektangel i (0,0), hvis bredde og højde er 0.
</para>

<para>
Rectangle(int
bredde, int højde)opretter et rektangel i (0,0) med den
angivne bredde og højde.
</para>

<para>
Rectangle(int
x, int y, int bredde, int højde)opretter et rektangel i
(x,y) med den angivne bredde og højde.
</para>

<para>
Rectangle(Point
p)opretter et rektangel i <emphasis>p</emphasis>, hvis bredde og højde
er 0.
</para>

<para>
<emphasis>Metoder</emphasis>
</para>

<para>
void <emphasis>add
</emphasis>(Point p) udvider rektanglet sådan, at det også
omfatter punktet <emphasis>p</emphasis>.
</para>

<para>
void <emphasis>translate
</emphasis>(int x, int y)rykker rektanglets koordinater relativt i
forhold til, hvor det er.
</para>

<para>
boolean
<emphasis>contains </emphasis>(Point p)returnerer true, hvis <emphasis>p</emphasis>
er inden for rektanglet, ellers false.
</para>

<para>
boolean
<emphasis>intersects </emphasis>(Rectangle r)returnerer true, hvis rektanglet
og <emphasis>r</emphasis> overlapper.
</para>

<para>
Rectangle
<emphasis>intersection </emphasis>(Rectangle r)undersøger overlappet
(fællesmængden, snitmængden) mellem rektanglet og
<emphasis>r</emphasis>, og returnerer et, rektangel der repræsenterer
det fælles overlap.
</para>

<para>
Rectangle
<emphasis>union</emphasis>(Rectangle r)returnerer et rektangel, der
repræsenterer foreningsmængden, dvs. det mindste
rektangel, der indeholder både <emphasis>r</emphasis> og dette
rektangel.
</para>

<para>
boolean <emphasis>equals</emphasis>(Object
obj)Undersøger, om rektanglet har samme koordinater og mål
som <emphasis>obj</emphasis>. Returnerer true,
hvis det er tilfældet, og false, hvis obj ikke er et rektangel,
eller hvis det har andre koordinater eller mål.
</para>

<para>
String
<emphasis>toString</emphasis>()giver en strengrepræsentation af
rektanglet med (x,y)-koordinater og mål.
</para>
</sect2>    <!--   Rectangle -->

<sect2 id="java-obj-appendix-string">
  <title>String</title>

<para>
Strenge er specielle ved, at de ikke kan ændres, når
de først er oprettet.
</para>

<para>
<emphasis>java.lang.String -
tekststrenge</emphasis>
</para>

<para>
char <emphasis>charAt</emphasis> (int indeks)returnerer
tegnet på det angivne <emphasis>indeks</emphasis>. Indeks tæller fra 0.
</para>

<para>
String <emphasis>replace</emphasis> (char gammeltTegn,
char nytTegn) returnerer en ny streng, som er identisk med denne
streng, bortset fra at alle forekomster af <emphasis>gammeltTegn</emphasis> er
erstattet med <emphasis>nytTegn</emphasis>.
</para>

<para>
String <emphasis>substring</emphasis> (int
startindeks)Returnerer en ny streng, som er en del af denne
streng. Delstrengen starter ved <emphasis>startindeks</emphasis> og går
til slutningen.
</para>

<para>
String <emphasis>substring</emphasis> (int startindeks,
int slutindeks)Returnerer en ny streng, som er en del af denne
streng. Delstrengen starter ved <emphasis>startindeks</emphasis> og slutter
ved <emphasis>slutindeks</emphasis> (til og med <emphasis>slutindeks</emphasis>-1).
</para>

<para>
String <emphasis>toLowerCase</emphasis> ()returnerer
en ny streng, som er identisk med denne streng, bortset fra at alle
store bogstaver er erstattet med små.
</para>

<para>
String <emphasis>toUpperCase</emphasis> ()returnerer
en ny streng, som er identisk med denne streng, bortset fra at alle
små bogstaver er erstattet med store.
</para>

<para>
String <emphasis>trim</emphasis> ()returnerer en ny
streng, som er identisk med denne streng, bortset fra at alle
blanktegn, tabulatortegn, linjeskift etc. er fjernet fra begge
ender af strengen.
</para>

<para>
int <emphasis>length</emphasis> ()returnerer længden
af (antal tegn i) strengen.
</para>

<para>
int <emphasis>indexOf</emphasis> (String str)returnerer
indekset på den første forekomst af <emphasis>str</emphasis> som
delstreng. Hvis <emphasis>str</emphasis> ikke er en delstreng, returneres -1.
</para>

<para>
int
<emphasis>lastIndexOf</emphasis> (String str)returnerer indekset på den
sidste forekomst af <emphasis>str</emphasis> som delstreng. Hvis <emphasis>str</emphasis> ikke er
en delstreng, returneres -1.
</para>

<para>
boolean <emphasis>startsWith</emphasis> (String
str)returnerer sand, hvis denne streng starter med de samme tegn
som <emphasis>str</emphasis>, ellers falsk.
</para>

<para>
boolean <emphasis>endsWith</emphasis> (String
str)returnerer sand, hvis denne streng slutter med de samme tegn
som <emphasis>str</emphasis>, ellers falsk.
</para>

<para>
boolean <emphasis>equals</emphasis> (String
str)returnerer sand, hvis denne streng har samme indhold som <emphasis>str</emphasis>,
ellers falsk.
</para>

<para>
boolean
<emphasis>equalsIgnoreCase</emphasis> (String str)returnerer sand, hvis denne
streng har samme indhold som <emphasis>str</emphasis>, ellers falsk. Der skelnes
ikke mellem store og små bogstaver.
</para>

<para>
To strenge s1 og s2 sammenlignes ved at kalde s1.equals(s2), ikke
med s1==s2 (der sammenligner objektreferencer).
</para>
</sect2>    <!--   String -->

<sect2 id="java-obj-appendix-spec-tegn">
  <title>Specialtegn i strenge</title>

<para>
Visse tegn kan man ikke skrive direkte i tekststrenge i
kildeteksten. De står opført herunder:
</para>

<table>
<title>Java</title>
<tgroup cols="2" align="char">
<thead>
<row>
<entry>
&Oslash;nsket tegn
</entry>
<entry>
I kildeteksten skrives
</entry>
</row>
</thead>

<tbody>
<row>
<entry>
Tabulator
</entry>
<entry>
\t
</entry>

</row>
<row>
<entry>
Linjeskift (eng.: newline)
</entry>
<entry>\n
</entry>
</row>

<row>
<entry>
Vognretur (eng.: carriage return). Bruges sjældent
</entry>
<entry>
\r
</entry>
</row>

<row>
<entry>
Bak (eng.: backspace). Bruges sjældent
</entry>
<entry>
\b
</entry>
</row>
<row>
<entry>Anførelsestegn &quot;
</entry>
<entry>
\&quot;
</entry></row>
<row>
<entry>Apostrof '
</entry>
<entry>
\'
</entry></row>
<row>
<entry>
En bagstreg \ (eng.: backslash)
</entry>
<entry>
\\
</entry></row>
<row>
<entry>Unikode-tegn nummer XXXX
</entry>
<entry>
\uXXXX
</entry></row>
</tbody>

</tgroup>
</table>

<para>
Unikode-tegn skrives som fire hexadecimale cifre
(0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F). F.eks. kan de græske
bogstaver findes på &quot;\u0390&quot; til &quot;\u03F3&quot;
(det græske pi skrives med &quot;\u03C0&quot;), og de
kyrilliske tegn findes fra &quot;\u0400&quot; til &quot;\u047F&quot;.
Unikode-tegntabellen kan findes på <ulink url="http://unicode.org/">http://unicode.org</ulink>
</para>

<para>
Eksempler:
</para>

<screen>
System.out.println(&quot;Jacob\n\n\n\tNordfaaa\b\blk&quot;);
</screen>


<screen>
Jacob

    Nordfalk
</screen>


<screen>
System.out.println(&quot;\t\&quot;At være eller ikke være\n\tdet er spørgsmålet.\&quot;&quot;);
System.out.println(&quot;\t\t\t\t\t\t\t\t\t\tShakespeare&quot;);
</screen>


<screen>
  &quot;At være eller ikke være
  det er spørgsmålet.&quot;
                    Shakespeare
</screen>


<sect3 id="java-obj-appendix-date">
<title>Date</title>

<para>
Date repræsenterer en tid, dvs. en dato og et klokkeslæt.
</para>

<para>
<emphasis>java.util.Date - et
tidspunkt - skal importeres med import java.util.*;</emphasis>
</para>

<para>
<emphasis>Konstruktører</emphasis>
</para>

<para>
Date ()opretter et Date-objekt, som
repræsenterer tidspunktet, da det blev oprettet, målt i
millisekunder.
</para>

<para>
Date (long tid_i_millisekunder)opretter
et Date-objekt, som repræsenterer et tidspunkt, der er
<emphasis>tid_i_millisekunder</emphasis> efter 1. januar 1970 kl 00:00:00 GMT.
</para>

<para>
Date (int år, int måned, int
dag, int timer, int minutter)  <emphasis>(frarådes)</emphasis>opretter
et Date-objekt med det givne tidspunkt. Bemærk, at <emphasis>år</emphasis>
regnes fra år 1900 (1997 svarer til <emphasis>år</emphasis>=97),
og <emphasis>måned</emphasis> regnes
fra 0. (januar svarer til <emphasis>måned</emphasis>=0).
</para>

<para>
Date (String dato)  <emphasis>(frarådes)</emphasis>opretter
et Date-objekt, som repræsenterer det tidspunkt, <emphasis>dato</emphasis>
indeholder.
</para>

<para>
<emphasis>Metoder</emphasis>
</para>

<para>
long <emphasis>getTime</emphasis> ()returnerer antal
millisekunder siden 1. januar 1970 kl. 00:00:00 GMT repræsenteret
af dette Date-objekt.
</para>

<para>
void <emphasis>setTime</emphasis> (long
tid_i_millisekunder)ændrer dette Date-objekt til at
repræsentere et tidspunkt, der er <emphasis>tid_i_millisekunder</emphasis>
efter 1. januar 1970 kl 00:00:00 GMT.
</para>

<para>
boolean <emphasis>after</emphasis> (Date
hvornår)undersøger, om denne dato er efter
<emphasis>hvornår</emphasis>-datoen.
</para>

<para>
boolean <emphasis>before</emphasis> (Date
hvornår)undersøger, om denne dato er før
<emphasis>hvornår</emphasis>-datoen.
</para>

<para>
String <emphasis>toString</emphasis> ()returnerer en
strengrepræsentation af formen: ugedag mm dd tt:mm:ss åååå
(f.eks. Man 5. juli 15:23:18 2000). Denne metode kaldes automatisk,
hvis man forsøger at lægge en dato sammen med en
streng med +-operatoren.
</para>

<para>
int <emphasis>getDate</emphasis>
()    <emphasis>(frarådes)</emphasis>returnerer dagen i måneden
repræsenteret af dette objekt.
</para>

<para>
void <emphasis>setDate</emphasis> (int
dag).  <emphasis>(frarådes)</emphasis>ændrer
dagen i måneden til <emphasis>dag</emphasis> på
dette objekt. Sættes den til en dag uden for denne måned,
ændres måneden tilsvarende. ... tilsvarende
med <emphasis>getYear()</emphasis>, <emphasis>setYear()</emphasis>, <emphasis>getMonth()</emphasis>,
<emphasis>setMonth()</emphasis>, <emphasis>getHours()</emphasis>, <emphasis>setHours(),
getMinutes(), setMinutes()</emphasis>, <emphasis>getSeconds()</emphasis> og
<emphasis>setSeconds()</emphasis>.  <emphasis>(frarådes)</emphasis>
</para>

<para>
(frarådes): Disse metoder blev frarådet fra JDK
version 1.1, fordi de ikke understøtter andre kalendre
end det gregorianske kalendersystem der bruges i den vestlige verden.
Det betyder dog ikke det store for europæiske programmer.
</para>
</sect3>

<sect3 id="java-obj-appendix-vector">
<title>Vector</title>

<para>
Vector er en liste af andre objekter.
</para>

<para>
<emphasis>java.util.Vector - en
liste af objekter - skal importeres med import java.util.*;</emphasis>
</para>

<para>
<emphasis>Konstruktører</emphasis>
</para>

<para>
Vector ()opretter en tom Vector.
</para>

<para>
<emphasis>Metoder</emphasis>
</para>

<para>
void <emphasis>addElement</emphasis>( objekt )føjer
<emphasis>objekt</emphasis> til vektoren. <emphasis>objekt</emphasis>
kan være et vilkårligt objekt (men ikke en simpel type).
</para>

<para>
void <emphasis>insertElementAt</emphasis>( objekt, int
indeks )indsætter <emphasis>objekt</emphasis>
i vektoren lige før plads nummer <emphasis>indeks.</emphasis>
</para>

<para>
void <emphasis>removeElementAt</emphasis>( int indeks
)sletter objektet på plads
nummer <emphasis>indeks.</emphasis>
</para>

<para>
boolean <emphasis>isEmpty</emphasis>()returnerer
sand, hvis vektoren er tom (indeholder 0 elementer).
</para>

<para>
int <emphasis>size</emphasis>()returnerer antallet af
elementer.
</para>

<para>
Object <emphasis>elementAt</emphasis> (int
indeks)returnerer en reference til objektet på plads nummer
<emphasis>indeks</emphasis>. Husk at lave en
typekonvertering af referencen til den rigtige klasse, før
du bruger resultatet.
</para>

<para>
boolean <emphasis>contains</emphasis>( objekt
)returnerer sand, hvis <emphasis>objekt</emphasis>
findes i vektoren.
</para>

<para>
int <emphasis>indexOf</emphasis>( objekt )returnerer
indekset på første forekomst af <emphasis>objekt</emphasis>
i vektoren. Hvis den ikke findes, returneres -1.
</para>

<para>
Enumeration <emphasis>elements</emphasis>()giver
en opremsning (eng.: enumeration) af elementerne. 
</para>

<para>
String <emphasis>toString</emphasis> ()returnerer
vektorens indhold som en streng. Dette sker ved at konvertere hver af
elementerne til en streng.
</para>

</sect3>
</sect2>    <!--   Specialtegn i strenge -->
</sect1>    <!--   Ekstra eksempler -->
</chapter>    <!--   Objekter -->

