<chapter>
  <title>RMI - objekter over netværk</title>

<para>
Indhold:
</para>

<itemizedlist mark="bullet">
  <listitem>

<para>

Forstå principperne i RMI
</para>

</listitem>

  <listitem>

<para>
Kalde metoder i fjerne objekter
</para>

</listitem>
</itemizedlist>

<para>
Kapitlet forudsættes ikke i resten af bogen.
</para>

<para>
Forudsætter kapitel 11, Interfaces, kapitel 17, Serialisering
og kendskab til netværk.
</para>

<para>
RMI (Remote Method Invocation) er en måde at arbejde med
objekter der eksisterer i en anden Java virtuel maskine (ofte på
en anden fysisk maskine), <emphasis>som om de var lokale objekter</emphasis>.
</para>

<sect2>
  <title>Principper</title>

<para>
Herunder er tegnet, hvad der sker, når en klient på
maskine A laver et kald til et serverobjekt (da: værts-objekt),
der er i maskine B.
</para>

<figure>
<graphic fileref="Nordfalk2015469.&magic;" scale="60"></graphic>
</figure>

<para>
Serverobjektet findes slet ikke på maskine A, i stedet er
der en såkaldt <emphasis>RMI-stub</emphasis>, der repræsenterer
det. Når der sker et kald til RMI-stubben på maskine A,
sørger den for at transportere kaldet og alle parametre til
maskine B, hvor serverobjektet bliver kaldt, som om det var et lokalt
kald. Serverobjektets svar bliver transporteret tilbage til
RMI-stubben, der returnerer det til klienten.
</para>

<para>
Denne proces foregår helt automatisk og er usynlig for
klienten såvel som serverobjektet.
</para>

<para>
RMI benytter serialisering til at transportere parametre og
returværdi mellem maskinerne, så man skal huske, at alle
objekter, der sendes over netværket, skal implementere
Serializable-interfacet, og at variabler, der ikke skal
overføres, skal mærkes med nøgleordet transient.
</para>

<para>
Overordnet set foregår det på den måde, at der
defineres et interface til de metoder på serverobjektet, der
skal være tilgængelige for klienten.
</para>
</sect2>    <!--   Principper -->

<sect2>
  <title>Konkret</title>

<para>
Konkret kunne man tænke sig, at serveren havde et
konto-objekt, hvor man kan overføre penge, spørge om
saldo og få bevægelserne på kontoen. Så ville
man definere et Konto-interface (her kaldt KontoI):
</para>

<screen>
import java.util.Vector;

public interface KontoI extends java.rmi.Remote
{
  public void overførsel(int kroner) throws java.rmi.RemoteException;
  public int saldo()                 throws java.rmi.RemoteException;
  public Vector bevægelser()         throws java.rmi.RemoteException;
}
</screen>


<para>
Interfacet skal arve fra interfacet java.rmi.Remote, og alle
metoder skal kunne kaste undtagelsen java.rmi.RemoteException.
</para>

<para>
Interfacet bliver brugt på både
klientsiden og serversiden.
</para>

<sect3>
  <title>På serversiden</title>

<para>
På serversiden skal vi implementere Konto-interfacet og
programmere den funktionalitet der skjuler sig bag det, i et
serverobjekt, som normalt ender på Impl (for at signalere, at
det er implementationen af interfacet). Serverobjektet skal
arve fra UnicastRemoteObject.
</para>

<screen>
import java.util.Vector;
import java.rmi.server.UnicastRemoteObject;

public class KontoImpl <emphasis>extends UnicastRemoteObject implements KontoI</emphasis>
{
<emphasis>  public int saldo;</emphasis>
<emphasis>  public Vector bevægelser;</emphasis>

  public KontoImpl() throws java.rmi.RemoteException 
  {
    // man starter med 100 kroner
    saldo = 100;
    bevægelser = new Vector();
  }

  public void overførsel(int kroner) throws java.rmi.RemoteException
  {
    saldo = saldo + kroner;
    String s = &quot;Overførsel på &quot;+kroner+&quot; kr. Ny saldo er &quot;+saldo+&quot; kr.&quot;;
    bevægelser.addElement(s);
    System.out.println(s);
  }

  public int saldo()                 throws java.rmi.RemoteException
  {
    System.out.println(&quot;Der spørges om saldoen. Den er &quot;+saldo+&quot; kr.&quot;);
    return saldo;
  }

  public Vector bevægelser()         throws java.rmi.RemoteException
  {
    System.out.println(&quot;Der spørges på alle bevægelser.&quot;);
    return bevægelser;
  }
}
</screen>


<para>
Nu skal vi oprette et serverobjekt og registrere vores tjeneste
under et navn i RMI. Det sker sådan her:
</para>

<screen>
import java.rmi.Naming;
public class Kontoserver
{
  public static void main(String args[]) throws Exception
  {
    KontoI <emphasis>k = new KontoImpl()</emphasis>;
<emphasis>    Naming.rebind(&quot;rmi://localhost/Kontotjeneste&quot;, k);</emphasis>
    System.out.println(&quot;Kontotjeneste registreret.&quot;);
  }
}
</screen>


<para>
Derudover skal der køre en RMI-navnetjeneste, der holder
styr på, hvilke tjenester der udbydes under hvilke navne
og formidler kontakten til dem. Det er et lille program, der hedder
rmiregistry. Det skal kende definitionen af de klasser, der
overføres.
</para>

<para>
Når vi skal køre vores server sker de i fire trin:
</para>

<itemizedlist mark="bullet">
  <listitem>

<para>

alle kildetekster oversættes til bytekode:  <font face="courier, monospace">javac
  *.java</font> (eller i et udviklingsværktøj)
</para>

</listitem>

  <listitem>

<para>
KontoImpl skal have en RMI-stub og en RMI-skel:  <font face="courier, monospace">rmic
  KontoImpl.java</font>
</para>

</listitem>

  <listitem>

<para>
rmiregistry startes i et separat vindue (fra samme katalog,
  som bytekoden ligger i):  <font face="courier, monospace">rmiregistry</font>
</para>

</listitem>

  <listitem>

<para>
til sidst kan Kontoserver startes fra et separat
  vindue:  <font face="courier, monospace">java Kontoserver</font>
  (eller i et udviklingsværktøj)
</para>

</listitem>
</itemizedlist>
</sect3>    <!--   På serversiden -->

<sect3>
  <title>På klientsiden</title>

<para>
På klientsiden skal vi slå serverobjektet op i
RMI-tjenesten og derefter bruge det objekt, vi får retur, som
om det var serverobjektet selv (i virkeligheden er det en RMI-stub,
der implementerer KontoI):
</para>

<screen>
import java.util.Vector;
import java.rmi.Naming;

public class Kontoklient
{
  public static void main(String[] args)
  {
    try 
    {
<emphasis>      KontoI k =(KontoI) Naming.lookup(&quot;rmi://localhost/Kontotjeneste&quot;);</emphasis>
      k.overførsel(100);
      k.overførsel(50);
      System.out.println( &quot;Saldo er: &quot;+ k.saldo() );
      k.overførsel(-200);
      k.overførsel(51);
      System.out.println( &quot;Saldo er: &quot;+ k.saldo() );
      Vector bevægelser = k.bevægelser();

      System.out.println( &quot;Bevægelser er: &quot;+ bevægelser );
    }
    catch (Exception e)
    {
      System.out.println(e);
      e.printStackTrace();
    }
  }
}
</screen>


<screen>
Saldo er: 250
Saldo er: 101
Bevægelser er: [Overførsel på 100 kr. Ny saldo er 200 kr., Overførsel på 50 kr. Ny saldo er 250 kr., Overførsel på -200 kr. Ny saldo er 50 kr., Overførsel på 51 kr. Ny saldo er 101 kr.]
</screen>


<para>
Herunder ses de enkelte klassers funktioner.
</para>

<figure>
<graphic fileref="Nordfalk2015471.&magic;" scale="60"></graphic>
</figure>
</sect3>    <!--   På klientsiden -->
</sect2>    <!--   Konkret -->
</chapter>    <!--   RMI - objekter over netværk -->

