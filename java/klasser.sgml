<chapter id="java-klasser">
  <title>Definition af klasser</title>

<para>
Kapitlet forudsættes af resten af bogen.
</para>

<para>
Forudsætter <xref linkend="java-obj" />, Objekter.
</para>

<para>
Er man i gang med et større program, vil man have brug for
at definere sine egne specialiserede klasser. Et
regnskabsprogram kunne f.eks. definere en Konto-klasse. Ud fra
Konto-klassen ville der blive skabt et antal konto-objekter
svarende til de konti, der skulle administreres.
</para>

<para>
I dette kapitel ser vi på, hvordan man selv definerer sine
egne klasser. Vi minder om, at
</para>

<blockquote><para>En klasse er en skabelon, som man kan
danne objekter ud fra</para></blockquote>
<blockquote><para>Klassen beskriver variabler og
metoder, der kendetegner objekterne</para></blockquote>
<blockquote><para>Et objekt er en konkret forekomst
(instans) af klassen</para></blockquote>

<para>
Når man programmerer objektorienteret, samler man data i
selvstændige objekter og definerer metoder, som arbejder
på disse data i objekterne.
</para>

<sect1 id="java-klasser-boks">
  <title>En Boks-klasse</title>

<para>
Lad os tage et eksempel på en klassedefinition:
</para>

<figure id="java-klasser-klasse-def-fig">
<title>Java</title>

<graphic fileref="Nordfalk615381.&magic;" scale="60"></graphic>
</figure>

<para>
Vi definerer klassen Boks, som indeholder tre
variabler, nemlig bredde, højde og længde. Derudover
definerer vi metoden volumen(), som arbejder på disse data.
Metoden returnerer en double og tager ingen parametre.
</para>

<screen>
public class Boks
{
  double længde;
  double bredde;
  double højde;

  double volumen()
  {
    double vol;
    vol = længde*bredde*højde;
    return vol; 
  }
}
</screen>

<sect2 id="java-klasser-boks-var">
  <title>Variabler</title>

<para>
Variablerne bredde, højde og længde kaldes også
objektvariabler, fordi hvert Boks-objekt har en af hver.
</para>

<blockquote><para>Objektvariabler erklæres direkte
i klassen uden for metoderne</para></blockquote>

<para>
Vi kan lave et Boks-objekt, boksobjekt med new:
</para>

<screen>
    Boks boksobjekt;
    boksobjekt = new Boks();
</screen>


<para>
Nu er der oprettet et Boks-objekt i lageret, der således har
en højde-, en bredde- og en længde-variabel.
</para>

<para>
Variablen vol kaldes en lokal variabel, fordi den er erklæret
lokalt i volumen-metoden.
</para>

<blockquote><para>En variabel erklæret inde i en
metode kaldes en lokal variabel</para></blockquote>
<blockquote><para>Lokale variabler eksisterer kun, så
længe metoden, hvori de er erklæret, udføres</para></blockquote>

<para>
Modsat højde, længde og bredde begynder vol-variabler
altså ikke at eksistere, bare fordi vi har skabt en Boks.
</para>
</sect2>    <!--   Variabler -->

<sect2 id="java-klasser-boks-brug">
  <title>Brug af klassen</title>

<para>
Objekter af klassen Boks kan f.eks. benyttes på følgende
måde:
</para>

<screen>
public class BenytBoks
{
  public static void main(String args[])
  {
    double rumfang;

<emphasis>    Boks boksobjekt;</emphasis>
<emphasis>    boksobjekt = new Boks();</emphasis>
<emphasis>    boksobjekt.længde= 12.3;</emphasis>
<emphasis>    boksobjekt.bredde= 2.22;</emphasis>
<emphasis>    boksobjekt.højde = 6.18;</emphasis>
<emphasis>    rumfang = boksobjekt.volumen();</emphasis>
    System.out.println(&quot;Boksens volume: &quot;+ rumfang);
  }
}
</screen>


<screen>
Boksens volume: 168.75108
</screen>


<para>
Som det ses, er det klassen BenytBoks, der indeholder
main()-metoden. Der skal være &eacute;n og kun &eacute;n klasse
med en main-metode i et program. En sådan &quot;main-klasse&quot;
bruges ikke til at definere objekttyper med - kun til at angive, hvor
programmet skal startes.
</para>

<para>
I følgende sætninger (i klassen BenytBoks) sættes
det nyoprettede Boks-objekts variabler:
</para>

<screen>
  boksobjekt.længde= 12.3;
  boksobjekt.bredde= 2.22;
  boksobjekt.højde = 6.18;
</screen>


<para>
I den efterfølgende sætning:
</para>

<screen>
  rumfang = boksobjekt.volumen();
</screen>


<para>
kaldes metoden volumen() i Boks-objektet, der udregner rumfanget
ud fra variablerne, som er blevet tilført data i linjerne
ovenfor. Metoden returnerer en double - denne lægges over i
rumfang-variablen, som udskrives.
</para>
</sect2>    <!--   Brug af klassen -->

<sect2 id="java-klasser-boks-met-def">
  <title>Metodedefinition</title>

<para>
Når vi definerer en metode, giver vi den et hoved og en
krop.
</para>

<para>
<emphasis>Hovedet</emphasis> ligner den måde vi tidligere har set metoder
opremset på. Metodehovedet fortæller metodens navn,
returtype og hvilke parametre den eventuelt tager:
</para>

<screen>
  double volumen()
</screen>


<para>
<emphasis>Kroppen</emphasis> kommer lige under hovedet:
</para>

<screen>
  {
    double vol;
    vol = længde*bredde*højde;
    return vol; 
  }
</screen>


<para>
I kroppen står der, hvad der skal ske, når metoden
kaldes. Her står altså, at når metoden volumen()
kaldes, bliver der først oprettet en lokal variabel, vol.
Denne bliver tildelt produktet af de tre variabler længde,
bredde og højde. Den sidste linje i kroppen fortæller,
at resultatet af vol bliver givet tilbage (returneret) til der, hvor
metoden blev kaldt.
</para>

<blockquote><para>En metodekrop udføres, når
metoden kaldes</para></blockquote>

<para>
Variablerne længde, bredde og højde, som kroppen
bruger, er dem, der findes i netop det objekt, som
volumen()-metoden blev kaldt på. Lad os kigge på en stump
af BenytBoks:
</para>

<screen>
    boksobjekt.længde= 12.3;
    boksobjekt.bredde= 2.22;
    boksobjekt.højde= 6.18;
    rumfang = boksobjekt.volumen();
</screen>


<para>
Her får det Boks-objekt, som boksobjekt refererer til, sat
sine variabler, og når metoden volumen() derefter kaldes på
dette objekt, vil længde, bredde og højde have disse
værdier. rumfang bliver sat til den værdi, vol har i
return-linjen, og vol nedlægges (da den er en lokal variabel).
</para>

<blockquote><para>En return-sætning afslutter
udførelsen af metodekroppen og leverer en værdi tilbage
til kalderen</para></blockquote>
</sect2>    <!--   Metodedefinition -->

<sect2 id="java-klasser-boks-flere-obj">
  <title>Flere objekter</title>

<para>
Herunder opretter vi to bokse og udregner deres forskel i rumfang.
Hver boks er et aftryk af Boks-klassen forstået på den
måde, at de hver indeholder deres egne sæt variabler.
Variablen bredde kan således have forskellige værdier
i hvert objekt.
</para>

<screen>
public class BenytBokse
{
  public static void main(String args[])
  {
    Boks boks1, boks2;
<emphasis>    boks1 = new Boks();</emphasis>
<emphasis>    boks2 = new Boks();</emphasis>

<emphasis>    boks1.længde= 12.3;</emphasis>
<emphasis>    boks1.bredde= 2.22;</emphasis>
<emphasis>    boks1.højde= 6.18;</emphasis>

<emphasis>    boks2.længde= 13.3;</emphasis>
<emphasis>    boks2.bredde= 3.33;</emphasis>
<emphasis>    boks2.højde= 7.18;</emphasis>

    double v1, v2;

<emphasis>    v1 = boks1.volumen();</emphasis>
<emphasis>    v2 = boks2.volumen();</emphasis>

    System.out.println(&quot;Volumenforskel: &quot;+ (<emphasis>v2 - v1</emphasis>));
  }
}
</screen>


<screen>
Volumenforskel: 149.24394
</screen>


<para>
Når vi kalder volumen() på boks1 og boks2, er det
således to forskellige sæt længde-, højde-
og bredde-variabler, der bliver brugt til beregningen når
volumen()'s krop udføres.
</para>
</sect2>    <!--   Flere objekter -->
</sect1>    <!--   En Boks-klasse -->

<sect1 id="java-klasser-indkap">
  <title>Indkapsling</title>

<para>
Indkapsling af data og metoder i objekter betyder, at man ikke
lader andre bruge objekterne helt efter eget forgodtbefindende.
Man gør visse dele af objekterne utilgængelige uden for
klassens metoder. Herved sætter man nogle regler op for,
hvordan man kan benytte objekterne.
</para>

<para>
Hvorfor overhovedet indkapsle (skjule) variabler?
</para>

<para>
Indkapsling i klasser er vigtig, når programmerne bliver
store og komplekse. Hvis det er muligt at ændre data i en
klasse, se eksemplet ovenfor, kan det føre til situationer,
som kommer ud af kontrol i store komplekse systemer.
</para>

<para>
Ved at indkapsle data er den eneste måde at ændre data
på brugen af metoder. I metoderne kan man sikre sig mod
vanvittige overgreb på variabler ved at tilføre
logik, der sikrer, at variablerne er konsistente.
</para>

<para>
I ovenstående eksempel kan man for eksempel sætte
højden af en boks til et negativt tal. Spørger man
derefter på volumen(), vil man få et negativt svar! Det
kræver ikke meget fantasi at forestille sig, hvordan sådanne
fejl kunne gøre et program ubrugeligt. Tænk for eksempel
på pakkepost-omdeling, hvis et af Post Danmarks programmer
påstod, at der nemt kunne være 10001 pakker på hver
<emphasis>minus</emphasis> en kubikmeter og 10000 pakker på hver plus en
kubikmeter i &eacute;n postvogn... endda med flere kubikmeter til
overs til anden post!
</para>

<para>
Med indkapsling opnår man at objekterne altid er
konsistente, fordi objekterne selv sørger for at deres
variabler har fornuftige værdier.
</para>

<para>
Man styrer &quot;synligheden&quot; af en variabel eller metode med
nøgleordene public og private:
</para>

<blockquote><para>public betyder &quot;synlig for alle&quot;</para></blockquote>
<blockquote><para>private betyder &quot;kun synlig i
klassen&quot;</para></blockquote>

<para>
Herunder ses en modificeret version af eksemplet med Boks- og
BenytBoks-klassen, men nu er variablerne erklæret private.
</para>

<screen>
public class Boks2
{
<emphasis>  private double længde;</emphasis>
<emphasis>  private double bredde;</emphasis>
<emphasis>  private double højde;</emphasis>

<emphasis>  public void sætMål(double lgd, double b, double h)</emphasis>
  {
    if (lgd&lt;=0 || b&lt;=0 || h&lt;=0)
    {
       System.out.println(&quot;Ugyldige mål. Bruger standardmål.&quot;);
      længde = 10.0;
      bredde = 10.0;
      højde  = 10.0;
    } else {
      længde = lgd;
      bredde = b;
      højde  = h;
    }
  }

<emphasis>  public double volumen()</emphasis>
  {
    double vol;
    vol = længde*bredde*højde;
    return vol; 
  }
}
</screen>


<para>
Klassen er illustreret med UML nedenfor. Bemærk, at
variablerne er private, så de har et - foran, mens metoderne,
som kan ses udefra (public), har et + foran:
</para>

<figure id="java-klasser-uml-fig">
<title>Java</title>

<graphic fileref="Nordfalk615383.&magic;" scale="60"></graphic>
</figure>

<para>
Nu da variablerne bredde, højde og længde er erklæret
private, er det ulovligt at ændre dem &quot;udefra&quot;, i
vores BenytBoks-program.
</para>

<para>
Til gengæld har vi defineret metoden sætMål(),
som man kan kalde for at sætte målene. Nu da den eneste
måde at ændre data på er ved specifikt at kalde
metoden sætMål(), kan vi indlægge en ønsket
logik - for eksempel sikre os mod 0 (nul) eller negative værdier.
</para>

<screen>
public class BenytBoks2
{
  public static void main(String args[])
  {
    Boks2 <emphasis>enBoks = new Boks2()</emphasis>;

<emphasis>    //ulovligt: enBoks.længde= 12.3;</emphasis>
<emphasis>    //ulovligt: enBoks.bredde= 2.22;</emphasis>
<emphasis>    //ulovligt: enBoks.højde= 6.18;</emphasis>

<emphasis>    enBoks.sætMål( 2.0, 2.5, 1.5);</emphasis>

    System.out.println(&quot;Volumen er: &quot;+ enBoks.volumen());

<emphasis>    enBoks.sætMål(-2.0, 0.0, 1.0);</emphasis>

    System.out.println(&quot;Volumen er: &quot;+ enBoks.volumen());

<emphasis>    enBoks.sætMål( 2.0, 3.0 ,1.0);</emphasis>

    System.out.println(&quot;Volumen er: &quot;+ enBoks.volumen());
  }
}
</screen>


<screen>
Volumen er: 7.5
Ugyldige mål. Bruger standardmål.
Volumen er: 1000.0
Volumen er: 6.0
</screen>


<para>
En anden fordel ved indkapsling er, at man bliver uafhængig
af repræsentationen. Man kunne f.eks. gemme volumen i
Boks-klassen i stedet for højden og så lade højden
være beregnet.
</para>
</sect1>    <!--   Indkapsling -->

<sect1 id="java-klasser-konst">
  <title>Konstruktører</title>

<para>
En konstruktør (eng.: constructor) er en speciel metode,
der har samme navn som klassen. Den kaldes automatisk ved oprettelse
af et objekt med 'new'-operatoren og benyttes oftest til at
klare forskellige former for initialisering af det nye objekt.
</para>

<para>
Som vi så i forrige kapitel (i tilfældet med
Rectangle, Point og Date), kan man have flere konstruktører
for en klasse, bare parameterlisterne er forskellige.
</para>

<para>
Her kommer et eksempel med nogle konstruktører:
</para>

<figure id="java-klasser-konst-fig">
<title>Java</title>

<graphic fileref="Nordfalk615385.&magic;" scale="60"></graphic>
</figure>

<screen>
public class Boks3 
{
  private double længde;
  private double bredde;
  private double højde;

<emphasis>  public Boks3()</emphasis>
  {
    System.out.println(&quot;Standardboks oprettes&quot;);
    sætMål(10, 10, 10);
  }

<emphasis>  // En anden konstruktør der tager bredde, højde og længde</emphasis>
<emphasis>  public Boks3(double lgd, double b, double h)</emphasis>
  {
    System.out.println(&quot;Boks oprettes med lgd=&quot;+lgd+&quot; b=&quot;+b+&quot; h=&quot;+h);
    sætMål(lgd,b,h);
  }

  public void sætMål(double lgd, double b, double h)
  {
    if (lgd&lt;=0 || b&lt;=0 || h&lt;=0) 
    {
       System.out.println(&quot;Ugyldige mål. Bruger standardmål.&quot;);
      længde = 10.0;
      bredde = 10.0;
      højde  = 10.0;
    } else {
      længde = lgd;
      bredde = b;
      højde  = h;
    }
  }

  public double volumen()
  {
    return længde*bredde*højde; 
  }
}
</screen>


<para>
Bemærk:
</para>

<blockquote><para>En konstruktør erklæres
som en metode med samme navn som klassen</para></blockquote>
<blockquote><para>En konstruktør har ingen
returtype - ikke engang 'void'</para></blockquote>

<para>
I ovenstående eksempel er der defineret to konstruktører:
</para>

<screen>
  public Boks3()
  public Boks3(double lgd, double b, double h)
</screen>


<para>
Vi prøver Boks3 med:
</para>

<screen>
public class BenytBoks3
{
  public static void main(String args[])
  {
    Boks3 enBoks;
<emphasis>    // brug konstruktøren uden parametre</emphasis>
    enBoks = <emphasis>new Boks3()</emphasis>;

    System.out.println(&quot;Volumen er: &quot;+ enBoks.volumen());

    Boks3 enAndenBoks;
<emphasis>    // brug den anden konstruktør</emphasis>
    enAndenBoks = <emphasis>new Boks3(5,5,10)</emphasis>;

    System.out.println(&quot;Volumen er: &quot;+ enAndenBoks.volumen());
  }
}
</screen>


<screen>
Standardboks oprettes
Volumen er: 1000.0
Boks oprettes med lgd=5.0 b=5.0 h=10.0
Volumen er: 250.0
</screen>

<sect2 id="java-klasser-konst-std">
  <title>Standardkonstruktører</title>

<para>
Når vi i de foregående eksempler (f.eks. Boks2) ikke
har benyttet en konstruktør, er det, fordi Java, hvis ikke en
konstruktør er erklæret, selv erklærer en tom
standardkonstruktør uden parametre. Dvs. Java i Boks2's
tilfælde usynligt har defineret konstruktøren:
</para>

<screen>
public Boks2()
{
}
</screen>


<para>
Denne konstruktør har vi kaldt, hver gang vi har oprettet
et objekt med 'new'.
</para>

<blockquote><para>Der kaldes altid en konstruktør,
når et objekt oprettes</para></blockquote>
<blockquote><para>Standardkonstruktøren genereres
automatisk, hvis der ikke er andre konstruktører i
klassen</para></blockquote>

<para>
En standardkonstruktør genereres kun, hvis der ikke er
andre konstruktører i klassen.
</para>

<para>
Hvis vi ikke havde defineret en konstruktør uden parametre
i Boks3, ville oversætteren i BenytBoks3 brokke sig over, at
denne type konstruktør ikke fandtes:
</para>

<screen>
  BenytBoks3.java:7: No constructor matching Boks3() found in class Boks3.
                  enBoks = new Boks3();
</screen>
</sect2>    <!--   Standardkonstruktører -->

<sect2 id="java-klasser-konst-opg">
  <title>Opgaver</title>
<orderedlist>
  <listitem>

<para>

Defin&eacute;r klassen Pyramide. Objekterne skal have
  variablerne <emphasis>side</emphasis> og <emphasis>højde</emphasis> (defin&eacute;r en
  konstruktør) og en metode til at udregne volumen
  (side*side*højde/4). Skriv en BenytPyramider, som
  opretter 3 pyramider og udregner volumen.
</para>

</listitem>

  <listitem>

<para>
Ret Boks3 til også at have variablen massefylde, og
  defin&eacute;r en ekstra konstruktør der også tager
  massefylden (den oprindelige konstruktør med lgd, b og h kan
  sætte massefylden til 1). Lav også metoder til at
  sætte massefylden, sætMassefylde(double m), og udregne
  vægten, vægt(). Test din klasse med en ændret
  udgave af BenytBoks3.
</para>

</listitem>
</orderedlist>
</sect2>    <!--   Opgaver -->
</sect1>    <!--   Konstruktører -->

<sect1 id="java-klasser-dice">
  <title>En Terning-klasse</title>

<para>
Lad os tage et andet eksempel, en terning. Den vigtigste egenskab
ved en terning er dens værdi (dvs. antallet af øjne på
siden, der vender opad lige nu) mellem 1 og 6.
</para>

<figure id="java-klasser-dice-fig">
<title>Java</title>

<graphic fileref="Nordfalk615387.&magic;" scale="60"></graphic>
</figure>

<screen>
<emphasis>// En klasse der beskriver 6-sidede terninger</emphasis>
public class Terning
{
  <emphasis>// den side der vender opad lige nu</emphasis>
<emphasis>  int værdi;</emphasis>

  <emphasis>// konstruktør</emphasis>
<emphasis>  public Terning()</emphasis>
  {
    kast(); <emphasis>// kald kast() der sætter værdi til noget fornuftigt</emphasis>
  }

  <emphasis>// metode til at kaste terningen</emphasis>
<emphasis>  public void kast()</emphasis>
  {
    <emphasis>// find en tilfældig side</emphasis>
    double tilfældigtTal = Math.random();
    værdi = (int) (tilfældigtTal * 6 + 1);
  }

  <emphasis>// giver en beskrivelse af terningen som en streng</emphasis>
<emphasis>  public String toString()</emphasis>
  {
    String svar = &quot;&quot;+værdi;  <emphasis>// værdi som streng, f.eks. &quot;4&quot;</emphasis>
    return svar;
  }
}
</screen>


<para>
Her er et program, der bruger et Terning-objekt til at slå
med, indtil vi får en 6'er:
</para>

<screen>
public class BenytTerning
{
  public static void main(String args[])
  {
    Terning t;
    t = new Terning();  <emphasis>// opret terning</emphasis>

<emphasis>    // Slå nu med terningen indtil vi får en sekser</emphasis>
    boolean sekser = false;
    int antalKast = 0;

    while (sekser==false)
    {
      t.kast();
      antalKast = antalKast + 1;
      System.out.println(&quot;kast &quot;+antalKast+&quot;: &quot;+t.værdi);
      if (t.værdi == 6) sekser = true;
    }

    System.out.println(&quot;Vi slog en 6'er efter &quot;+antalKast+&quot; slag.&quot;);
  }
}
</screen>


<screen>
kast 1: 4
kast 2: 2
kast 3: 6
Vi slog en 6'er efter 3 slag.
</screen>

<sect2 id="java-klasser-dice-opg">
  <title>Opgaver</title>
<orderedlist>
  <listitem>

<para>

Skriv et program, der rafler med to terning-objekter, indtil
  der slås en 6'er.
</para>

</listitem>

  <listitem>

<para>
Skriv et program, der rafler med fire terninger, indtil der
  slås tre eller fire 6'ere. Udskriv antal øjne for
  hver terning.
</para>

</listitem>

  <listitem>

<para>
Skriv et program, der rafler med 12 terninger, og hver gang
  udskriver øjnene, summen af øjnene og hvor mange 6'ere
  der kom. Brug Vector-klassen til at holde styr på
  terningerne.
</para>

</listitem>

  <listitem>

<para>
Lav en Moent-klasse der repræsenterer en mønt
  med 2 sider (du kan tage udgangspunkt i Terning.java). Lav
  metoden krone(), der returnerer true eller false. Lav et program,
  der kaster en mønt 100 gange og tæller antal gange, det
  fik krone.
</para>

</listitem>
</orderedlist>
</sect2>    <!--   Opgaver -->
</sect1>    <!--   En Terning-klasse -->

<sect1 id="java-klasser-rela">
  <title>Relationer mellem objekter</title>

<para>
Indtil nu har alle vore objekter haft simple typer som variabler.
Nu vil vi se på objekter der har andre objekter som variabler
(dvs. de har referencer til andre objekter).
</para>

<sect2 id="java-klasser-rela-rafle">
  <title>En Raflebæger-klasse</title>

<para>
Når man laver et større program, bliver det ofte
nødvendigt at uddelegere nogle af opgaverne fra
hovedprogrammet til andre dele af programmet. I vores tilfælde
kunne vi godt lave et lille terningspil direkte fra main(), men hvis
vi skulle lave f.eks. et yatzy- eller matadorspil, ville det
blive besværligt at skulle holde rede på hver enkelt
terning (og alle de andre objekter) på den måde. Hver
gang en spiller kaster med terningerne, skal man først kaste
hver enkelt terning, hvorefter man skal udregne summen (eller i Yatzy
undersøge antallet af par, tre ens osv.).
</para>

<para>
En løsning er at skabe andre, mere overordnede objekter,
som tager sig af detaljerne.
</para>

<para>
I vores tilfælde kan man definere en Raflebæger-klasse,
der 'har' terningerne, og som er bekvem at bruge fra hovedprogrammet.
Med 'har' menes, at referencerne til Terning-objekterne kendes
af raflebægeret, men ikke nødvendigvis af
hovedprogrammet.
</para>

<para>
Raflebægeret har metoderne ryst(), der kaster alle
terningerne, sum(), der udregner summen af terningernes værdier
og antalDerViser(), der fortæller hvor mange terninger, der har
en given værdi (f.eks. hvor mange terninger der viser 6 øjne).
</para>

<screen>
import java.util.*;

public class Raflebaeger
{
<emphasis>  public Vector terninger; </emphasis> <emphasis>// Raflebaeger <emphasis>har en</emphasis> vektor af terninger</emphasis>

<emphasis>  public Raflebaeger(int antalTerninger)</emphasis>
  {
    terninger = new Vector();
    for (int i=0;i&lt;antalTerninger;i++)
    {
      Terning t;
      t = new Terning();
      tilføj(t);
    }
  }

  public void tilføj(Terning t)<emphasis>       </emphasis><emphasis>// Læg en terning i bægeret</emphasis>
  {
    terninger.addElement(t);
  }

<emphasis>  public void ryst()                  </emphasis><emphasis>// Kast alle terningerne</emphasis>
  {
    for (int i=0;i&lt;terninger.size();i++) 
    {
      Terning t;
      t = (Terning) terninger.elementAt(i);
      t.kast();
    }
  }

<emphasis>  public int sum()                   </emphasis><emphasis> // Summen af alle terningers værdier</emphasis>
  {
    int resultat;
    resultat=0;
    for (int i=0;i&lt;terninger.size();i++) 
    {
      Terning t;
      t = (Terning) terninger.elementAt(i);
      resultat = resultat + t.værdi;
    }
    return resultat;
  }
  
<emphasis>  public int antalDerViser(int værdi)</emphasis><emphasis> // Antal terninger med en bestemt værdi</emphasis>
  {
    int resultat;
    resultat = 0;
    for (int i=0;i&lt;terninger.size();i++) 
    {
      Terning t;
      t = (Terning) terninger.elementAt(i);
      if (t.værdi==værdi) 
      {
        resultat = resultat + 1;
      }
    }
    return resultat;
  }

  public String toString ()<emphasis>           </emphasis><emphasis>// Beskriv bægerets indhold</emphasis>
  {<emphasis>// (vektorens toString() kalder toString() på hver terning)</emphasis>
    return terninger.toString();
  }
}
</screen>


<para>
Herunder er et lille program der spiller med tre terninger indtil
man får netop to seksere:
</para>

<screen>
public class ToSeksere
{
  public static void main(String[] args)
  {  
    Raflebaeger bæger;
    boolean toSeksere;
    int antalForsøg;

    <emphasis>bæger = new Raflebaeger(3)</emphasis>;<emphasis>   // opret et bæger med 3 terninger</emphasis>
    <emphasis>toseksere=false</emphasis>;
    antalForsøg = 0;
    <emphasis>while (toseksere==false)</emphasis>
    {
      <emphasis>bæger.ryst()</emphasis>;              <emphasis>// kast alle terningerne</emphasis>
      System.out.print(&quot;Bæger: &quot; + bæger + &quot; sum: &quot; + <emphasis>bæger.sum()</emphasis>);
      System.out.println(&quot; Antal 6'ere: &quot;+bæger.antalDerViser(6)
                       + &quot; antal 5'ere: &quot;+bæger.antalDerViser(5));
<emphasis>      if (bæger.antalDerViser(6) == 2)</emphasis>
<emphasis>      {</emphasis>
<emphasis>        toSeksere = true;</emphasis>
<emphasis>      }</emphasis>
      antalForsøg++;
    }
    System.out.println(&quot;Du fik to seksere efter &quot;+ antalForsøg+&quot; forsøg.&quot;);
  }
}
</screen>


<screen>
Bæger: [4, 4, 4] sum: 12 Antal 6'ere: 0 antal 5'ere: 0
Bæger: [5, 5, 6] sum: 16 Antal 6'ere: 1 antal 5'ere: 2
Bæger: [2, 5, 6] sum: 13 Antal 6'ere: 1 antal 5'ere: 1
Bæger: [4, 2, 4] sum: 10 Antal 6'ere: 0 antal 5'ere: 0
Bæger: [6, 4, 1] sum: 11 Antal 6'ere: 1 antal 5'ere: 0
Bæger: [6, 6, 4] sum: 16 Antal 6'ere: 2 antal 5'ere: 0
Du fik to seksere efter 6 forsøg.
</screen>


<para>
Linjen:
</para>

<screen>
    bæger = new Raflebaeger(3);
</screen>


<para>

opretter et raflebæger med tre terninger i.
</para>
</sect2>    <!--   En Raflebæger-klasse -->

<sect2 id="java-klasser-rela-opg">
  <title>Opgaver</title>
<orderedlist>
  <listitem>

<para>

Skriv et program, der vha. et Raflebaeger rafler med fire
  terninger, indtil der slås tre eller fire 6'ere. Udskriv antal
  øjne for hver terning.
</para>

</listitem>

  <listitem>

<para>
Skriv et program, der vha. et Raflebaeger rafler med 12
  terninger og udskriver terningernes værdier, summen af
  værdierne og hvor mange 6'ere der kom.
</para>

</listitem>

  <listitem>

<para>
Skriv et simpelt Yatzy-spil med fem terninger. Man kaster &eacute;n
  gang og ser om man har et par, to par, tre ens, hus (et par og tre
  ens, f.eks. 25225), fire ens eller fem ens.
</para>

</listitem>
</orderedlist>

<para>
Udvid Raflebaeger så man kan
spørge, om der er fire ens, ved at kalde en fireEns()-metode:
</para>

<screen>
  public boolean fireEns() 
  { 
    ... 
  }
</screen>


<para>

Lav tilsvarende de andre metoder.
</para>

<para>
Ret toString()-metoden, så den
fortæller, om der var fem ens, hus eller lignende.
</para>

<para>
Lav et program (en klasse med en
main()-metode), der rafler et Raflebaeger et par gange og skriver
dets indhold ud. Her er et eksempel på, hvordan uddata kunne se
ud:
</para>

<screen>
1 4 4 3 4  : Tre ens
4 2 1 6 6  : Et par
2 6 2 2 6  : Hus
5 2 3 6 4  : Ingenting
2 3 4 5 4  : Et par
6 5 2 6 2  : To par
6 6 2 2 6  : Hus
...
</screen>
</sect2>    <!--   Opgaver -->
</sect1>    <!--   Relationer mellem objekter -->

<sect1 id="java-klasser-this">
  <title>Nøgleordet this</title>

<para>
Nogle gange kan et objekt have brug for at referere til sig selv.
Det gøres med <emphasis>this</emphasis>-nøgleordet, der ligner
(og bruges som) en variabel.
</para>

<blockquote><para>this refererer til det objekt, man er
i</para></blockquote>

<para>
Læs igen definitionen af Boks2. I dens sætMål-metode
brugte vi andre variabelnavne for parametrene (nemlig lgd, b og h)
end objektvariablerne (længde, bredde og højde). Vi kan
altid få fat i objektets variabler med this, så vi kunne
også have brugt de samme variabelnavne:
</para>

<screen>
import java.util.*;
public class Boks2medThis
{
  private double længde;
  private double bredde;
  private double højde;

  public void sætMål(double længde, double bredde, double højde)
  {
    if (længde&lt;=0 || bredde&lt;=0 || højde&lt;=0) 
    {
       System.out.println(&quot;Ugyldige mål. Bruger standardmål.&quot;);
      <emphasis>this</emphasis>.længde = 10.0;
      <emphasis>this</emphasis>.bredde = 10.0;
      <emphasis>this</emphasis>.højde  = 10.0;
    } else {
      <emphasis>this</emphasis>.længde = længde;
      <emphasis>this</emphasis>.bredde = bredde;
      <emphasis>this</emphasis>.højde  = højde;
    }
  }

  public double volumen()
  {
    return bredde*højde*længde; 
  }

  public void føjTilVektor(Vector v)
  {
    v.addElement(<emphasis>this</emphasis>);
  }
}
</screen>


<figure id="java-klasser-this-fig">
<title><emphasis>this</emphasis>
  virker som en variabel der refererer til objektet selv</title>

<graphic fileref="Nordfalk615388.&magic;" scale="60"></graphic>
</figure>

<para>
I sætMål() er der nu to sæt variabler med samme
navn. Da vælger Java altid den variabel, der er &quot;tættest
på&quot;, dvs. f.eks. 'længde' svarer til
parametervariablen længde. For at få fat i
objektvariablen skal vi bruge this.længde.
</para>

<para>
Derfor skal vi skrive
</para>

<screen>
      this.længde = længde;
</screen>


<para>

for at tildele objektets længde-variabel den nye værdi.
</para>

<para>
En anden anvendelse af this er,
når et objekt har brug for at give en reference til sig selv
til et andet objekt. Normalt ville vi tilføje en boks til en
vektor med:
</para>

<screen>
  Vector v = new Vector()
  Boks2medThis b = new Boks2medThis();
  v.addElement(b);
</screen>


<para>
Med metoden føjTilVektor() kan vi i stedet for bede b om at
tilføje sig selv:
</para>

<screen>
  b.føjTilVektor(v);
</screen>


<para>
Vi vil senere (i Spiller-klassen i matadorspillet i kapitlet om
nedarvning) se et eksempel på dette, hvor det er en fordel i
praksis.
</para>
</sect1>    <!--   Nøgleordet this -->

<sect1 id="java-klasser-eks">
  <title>Ekstra eksempler</title>

<para>
Dette afsnit giver nogle ekstra eksempler, der repeterer stoffet i
kapitlet.
</para>

<sect2 id="java-klasser-eks-n-dice">
  <title>En n-sidet terning</title>

<para>
Det normale er en 6-sidet terning, men der findes også 4-,
8- 12- og 20-sidede. Klassen nedenfor beskriver en generel n-sidet
terning.
</para>

<para>
Vi har ladet antallet af sider og værdien  være
private, og lavet metoden hentVærdi(), som kan bruges udefra.
Der er også en sætVærdi()-metode, mens antallet af
sider ikke kan ændres udefra, når først terningen
er skabt.
</para>

<figure id="java-klasser-n-dice-fig">
<title>Java</title>

<graphic fileref="Nordfalk615390.&magic;" scale="60"></graphic>
</figure>

<screen>
<emphasis>// En n-sidet terning.</emphasis>
public class NSidetTerning
{
<emphasis>  // hvor mange sider har terningen (normalt 6)</emphasis>
<emphasis>  private int sider;</emphasis>

<emphasis>  // den side der vender opad lige nu</emphasis>
<emphasis>  private int værdi;</emphasis>

<emphasis>  // konstruktør opretter normal terning med 6 sider</emphasis>
<emphasis>  public NSidetTerning ()</emphasis>
  {
    sider = 6;
    kast(); // sæt værdi til noget
  }

<emphasis>  // opretter terning med et vist antal sider</emphasis>
<emphasis>  public NSidetTerning (int antalSider)</emphasis>
  {
    if (antalSider &gt;= 3) sider = antalSider;
    else sider = 6;
    kast();
  }

<emphasis>  // metode der kaster terningen</emphasis>
<emphasis>  public void kast ()</emphasis>
  {
<emphasis>    // find en tilfældig side</emphasis>
    double tilfældigtTal = Math.random();
    værdi = (int) (tilfældigtTal * sider + 1);
  }

<emphasis>  // giver antallet af øjne på siden der vender opad</emphasis>
<emphasis>  public int hentVærdi ()</emphasis>
  {
    return værdi;
  }

<emphasis>  // sætter antallet af øjne der vender opad</emphasis>
<emphasis>  public void sætVærdi (int nyVærdi)</emphasis>
  {
    if (nyVærdi &gt; 0 &amp;&amp; nyVærdi &lt;= sider) værdi = nyVærdi;
    else System.out.println(&quot;Ugyldig værdi&quot;);
  }

<emphasis>  // giver en strengrepræsentation af terningen</emphasis>
  // hvis den ikke har 6 sider udskrives også antal af sider
<emphasis>  public String toString ()</emphasis>
  {
    String svar = &quot;&quot;+værdi;  <emphasis>// værdi som streng, f.eks. &quot;4&quot;</emphasis>
    if (sider!= 6) svar= svar+&quot;(&quot;+sider+&quot;s)&quot;;
    return svar;
  }
}
</screen>


<para>
Her er et program til at afprøve klassen med:
</para>

<screen>
public class BenytNSidetTerning
{
  public static void main(String args[])
  {
    NSidetTerning t = new NSidetTerning(); <emphasis>// sekssidet terning</emphasis>

    System.out.println(&quot;t viser nu &quot;+t.hentVærdi()+&quot; øjne&quot;);

    NSidetTerning t6 = new NSidetTerning(6); <emphasis>// sekssidet terning</emphasis>
    NSidetTerning t4 = new NSidetTerning(4); <emphasis>// firesidet terning</emphasis>
    NSidetTerning t12 = new NSidetTerning(12); <emphasis>// tolvsidet terning</emphasis>

    System.out.println(&quot;t4 er &quot;+t4); <emphasis>// t4.toString() kaldes implicit</emphasis>
    t4.kast();
    System.out.println(&quot;t4 er nu &quot;+t4);
    t4.kast();

    System.out.println(&quot;terninger: &quot;+t+&quot; &quot;+t6+&quot; &quot;+t4+&quot; &quot;+t12);
    t.kast();
    t12.kast();
    System.out.println(&quot;terninger: &quot;+t+&quot; &quot;+t6+&quot; &quot;+t4+&quot; &quot;+t12);

    for (int i=0; i&lt;5; i++) 
    {
      t.kast();
      t6.kast();
      t4.kast();
      t12.kast();
      System.out.println(&quot;kast &quot;+i+&quot;: &quot;+t+&quot; &quot;+t6+&quot; &quot;+t4+&quot; &quot;+t12);
      if (t.hentVærdi() == t6.hentVærdi())
      {
        System.out.println(&quot;t og t6 er ens!&quot;);
      }
    }
  }
}
</screen>


<screen>
t viser nu 6 øjne
t4 er 4(4s)
t4 er nu 1(4s)
terninger: 6 1 4(4s) 5(12s)
terninger: 6 1 4(4s) 3(12s)
kast 0: 3 1 4(4s) 2(12s)
kast 1: 1 6 4(4s) 11(12s)
kast 2: 1 1 4(4s) 5(12s)
t og t6 er ens!
kast 3: 3 6 4(4s) 3(12s)
kast 4: 3 2 2(4s) 6(12s)
</screen>
</sect2>    <!--   En n-sidet terning -->

<sect2 id="java-klasser-eks-pers">
  <title>Personer</title>

<para>
Lad os lave en klasse til at repræsentere en person. Hvert
person-objekt skal have et fornavn, et efternavn og en alder.
Når man opretter en ny Person, skal man angive disse data,
f.eks.: new Person(&quot;Jacob&quot;,&quot;Nordfalk&quot;,30), så
vi definerer en konstruktør med disse parametre.
</para>

<para>
Vi definerer også, at hver person har metoden toString(),
der returnerer en streng med personens oplysninger af formen &quot;Jacob
Nordfalk (30 år)&quot;.
</para>

<para>
Desuden har vi metoden præsentation(), der skriver
oplysningerne pænt ud til skærmen som &quot;Jeg
hedder Jacob og jeg er 30 år&quot;. Denne metode returnerer
ikke noget, men skriver i stedet hilsenen ud til skærmen
(personer under 5 år siger bare &quot;agyyy!&quot;)
</para>

<para>
Til sidst kunne man forestille sig, at en person kan hilse på
en anden person (metoden hils()). Det afhænger af alderen
hvordan man hilser. En person på over 60 år vil hilse på
Jacob med &quot;Goddag hr Nordfalk&quot;, mens en yngre bare vil sige
&quot;Hej Jacob&quot;.
</para>

<screen>
import java.util.*;
public class Person
{
<emphasis>  public String fornavn;</emphasis>
<emphasis>  public String efternavn;</emphasis>
<emphasis>  public int alder;</emphasis>
  public Vector konti; <emphasis>// bruges senere</emphasis>

<emphasis>  public Person(String fornavnP, String efternavnP, int alderP)</emphasis>
  {
    fornavn = fornavnP;
    efternavn = efternavnP;
    alder = alderP;
    konti = new Vector(); <emphasis>// bruges senere</emphasis>
  }

<emphasis>  public String toString()</emphasis>
  {
    return fornavn+&quot; &quot;+efternavn+&quot; (&quot;+alder+&quot; år)&quot;;
  }

<emphasis>  public void præsentation()</emphasis>
  {
    if (alder &lt; 5) System.out.println(&quot;agyyy!&quot;);
    else System.out.println(&quot;Jeg hedder &quot;+fornavn+&quot;, og jeg er &quot;+alder+&quot; år.&quot;);
  }

<emphasis>  public void hils(Person andenPerson)</emphasis>
  {
    if (alder &lt; 5) System.out.print(&quot;ma ma.. &quot;);
    else if (alder &lt; 60) System.out.print(&quot;Hej &quot;+<emphasis>andenPerson.fornavn</emphasis>+&quot;. &quot;);
    else  System.out.print(&quot;Goddag hr. &quot;+<emphasis>andenPerson.efternavn</emphasis>+&quot;. &quot;);

    præsentation();
  }
}
</screen>


<para>
Bemærk, at Person-objektet har to andre objekter, nemlig to
strenge. Selvom man ikke plejer at tegne strenge med i
klassediagrammer, har vi alligevel taget dem med for at illustrere,
at der faktisk også eksisterer en <emphasis>har-en</emphasis>-relation mellem
disse to klasser.
</para>

<figure id="java-klasser-strenge-fig">
<title>En
Person har to String-objekter. Disse er undtagelsesvist også
vist</title>

<graphic fileref="Nordfalk615391.&magic;" scale="60"></graphic>
</figure>



<para>
Læg også mærke til, hvordan vi fra
hils()-metoden kalder præsentation(). Lad os prøve at
oprette tre personer og lade dem præsentere sig og derpå
hilse på hinanden:
</para>

<screen>
public class BenytPerson
{
  public static void main(String args[])
  {
    Person x, y, z;
    x = new Person(&quot;Jacob&quot;, &quot;Nordfalk&quot;, 30);
    y = new Person(&quot;Kai&quot;, &quot;Lund&quot;, 86);
    z = new Person(&quot;Peter&quot;, &quot;Holm&quot;, 2);

    System.out.println(&quot;Vi har oprettet &quot;+x+&quot;, &quot;+y+&quot; og &quot;+z);
    x.præsentation();
    y.præsentation();
    z.præsentation();
    x.hils(y);
    y.hils(x);
    z.hils(x);
  }
}
</screen>


<screen>
Vi har oprettet Jacob Nordfalk (30 år), Kai Lund (86 år) og Peter Holm (2 år)
Jeg hedder Jacob, og jeg er 30 år.
Jeg hedder Kai, og jeg er 86 år.
agyyy!
Hej Kai. Jeg hedder Jacob, og jeg er 30 år.
Goddag hr. Nordfalk. Jeg hedder Kai, og jeg er 86 år.
ma ma.. agyyy!
</screen>


<para>
I linjen
</para>

<screen>
    x.hils(y);
</screen>


<para>

er det x-variablens person (Jacob), der hilser på y-variablens
person. Da x-variablens person er under 60, vil den uformelle hilsen
&quot;Hej Kai&quot; blive brugt. I linjen under er det lige omvendt.
</para>
</sect2>    <!--   Personer -->

<sect2 id="java-klasser-eks-bank">
  <title>Bankkonti</title>

<para>
Lad os se nærmere på relationer mellem objekter i
bankverdenen. De vigtigste egenskaber ved en bankkonto er saldoen, og
hvem der ejer den. Et Konto-objekt kunne altså have et
Person-objekt tilknyttet, en <emphasis>har-en</emphasis>-relation, og denne
person bør være kendt, når kontoen oprettes.
Det er derfor oplagt, at ejeren skal angives i Konto's konstruktør.
Kontoen skal også sørge for at indsætte sig selv
(her bruges nøgleordet this) i personens liste over konti,
sådan at der er konsistens mellem data i Konto-objektet og data
i Person-objektet.
</para>

<screen>
public class Konto
{
<emphasis>  public int saldo;</emphasis>
<emphasis>  public Person ejer;</emphasis>

<emphasis>  public Konto(Person ejeren)</emphasis>
  {
    saldo = 0;
<emphasis>    ejer = ejeren;              </emphasis> <emphasis>// Sæt kontoen til at referere til personen</emphasis>
<emphasis>    ejer.konti.addElement(this);</emphasis> <emphasis>// ..og personen til at referere til kontoen</emphasis>
  }

  public void overførsel(int kroner)
  {
    saldo = saldo + kroner;
  }

  public String toString()
  {
    return ejer+&quot; har &quot;+saldo+&quot; kroner&quot;;
  }
}
</screen>


<figure id="java-klasser-konto-fig">
<title>Java</title>

<graphic fileref="Nordfalk615393.&magic;" scale="60"></graphic>
</figure>

<para>
<emphasis>En
Konto har altid en Person tilknyttet</emphasis>
</para>

<para>
Dette er et eksempel på en <emphasis>har-en</emphasis>-relation begge
veje. Læg mærke til, hvordan vi fra Konto-objektet får
fat i listen af ejerens konti. Den tilføjer vi så
kontoen selv - <emphasis>this</emphasis> - til:
</para>

<screen>
    <emphasis>ejer.konti</emphasis>.addElement(<emphasis>this</emphasis>);
</screen>
</sect2>    <!--   Bankkonti -->
</sect1>    <!--   Ekstra eksempler -->

<sect1 id="java-klasser-opg">
  <title>Opgaver</title>

<para>
Husk at lave små main()-programmer, der afprøver de
ting, du programmerer.
</para>

<orderedlist>
  <listitem>

<para>

Udbyg Person-klassen med metoden formue(), der skal returnere
  summen af saldiene på personens konti. Lav en BenytKonto med
  flere personer, der har flere konti.
</para>

</listitem>

  <listitem>

<para>
Lav en klasse, der repræsenterer en Postering på
  en bankkonto med tekst, indsat beløb (udtræk regnes
  negativt) og dato. Udvid Konto med en liste af posteringer, og
  metoden udskrivPosteringer(), der skal udskrive posteringerne og
  løbende saldo på skærmen.
</para>

</listitem>

  <listitem>

<para>
Lav en klasse, der repræsenterer en bil. En bil har en
  farve, et antal kørte kilometer og en (vurderet) pris.
</para>

</listitem>

  <listitem>

<para>
Udbyg Bil-klassen med en vektor, der husker, hvilke personer
  der sidder i bilen lige nu. Defin&eacute;r følgende metoder
  på Bil-klassen, og afprøv klassen.public void
  enSætterSigInd(Person p) // kaldes, når en person sætter
  sig ind i bilen.public String hvemSidderIBilen() // giver en
  streng, der beskriver personerne i bilen.public void
  alleStigerUd() // kaldes, når alle stiger ud af bilen.
</para>

</listitem>

  <listitem>

<para>
Udbyg Person-klassen, så en person kan eje en bil.
  Udbyg metoden formue(), sådan at den husker at indregne bilens
  pris. Metoden skal virke både for personer med og uden bil
  (Person-objekter uden bil kan have denne variabel sat til null).
</para>

</listitem>
</orderedlist>


<sect2 id="java-klasser-opg-fejl">
  <title>Fejlfinding</title>
<orderedlist>
  <listitem>

<para>

Der er 2 fejl i koden nedenfor. Find dem, og ret dem. Kig
  eventuelt på afsnittene om formen af en klasse og formen
  af en metode ovenfor.
</para>

</listitem>
</orderedlist>

<screen>
public class Fejlfinding1
{
  private int a = 5;
  private String b;
  private c String;
  {
}
</screen>

<orderedlist>
  <listitem>

<para>

Der er 3 fejl i koden nedenfor. Find dem, og ret dem.
</para>

</listitem>
</orderedlist>

<screen>
public class Fejlfinding2
{
  private String b;
  b = &quot;Hej&quot;;

  public Fejlfinding2() {
    return b;
  }

  public Fejlfinding2(String c) {
    b = c
  }
 }
}
</screen>

<orderedlist>
  <listitem>

<para>

Der er 9 fejl i koden nedenfor. Find dem, og ret dem.
</para>

</listitem>
</orderedlist>

<screen>
import java.util.*;

public class Fejlfinding3
{
  public String v = 'hej';
  public string etLangtVariabelnavn;
  public vector v2;
  public INT v3;
  public flot v4;
  public v5;
  public int vi = 5.3;
  public Vector vi3 = &quot;xxx&quot;;
  public String vi5 = new String(Hej);
}
</screen>

<orderedlist>
  <listitem>

<para>

Der er 8 fejl i koden nedenfor. Find dem, ret dem og begrund
  rettelserne.
</para>

</listitem>
</orderedlist>

<screen>
public class Fejlfinding4
{
  private int a = 5;
  private String b;

  public void x1(int y)
  {
    y = a;
  }

  a = 2;

  public Fejlfind(int a) {
    a = 4;
    String = &quot;goddag&quot;;
  }

  public x2(int y)
  {
    a = y*2;
  }

  public int x3(int y)
  {
    b = y;
  }

  public void x4(int y)
  {
    return 5;
  }
</screen>

<orderedlist>
  <listitem>

<para>

Der er 7 fejl i koden nedenfor. Find dem, og ret dem.
</para>

</listitem>
</orderedlist>

<screen>
public class Fejlfinding5
{
  private int a = 5
  public void x1(int y)   {
    a = y;                         }
}
  public x2(int y) <emphasis>// fejlmeddelelse: 'class' or 'interface' expected</emphasis>
  {
    a = y*2*x1;

  public int x3(int y)
  {
    a = y*x2();
  }
  }

  public void x4(int y)
  {
    x4 = 8;
  }
}
</screen>

<orderedlist>
  <listitem>

<para>

Find så mange fejl du kan i koden nedenfor og ret dem.
</para>

</listitem>
</orderedlist>

<screen>
public class Fejlfinding6
{
  public int m()
  {
    System.out.println(&quot;Metode m blev kaldt.&quot;);

  public void m2()
  {
    String s = &quot;Metode m2 blev kaldt.&quot;
    System.out.println(s);
    return s;
  }

  public m3()
  {
    System.out.println(&quot;Metode m3 blev kaldt.&quot;);
  }

  public void m4(int)
  {
    System.out.println(&quot;m4 fik parameter &quot;+p);
  }

  public void m5(p1, p2, p3)
  {
    System.out.println(&quot;m5 fik &quot;+p1+&quot; og &quot;+p2+&quot; og &quot;+p3);
    System.out.println(&quot;s er: &quot;+s);
    String s = p2.toUpperCase();
  }
}
</screen>

</sect2>    <!--   Fejlfinding -->
</sect1>    <!--   Opgaver -->
</chapter>    <!--   Definition af klasser -->

